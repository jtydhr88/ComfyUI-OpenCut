{"version":3,"file":"static/chunks/298-a8dd9316edd7f910.js","mappings":"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","sources":["webpack://_N_E/./src/types/timeline.ts","webpack://_N_E/./src/lib/storage/indexeddb-adapter.ts","webpack://_N_E/./src/lib/storage/opfs-adapter.ts","webpack://_N_E/./src/lib/storage/storage-service.ts","webpack://_N_E/./src/stores/media-store.ts","webpack://_N_E/./src/stores/project-store.ts","webpack://_N_E/./src/constants/timeline-constants.ts","webpack://_N_E/./src/lib/editor-utils.ts","webpack://_N_E/./src/lib/timeline.ts","webpack://_N_E/./src/stores/timeline-store.ts","webpack://_N_E/./src/lib/utils.ts"],"sourcesContent":["import { MediaType } from \"@/stores/media-store\";\r\nimport { generateUUID } from \"@/lib/utils\";\r\n\r\nexport type TrackType = \"media\" | \"text\" | \"audio\";\r\n\r\n// Base element properties\r\ninterface BaseTimelineElement {\r\n  id: string;\r\n  name: string;\r\n  duration: number;\r\n  startTime: number;\r\n  trimStart: number;\r\n  trimEnd: number;\r\n  hidden?: boolean;\r\n}\r\n\r\n// Media element that references MediaStore\r\nexport interface MediaElement extends BaseTimelineElement {\r\n  type: \"media\";\r\n  mediaId: string;\r\n  muted?: boolean;\r\n}\r\n\r\n// Text element with embedded text data\r\nexport interface TextElement extends BaseTimelineElement {\r\n  type: \"text\";\r\n  content: string;\r\n  fontSize: number;\r\n  fontFamily: string;\r\n  color: string;\r\n  backgroundColor: string;\r\n  textAlign: \"left\" | \"center\" | \"right\";\r\n  fontWeight: \"normal\" | \"bold\";\r\n  fontStyle: \"normal\" | \"italic\";\r\n  textDecoration: \"none\" | \"underline\" | \"line-through\";\r\n  x: number; // Position relative to canvas center\r\n  y: number; // Position relative to canvas center\r\n  rotation: number; // in degrees\r\n  opacity: number; // 0-1\r\n}\r\n\r\n// Typed timeline elements\r\nexport type TimelineElement = MediaElement | TextElement;\r\n\r\n// Creation types (without id, for addElementToTrack)\r\nexport type CreateMediaElement = Omit<MediaElement, \"id\">;\r\nexport type CreateTextElement = Omit<TextElement, \"id\">;\r\nexport type CreateTimelineElement = CreateMediaElement | CreateTextElement;\r\n\r\nexport interface TimelineElementProps {\r\n  element: TimelineElement;\r\n  track: TimelineTrack;\r\n  zoomLevel: number;\r\n  isSelected: boolean;\r\n  onElementMouseDown: (e: React.MouseEvent, element: TimelineElement) => void;\r\n  onElementClick: (e: React.MouseEvent, element: TimelineElement) => void;\r\n}\r\n\r\nexport interface ResizeState {\r\n  elementId: string;\r\n  side: \"left\" | \"right\";\r\n  startX: number;\r\n  initialTrimStart: number;\r\n  initialTrimEnd: number;\r\n}\r\n\r\n// Drag data types for type-safe drag and drop\r\nexport interface MediaItemDragData {\r\n  id: string;\r\n  type: MediaType;\r\n  name: string;\r\n}\r\n\r\nexport interface TextItemDragData {\r\n  id: string;\r\n  type: \"text\";\r\n  name: string;\r\n  content: string;\r\n}\r\n\r\nexport type DragData = MediaItemDragData | TextItemDragData;\r\n\r\nexport interface TimelineTrack {\r\n  id: string;\r\n  name: string;\r\n  type: TrackType;\r\n  elements: TimelineElement[];\r\n  muted?: boolean;\r\n  isMain?: boolean;\r\n}\r\n\r\nexport function sortTracksByOrder(tracks: TimelineTrack[]): TimelineTrack[] {\r\n  return [...tracks].sort((a, b) => {\r\n    // Text tracks always go to the top\r\n    if (a.type === \"text\" && b.type !== \"text\") return -1;\r\n    if (b.type === \"text\" && a.type !== \"text\") return 1;\r\n\r\n    // Audio tracks always go to bottom\r\n    if (a.type === \"audio\" && b.type !== \"audio\") return 1;\r\n    if (b.type === \"audio\" && a.type !== \"audio\") return -1;\r\n\r\n    // Main track goes above audio but below text tracks\r\n    if (a.isMain && !b.isMain && b.type !== \"audio\" && b.type !== \"text\")\r\n      return 1;\r\n    if (b.isMain && !a.isMain && a.type !== \"audio\" && a.type !== \"text\")\r\n      return -1;\r\n\r\n    // Within same category, maintain creation order\r\n    return 0;\r\n  });\r\n}\r\n\r\nexport function getMainTrack(tracks: TimelineTrack[]): TimelineTrack | null {\r\n  return tracks.find((track) => track.isMain) || null;\r\n}\r\n\r\nexport function ensureMainTrack(tracks: TimelineTrack[]): TimelineTrack[] {\r\n  const hasMainTrack = tracks.some((track) => track.isMain);\r\n\r\n  if (!hasMainTrack) {\r\n    // Create main track if it doesn't exist\r\n    const mainTrack: TimelineTrack = {\r\n      id: generateUUID(),\r\n      name: \"Main Track\",\r\n      type: \"media\",\r\n      elements: [],\r\n      muted: false,\r\n      isMain: true,\r\n    };\r\n    return [mainTrack, ...tracks];\r\n  }\r\n\r\n  return tracks;\r\n}\r\n\r\n// Timeline validation utilities\r\nexport function canElementGoOnTrack(\r\n  elementType: \"text\" | \"media\",\r\n  trackType: TrackType\r\n): boolean {\r\n  if (elementType === \"text\") {\r\n    return trackType === \"text\";\r\n  }\r\n  if (elementType === \"media\") {\r\n    return trackType === \"media\" || trackType === \"audio\";\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function validateElementTrackCompatibility(\r\n  element: { type: \"text\" | \"media\" },\r\n  track: { type: TrackType }\r\n): { isValid: boolean; errorMessage?: string } {\r\n  const isValid = canElementGoOnTrack(element.type, track.type);\r\n\r\n  if (!isValid) {\r\n    const errorMessage =\r\n      element.type === \"text\"\r\n        ? \"Text elements can only be placed on text tracks\"\r\n        : \"Media elements can only be placed on media or audio tracks\";\r\n\r\n    return { isValid: false, errorMessage };\r\n  }\r\n\r\n  return { isValid: true };\r\n}\r\n","import { StorageAdapter } from \"./types\";\r\n\r\nexport class IndexedDBAdapter<T> implements StorageAdapter<T> {\r\n  private dbName: string;\r\n  private storeName: string;\r\n  private version: number;\r\n\r\n  constructor(dbName: string, storeName: string, version = 1) {\r\n    this.dbName = dbName;\r\n    this.storeName = storeName;\r\n    this.version = version;\r\n  }\r\n\r\n  private async getDB(): Promise<IDBDatabase> {\r\n    return new Promise((resolve, reject) => {\r\n      const request = indexedDB.open(this.dbName, this.version);\r\n\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve(request.result);\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        const db = (event.target as IDBOpenDBRequest).result;\r\n        if (!db.objectStoreNames.contains(this.storeName)) {\r\n          db.createObjectStore(this.storeName, { keyPath: \"id\" });\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  async get(key: string): Promise<T | null> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readonly\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.get(key);\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve(request.result || null);\r\n    });\r\n  }\r\n\r\n  async set(key: string, value: T): Promise<void> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readwrite\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.put({ id: key, ...value });\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve();\r\n    });\r\n  }\r\n\r\n  async remove(key: string): Promise<void> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readwrite\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.delete(key);\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve();\r\n    });\r\n  }\r\n\r\n  async list(): Promise<string[]> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readonly\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.getAllKeys();\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve(request.result as string[]);\r\n    });\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    const db = await this.getDB();\r\n    const transaction = db.transaction([this.storeName], \"readwrite\");\r\n    const store = transaction.objectStore(this.storeName);\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = store.clear();\r\n      request.onerror = () => reject(request.error);\r\n      request.onsuccess = () => resolve();\r\n    });\r\n  }\r\n}\r\n","import { StorageAdapter } from \"./types\";\r\n\r\nexport class OPFSAdapter implements StorageAdapter<File> {\r\n  private directoryName: string;\r\n\r\n  constructor(directoryName = \"media\") {\r\n    this.directoryName = directoryName;\r\n  }\r\n\r\n  private async getDirectory(): Promise<FileSystemDirectoryHandle> {\r\n    const opfsRoot = await navigator.storage.getDirectory();\r\n    return await opfsRoot.getDirectoryHandle(this.directoryName, {\r\n      create: true,\r\n    });\r\n  }\r\n\r\n  async get(key: string): Promise<File | null> {\r\n    try {\r\n      const directory = await this.getDirectory();\r\n      const fileHandle = await directory.getFileHandle(key);\r\n      return await fileHandle.getFile();\r\n    } catch (error) {\r\n      if ((error as Error).name === \"NotFoundError\") {\r\n        return null;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async set(key: string, file: File): Promise<void> {\r\n    const directory = await this.getDirectory();\r\n    const fileHandle = await directory.getFileHandle(key, { create: true });\r\n    const writable = await fileHandle.createWritable();\r\n\r\n    await writable.write(file);\r\n    await writable.close();\r\n  }\r\n\r\n  async remove(key: string): Promise<void> {\r\n    try {\r\n      const directory = await this.getDirectory();\r\n      await directory.removeEntry(key);\r\n    } catch (error) {\r\n      if ((error as Error).name !== \"NotFoundError\") {\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n\r\n  async list(): Promise<string[]> {\r\n    const directory = await this.getDirectory();\r\n    const keys: string[] = [];\r\n\r\n    for await (const name of directory.keys()) {\r\n      keys.push(name);\r\n    }\r\n\r\n    return keys;\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    const directory = await this.getDirectory();\r\n\r\n    for await (const name of directory.keys()) {\r\n      await directory.removeEntry(name);\r\n    }\r\n  }\r\n\r\n  // Helper method to check OPFS support\r\n  static isSupported(): boolean {\r\n    return \"storage\" in navigator && \"getDirectory\" in navigator.storage;\r\n  }\r\n}\r\n","import { TProject } from \"@/types/project\";\r\nimport { MediaItem } from \"@/stores/media-store\";\r\nimport { IndexedDBAdapter } from \"./indexeddb-adapter\";\r\nimport { OPFSAdapter } from \"./opfs-adapter\";\r\nimport {\r\n  MediaFileData,\r\n  StorageConfig,\r\n  SerializedProject,\r\n  TimelineData,\r\n} from \"./types\";\r\nimport { TimelineTrack } from \"@/types/timeline\";\r\nimport { SavedSoundsData, SavedSound, SoundEffect } from \"@/types/sounds\";\r\n\r\nclass StorageService {\r\n  private projectsAdapter: IndexedDBAdapter<SerializedProject>;\r\n  private savedSoundsAdapter: IndexedDBAdapter<SavedSoundsData>;\r\n  private config: StorageConfig;\r\n\r\n  constructor() {\r\n    this.config = {\r\n      projectsDb: \"video-editor-projects\",\r\n      mediaDb: \"video-editor-media\",\r\n      timelineDb: \"video-editor-timelines\",\r\n      savedSoundsDb: \"video-editor-saved-sounds\",\r\n      version: 1,\r\n    };\r\n\r\n    this.projectsAdapter = new IndexedDBAdapter<SerializedProject>(\r\n      this.config.projectsDb,\r\n      \"projects\",\r\n      this.config.version\r\n    );\r\n\r\n    this.savedSoundsAdapter = new IndexedDBAdapter<SavedSoundsData>(\r\n      this.config.savedSoundsDb,\r\n      \"saved-sounds\",\r\n      this.config.version\r\n    );\r\n  }\r\n\r\n  // Helper to get project-specific media adapters\r\n  private getProjectMediaAdapters(projectId: string) {\r\n    const mediaMetadataAdapter = new IndexedDBAdapter<MediaFileData>(\r\n      `${this.config.mediaDb}-${projectId}`,\r\n      \"media-metadata\",\r\n      this.config.version\r\n    );\r\n\r\n    const mediaFilesAdapter = new OPFSAdapter(`media-files-${projectId}`);\r\n\r\n    return { mediaMetadataAdapter, mediaFilesAdapter };\r\n  }\r\n\r\n  // Helper to get project-specific timeline adapter\r\n  private getProjectTimelineAdapter(projectId: string) {\r\n    return new IndexedDBAdapter<TimelineData>(\r\n      `${this.config.timelineDb}-${projectId}`,\r\n      \"timeline\",\r\n      this.config.version\r\n    );\r\n  }\r\n\r\n  // Project operations\r\n  async saveProject(project: TProject): Promise<void> {\r\n    // Convert TProject to serializable format\r\n    const serializedProject: SerializedProject = {\r\n      id: project.id,\r\n      name: project.name,\r\n      thumbnail: project.thumbnail,\r\n      createdAt: project.createdAt.toISOString(),\r\n      updatedAt: project.updatedAt.toISOString(),\r\n      backgroundColor: project.backgroundColor,\r\n      backgroundType: project.backgroundType,\r\n      blurIntensity: project.blurIntensity,\r\n      bookmarks: project.bookmarks,\r\n      fps: project.fps,\r\n      canvasSize: project.canvasSize,\r\n      canvasMode: project.canvasMode,\r\n    };\r\n\r\n    await this.projectsAdapter.set(project.id, serializedProject);\r\n  }\r\n\r\n  async loadProject(id: string): Promise<TProject | null> {\r\n    const serializedProject = await this.projectsAdapter.get(id);\r\n\r\n    if (!serializedProject) return null;\r\n\r\n    // Convert back to TProject format\r\n    return {\r\n      id: serializedProject.id,\r\n      name: serializedProject.name,\r\n      thumbnail: serializedProject.thumbnail,\r\n      createdAt: new Date(serializedProject.createdAt),\r\n      updatedAt: new Date(serializedProject.updatedAt),\r\n      backgroundColor: serializedProject.backgroundColor,\r\n      backgroundType: serializedProject.backgroundType,\r\n      blurIntensity: serializedProject.blurIntensity,\r\n      bookmarks: serializedProject.bookmarks,\r\n      fps: serializedProject.fps,\r\n      canvasSize: serializedProject.canvasSize,\r\n      canvasMode: serializedProject.canvasMode,\r\n    };\r\n  }\r\n\r\n  async loadAllProjects(): Promise<TProject[]> {\r\n    const projectIds = await this.projectsAdapter.list();\r\n    const projects: TProject[] = [];\r\n\r\n    for (const id of projectIds) {\r\n      const project = await this.loadProject(id);\r\n      if (project) {\r\n        projects.push(project);\r\n      }\r\n    }\r\n\r\n    // Sort by last updated (most recent first)\r\n    return projects.sort(\r\n      (a, b) => b.updatedAt.getTime() - a.updatedAt.getTime()\r\n    );\r\n  }\r\n\r\n  async deleteProject(id: string): Promise<void> {\r\n    await this.projectsAdapter.remove(id);\r\n  }\r\n\r\n  // Media operations - now project-specific\r\n  async saveMediaItem(projectId: string, mediaItem: MediaItem): Promise<void> {\r\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\r\n      this.getProjectMediaAdapters(projectId);\r\n\r\n    // Save file to project-specific OPFS\r\n    await mediaFilesAdapter.set(mediaItem.id, mediaItem.file);\r\n\r\n    // Save metadata to project-specific IndexedDB\r\n    const metadata: MediaFileData = {\r\n      id: mediaItem.id,\r\n      name: mediaItem.name,\r\n      type: mediaItem.type,\r\n      size: mediaItem.file.size,\r\n      lastModified: mediaItem.file.lastModified,\r\n      width: mediaItem.width,\r\n      height: mediaItem.height,\r\n      duration: mediaItem.duration,\r\n      ephemeral: mediaItem.ephemeral,\r\n    };\r\n\r\n    await mediaMetadataAdapter.set(mediaItem.id, metadata);\r\n  }\r\n\r\n  async loadMediaItem(\r\n    projectId: string,\r\n    id: string\r\n  ): Promise<MediaItem | null> {\r\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\r\n      this.getProjectMediaAdapters(projectId);\r\n\r\n    const [file, metadata] = await Promise.all([\r\n      mediaFilesAdapter.get(id),\r\n      mediaMetadataAdapter.get(id),\r\n    ]);\r\n\r\n    if (!file || !metadata) return null;\r\n\r\n    let url: string;\r\n    if (metadata.type === \"image\" && (!file.type || file.type === \"\")) {\r\n      try {\r\n        const text = await file.text();\r\n        if (text.trim().startsWith(\"<svg\")) {\r\n          const svgBlob = new Blob([text], { type: \"image/svg+xml\" });\r\n          url = URL.createObjectURL(svgBlob);\r\n        } else {\r\n          url = URL.createObjectURL(file);\r\n        }\r\n      } catch {\r\n        url = URL.createObjectURL(file);\r\n      }\r\n    } else {\r\n      url = URL.createObjectURL(file);\r\n    }\r\n\r\n    return {\r\n      id: metadata.id,\r\n      name: metadata.name,\r\n      type: metadata.type,\r\n      file,\r\n      url,\r\n      width: metadata.width,\r\n      height: metadata.height,\r\n      duration: metadata.duration,\r\n      ephemeral: metadata.ephemeral,\r\n    };\r\n  }\r\n\r\n  async loadAllMediaItems(projectId: string): Promise<MediaItem[]> {\r\n    const { mediaMetadataAdapter } = this.getProjectMediaAdapters(projectId);\r\n\r\n    const mediaIds = await mediaMetadataAdapter.list();\r\n    const mediaItems: MediaItem[] = [];\r\n\r\n    for (const id of mediaIds) {\r\n      const item = await this.loadMediaItem(projectId, id);\r\n      if (item) {\r\n        mediaItems.push(item);\r\n      }\r\n    }\r\n\r\n    return mediaItems;\r\n  }\r\n\r\n  async deleteMediaItem(projectId: string, id: string): Promise<void> {\r\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\r\n      this.getProjectMediaAdapters(projectId);\r\n\r\n    await Promise.all([\r\n      mediaFilesAdapter.remove(id),\r\n      mediaMetadataAdapter.remove(id),\r\n    ]);\r\n  }\r\n\r\n  async deleteProjectMedia(projectId: string): Promise<void> {\r\n    const { mediaMetadataAdapter, mediaFilesAdapter } =\r\n      this.getProjectMediaAdapters(projectId);\r\n\r\n    await Promise.all([\r\n      mediaMetadataAdapter.clear(),\r\n      mediaFilesAdapter.clear(),\r\n    ]);\r\n  }\r\n\r\n  // Timeline operations - now project-specific\r\n  async saveTimeline(\r\n    projectId: string,\r\n    tracks: TimelineTrack[]\r\n  ): Promise<void> {\r\n    const timelineAdapter = this.getProjectTimelineAdapter(projectId);\r\n    const timelineData: TimelineData = {\r\n      tracks,\r\n      lastModified: new Date().toISOString(),\r\n    };\r\n    await timelineAdapter.set(\"timeline\", timelineData);\r\n  }\r\n\r\n  async loadTimeline(projectId: string): Promise<TimelineTrack[] | null> {\r\n    const timelineAdapter = this.getProjectTimelineAdapter(projectId);\r\n    const timelineData = await timelineAdapter.get(\"timeline\");\r\n    return timelineData ? timelineData.tracks : null;\r\n  }\r\n\r\n  async deleteProjectTimeline(projectId: string): Promise<void> {\r\n    const timelineAdapter = this.getProjectTimelineAdapter(projectId);\r\n    await timelineAdapter.remove(\"timeline\");\r\n  }\r\n\r\n  // Utility methods\r\n  async clearAllData(): Promise<void> {\r\n    // Clear all projects\r\n    await this.projectsAdapter.clear();\r\n\r\n    // Note: Project-specific media and timelines will be cleaned up when projects are deleted\r\n  }\r\n\r\n  async getStorageInfo(): Promise<{\r\n    projects: number;\r\n    isOPFSSupported: boolean;\r\n    isIndexedDBSupported: boolean;\r\n  }> {\r\n    const projectIds = await this.projectsAdapter.list();\r\n\r\n    return {\r\n      projects: projectIds.length,\r\n      isOPFSSupported: this.isOPFSSupported(),\r\n      isIndexedDBSupported: this.isIndexedDBSupported(),\r\n    };\r\n  }\r\n\r\n  async getProjectStorageInfo(projectId: string): Promise<{\r\n    mediaItems: number;\r\n    hasTimeline: boolean;\r\n  }> {\r\n    const { mediaMetadataAdapter } = this.getProjectMediaAdapters(projectId);\r\n    const timelineAdapter = this.getProjectTimelineAdapter(projectId);\r\n\r\n    const [mediaIds, timelineData] = await Promise.all([\r\n      mediaMetadataAdapter.list(),\r\n      timelineAdapter.get(\"timeline\"),\r\n    ]);\r\n\r\n    return {\r\n      mediaItems: mediaIds.length,\r\n      hasTimeline: !!timelineData,\r\n    };\r\n  }\r\n\r\n  async loadSavedSounds(): Promise<SavedSoundsData> {\r\n    try {\r\n      const savedSoundsData = await this.savedSoundsAdapter.get(\"user-sounds\");\r\n      return (\r\n        savedSoundsData || {\r\n          sounds: [],\r\n          lastModified: new Date().toISOString(),\r\n        }\r\n      );\r\n    } catch (error) {\r\n      console.error(\"Failed to load saved sounds:\", error);\r\n      return { sounds: [], lastModified: new Date().toISOString() };\r\n    }\r\n  }\r\n\r\n  async saveSoundEffect(soundEffect: SoundEffect): Promise<void> {\r\n    try {\r\n      const currentData = await this.loadSavedSounds();\r\n\r\n      // Check if sound is already saved\r\n      if (currentData.sounds.some((sound) => sound.id === soundEffect.id)) {\r\n        return; // Already saved\r\n      }\r\n\r\n      const savedSound: SavedSound = {\r\n        id: soundEffect.id,\r\n        name: soundEffect.name,\r\n        username: soundEffect.username,\r\n        previewUrl: soundEffect.previewUrl,\r\n        downloadUrl: soundEffect.downloadUrl,\r\n        duration: soundEffect.duration,\r\n        tags: soundEffect.tags,\r\n        license: soundEffect.license,\r\n        savedAt: new Date().toISOString(),\r\n      };\r\n\r\n      const updatedData: SavedSoundsData = {\r\n        sounds: [...currentData.sounds, savedSound],\r\n        lastModified: new Date().toISOString(),\r\n      };\r\n\r\n      await this.savedSoundsAdapter.set(\"user-sounds\", updatedData);\r\n    } catch (error) {\r\n      console.error(\"Failed to save sound effect:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async removeSavedSound(soundId: number): Promise<void> {\r\n    try {\r\n      const currentData = await this.loadSavedSounds();\r\n\r\n      const updatedData: SavedSoundsData = {\r\n        sounds: currentData.sounds.filter((sound) => sound.id !== soundId),\r\n        lastModified: new Date().toISOString(),\r\n      };\r\n\r\n      await this.savedSoundsAdapter.set(\"user-sounds\", updatedData);\r\n    } catch (error) {\r\n      console.error(\"Failed to remove saved sound:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async isSoundSaved(soundId: number): Promise<boolean> {\r\n    try {\r\n      const currentData = await this.loadSavedSounds();\r\n      return currentData.sounds.some((sound) => sound.id === soundId);\r\n    } catch (error) {\r\n      console.error(\"Failed to check if sound is saved:\", error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async clearSavedSounds(): Promise<void> {\r\n    try {\r\n      await this.savedSoundsAdapter.remove(\"user-sounds\");\r\n    } catch (error) {\r\n      console.error(\"Failed to clear saved sounds:\", error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Check browser support\r\n  isOPFSSupported(): boolean {\r\n    return OPFSAdapter.isSupported();\r\n  }\r\n\r\n  isIndexedDBSupported(): boolean {\r\n    return \"indexedDB\" in window;\r\n  }\r\n\r\n  isFullySupported(): boolean {\r\n    return this.isIndexedDBSupported() && this.isOPFSSupported();\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const storageService = new StorageService();\r\nexport { StorageService };\r\n","import { create } from \"zustand\";\r\nimport { storageService } from \"@/lib/storage/storage-service\";\r\nimport { useTimelineStore } from \"./timeline-store\";\r\nimport { generateUUID } from \"@/lib/utils\";\r\n\r\nexport type MediaType = \"image\" | \"video\" | \"audio\";\r\n\r\nexport interface MediaItem {\r\n  id: string;\r\n  name: string;\r\n  type: MediaType;\r\n  file: File;\r\n  url?: string; // Object URL for preview\r\n  thumbnailUrl?: string; // For video thumbnails\r\n  duration?: number; // For video/audio duration\r\n  width?: number; // For video/image width\r\n  height?: number; // For video/image height\r\n  fps?: number; // For video frame rate\r\n  // Ephemeral items are used by timeline directly and should not appear in the media library or be persisted\r\n  ephemeral?: boolean;\r\n  // Text-specific properties\r\n  content?: string; // Text content\r\n  fontSize?: number; // Font size\r\n  fontFamily?: string; // Font family\r\n  color?: string; // Text color\r\n  backgroundColor?: string; // Background color\r\n  textAlign?: \"left\" | \"center\" | \"right\"; // Text alignment\r\n}\r\n\r\ninterface MediaStore {\r\n  mediaItems: MediaItem[];\r\n  isLoading: boolean;\r\n\r\n  // Actions - now require projectId\r\n  addMediaItem: (\r\n    projectId: string,\r\n    item: Omit<MediaItem, \"id\">\r\n  ) => Promise<void>;\r\n  removeMediaItem: (projectId: string, id: string) => Promise<void>;\r\n  loadProjectMedia: (projectId: string) => Promise<void>;\r\n  clearProjectMedia: (projectId: string) => Promise<void>;\r\n  clearAllMedia: () => void; // Clear local state only\r\n}\r\n\r\n// Helper function to determine file type\r\nexport const getFileType = (file: File): MediaType | null => {\r\n  const { type } = file;\r\n\r\n  if (type.startsWith(\"image/\")) {\r\n    return \"image\";\r\n  }\r\n  if (type.startsWith(\"video/\")) {\r\n    return \"video\";\r\n  }\r\n  if (type.startsWith(\"audio/\")) {\r\n    return \"audio\";\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\n// Helper function to get image dimensions\r\nexport const getImageDimensions = (\r\n  file: File\r\n): Promise<{ width: number; height: number }> => {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new window.Image();\r\n\r\n    img.addEventListener(\"load\", () => {\r\n      const width = img.naturalWidth;\r\n      const height = img.naturalHeight;\r\n      resolve({ width, height });\r\n      img.remove();\r\n    });\r\n\r\n    img.addEventListener(\"error\", () => {\r\n      reject(new Error(\"Could not load image\"));\r\n      img.remove();\r\n    });\r\n\r\n    img.src = URL.createObjectURL(file);\r\n  });\r\n};\r\n\r\n// Helper function to generate video thumbnail and get dimensions\r\nexport const generateVideoThumbnail = (\r\n  file: File\r\n): Promise<{ thumbnailUrl: string; width: number; height: number }> => {\r\n  return new Promise((resolve, reject) => {\r\n    const video = document.createElement(\"video\") as HTMLVideoElement;\r\n    const canvas = document.createElement(\"canvas\") as HTMLCanvasElement;\r\n    const ctx = canvas.getContext(\"2d\");\r\n\r\n    if (!ctx) {\r\n      reject(new Error(\"Could not get canvas context\"));\r\n      return;\r\n    }\r\n\r\n    video.addEventListener(\"loadedmetadata\", () => {\r\n      canvas.width = video.videoWidth;\r\n      canvas.height = video.videoHeight;\r\n\r\n      // Seek to 1 second or 10% of duration, whichever is smaller\r\n      video.currentTime = Math.min(1, video.duration * 0.1);\r\n    });\r\n\r\n    video.addEventListener(\"seeked\", () => {\r\n      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\r\n      const thumbnailUrl = canvas.toDataURL(\"image/jpeg\", 0.8);\r\n      const width = video.videoWidth;\r\n      const height = video.videoHeight;\r\n\r\n      resolve({ thumbnailUrl, width, height });\r\n\r\n      // Cleanup\r\n      video.remove();\r\n      canvas.remove();\r\n    });\r\n\r\n    video.addEventListener(\"error\", () => {\r\n      reject(new Error(\"Could not load video\"));\r\n      video.remove();\r\n      canvas.remove();\r\n    });\r\n\r\n    video.src = URL.createObjectURL(file);\r\n    video.load();\r\n  });\r\n};\r\n\r\n// Helper function to get media duration\r\nexport const getMediaDuration = (file: File): Promise<number> => {\r\n  return new Promise((resolve, reject) => {\r\n    const element = document.createElement(\r\n      file.type.startsWith(\"video/\") ? \"video\" : \"audio\"\r\n    ) as HTMLVideoElement;\r\n\r\n    element.addEventListener(\"loadedmetadata\", () => {\r\n      resolve(element.duration);\r\n      element.remove();\r\n    });\r\n\r\n    element.addEventListener(\"error\", () => {\r\n      reject(new Error(\"Could not load media\"));\r\n      element.remove();\r\n    });\r\n\r\n    element.src = URL.createObjectURL(file);\r\n    element.load();\r\n  });\r\n};\r\n\r\n// Helper to get aspect ratio from MediaItem\r\nexport const getMediaAspectRatio = (item: MediaItem): number => {\r\n  if (item.width && item.height) {\r\n    return item.width / item.height;\r\n  }\r\n  return 16 / 9; // Default aspect ratio\r\n};\r\n\r\nexport const useMediaStore = create<MediaStore>((set, get) => ({\r\n  mediaItems: [],\r\n  isLoading: false,\r\n\r\n  addMediaItem: async (projectId, item) => {\r\n    const newItem: MediaItem = {\r\n      ...item,\r\n      id: generateUUID(),\r\n    };\r\n\r\n    // Add to local state immediately for UI responsiveness\r\n    set((state) => ({\r\n      mediaItems: [...state.mediaItems, newItem],\r\n    }));\r\n\r\n    // Save to persistent storage in background\r\n    try {\r\n      await storageService.saveMediaItem(projectId, newItem);\r\n    } catch (error) {\r\n      console.error(\"Failed to save media item:\", error);\r\n      // Remove from local state if save failed\r\n      set((state) => ({\r\n        mediaItems: state.mediaItems.filter((media) => media.id !== newItem.id),\r\n      }));\r\n    }\r\n  },\r\n\r\n  removeMediaItem: async (projectId: string, id: string) => {\r\n    const state = get();\r\n    const item = state.mediaItems.find((media) => media.id === id);\r\n\r\n    // Cleanup object URLs to prevent memory leaks\r\n    if (item?.url) {\r\n      URL.revokeObjectURL(item.url);\r\n      if (item.thumbnailUrl) {\r\n        URL.revokeObjectURL(item.thumbnailUrl);\r\n      }\r\n    }\r\n\r\n    // 1) Remove from local state immediately\r\n    set((state) => ({\r\n      mediaItems: state.mediaItems.filter((media) => media.id !== id),\r\n    }));\r\n\r\n    // 2) Cascade into the timeline: remove any elements using this media ID\r\n    const timeline = useTimelineStore.getState();\r\n    const {\r\n      tracks,\r\n      removeElementFromTrack,\r\n      removeElementFromTrackWithRipple,\r\n      rippleEditingEnabled,\r\n      pushHistory,\r\n    } = timeline;\r\n\r\n    // Find all elements that reference this media\r\n    const elementsToRemove: Array<{ trackId: string; elementId: string }> = [];\r\n    for (const track of tracks) {\r\n      for (const el of track.elements) {\r\n        if (el.type === \"media\" && el.mediaId === id) {\r\n          elementsToRemove.push({ trackId: track.id, elementId: el.id });\r\n        }\r\n      }\r\n    }\r\n\r\n    // If there are elements to remove, push history once before batch removal\r\n    if (elementsToRemove.length > 0) {\r\n      pushHistory();\r\n\r\n      // Remove all elements without pushing additional history entries\r\n      for (const { trackId, elementId } of elementsToRemove) {\r\n        if (rippleEditingEnabled) {\r\n          removeElementFromTrackWithRipple(trackId, elementId, false);\r\n        } else {\r\n          removeElementFromTrack(trackId, elementId, false);\r\n        }\r\n      }\r\n    }\r\n\r\n    // 3) Remove from persistent storage\r\n    try {\r\n      await storageService.deleteMediaItem(projectId, id);\r\n    } catch (error) {\r\n      console.error(\"Failed to delete media item:\", error);\r\n    }\r\n  },\r\n\r\n  loadProjectMedia: async (projectId) => {\r\n    set({ isLoading: true });\r\n\r\n    try {\r\n      const mediaItems = await storageService.loadAllMediaItems(projectId);\r\n\r\n      // Regenerate thumbnails for video items\r\n      const updatedMediaItems = await Promise.all(\r\n        mediaItems.map(async (item) => {\r\n          if (item.type === \"video\" && item.file) {\r\n            try {\r\n              const { thumbnailUrl, width, height } =\r\n                await generateVideoThumbnail(item.file);\r\n              return {\r\n                ...item,\r\n                thumbnailUrl,\r\n                width: width || item.width,\r\n                height: height || item.height,\r\n              };\r\n            } catch (error) {\r\n              console.error(\r\n                `Failed to regenerate thumbnail for video ${item.id}:`,\r\n                error\r\n              );\r\n              return item;\r\n            }\r\n          }\r\n          return item;\r\n        })\r\n      );\r\n\r\n      set({ mediaItems: updatedMediaItems });\r\n    } catch (error) {\r\n      console.error(\"Failed to load media items:\", error);\r\n    } finally {\r\n      set({ isLoading: false });\r\n    }\r\n  },\r\n\r\n  clearProjectMedia: async (projectId) => {\r\n    const state = get();\r\n\r\n    // Cleanup all object URLs\r\n    state.mediaItems.forEach((item) => {\r\n      if (item.url) {\r\n        URL.revokeObjectURL(item.url);\r\n      }\r\n      if (item.thumbnailUrl) {\r\n        URL.revokeObjectURL(item.thumbnailUrl);\r\n      }\r\n    });\r\n\r\n    // Clear local state\r\n    set({ mediaItems: [] });\r\n\r\n    // Clear persistent storage\r\n    try {\r\n      const mediaIds = state.mediaItems.map((item) => item.id);\r\n      await Promise.all(\r\n        mediaIds.map((id) => storageService.deleteMediaItem(projectId, id))\r\n      );\r\n    } catch (error) {\r\n      console.error(\"Failed to clear media items from storage:\", error);\r\n    }\r\n  },\r\n\r\n  clearAllMedia: () => {\r\n    const state = get();\r\n\r\n    // Cleanup all object URLs\r\n    state.mediaItems.forEach((item) => {\r\n      if (item.url) {\r\n        URL.revokeObjectURL(item.url);\r\n      }\r\n      if (item.thumbnailUrl) {\r\n        URL.revokeObjectURL(item.thumbnailUrl);\r\n      }\r\n    });\r\n\r\n    // Clear local state\r\n    set({ mediaItems: [] });\r\n  },\r\n}));\r\n","import { TProject } from \"@/types/project\";\r\nimport { create } from \"zustand\";\r\nimport { storageService } from \"@/lib/storage/storage-service\";\r\nimport { toast } from \"sonner\";\r\nimport { useMediaStore } from \"./media-store\";\r\nimport { useTimelineStore } from \"./timeline-store\";\r\nimport { generateUUID } from \"@/lib/utils\";\r\nimport { CanvasSize, CanvasMode } from \"@/types/editor\";\r\n\r\nexport const DEFAULT_CANVAS_SIZE: CanvasSize = { width: 1920, height: 1080 };\r\nexport const DEFAULT_FPS = 30;\r\n\r\nconst DEFAULT_PROJECT: TProject = {\r\n  id: generateUUID(),\r\n  name: \"Untitled\",\r\n  thumbnail: \"\",\r\n  createdAt: new Date(),\r\n  updatedAt: new Date(),\r\n  backgroundColor: \"#000000\",\r\n  backgroundType: \"color\",\r\n  blurIntensity: 8,\r\n  bookmarks: [],\r\n  fps: DEFAULT_FPS,\r\n  canvasSize: DEFAULT_CANVAS_SIZE,\r\n  canvasMode: \"preset\",\r\n};\r\n\r\ninterface ProjectStore {\r\n  activeProject: TProject | null;\r\n  savedProjects: TProject[];\r\n  isLoading: boolean;\r\n  isInitialized: boolean;\r\n  invalidProjectIds?: Set<string>;\r\n\r\n  // Actions\r\n  createNewProject: (name: string) => Promise<string>;\r\n  loadProject: (id: string) => Promise<void>;\r\n  saveCurrentProject: () => Promise<void>;\r\n  loadAllProjects: () => Promise<void>;\r\n  deleteProject: (id: string) => Promise<void>;\r\n  closeProject: () => void;\r\n  renameProject: (projectId: string, name: string) => Promise<void>;\r\n  duplicateProject: (projectId: string) => Promise<string>;\r\n  updateProjectBackground: (backgroundColor: string) => Promise<void>;\r\n  updateBackgroundType: (\r\n    type: \"color\" | \"blur\",\r\n    options?: { backgroundColor?: string; blurIntensity?: number }\r\n  ) => Promise<void>;\r\n  updateProjectFps: (fps: number) => Promise<void>;\r\n  updateCanvasSize: (size: CanvasSize, mode: CanvasMode) => Promise<void>;\r\n\r\n  // Bookmark methods\r\n  toggleBookmark: (time: number) => Promise<void>;\r\n  isBookmarked: (time: number) => boolean;\r\n  removeBookmark: (time: number) => Promise<void>;\r\n\r\n  getFilteredAndSortedProjects: (\r\n    searchQuery: string,\r\n    sortOption: string\r\n  ) => TProject[];\r\n\r\n  // Global invalid project ID tracking\r\n  isInvalidProjectId: (id: string) => boolean;\r\n  markProjectIdAsInvalid: (id: string) => void;\r\n  clearInvalidProjectIds: () => void;\r\n}\r\n\r\nexport const useProjectStore = create<ProjectStore>((set, get) => ({\r\n  activeProject: null,\r\n  savedProjects: [],\r\n  isLoading: true,\r\n  isInitialized: false,\r\n  invalidProjectIds: new Set<string>(),\r\n\r\n  // Implementation of bookmark methods\r\n  toggleBookmark: async (time: number) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    // Round time to the nearest frame\r\n    const fps = activeProject.fps || DEFAULT_FPS;\r\n    const frameTime = Math.round(time * fps) / fps;\r\n\r\n    const bookmarks = activeProject.bookmarks || [];\r\n    let updatedBookmarks: number[];\r\n\r\n    // Check if already bookmarked\r\n    const bookmarkIndex = bookmarks.findIndex(\r\n      (bookmark) => Math.abs(bookmark - frameTime) < 0.001\r\n    );\r\n\r\n    if (bookmarkIndex !== -1) {\r\n      // Remove bookmark\r\n      updatedBookmarks = bookmarks.filter((_, i) => i !== bookmarkIndex);\r\n    } else {\r\n      // Add bookmark\r\n      updatedBookmarks = [...bookmarks, frameTime].sort((a, b) => a - b);\r\n    }\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      bookmarks: updatedBookmarks,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update project bookmarks:\", error);\r\n      toast.error(\"Failed to update bookmarks\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  isBookmarked: (time: number) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject || !activeProject.bookmarks) return false;\r\n\r\n    // Round time to the nearest frame\r\n    const fps = activeProject.fps || DEFAULT_FPS;\r\n    const frameTime = Math.round(time * fps) / fps;\r\n\r\n    return activeProject.bookmarks.some(\r\n      (bookmark) => Math.abs(bookmark - frameTime) < 0.001\r\n    );\r\n  },\r\n\r\n  removeBookmark: async (time: number) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject || !activeProject.bookmarks) return;\r\n\r\n    // Round time to the nearest frame\r\n    const fps = activeProject.fps || DEFAULT_FPS;\r\n    const frameTime = Math.round(time * fps) / fps;\r\n\r\n    const updatedBookmarks = activeProject.bookmarks.filter(\r\n      (bookmark) => Math.abs(bookmark - frameTime) >= 0.001\r\n    );\r\n\r\n    if (updatedBookmarks.length === activeProject.bookmarks.length) {\r\n      // No bookmark found to remove\r\n      return;\r\n    }\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      bookmarks: updatedBookmarks,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update project bookmarks:\", error);\r\n      toast.error(\"Failed to remove bookmark\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  createNewProject: async (name: string) => {\r\n    const newProject: TProject = {\r\n      ...DEFAULT_PROJECT,\r\n      id: generateUUID(),\r\n      name,\r\n      createdAt: new Date(),\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    set({ activeProject: newProject });\r\n\r\n    const mediaStore = useMediaStore.getState();\r\n    const timelineStore = useTimelineStore.getState();\r\n    mediaStore.clearAllMedia();\r\n    timelineStore.clearTimeline();\r\n\r\n    try {\r\n      await storageService.saveProject(newProject);\r\n      // Reload all projects to update the list\r\n      await get().loadAllProjects();\r\n      return newProject.id;\r\n    } catch (error) {\r\n      toast.error(\"Failed to save new project\");\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  loadProject: async (id: string) => {\r\n    if (!get().isInitialized) {\r\n      set({ isLoading: true });\r\n    }\r\n\r\n    // Clear media and timeline immediately to prevent flickering when switching projects\r\n    const mediaStore = useMediaStore.getState();\r\n    const timelineStore = useTimelineStore.getState();\r\n    mediaStore.clearAllMedia();\r\n    timelineStore.clearTimeline();\r\n\r\n    try {\r\n      const project = await storageService.loadProject(id);\r\n      if (project) {\r\n        set({ activeProject: project });\r\n\r\n        // Load project-specific data in parallel\r\n        await Promise.all([\r\n          mediaStore.loadProjectMedia(id),\r\n          timelineStore.loadProjectTimeline(id),\r\n        ]);\r\n      } else {\r\n        throw new Error(`Project with id ${id} not found`);\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to load project:\", error);\r\n      throw error; // Re-throw so the editor page can handle it\r\n    } finally {\r\n      set({ isLoading: false });\r\n    }\r\n  },\r\n\r\n  saveCurrentProject: async () => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    try {\r\n      // Save project metadata and timeline data in parallel\r\n      const timelineStore = useTimelineStore.getState();\r\n      await Promise.all([\r\n        storageService.saveProject(activeProject),\r\n        timelineStore.saveProjectTimeline(activeProject.id),\r\n      ]);\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to save project:\", error);\r\n    }\r\n  },\r\n\r\n  loadAllProjects: async () => {\r\n    if (!get().isInitialized) {\r\n      set({ isLoading: true });\r\n    }\r\n\r\n    try {\r\n      const projects = await storageService.loadAllProjects();\r\n      set({ savedProjects: projects });\r\n    } catch (error) {\r\n      console.error(\"Failed to load projects:\", error);\r\n    } finally {\r\n      set({ isLoading: false, isInitialized: true });\r\n    }\r\n  },\r\n\r\n  deleteProject: async (id: string) => {\r\n    try {\r\n      // Delete project data in parallel\r\n      await Promise.all([\r\n        storageService.deleteProjectMedia(id),\r\n        storageService.deleteProjectTimeline(id),\r\n        storageService.deleteProject(id),\r\n      ]);\r\n      await get().loadAllProjects(); // Refresh the list\r\n\r\n      // If we deleted the active project, close it and clear data\r\n      const { activeProject } = get();\r\n      if (activeProject?.id === id) {\r\n        set({ activeProject: null });\r\n        const mediaStore = useMediaStore.getState();\r\n        const timelineStore = useTimelineStore.getState();\r\n        mediaStore.clearAllMedia();\r\n        timelineStore.clearTimeline();\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to delete project:\", error);\r\n    }\r\n  },\r\n\r\n  closeProject: () => {\r\n    set({ activeProject: null });\r\n\r\n    // Clear data from stores when closing project\r\n    const mediaStore = useMediaStore.getState();\r\n    const timelineStore = useTimelineStore.getState();\r\n    mediaStore.clearAllMedia();\r\n    timelineStore.clearTimeline();\r\n  },\r\n\r\n  renameProject: async (id: string, name: string) => {\r\n    const { savedProjects } = get();\r\n\r\n    // Find the project to rename\r\n    const projectToRename = savedProjects.find((p) => p.id === id);\r\n    if (!projectToRename) {\r\n      toast.error(\"Project not found\", {\r\n        description: \"Please try again\",\r\n      });\r\n      return;\r\n    }\r\n\r\n    const updatedProject = {\r\n      ...projectToRename,\r\n      name,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      // Save to storage\r\n      await storageService.saveProject(updatedProject);\r\n\r\n      await get().loadAllProjects();\r\n\r\n      // Update activeProject if it's the same project\r\n      const { activeProject } = get();\r\n      if (activeProject?.id === id) {\r\n        set({ activeProject: updatedProject });\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to rename project:\", error);\r\n      toast.error(\"Failed to rename project\", {\r\n        description:\r\n          error instanceof Error ? error.message : \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  duplicateProject: async (projectId: string) => {\r\n    try {\r\n      const project = await storageService.loadProject(projectId);\r\n      if (!project) {\r\n        toast.error(\"Project not found\", {\r\n          description: \"Please try again\",\r\n        });\r\n        throw new Error(\"Project not found\");\r\n      }\r\n\r\n      const { savedProjects } = get();\r\n\r\n      // Extract the base name (remove any existing numbering)\r\n      const numberMatch = project.name.match(/^\\((\\d+)\\)\\s+(.+)$/);\r\n      const baseName = numberMatch ? numberMatch[2] : project.name;\r\n      const existingNumbers: number[] = [];\r\n\r\n      // Check for pattern \"(number) baseName\" in existing projects\r\n      savedProjects.forEach((p) => {\r\n        const match = p.name.match(/^\\((\\d+)\\)\\s+(.+)$/);\r\n        if (match && match[2] === baseName) {\r\n          existingNumbers.push(parseInt(match[1], 10));\r\n        }\r\n      });\r\n\r\n      const nextNumber =\r\n        existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;\r\n\r\n      const newProject: TProject = {\r\n        ...project, // Copy all properties from the original project\r\n        id: generateUUID(),\r\n        name: `(${nextNumber}) ${baseName}`,\r\n        createdAt: new Date(),\r\n        updatedAt: new Date(),\r\n      };\r\n\r\n      await storageService.saveProject(newProject);\r\n      await get().loadAllProjects();\r\n      return newProject.id;\r\n    } catch (error) {\r\n      console.error(\"Failed to duplicate project:\", error);\r\n      toast.error(\"Failed to duplicate project\", {\r\n        description:\r\n          error instanceof Error ? error.message : \"Please try again\",\r\n      });\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  updateProjectBackground: async (backgroundColor: string) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      backgroundColor,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update project background:\", error);\r\n      toast.error(\"Failed to update background\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  updateBackgroundType: async (\r\n    type: \"color\" | \"blur\",\r\n    options?: { backgroundColor?: string; blurIntensity?: number }\r\n  ) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      backgroundType: type,\r\n      ...(options?.backgroundColor && {\r\n        backgroundColor: options.backgroundColor,\r\n      }),\r\n      ...(options?.blurIntensity && { blurIntensity: options.blurIntensity }),\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update background type:\", error);\r\n      toast.error(\"Failed to update background\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  updateProjectFps: async (fps: number) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      fps,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update project FPS:\", error);\r\n      toast.error(\"Failed to update project FPS\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  updateCanvasSize: async (size: CanvasSize, mode: CanvasMode) => {\r\n    const { activeProject } = get();\r\n    if (!activeProject) return;\r\n\r\n    const updatedProject = {\r\n      ...activeProject,\r\n      canvasSize: size,\r\n      canvasMode: mode,\r\n      updatedAt: new Date(),\r\n    };\r\n\r\n    try {\r\n      await storageService.saveProject(updatedProject);\r\n      set({ activeProject: updatedProject });\r\n      await get().loadAllProjects(); // Refresh the list\r\n    } catch (error) {\r\n      console.error(\"Failed to update canvas size:\", error);\r\n      toast.error(\"Failed to update canvas size\", {\r\n        description: \"Please try again\",\r\n      });\r\n    }\r\n  },\r\n\r\n  getFilteredAndSortedProjects: (searchQuery: string, sortOption: string) => {\r\n    const { savedProjects } = get();\r\n\r\n    // Filter projects by search query\r\n    const filteredProjects = savedProjects.filter((project) =>\r\n      project.name.toLowerCase().includes(searchQuery.toLowerCase())\r\n    );\r\n\r\n    // Sort filtered projects\r\n    const sortedProjects = [...filteredProjects].sort((a, b) => {\r\n      const [key, order] = sortOption.split(\"-\");\r\n\r\n      if (key !== \"createdAt\" && key !== \"name\") {\r\n        console.warn(`Invalid sort key: ${key}`);\r\n        return 0;\r\n      }\r\n\r\n      const aValue = a[key];\r\n      const bValue = b[key];\r\n\r\n      if (aValue === undefined || bValue === undefined) return 0;\r\n\r\n      if (order === \"asc\") {\r\n        if (aValue < bValue) return -1;\r\n        if (aValue > bValue) return 1;\r\n        return 0;\r\n      }\r\n      if (aValue > bValue) return -1;\r\n      if (aValue < bValue) return 1;\r\n      return 0;\r\n    });\r\n\r\n    return sortedProjects;\r\n  },\r\n\r\n  // Global invalid project ID tracking implementation\r\n  isInvalidProjectId: (id: string) => {\r\n    const invalidIds = get().invalidProjectIds || new Set();\r\n    return invalidIds.has(id);\r\n  },\r\n\r\n  markProjectIdAsInvalid: (id: string) => {\r\n    set((state) => ({\r\n      invalidProjectIds: new Set([\r\n        ...(state.invalidProjectIds || new Set()),\r\n        id,\r\n      ]),\r\n    }));\r\n  },\r\n\r\n  clearInvalidProjectIds: () => {\r\n    set({ invalidProjectIds: new Set() });\r\n  },\r\n}));\r\n","import type { TrackType } from \"@/types/timeline\";\r\n\r\n// Track color definitions\r\nexport const TRACK_COLORS: Record<\r\n  TrackType,\r\n  { solid: string; background: string; border: string }\r\n> = {\r\n  media: {\r\n    solid: \"bg-blue-500\",\r\n    background: \"\",\r\n    border: \"\",\r\n  },\r\n  text: {\r\n    solid: \"bg-[#5DBAA0]\",\r\n    background: \"bg-[#5DBAA0]\",\r\n    border: \"\",\r\n  },\r\n  audio: {\r\n    solid: \"bg-green-500\",\r\n    background: \"bg-[#915DBE]\",\r\n    border: \"\",\r\n  },\r\n} as const;\r\n\r\n// Utility functions\r\nexport function getTrackColors(type: TrackType) {\r\n  return TRACK_COLORS[type];\r\n}\r\n\r\nexport function getTrackElementClasses(type: TrackType) {\r\n  const colors = getTrackColors(type);\r\n  return `${colors.background} ${colors.border}`;\r\n}\r\n\r\n// Track height definitions\r\nexport const TRACK_HEIGHTS: Record<TrackType, number> = {\r\n  media: 60,\r\n  text: 25,\r\n  audio: 50,\r\n} as const;\r\n\r\n// Utility function for track heights\r\nexport function getTrackHeight(type: TrackType): number {\r\n  return TRACK_HEIGHTS[type];\r\n}\r\n\r\n// Calculate cumulative height up to (but not including) a track index\r\nexport function getCumulativeHeightBefore(\r\n  tracks: Array<{ type: TrackType }>,\r\n  trackIndex: number\r\n): number {\r\n  const GAP = 4; // 4px gap between tracks (equivalent to Tailwind's gap-1)\r\n  return tracks\r\n    .slice(0, trackIndex)\r\n    .reduce((sum, track) => sum + getTrackHeight(track.type) + GAP, 0);\r\n}\r\n\r\n// Calculate total height of all tracks\r\nexport function getTotalTracksHeight(\r\n  tracks: Array<{ type: TrackType }>\r\n): number {\r\n  const GAP = 4; // 4px gap between tracks (equivalent to Tailwind's gap-1)\r\n  const tracksHeight = tracks.reduce(\r\n    (sum, track) => sum + getTrackHeight(track.type),\r\n    0\r\n  );\r\n  const gapsHeight = Math.max(0, tracks.length - 1) * GAP; // n-1 gaps for n tracks\r\n  return tracksHeight + gapsHeight;\r\n}\r\n\r\n// Other timeline constants\r\nexport const TIMELINE_CONSTANTS = {\r\n  ELEMENT_MIN_WIDTH: 80,\r\n  PIXELS_PER_SECOND: 50,\r\n  TRACK_HEIGHT: 60, // Default fallback\r\n  DEFAULT_TEXT_DURATION: 5,\r\n  DEFAULT_IMAGE_DURATION: 5,\r\n  ZOOM_LEVELS: [0.25, 0.5, 1, 1.5, 2, 3, 4],\r\n} as const;\r\n\r\n// FPS presets for project settings\r\nexport const FPS_PRESETS = [\r\n  { value: \"24\", label: \"24 fps\" },\r\n  { value: \"25\", label: \"25 fps\" },\r\n  { value: \"30\", label: \"30 fps\" },\r\n  { value: \"60\", label: \"60 fps\" },\r\n  { value: \"120\", label: \"120 fps\" },\r\n] as const;\r\n\r\n// Frame snapping utilities\r\nexport function timeToFrame(time: number, fps: number): number {\r\n  return Math.round(time * fps);\r\n}\r\n\r\nexport function frameToTime(frame: number, fps: number): number {\r\n  return frame / fps;\r\n}\r\n\r\nexport function snapTimeToFrame(time: number, fps: number): number {\r\n  if (fps <= 0) return time; // Fallback for invalid FPS\r\n  const frame = timeToFrame(time, fps);\r\n  return frameToTime(frame, fps);\r\n}\r\n\r\nexport function getFrameDuration(fps: number): number {\r\n  return 1 / fps;\r\n}\r\n","import { CanvasSize } from \"@/types/editor\";\r\n\r\nconst DEFAULT_CANVAS_PRESETS = [\r\n  { name: \"16:9\", width: 1920, height: 1080 },\r\n  { name: \"9:16\", width: 1080, height: 1920 },\r\n  { name: \"1:1\", width: 1080, height: 1080 },\r\n  { name: \"4:3\", width: 1440, height: 1080 },\r\n];\r\n\r\n/**\r\n * Helper function to find the best matching canvas preset for an aspect ratio\r\n * @param aspectRatio The target aspect ratio to match\r\n * @returns The best matching canvas size\r\n */\r\nexport function findBestCanvasPreset(aspectRatio: number): CanvasSize {\r\n  // Calculate aspect ratio for each preset and find the closest match\r\n  let bestMatch = DEFAULT_CANVAS_PRESETS[0]; // Default to 16:9 HD\r\n  let smallestDifference = Math.abs(\r\n    aspectRatio - bestMatch.width / bestMatch.height\r\n  );\r\n\r\n  for (const preset of DEFAULT_CANVAS_PRESETS) {\r\n    const presetAspectRatio = preset.width / preset.height;\r\n    const difference = Math.abs(aspectRatio - presetAspectRatio);\r\n\r\n    if (difference < smallestDifference) {\r\n      smallestDifference = difference;\r\n      bestMatch = preset;\r\n    }\r\n  }\r\n\r\n  // If the difference is still significant (> 0.1), create a custom size\r\n  // based on the media aspect ratio with a reasonable resolution\r\n  const bestAspectRatio = bestMatch.width / bestMatch.height;\r\n  if (Math.abs(aspectRatio - bestAspectRatio) > 0.1) {\r\n    // Create custom dimensions based on the aspect ratio\r\n    if (aspectRatio > 1) {\r\n      // Landscape - use 1920 width\r\n      return { width: 1920, height: Math.round(1920 / aspectRatio) };\r\n    }\r\n    // Portrait or square - use 1080 height\r\n    return { width: Math.round(1080 * aspectRatio), height: 1080 };\r\n  }\r\n\r\n  return { width: bestMatch.width, height: bestMatch.height };\r\n}\r\n","import { TimelineElement } from \"@/types/timeline\";\r\n\r\n// Helper function to check for element overlaps and prevent invalid timeline states\r\nexport const checkElementOverlaps = (elements: TimelineElement[]): boolean => {\r\n  // Sort elements by start time\r\n  const sortedElements = [...elements].sort(\r\n    (a, b) => a.startTime - b.startTime\r\n  );\r\n\r\n  for (let i = 0; i < sortedElements.length - 1; i++) {\r\n    const current = sortedElements[i];\r\n    const next = sortedElements[i + 1];\r\n\r\n    const currentEnd =\r\n      current.startTime +\r\n      (current.duration - current.trimStart - current.trimEnd);\r\n\r\n    // Check if current element overlaps with next element\r\n    if (currentEnd > next.startTime) return true; // Overlap detected\r\n  }\r\n\r\n  return false; // No overlaps\r\n};\r\n\r\n// Helper function to resolve overlaps by adjusting element positions\r\nexport const resolveElementOverlaps = (\r\n  elements: TimelineElement[]\r\n): TimelineElement[] => {\r\n  // Sort elements by start time\r\n  const sortedElements = [...elements].sort(\r\n    (a, b) => a.startTime - b.startTime\r\n  );\r\n  const resolvedElements: TimelineElement[] = [];\r\n\r\n  for (let i = 0; i < sortedElements.length; i++) {\r\n    const current = { ...sortedElements[i] };\r\n\r\n    if (resolvedElements.length > 0) {\r\n      const previous = resolvedElements[resolvedElements.length - 1];\r\n      const previousEnd =\r\n        previous.startTime +\r\n        (previous.duration - previous.trimStart - previous.trimEnd);\r\n\r\n      // If current element would overlap with previous, push it after previous ends\r\n      if (current.startTime < previousEnd) {\r\n        current.startTime = previousEnd;\r\n      }\r\n    }\r\n\r\n    resolvedElements.push(current);\r\n  }\r\n\r\n  return resolvedElements;\r\n};\r\n","import { create } from \"zustand\";\r\nimport {\r\n  TrackType,\r\n  TimelineElement,\r\n  CreateTimelineElement,\r\n  TimelineTrack,\r\n  TextElement,\r\n  DragData,\r\n  sortTracksByOrder,\r\n  ensureMainTrack,\r\n  validateElementTrackCompatibility,\r\n} from \"@/types/timeline\";\r\nimport {\r\n  useMediaStore,\r\n  getMediaAspectRatio,\r\n  type MediaItem,\r\n} from \"./media-store\";\r\nimport { findBestCanvasPreset } from \"@/lib/editor-utils\";\r\nimport { storageService } from \"@/lib/storage/storage-service\";\r\nimport { useProjectStore } from \"./project-store\";\r\nimport { generateUUID } from \"@/lib/utils\";\r\nimport { TIMELINE_CONSTANTS } from \"@/constants/timeline-constants\";\r\nimport { checkElementOverlaps, resolveElementOverlaps } from \"@/lib/timeline\";\r\n\r\n// Helper function to manage element naming with suffixes\r\nconst getElementNameWithSuffix = (\r\n  originalName: string,\r\n  suffix: string\r\n): string => {\r\n  // Remove existing suffixes to prevent accumulation\r\n  const baseName = originalName\r\n    .replace(/ \\(left\\)$/i, \"\")\r\n    .replace(/ \\(right\\)$/i, \"\")\r\n    .replace(/ \\(audio\\)$/i, \"\")\r\n    .replace(/ \\(split \\d+\\)$/i, \"\");\r\n\r\n  return `${baseName} (${suffix})`;\r\n};\r\n\r\ninterface TimelineStore {\r\n  // Private track storage\r\n  _tracks: TimelineTrack[];\r\n  history: TimelineTrack[][];\r\n  redoStack: TimelineTrack[][];\r\n\r\n  // Always returns properly ordered tracks with main track ensured\r\n  tracks: TimelineTrack[];\r\n\r\n  // Manual method if you need to force recomputation\r\n  getSortedTracks: () => TimelineTrack[];\r\n\r\n  // Snapping settings\r\n  snappingEnabled: boolean;\r\n\r\n  // Snapping actions\r\n  toggleSnapping: () => void;\r\n\r\n  // Ripple editing mode\r\n  rippleEditingEnabled: boolean;\r\n  toggleRippleEditing: () => void;\r\n\r\n  // Multi-selection\r\n  selectedElements: { trackId: string; elementId: string }[];\r\n  selectElement: (trackId: string, elementId: string, multi?: boolean) => void;\r\n  deselectElement: (trackId: string, elementId: string) => void;\r\n  clearSelectedElements: () => void;\r\n  setSelectedElements: (\r\n    elements: { trackId: string; elementId: string }[]\r\n  ) => void;\r\n\r\n  // Drag state\r\n  dragState: {\r\n    isDragging: boolean;\r\n    elementId: string | null;\r\n    trackId: string | null;\r\n    startMouseX: number;\r\n    startElementTime: number;\r\n    clickOffsetTime: number;\r\n    currentTime: number;\r\n  };\r\n  setDragState: (dragState: Partial<TimelineStore[\"dragState\"]>) => void;\r\n  startDrag: (\r\n    elementId: string,\r\n    trackId: string,\r\n    startMouseX: number,\r\n    startElementTime: number,\r\n    clickOffsetTime: number\r\n  ) => void;\r\n  updateDragTime: (currentTime: number) => void;\r\n  endDrag: () => void;\r\n\r\n  // Actions\r\n  addTrack: (type: TrackType) => string;\r\n  insertTrackAt: (type: TrackType, index: number) => string;\r\n  removeTrack: (trackId: string) => void;\r\n  removeTrackWithRipple: (trackId: string) => void;\r\n  addElementToTrack: (trackId: string, element: CreateTimelineElement) => void;\r\n  removeElementFromTrack: (\r\n    trackId: string,\r\n    elementId: string,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n  moveElementToTrack: (\r\n    fromTrackId: string,\r\n    toTrackId: string,\r\n    elementId: string\r\n  ) => void;\r\n  updateElementTrim: (\r\n    trackId: string,\r\n    elementId: string,\r\n    trimStart: number,\r\n    trimEnd: number,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n  updateElementDuration: (\r\n    trackId: string,\r\n    elementId: string,\r\n    duration: number,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n  updateElementStartTime: (\r\n    trackId: string,\r\n    elementId: string,\r\n    startTime: number,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n  toggleTrackMute: (trackId: string) => void;\r\n  toggleElementHidden: (trackId: string, elementId: string) => void;\r\n  toggleElementMuted: (trackId: string, elementId: string) => void;\r\n\r\n  // Split operations for elements\r\n  splitElement: (\r\n    trackId: string,\r\n    elementId: string,\r\n    splitTime: number\r\n  ) => string | null;\r\n  splitAndKeepLeft: (\r\n    trackId: string,\r\n    elementId: string,\r\n    splitTime: number\r\n  ) => void;\r\n  splitAndKeepRight: (\r\n    trackId: string,\r\n    elementId: string,\r\n    splitTime: number\r\n  ) => void;\r\n  separateAudio: (trackId: string, elementId: string) => string | null;\r\n\r\n  // Replace media for an element\r\n  replaceElementMedia: (\r\n    trackId: string,\r\n    elementId: string,\r\n    newFile: File\r\n  ) => Promise<{ success: boolean; error?: string }>;\r\n\r\n  // Ripple editing functions\r\n  updateElementStartTimeWithRipple: (\r\n    trackId: string,\r\n    elementId: string,\r\n    newStartTime: number\r\n  ) => void;\r\n  removeElementFromTrackWithRipple: (\r\n    trackId: string,\r\n    elementId: string,\r\n    pushHistory?: boolean\r\n  ) => void;\r\n\r\n  // Computed values\r\n  getTotalDuration: () => number;\r\n  getProjectThumbnail: (projectId: string) => Promise<string | null>;\r\n\r\n  // History actions\r\n  undo: () => void;\r\n  redo: () => void;\r\n  pushHistory: () => void;\r\n\r\n  // Persistence actions\r\n  loadProjectTimeline: (projectId: string) => Promise<void>;\r\n  saveProjectTimeline: (projectId: string) => Promise<void>;\r\n  clearTimeline: () => void;\r\n  updateTextElement: (\r\n    trackId: string,\r\n    elementId: string,\r\n    updates: Partial<\r\n      Pick<\r\n        TextElement,\r\n        | \"content\"\r\n        | \"fontSize\"\r\n        | \"fontFamily\"\r\n        | \"color\"\r\n        | \"backgroundColor\"\r\n        | \"textAlign\"\r\n        | \"fontWeight\"\r\n        | \"fontStyle\"\r\n        | \"textDecoration\"\r\n        | \"x\"\r\n        | \"y\"\r\n        | \"rotation\"\r\n        | \"opacity\"\r\n      >\r\n    >\r\n  ) => void;\r\n  checkElementOverlap: (\r\n    trackId: string,\r\n    startTime: number,\r\n    duration: number,\r\n    excludeElementId?: string\r\n  ) => boolean;\r\n  findOrCreateTrack: (trackType: TrackType) => string;\r\n  addMediaAtTime: (item: MediaItem, currentTime?: number) => boolean;\r\n  addTextAtTime: (item: TextElement, currentTime?: number) => boolean;\r\n  addMediaToNewTrack: (item: MediaItem) => boolean;\r\n  addTextToNewTrack: (item: TextElement | DragData) => boolean;\r\n}\r\n\r\nexport const useTimelineStore = create<TimelineStore>((set, get) => {\r\n  // Helper to update tracks and maintain ordering\r\n  const updateTracks = (newTracks: TimelineTrack[]) => {\r\n    const tracksWithMain = ensureMainTrack(newTracks);\r\n    const sortedTracks = sortTracksByOrder(tracksWithMain);\r\n    set({\r\n      _tracks: tracksWithMain,\r\n      tracks: sortedTracks,\r\n    });\r\n  };\r\n\r\n  // Helper to auto-save timeline changes\r\n  const autoSaveTimeline = async () => {\r\n    const activeProject = useProjectStore.getState().activeProject;\r\n    if (activeProject) {\r\n      try {\r\n        await storageService.saveTimeline(activeProject.id, get()._tracks);\r\n      } catch (error) {\r\n        console.error(\"Failed to auto-save timeline:\", error);\r\n      }\r\n    }\r\n  };\r\n\r\n  // Helper to update tracks and auto-save\r\n  const updateTracksAndSave = (newTracks: TimelineTrack[]) => {\r\n    updateTracks(newTracks);\r\n    // Auto-save in background\r\n    setTimeout(autoSaveTimeline, 100);\r\n  };\r\n\r\n  // Initialize with proper track ordering\r\n  const initialTracks = ensureMainTrack([]);\r\n  const sortedInitialTracks = sortTracksByOrder(initialTracks);\r\n\r\n  return {\r\n    _tracks: initialTracks,\r\n    tracks: sortedInitialTracks,\r\n    history: [],\r\n    redoStack: [],\r\n    selectedElements: [],\r\n    rippleEditingEnabled: false,\r\n\r\n    // Snapping settings defaults\r\n    snappingEnabled: true,\r\n\r\n    getSortedTracks: () => {\r\n      const { _tracks } = get();\r\n      const tracksWithMain = ensureMainTrack(_tracks);\r\n      return sortTracksByOrder(tracksWithMain);\r\n    },\r\n\r\n    pushHistory: () => {\r\n      const { _tracks, history } = get();\r\n      set({\r\n        history: [...history, JSON.parse(JSON.stringify(_tracks))],\r\n        redoStack: [],\r\n      });\r\n    },\r\n\r\n    undo: () => {\r\n      const { history, redoStack, _tracks } = get();\r\n      if (history.length === 0) return;\r\n      const prev = history[history.length - 1];\r\n      updateTracksAndSave(prev);\r\n      set({\r\n        history: history.slice(0, -1),\r\n        redoStack: [...redoStack, JSON.parse(JSON.stringify(_tracks))],\r\n      });\r\n    },\r\n\r\n    selectElement: (trackId, elementId, multi = false) => {\r\n      set((state) => {\r\n        const exists = state.selectedElements.some(\r\n          (c) => c.trackId === trackId && c.elementId === elementId\r\n        );\r\n        if (multi) {\r\n          return exists\r\n            ? {\r\n                selectedElements: state.selectedElements.filter(\r\n                  (c) => !(c.trackId === trackId && c.elementId === elementId)\r\n                ),\r\n              }\r\n            : {\r\n                selectedElements: [\r\n                  ...state.selectedElements,\r\n                  { trackId, elementId },\r\n                ],\r\n              };\r\n        }\r\n        return { selectedElements: [{ trackId, elementId }] };\r\n      });\r\n    },\r\n\r\n    deselectElement: (trackId, elementId) => {\r\n      set((state) => ({\r\n        selectedElements: state.selectedElements.filter(\r\n          (c) => !(c.trackId === trackId && c.elementId === elementId)\r\n        ),\r\n      }));\r\n    },\r\n\r\n    clearSelectedElements: () => {\r\n      set({ selectedElements: [] });\r\n    },\r\n\r\n    setSelectedElements: (elements) => set({ selectedElements: elements }),\r\n\r\n    addTrack: (type) => {\r\n      get().pushHistory();\r\n\r\n      const trackName =\r\n        type === \"media\"\r\n          ? \"Media Track\"\r\n          : type === \"text\"\r\n            ? \"Text Track\"\r\n            : type === \"audio\"\r\n              ? \"Audio Track\"\r\n              : \"Track\";\r\n\r\n      const newTrack: TimelineTrack = {\r\n        id: generateUUID(),\r\n        name: trackName,\r\n        type,\r\n        elements: [],\r\n        muted: false,\r\n      };\r\n\r\n      updateTracksAndSave([...get()._tracks, newTrack]);\r\n      return newTrack.id;\r\n    },\r\n\r\n    insertTrackAt: (type, index) => {\r\n      get().pushHistory();\r\n\r\n      const trackName =\r\n        type === \"media\"\r\n          ? \"Media Track\"\r\n          : type === \"text\"\r\n            ? \"Text Track\"\r\n            : type === \"audio\"\r\n              ? \"Audio Track\"\r\n              : \"Track\";\r\n\r\n      const newTrack: TimelineTrack = {\r\n        id: generateUUID(),\r\n        name: trackName,\r\n        type,\r\n        elements: [],\r\n        muted: false,\r\n      };\r\n\r\n      const newTracks = [...get()._tracks];\r\n      newTracks.splice(index, 0, newTrack);\r\n      updateTracksAndSave(newTracks);\r\n      return newTrack.id;\r\n    },\r\n\r\n    removeTrack: (trackId) => {\r\n      const { rippleEditingEnabled } = get();\r\n\r\n      if (rippleEditingEnabled) {\r\n        get().removeTrackWithRipple(trackId);\r\n      } else {\r\n        get().pushHistory();\r\n        updateTracksAndSave(\r\n          get()._tracks.filter((track) => track.id !== trackId)\r\n        );\r\n      }\r\n    },\r\n\r\n    removeTrackWithRipple: (trackId) => {\r\n      const { _tracks } = get();\r\n      const trackToRemove = _tracks.find((t) => t.id === trackId);\r\n\r\n      if (!trackToRemove) return;\r\n\r\n      get().pushHistory();\r\n\r\n      const occupiedRanges = trackToRemove.elements.map((element) => ({\r\n        startTime: element.startTime,\r\n        endTime:\r\n          element.startTime +\r\n          (element.duration - element.trimStart - element.trimEnd),\r\n      }));\r\n\r\n      occupiedRanges.sort((a, b) => a.startTime - b.startTime);\r\n\r\n      const mergedRanges: Array<{\r\n        startTime: number;\r\n        endTime: number;\r\n        duration: number;\r\n      }> = [];\r\n\r\n      for (const range of occupiedRanges) {\r\n        if (mergedRanges.length === 0) {\r\n          mergedRanges.push({\r\n            startTime: range.startTime,\r\n            endTime: range.endTime,\r\n            duration: range.endTime - range.startTime,\r\n          });\r\n        } else {\r\n          const lastRange = mergedRanges[mergedRanges.length - 1];\r\n          if (range.startTime <= lastRange.endTime) {\r\n            lastRange.endTime = Math.max(lastRange.endTime, range.endTime);\r\n            lastRange.duration = lastRange.endTime - lastRange.startTime;\r\n          } else {\r\n            mergedRanges.push({\r\n              startTime: range.startTime,\r\n              endTime: range.endTime,\r\n              duration: range.endTime - range.startTime,\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      const updatedTracks = _tracks\r\n        .filter((track) => track.id !== trackId)\r\n        .map((track) => {\r\n          const updatedElements = track.elements.map((element) => {\r\n            let newStartTime = element.startTime;\r\n\r\n            for (let i = mergedRanges.length - 1; i >= 0; i--) {\r\n              const gap = mergedRanges[i];\r\n              if (newStartTime >= gap.endTime) {\r\n                newStartTime -= gap.duration;\r\n              }\r\n            }\r\n\r\n            return {\r\n              ...element,\r\n              startTime: Math.max(0, newStartTime),\r\n            };\r\n          });\r\n\r\n          const hasOverlaps = checkElementOverlaps(updatedElements);\r\n          if (hasOverlaps) {\r\n            const resolvedElements = resolveElementOverlaps(updatedElements);\r\n            return { ...track, elements: resolvedElements };\r\n          }\r\n\r\n          return { ...track, elements: updatedElements };\r\n        });\r\n\r\n      updateTracksAndSave(updatedTracks);\r\n    },\r\n\r\n    addElementToTrack: (trackId, elementData) => {\r\n      get().pushHistory();\r\n\r\n      const track = get()._tracks.find((t) => t.id === trackId);\r\n      if (!track) {\r\n        console.error(\"Track not found:\", trackId);\r\n        return;\r\n      }\r\n\r\n      const validation = validateElementTrackCompatibility(elementData, track);\r\n      if (!validation.isValid) {\r\n        console.error(validation.errorMessage);\r\n        return;\r\n      }\r\n\r\n      if (elementData.type === \"media\" && !elementData.mediaId) {\r\n        console.error(\"Media element must have mediaId\");\r\n        return;\r\n      }\r\n\r\n      if (elementData.type === \"text\" && !elementData.content) {\r\n        console.error(\"Text element must have content\");\r\n        return;\r\n      }\r\n\r\n      const currentState = get();\r\n      const totalElementsInTimeline = currentState._tracks.reduce(\r\n        (total, track) => total + track.elements.length,\r\n        0\r\n      );\r\n      const isFirstElement = totalElementsInTimeline === 0;\r\n\r\n      const newElement: TimelineElement = {\r\n        ...elementData,\r\n        id: generateUUID(),\r\n        startTime: elementData.startTime || 0,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n        ...(elementData.type === \"media\" ? { muted: false } : {}),\r\n      } as TimelineElement;\r\n\r\n      if (isFirstElement && newElement.type === \"media\") {\r\n        const mediaStore = useMediaStore.getState();\r\n        const mediaItem = mediaStore.mediaItems.find(\r\n          (item) => item.id === newElement.mediaId\r\n        );\r\n\r\n        if (\r\n          mediaItem &&\r\n          (mediaItem.type === \"image\" || mediaItem.type === \"video\")\r\n        ) {\r\n          const projectStore = useProjectStore.getState();\r\n          projectStore.updateCanvasSize(\r\n            findBestCanvasPreset(getMediaAspectRatio(mediaItem)),\r\n            \"original\"\r\n          );\r\n        }\r\n\r\n        if (mediaItem && mediaItem.type === \"video\" && mediaItem.fps) {\r\n          const projectStore = useProjectStore.getState();\r\n          if (projectStore.activeProject) {\r\n            projectStore.updateProjectFps(mediaItem.fps);\r\n          }\r\n        }\r\n      }\r\n\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? { ...track, elements: [...track.elements, newElement] }\r\n            : track\r\n        )\r\n      );\r\n\r\n      get().selectElement(trackId, newElement.id);\r\n    },\r\n\r\n    removeElementFromTrack: (trackId, elementId, pushHistory = true) => {\r\n      const { rippleEditingEnabled } = get();\r\n\r\n      if (rippleEditingEnabled) {\r\n        get().removeElementFromTrackWithRipple(trackId, elementId, pushHistory);\r\n      } else {\r\n        if (pushHistory) get().pushHistory();\r\n        updateTracksAndSave(\r\n          get()\r\n            ._tracks.map((track) =>\r\n              track.id === trackId\r\n                ? {\r\n                    ...track,\r\n                    elements: track.elements.filter(\r\n                      (element) => element.id !== elementId\r\n                    ),\r\n                  }\r\n                : track\r\n            )\r\n            .filter((track) => track.elements.length > 0)\r\n        );\r\n      }\r\n    },\r\n\r\n    removeElementFromTrackWithRipple: (\r\n      trackId,\r\n      elementId,\r\n      pushHistory = true\r\n    ) => {\r\n      const { _tracks, rippleEditingEnabled } = get();\r\n\r\n      if (!rippleEditingEnabled) {\r\n        get().removeElementFromTrack(trackId, elementId, pushHistory);\r\n        return;\r\n      }\r\n\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((e) => e.id === elementId);\r\n\r\n      if (!element || !track) return;\r\n\r\n      if (pushHistory) get().pushHistory();\r\n\r\n      const elementStartTime = element.startTime;\r\n      const elementDuration =\r\n        element.duration - element.trimStart - element.trimEnd;\r\n      const elementEndTime = elementStartTime + elementDuration;\r\n\r\n      const updatedTracks = _tracks\r\n        .map((currentTrack) => {\r\n          const shouldApplyRipple = currentTrack.id === trackId;\r\n\r\n          const updatedElements = currentTrack.elements\r\n            .filter((currentElement) => {\r\n              if (\r\n                currentElement.id === elementId &&\r\n                currentTrack.id === trackId\r\n              ) {\r\n                return false;\r\n              }\r\n              return true;\r\n            })\r\n            .map((currentElement) => {\r\n              if (!shouldApplyRipple) {\r\n                return currentElement;\r\n              }\r\n\r\n              if (currentElement.startTime >= elementEndTime) {\r\n                return {\r\n                  ...currentElement,\r\n                  startTime: Math.max(\r\n                    0,\r\n                    currentElement.startTime - elementDuration\r\n                  ),\r\n                };\r\n              }\r\n              return currentElement;\r\n            });\r\n\r\n          const hasOverlaps = checkElementOverlaps(updatedElements);\r\n          if (hasOverlaps) {\r\n            const resolvedElements = resolveElementOverlaps(updatedElements);\r\n            return { ...currentTrack, elements: resolvedElements };\r\n          }\r\n\r\n          return { ...currentTrack, elements: updatedElements };\r\n        })\r\n        .filter((track) => track.elements.length > 0 || track.isMain);\r\n\r\n      updateTracksAndSave(updatedTracks);\r\n    },\r\n\r\n    moveElementToTrack: (fromTrackId, toTrackId, elementId) => {\r\n      get().pushHistory();\r\n\r\n      const fromTrack = get()._tracks.find((track) => track.id === fromTrackId);\r\n      const toTrack = get()._tracks.find((track) => track.id === toTrackId);\r\n      const elementToMove = fromTrack?.elements.find(\r\n        (element) => element.id === elementId\r\n      );\r\n\r\n      if (!elementToMove || !toTrack) return;\r\n\r\n      const validation = validateElementTrackCompatibility(\r\n        elementToMove,\r\n        toTrack\r\n      );\r\n      if (!validation.isValid) {\r\n        console.error(validation.errorMessage);\r\n        return;\r\n      }\r\n\r\n      const newTracks = get()\r\n        ._tracks.map((track) => {\r\n          if (track.id === fromTrackId) {\r\n            return {\r\n              ...track,\r\n              elements: track.elements.filter(\r\n                (element) => element.id !== elementId\r\n              ),\r\n            };\r\n          }\r\n          if (track.id === toTrackId) {\r\n            return {\r\n              ...track,\r\n              elements: [...track.elements, elementToMove],\r\n            };\r\n          }\r\n          return track;\r\n        })\r\n        .filter((track) => track.elements.length > 0);\r\n\r\n      updateTracksAndSave(newTracks);\r\n    },\r\n\r\n    updateElementTrim: (\r\n      trackId,\r\n      elementId,\r\n      trimStart,\r\n      trimEnd,\r\n      pushHistory = true\r\n    ) => {\r\n      if (pushHistory) get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId\r\n                    ? { ...element, trimStart, trimEnd }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    updateElementDuration: (\r\n      trackId,\r\n      elementId,\r\n      duration,\r\n      pushHistory = true\r\n    ) => {\r\n      if (pushHistory) get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId ? { ...element, duration } : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    updateElementStartTime: (\r\n      trackId,\r\n      elementId,\r\n      startTime,\r\n      pushHistory = true\r\n    ) => {\r\n      if (pushHistory) get().pushHistory();\r\n      const clampedStartTime = Math.max(0, startTime);\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId\r\n                    ? { ...element, startTime: clampedStartTime }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    updateElementStartTimeWithRipple: (trackId, elementId, newStartTime) => {\r\n      const { _tracks, rippleEditingEnabled } = get();\r\n\r\n      if (!rippleEditingEnabled) {\r\n        get().updateElementStartTime(trackId, elementId, newStartTime);\r\n        return;\r\n      }\r\n\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((e) => e.id === elementId);\r\n\r\n      if (!element || !track) return;\r\n\r\n      get().pushHistory();\r\n\r\n      const oldStartTime = element.startTime;\r\n      const oldEndTime =\r\n        element.startTime +\r\n        (element.duration - element.trimStart - element.trimEnd);\r\n      const newEndTime =\r\n        newStartTime + (element.duration - element.trimStart - element.trimEnd);\r\n      const timeDelta = newStartTime - oldStartTime;\r\n\r\n      const updatedTracks = _tracks.map((currentTrack) => {\r\n        const shouldApplyRipple = currentTrack.id === trackId;\r\n\r\n        const updatedElements = currentTrack.elements.map((currentElement) => {\r\n          if (currentElement.id === elementId && currentTrack.id === trackId) {\r\n            return { ...currentElement, startTime: Math.max(0, newStartTime) };\r\n          }\r\n\r\n          if (!shouldApplyRipple) {\r\n            return currentElement;\r\n          }\r\n\r\n          const currentElementStart = currentElement.startTime;\r\n          const currentElementEnd =\r\n            currentElement.startTime +\r\n            (currentElement.duration -\r\n              currentElement.trimStart -\r\n              currentElement.trimEnd);\r\n\r\n          if (timeDelta > 0) {\r\n            if (currentElementStart >= oldEndTime) {\r\n              return {\r\n                ...currentElement,\r\n                startTime: currentElementStart + timeDelta,\r\n              };\r\n            }\r\n          } else if (timeDelta < 0) {\r\n            if (\r\n              currentElementStart >= newEndTime &&\r\n              currentElementStart >= oldStartTime\r\n            ) {\r\n              return {\r\n                ...currentElement,\r\n                startTime: Math.max(0, currentElementStart + timeDelta),\r\n              };\r\n            }\r\n          }\r\n\r\n          return currentElement;\r\n        });\r\n\r\n        const hasOverlaps = checkElementOverlaps(updatedElements);\r\n        if (hasOverlaps) {\r\n          const resolvedElements = resolveElementOverlaps(updatedElements);\r\n          return { ...currentTrack, elements: resolvedElements };\r\n        }\r\n\r\n        return { ...currentTrack, elements: updatedElements };\r\n      });\r\n\r\n      updateTracksAndSave(updatedTracks);\r\n    },\r\n\r\n    toggleTrackMute: (trackId) => {\r\n      get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId ? { ...track, muted: !track.muted } : track\r\n        )\r\n      );\r\n    },\r\n\r\n    toggleElementHidden: (trackId, elementId) => {\r\n      get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId\r\n                    ? { ...element, hidden: !element.hidden }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    toggleElementMuted: (trackId, elementId) => {\r\n      get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId && element.type === \"media\"\r\n                    ? { ...element, muted: !element.muted }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    updateTextElement: (trackId, elementId, updates) => {\r\n      get().pushHistory();\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((element) =>\r\n                  element.id === elementId && element.type === \"text\"\r\n                    ? { ...element, ...updates }\r\n                    : element\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    splitElement: (trackId, elementId, splitTime) => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element) return null;\r\n\r\n      const effectiveStart = element.startTime;\r\n      const effectiveEnd =\r\n        element.startTime +\r\n        (element.duration - element.trimStart - element.trimEnd);\r\n\r\n      if (splitTime <= effectiveStart || splitTime >= effectiveEnd) return null;\r\n\r\n      get().pushHistory();\r\n\r\n      const relativeTime = splitTime - element.startTime;\r\n      const firstDuration = relativeTime;\r\n      const secondDuration =\r\n        element.duration - element.trimStart - element.trimEnd - relativeTime;\r\n\r\n      const secondElementId = generateUUID();\r\n\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.flatMap((c) =>\r\n                  c.id === elementId\r\n                    ? [\r\n                        {\r\n                          ...c,\r\n                          trimEnd: c.trimEnd + secondDuration,\r\n                          name: getElementNameWithSuffix(c.name, \"left\"),\r\n                        },\r\n                        {\r\n                          ...c,\r\n                          id: secondElementId,\r\n                          startTime: splitTime,\r\n                          trimStart: c.trimStart + firstDuration,\r\n                          name: getElementNameWithSuffix(c.name, \"right\"),\r\n                        },\r\n                      ]\r\n                    : [c]\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n\r\n      return secondElementId;\r\n    },\r\n\r\n    // Split element and keep only the left portion\r\n    splitAndKeepLeft: (trackId, elementId, splitTime) => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element) return;\r\n\r\n      const effectiveStart = element.startTime;\r\n      const effectiveEnd =\r\n        element.startTime +\r\n        (element.duration - element.trimStart - element.trimEnd);\r\n\r\n      if (splitTime <= effectiveStart || splitTime >= effectiveEnd) return;\r\n\r\n      get().pushHistory();\r\n\r\n      const relativeTime = splitTime - element.startTime;\r\n      const durationToRemove =\r\n        element.duration - element.trimStart - element.trimEnd - relativeTime;\r\n\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((c) =>\r\n                  c.id === elementId\r\n                    ? {\r\n                        ...c,\r\n                        trimEnd: c.trimEnd + durationToRemove,\r\n                        name: getElementNameWithSuffix(c.name, \"left\"),\r\n                      }\r\n                    : c\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    // Split element and keep only the right portion\r\n    splitAndKeepRight: (trackId, elementId, splitTime) => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element) return;\r\n\r\n      const effectiveStart = element.startTime;\r\n      const effectiveEnd =\r\n        element.startTime +\r\n        (element.duration - element.trimStart - element.trimEnd);\r\n\r\n      if (splitTime <= effectiveStart || splitTime >= effectiveEnd) return;\r\n\r\n      get().pushHistory();\r\n\r\n      const relativeTime = splitTime - element.startTime;\r\n\r\n      updateTracksAndSave(\r\n        get()._tracks.map((track) =>\r\n          track.id === trackId\r\n            ? {\r\n                ...track,\r\n                elements: track.elements.map((c) =>\r\n                  c.id === elementId\r\n                    ? {\r\n                        ...c,\r\n                        startTime: splitTime,\r\n                        trimStart: c.trimStart + relativeTime,\r\n                        name: getElementNameWithSuffix(c.name, \"right\"),\r\n                      }\r\n                    : c\r\n                ),\r\n              }\r\n            : track\r\n        )\r\n      );\r\n    },\r\n\r\n    // Extract audio from video element to an audio track\r\n    separateAudio: (trackId, elementId) => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element || track?.type !== \"media\") return null;\r\n\r\n      get().pushHistory();\r\n\r\n      const existingAudioTrack = _tracks.find((t) => t.type === \"audio\");\r\n      const audioElementId = generateUUID();\r\n\r\n      if (existingAudioTrack) {\r\n        updateTracksAndSave(\r\n          get()._tracks.map((track) =>\r\n            track.id === existingAudioTrack.id\r\n              ? {\r\n                  ...track,\r\n                  elements: [\r\n                    ...track.elements,\r\n                    {\r\n                      ...element,\r\n                      id: audioElementId,\r\n                      name: getElementNameWithSuffix(element.name, \"audio\"),\r\n                    },\r\n                  ],\r\n                }\r\n              : track\r\n          )\r\n        );\r\n      } else {\r\n        const newAudioTrack: TimelineTrack = {\r\n          id: generateUUID(),\r\n          name: \"Audio Track\",\r\n          type: \"audio\",\r\n          elements: [\r\n            {\r\n              ...element,\r\n              id: audioElementId,\r\n              name: getElementNameWithSuffix(element.name, \"audio\"),\r\n            },\r\n          ],\r\n          muted: false,\r\n        };\r\n\r\n        updateTracksAndSave([...get()._tracks, newAudioTrack]);\r\n      }\r\n\r\n      return audioElementId;\r\n    },\r\n\r\n    // Replace media for an element\r\n    replaceElementMedia: async (\r\n      trackId: string,\r\n      elementId: string,\r\n      newFile: File\r\n    ): Promise<{ success: boolean; error?: string }> => {\r\n      const { _tracks } = get();\r\n      const track = _tracks.find((t) => t.id === trackId);\r\n      const element = track?.elements.find((c) => c.id === elementId);\r\n\r\n      if (!element) {\r\n        return { success: false, error: \"Timeline element not found\" };\r\n      }\r\n\r\n      if (element.type !== \"media\") {\r\n        return {\r\n          success: false,\r\n          error: \"Replace is only available for media clips\",\r\n        };\r\n      }\r\n\r\n      try {\r\n        const mediaStore = useMediaStore.getState();\r\n        const projectStore = useProjectStore.getState();\r\n\r\n        if (!projectStore.activeProject) {\r\n          return { success: false, error: \"No active project found\" };\r\n        }\r\n\r\n        const {\r\n          getFileType,\r\n          getImageDimensions,\r\n          generateVideoThumbnail,\r\n          getMediaDuration,\r\n        } = await import(\"./media-store\");\r\n\r\n        const fileType = getFileType(newFile);\r\n        if (!fileType) {\r\n          return {\r\n            success: false,\r\n            error:\r\n              \"Unsupported file type. Please select a video, audio, or image file.\",\r\n          };\r\n        }\r\n\r\n        const mediaData: any = {\r\n          name: newFile.name,\r\n          type: fileType,\r\n          file: newFile,\r\n          url: URL.createObjectURL(newFile),\r\n        };\r\n\r\n        try {\r\n          if (fileType === \"image\") {\r\n            const { width, height } = await getImageDimensions(newFile);\r\n            mediaData.width = width;\r\n            mediaData.height = height;\r\n          } else if (fileType === \"video\") {\r\n            const [duration, { thumbnailUrl, width, height }] =\r\n              await Promise.all([\r\n                getMediaDuration(newFile),\r\n                generateVideoThumbnail(newFile),\r\n              ]);\r\n            mediaData.duration = duration;\r\n            mediaData.thumbnailUrl = thumbnailUrl;\r\n            mediaData.width = width;\r\n            mediaData.height = height;\r\n          } else if (fileType === \"audio\") {\r\n            mediaData.duration = await getMediaDuration(newFile);\r\n          }\r\n        } catch (error) {\r\n          return {\r\n            success: false,\r\n            error: `Failed to process ${fileType} file: ${error instanceof Error ? error.message : \"Unknown error\"}`,\r\n          };\r\n        }\r\n\r\n        try {\r\n          await mediaStore.addMediaItem(\r\n            projectStore.activeProject.id,\r\n            mediaData\r\n          );\r\n        } catch (error) {\r\n          return {\r\n            success: false,\r\n            error: `Failed to add media to project: ${error instanceof Error ? error.message : \"Unknown error\"}`,\r\n          };\r\n        }\r\n\r\n        const newMediaItem = mediaStore.mediaItems.find(\r\n          (item) => item.file === newFile\r\n        );\r\n\r\n        if (!newMediaItem) {\r\n          return {\r\n            success: false,\r\n            error: \"Failed to create media item in project. Please try again.\",\r\n          };\r\n        }\r\n\r\n        get().pushHistory();\r\n\r\n        updateTracksAndSave(\r\n          _tracks.map((track) =>\r\n            track.id === trackId\r\n              ? {\r\n                  ...track,\r\n                  elements: track.elements.map((c) =>\r\n                    c.id === elementId\r\n                      ? {\r\n                          ...c,\r\n                          mediaId: newMediaItem.id,\r\n                          name: newMediaItem.name,\r\n                          duration: newMediaItem.duration || c.duration,\r\n                        }\r\n                      : c\r\n                  ),\r\n                }\r\n              : track\r\n          )\r\n        );\r\n\r\n        return { success: true };\r\n      } catch (error) {\r\n        console.error(\"Failed to replace element media:\", error);\r\n        return {\r\n          success: false,\r\n          error: `Unexpected error: ${error instanceof Error ? error.message : \"Unknown error\"}`,\r\n        };\r\n      }\r\n    },\r\n\r\n    getTotalDuration: () => {\r\n      const { _tracks } = get();\r\n      if (_tracks.length === 0) return 0;\r\n\r\n      const trackEndTimes = _tracks.map((track) =>\r\n        track.elements.reduce((maxEnd, element) => {\r\n          const elementEnd =\r\n            element.startTime +\r\n            element.duration -\r\n            element.trimStart -\r\n            element.trimEnd;\r\n          return Math.max(maxEnd, elementEnd);\r\n        }, 0)\r\n      );\r\n\r\n      return Math.max(...trackEndTimes, 0);\r\n    },\r\n\r\n    getProjectThumbnail: async (projectId) => {\r\n      try {\r\n        const tracks = await storageService.loadTimeline(projectId);\r\n        const mediaItems = await storageService.loadAllMediaItems(projectId);\r\n\r\n        if (!tracks || !mediaItems.length) return null;\r\n\r\n        const firstMediaElement = tracks\r\n          .flatMap((track) => track.elements)\r\n          .filter((element) => element.type === \"media\")\r\n          .sort((a, b) => a.startTime - b.startTime)[0];\r\n\r\n        if (!firstMediaElement) return null;\r\n\r\n        const mediaItem = mediaItems.find(\r\n          (item) => item.id === firstMediaElement.mediaId\r\n        );\r\n        if (!mediaItem) return null;\r\n\r\n        if (mediaItem.type === \"video\" && mediaItem.file) {\r\n          const { generateVideoThumbnail } = await import(\r\n            \"@/stores/media-store\"\r\n          );\r\n          const { thumbnailUrl } = await generateVideoThumbnail(mediaItem.file);\r\n          return thumbnailUrl;\r\n        }\r\n        if (mediaItem.type === \"image\" && mediaItem.url) {\r\n          return mediaItem.url;\r\n        }\r\n\r\n        return null;\r\n      } catch (error) {\r\n        console.error(\"Failed to get project thumbnail:\", error);\r\n        return null;\r\n      }\r\n    },\r\n\r\n    redo: () => {\r\n      const { redoStack } = get();\r\n      if (redoStack.length === 0) return;\r\n      const next = redoStack[redoStack.length - 1];\r\n      updateTracksAndSave(next);\r\n      set({ redoStack: redoStack.slice(0, -1) });\r\n    },\r\n\r\n    dragState: {\r\n      isDragging: false,\r\n      elementId: null,\r\n      trackId: null,\r\n      startMouseX: 0,\r\n      startElementTime: 0,\r\n      clickOffsetTime: 0,\r\n      currentTime: 0,\r\n    },\r\n\r\n    setDragState: (dragState) =>\r\n      set((state) => ({\r\n        dragState: { ...state.dragState, ...dragState },\r\n      })),\r\n\r\n    startDrag: (\r\n      elementId,\r\n      trackId,\r\n      startMouseX,\r\n      startElementTime,\r\n      clickOffsetTime\r\n    ) => {\r\n      set({\r\n        dragState: {\r\n          isDragging: true,\r\n          elementId,\r\n          trackId,\r\n          startMouseX,\r\n          startElementTime,\r\n          clickOffsetTime,\r\n          currentTime: startElementTime,\r\n        },\r\n      });\r\n    },\r\n\r\n    updateDragTime: (currentTime) => {\r\n      set((state) => ({\r\n        dragState: {\r\n          ...state.dragState,\r\n          currentTime,\r\n        },\r\n      }));\r\n    },\r\n\r\n    endDrag: () => {\r\n      set({\r\n        dragState: {\r\n          isDragging: false,\r\n          elementId: null,\r\n          trackId: null,\r\n          startMouseX: 0,\r\n          startElementTime: 0,\r\n          clickOffsetTime: 0,\r\n          currentTime: 0,\r\n        },\r\n      });\r\n    },\r\n\r\n    loadProjectTimeline: async (projectId) => {\r\n      try {\r\n        const tracks = await storageService.loadTimeline(projectId);\r\n        if (tracks) {\r\n          updateTracks(tracks);\r\n        } else {\r\n          const defaultTracks = ensureMainTrack([]);\r\n          updateTracks(defaultTracks);\r\n        }\r\n        set({ history: [], redoStack: [] });\r\n      } catch (error) {\r\n        console.error(\"Failed to load timeline:\", error);\r\n        const defaultTracks = ensureMainTrack([]);\r\n        updateTracks(defaultTracks);\r\n        set({ history: [], redoStack: [] });\r\n      }\r\n    },\r\n\r\n    saveProjectTimeline: async (projectId) => {\r\n      try {\r\n        await storageService.saveTimeline(projectId, get()._tracks);\r\n      } catch (error) {\r\n        console.error(\"Failed to save timeline:\", error);\r\n      }\r\n    },\r\n\r\n    clearTimeline: () => {\r\n      const defaultTracks = ensureMainTrack([]);\r\n      updateTracks(defaultTracks);\r\n      set({ history: [], redoStack: [], selectedElements: [] });\r\n    },\r\n\r\n    // Snapping actions\r\n    toggleSnapping: () => {\r\n      set((state) => ({ snappingEnabled: !state.snappingEnabled }));\r\n    },\r\n\r\n    // Ripple editing functions\r\n    toggleRippleEditing: () => {\r\n      set((state) => ({\r\n        rippleEditingEnabled: !state.rippleEditingEnabled,\r\n      }));\r\n    },\r\n\r\n    checkElementOverlap: (trackId, startTime, duration, excludeElementId) => {\r\n      const track = get()._tracks.find((t) => t.id === trackId);\r\n      if (!track) return false;\r\n\r\n      const overlap = track.elements.some((element) => {\r\n        const elementEnd =\r\n          element.startTime +\r\n          element.duration -\r\n          element.trimStart -\r\n          element.trimEnd;\r\n\r\n        if (element.id === excludeElementId) {\r\n          return false;\r\n        }\r\n\r\n        return (\r\n          (startTime >= element.startTime && startTime < elementEnd) ||\r\n          (startTime + duration > element.startTime &&\r\n            startTime + duration <= elementEnd) ||\r\n          (startTime < element.startTime && startTime + duration > elementEnd)\r\n        );\r\n      });\r\n      return overlap;\r\n    },\r\n\r\n    findOrCreateTrack: (trackType) => {\r\n      if (trackType === \"text\") {\r\n        return get().insertTrackAt(trackType, 0);\r\n      }\r\n\r\n      const existingTrack = get()._tracks.find((t) => t.type === trackType);\r\n      if (existingTrack) {\r\n        return existingTrack.id;\r\n      }\r\n\r\n      return get().addTrack(trackType);\r\n    },\r\n\r\n    addMediaAtTime: (item, currentTime = 0) => {\r\n      const trackType = item.type === \"audio\" ? \"audio\" : \"media\";\r\n      const duration =\r\n        item.duration || TIMELINE_CONSTANTS.DEFAULT_IMAGE_DURATION;\r\n\r\n      const tracks = get()._tracks.filter((t) => t.type === trackType);\r\n\r\n      let targetTrackId = null;\r\n      for (const track of tracks) {\r\n        if (!get().checkElementOverlap(track.id, currentTime, duration)) {\r\n          targetTrackId = track.id;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!targetTrackId) {\r\n        targetTrackId = get().addTrack(trackType);\r\n      }\r\n\r\n      get().addElementToTrack(targetTrackId, {\r\n        type: \"media\",\r\n        mediaId: item.id,\r\n        name: item.name,\r\n        duration,\r\n        startTime: currentTime,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n        muted: false,\r\n      });\r\n      return true;\r\n    },\r\n\r\n    addTextAtTime: (item, currentTime = 0) => {\r\n      const targetTrackId = get().insertTrackAt(\"text\", 0);\r\n\r\n      get().addElementToTrack(targetTrackId, {\r\n        type: \"text\",\r\n        name: item.name || \"Text\",\r\n        content: item.content || \"Default Text\",\r\n        duration: item.duration || TIMELINE_CONSTANTS.DEFAULT_TEXT_DURATION,\r\n        startTime: currentTime,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n        fontSize: item.fontSize || 48,\r\n        fontFamily: item.fontFamily || \"Arial\",\r\n        color: item.color || \"#ffffff\",\r\n        backgroundColor: item.backgroundColor || \"transparent\",\r\n        textAlign: item.textAlign || \"center\",\r\n        fontWeight: item.fontWeight || \"normal\",\r\n        fontStyle: item.fontStyle || \"normal\",\r\n        textDecoration: item.textDecoration || \"none\",\r\n        x: item.x || 0,\r\n        y: item.y || 0,\r\n        rotation: item.rotation || 0,\r\n        opacity: item.opacity !== undefined ? item.opacity : 1,\r\n      });\r\n      return true;\r\n    },\r\n\r\n    addMediaToNewTrack: (item) => {\r\n      const trackType = item.type === \"audio\" ? \"audio\" : \"media\";\r\n      const targetTrackId = get().findOrCreateTrack(trackType);\r\n\r\n      get().addElementToTrack(targetTrackId, {\r\n        type: \"media\",\r\n        mediaId: item.id,\r\n        name: item.name,\r\n        duration: item.duration || TIMELINE_CONSTANTS.DEFAULT_IMAGE_DURATION,\r\n        startTime: 0,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n        muted: false,\r\n      });\r\n      return true;\r\n    },\r\n\r\n    addTextToNewTrack: (item) => {\r\n      const targetTrackId = get().insertTrackAt(\"text\", 0);\r\n\r\n      get().addElementToTrack(targetTrackId, {\r\n        type: \"text\",\r\n        name: item.name || \"Text\",\r\n        content:\r\n          (\"content\" in item ? item.content : \"Default Text\") || \"Default Text\",\r\n        duration: TIMELINE_CONSTANTS.DEFAULT_TEXT_DURATION,\r\n        startTime: 0,\r\n        trimStart: 0,\r\n        trimEnd: 0,\r\n        fontSize: (\"fontSize\" in item ? item.fontSize : 48) || 48,\r\n        fontFamily:\r\n          (\"fontFamily\" in item ? item.fontFamily : \"Arial\") || \"Arial\",\r\n        color: (\"color\" in item ? item.color : \"#ffffff\") || \"#ffffff\",\r\n        backgroundColor:\r\n          (\"backgroundColor\" in item ? item.backgroundColor : \"transparent\") ||\r\n          \"transparent\",\r\n        textAlign:\r\n          (\"textAlign\" in item ? item.textAlign : \"center\") || \"center\",\r\n        fontWeight:\r\n          (\"fontWeight\" in item ? item.fontWeight : \"normal\") || \"normal\",\r\n        fontStyle:\r\n          (\"fontStyle\" in item ? item.fontStyle : \"normal\") || \"normal\",\r\n        textDecoration:\r\n          (\"textDecoration\" in item ? item.textDecoration : \"none\") || \"none\",\r\n        x: (\"x\" in item ? item.x : 0) || 0,\r\n        y: (\"y\" in item ? item.y : 0) || 0,\r\n        rotation: (\"rotation\" in item ? item.rotation : 0) || 0,\r\n        opacity:\r\n          \"opacity\" in item && item.opacity !== undefined ? item.opacity : 1,\r\n      });\r\n      return true;\r\n    },\r\n  };\r\n});\r\n","// Generic utilities\r\n\r\nimport { type ClassValue, clsx } from \"clsx\";\r\nimport { twMerge } from \"tailwind-merge\";\r\n\r\nexport function cn(...inputs: ClassValue[]) {\r\n  return twMerge(clsx(inputs));\r\n}\r\n\r\n/**\r\n * Generates a UUID v4 string\r\n * Uses crypto.randomUUID() if available, otherwise falls back to a custom implementation\r\n */\r\nexport function generateUUID(): string {\r\n  // Use the native crypto.randomUUID if available\r\n  if (\r\n    typeof crypto !== \"undefined\" &&\r\n    typeof crypto.randomUUID === \"function\"\r\n  ) {\r\n    return crypto.randomUUID();\r\n  }\r\n\r\n  // Secure fallback using crypto.getRandomValues\r\n  const bytes = new Uint8Array(16);\r\n  crypto.getRandomValues(bytes);\r\n\r\n  // Set version 4 (UUIDv4)\r\n  bytes[6] = (bytes[6] & 0x0f) | 0x40;\r\n  // Set variant 10xxxxxx\r\n  bytes[8] = (bytes[8] & 0x3f) | 0x80;\r\n\r\n  const hex = [...bytes].map((b) => b.toString(16).padStart(2, \"0\"));\r\n\r\n  return (\r\n    hex.slice(0, 4).join(\"\") +\r\n    \"-\" +\r\n    hex.slice(4, 6).join(\"\") +\r\n    \"-\" +\r\n    hex.slice(6, 8).join(\"\") +\r\n    \"-\" +\r\n    hex.slice(8, 10).join(\"\") +\r\n    \"-\" +\r\n    hex.slice(10, 16).join(\"\")\r\n  );\r\n}\r\n\r\nexport function isDOMElement(el: any): el is HTMLElement {\r\n  return !!el && (el instanceof Element || el instanceof HTMLElement);\r\n}\r\n\r\nexport function isTypableElement(el: HTMLElement): boolean {\r\n  // If content editable, then it is editable\r\n  if (el.isContentEditable) return true;\r\n\r\n  // If element is an input and the input is enabled, then it is typable\r\n  if (el.tagName === \"INPUT\") {\r\n    return !(el as HTMLInputElement).disabled;\r\n  }\r\n  // If element is a textarea and the input is enabled, then it is typable\r\n  if (el.tagName === \"TEXTAREA\") {\r\n    return !(el as HTMLTextAreaElement).disabled;\r\n  }\r\n\r\n  return false;\r\n}\r\nexport function isAppleDevice() {\r\n  return /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);\r\n}\r\n\r\nexport function getPlatformSpecialKey() {\r\n  return isAppleDevice() ? \"\" : \"Ctrl\";\r\n}\r\n\r\nexport function getPlatformAlternateKey() {\r\n  return isAppleDevice() ? \"\" : \"Alt\";\r\n}\r\n"],"names":["sortTracksByOrder","tracks","sort","a","b","type","isMain","getMainTrack","find","track","ensureMainTrack","some","hasMainTrack","id","generateUUID","name","elements","muted","canElementGoOnTrack","elementType","trackType","validateElementTrackCompatibility","element","isValid","errorMessage","IndexedDBAdapter","getDB","Promise","resolve","reject","request","indexedDB","open","dbName","version","onerror","error","onsuccess","result","onupgradeneeded","event","db","target","objectStoreNames","contains","storeName","createObjectStore","keyPath","get","key","store","transaction","objectStore","set","value","put","remove","delete","list","getAllKeys","clear","OPFSAdapter","getDirectory","opfsRoot","navigator","storage","getDirectoryHandle","directoryName","create","directory","fileHandle","getFileHandle","getFile","file","writable","createWritable","write","close","removeEntry","keys","push","isSupported","StorageService","getProjectMediaAdapters","projectId","mediaMetadataAdapter","config","mediaDb","mediaFilesAdapter","getProjectTimelineAdapter","timelineDb","saveProject","project","serializedProject","thumbnail","createdAt","toISOString","updatedAt","backgroundColor","backgroundType","blurIntensity","bookmarks","fps","canvasSize","canvasMode","projectsAdapter","loadProject","Date","loadAllProjects","projectIds","projects","getTime","deleteProject","saveMediaItem","mediaItem","metadata","size","lastModified","width","height","duration","ephemeral","loadMediaItem","url","all","URL","createObjectURL","text","trim","startsWith","svgBlob","Blob","loadAllMediaItems","mediaIds","mediaItems","item","deleteMediaItem","deleteProjectMedia","saveTimeline","timelineAdapter","timelineData","loadTimeline","deleteProjectTimeline","clearAllData","getStorageInfo","length","isOPFSSupported","isIndexedDBSupported","getProjectStorageInfo","hasTimeline","loadSavedSounds","savedSoundsAdapter","sounds","saveSoundEffect","soundEffect","currentData","sound","savedSound","username","previewUrl","downloadUrl","tags","license","savedAt","updatedData","removeSavedSound","soundId","filter","isSoundSaved","clearSavedSounds","window","isFullySupported","projectsDb","savedSoundsDb","storageService","getFileType","img","Image","addEventListener","naturalWidth","naturalHeight","src","generateVideoThumbnail","video","document","createElement","canvas","ctx","getContext","videoWidth","videoHeight","currentTime","Math","min","drawImage","thumbnailUrl","toDataURL","load","getMediaDuration","getMediaAspectRatio","useMediaStore","isLoading","addMediaItem","newItem","state","media","removeMediaItem","revokeObjectURL","removeElementFromTrack","removeElementFromTrackWithRipple","rippleEditingEnabled","pushHistory","useTimelineStore","timeline","getState","elementsToRemove","el","mediaId","trackId","elementId","loadProjectMedia","updatedMediaItems","map","clearProjectMedia","forEach","clearAllMedia","DEFAULT_CANVAS_SIZE","DEFAULT_FPS","useProjectStore","savedProjects","isInitialized","invalidProjectIds","Set","toggleBookmark","time","updatedBookmarks","activeProject","frameTime","round","bookmarkIndex","findIndex","abs","bookmark","_","i","updatedProject","toast","description","isBookmarked","removeBookmark","createNewProject","newProject","DEFAULT_PROJECT","mediaStore","timelineStore","clearTimeline","loadProjectTimeline","saveCurrentProject","saveProjectTimeline","closeProject","renameProject","projectToRename","p","Error","message","duplicateProject","numberMatch","match","baseName","existingNumbers","nextNumber","max","updateProjectBackground","updateBackgroundType","options","updateProjectFps","updateCanvasSize","mode","getFilteredAndSortedProjects","searchQuery","sortOption","sortedProjects","toLowerCase","includes","order","split","aValue","bValue","undefined","isInvalidProjectId","has","markProjectIdAsInvalid","clearInvalidProjectIds","TRACK_COLORS","solid","background","border","audio","getTrackElementClasses","colors","getTrackColors","TRACK_HEIGHTS","getTrackHeight","getCumulativeHeightBefore","trackIndex","slice","reduce","sum","GAP","getTotalTracksHeight","gapsHeight","TIMELINE_CONSTANTS","PIXELS_PER_SECOND","TRACK_HEIGHT","DEFAULT_TEXT_DURATION","DEFAULT_IMAGE_DURATION","ZOOM_LEVELS","label","snapTimeToFrame","DEFAULT_CANVAS_PRESETS","checkElementOverlaps","sortedElements","startTime","current","next","currentEnd","trimStart","trimEnd","resolvedElements","previous","previousEnd","originalName","suffix","replace","updateTracks","tracksWithMain","newTracks","sortedTracks","_tracks","autoSaveTimeline","updateTracksAndSave","setTimeout","initialTracks","sortedInitialTracks","history","redoStack","selectedElements","snappingEnabled","getSortedTracks","JSON","parse","stringify","undo","prev","selectElement","multi","exists","c","deselectElement","clearSelectedElements","setSelectedElements","addTrack","newTrack","trackName","insertTrackAt","index","splice","removeTrack","removeTrackWithRipple","trackToRemove","t","occupiedRanges","endTime","mergedRanges","range","lastRange","updatedTracks","updatedElements","newStartTime","gap","hasOverlaps","resolveElementOverlaps","addElementToTrack","elementData","content","totalElementsInTimeline","currentState","total","newElement","projectStore","findBestCanvasPreset","bestMatch","smallestDifference","aspectRatio","preset","difference","presetAspectRatio","bestAspectRatio","e","elementStartTime","elementDuration","elementEndTime","shouldApplyRipple","currentTrack","currentElement","moveElementToTrack","fromTrackId","toTrackId","fromTrack","toTrack","elementToMove","validation","updateElementTrim","updateElementDuration","updateElementStartTime","clampedStartTime","updateElementStartTimeWithRipple","oldStartTime","oldEndTime","newEndTime","timeDelta","currentElementStart","toggleTrackMute","toggleElementHidden","hidden","toggleElementMuted","updateTextElement","updates","splitElement","splitTime","effectiveStart","effectiveEnd","relativeTime","secondDuration","secondElementId","flatMap","getElementNameWithSuffix","firstDuration","splitAndKeepLeft","durationToRemove","splitAndKeepRight","separateAudio","existingAudioTrack","audioElementId","newAudioTrack","replaceElementMedia","newFile","success","getImageDimensions","fileType","mediaData","newMediaItem","getTotalDuration","maxEnd","elementEnd","getProjectThumbnail","firstMediaElement","redo","dragState","isDragging","startMouseX","startElementTime","clickOffsetTime","setDragState","startDrag","updateDragTime","endDrag","defaultTracks","toggleSnapping","toggleRippleEditing","checkElementOverlap","excludeElementId","findOrCreateTrack","existingTrack","addMediaAtTime","targetTrackId","addTextAtTime","fontSize","fontFamily","color","textAlign","fontWeight","fontStyle","textDecoration","x","y","rotation","opacity","addMediaToNewTrack","addTextToNewTrack","cn","inputs","twMerge","clsx","crypto","randomUUID","bytes","Uint8Array","getRandomValues","hex","toString","padStart","join","isDOMElement","Element","HTMLElement","isTypableElement","isContentEditable","tagName","disabled","isAppleDevice","test","platform","getPlatformSpecialKey","getPlatformAlternateKey"],"sourceRoot":"","ignoreList":[]}