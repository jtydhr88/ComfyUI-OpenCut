{"version":3,"file":"static/chunks/f6d2e299.1876fd6ea2bb2064.js","mappings":"iGAi7FA,EAs6EA,EAojiBA,EAg3NA,EACA,EACA,EAqpTA,IAk7XA,EAy3EA,EA4pCA,EAprCA,EApwFA,aAvpiDA,YAicA,yHAnsDA,wBAEA,YADA,uBAAkF,kDAA6D,UAC/I,+BACA,sBAAyD,GAAW,CACpE,6BACA,MAAiB,OAAG,WACpB,cACA,cACA,mBACA,SACA,CAAK,EACL,eACA,CACA,2BACA,GAAQ,GAAQ,YAAc,GAAQ,iBAAmB,GAAQ,0BACjE,8BACA,qBAEA,IACA,MAA0B,GAAQ,gBAAgB,GAAQ,8BAC1D,yBACA,wBAEA,CACA,CACA,oBACA,eACA,iBACA,EAAuB,OAAG,4BAC1B,yBACA,kBACA,CACA,YACA,sBACA,4CAEA,0BAEA,UAAwB,OAAG,oBAAsB,qBAAuB,EACxE,EACA,EAEA,0CACA,kCACU,OAAG,OAAQ,EACrB,2FACA,GAGA,qBACA,CACA,CACA,cACA,OACA,CACA,gBACA,SACA,sBACA,iBACA,6CACA,kBACA,CAUA,OATA,OACM,OAAG,WACT,cACA,oBACA,aACA,YACA,CACA,CAAO,GAEP,CACA,CACA,oBACA,MACA,GAAuB,MAAvB,GAAe,GAAQ,qBAmDvB,QAnDuB,EACvB,SACA,EAAmB,GAAQ,gBAC3B,YAAsB,WAAiB,IACvC,OAAyB,OAAG,WAAa,QAAU,KAAM,EAAE,KAE3D,MAAqB,OAAG,CACxB,SACA,CACA,4BACA,aACA,UAAgC,GAAQ,aAC1B,GAAQ,gDACtB,sBAEA,CACA,CAAS,CACT,GAEA,EAAmB,OAAG,QAAS,EACvB,OAAG,QAAS,EAAG,OAAG,SAAW,cAAgB,qBAC7C,OAAG,QAAS,MACpB,EACA,EAAqB,OAAG,CACxB,SACA,CACA,8BACA,aACA,UAAgC,GAAQ,aAC1B,GAAQ,yCAEtB,CACA,CAAS,CACT,CACU,OAAG,WAAa,iBAAmB,aACnC,OAAG,WAAa,YAAc,QACxC,CAEA,SAAqB,GAAQ,0BAC7B,MAAmB,OAAG,QAAS,EACvB,OAAG,QAAS,EAAG,OAAG,SAAW,cAAgB,mBAC7C,OAAG,QAAS,MACpB,EACA,EAAkB,OAAG,CACrB,KACA,CAAU,wDAAgE,CAC1E,CAAS,OAAG,QAAU,0CAAmD,OAEzE,EAAmB,OAAG,QAAS,MAC/B,MAAa,OAAG,WAAY,SAC5B,CAGA,CACA,mBACA,YACA,UAAe,GAAQ,2BACV,OAAG,QAAU,0CAAmD,EACvE,GAEN,OACA,eACA,kCACA,CACA,EACA,gBACA,qBAEA,GAAG,oBACH,uBACA,QACA,2BACA,aACA,eANA,EAOQ,GAAQ,4CAEN,GAAQ,WATlB,EAUA,gBACQ,uCACR,CACA,CACA,CAAC,EAuID,GAAG,mBAtIH,CACA,+BACA,OACA,MAAoB,GAAS,aACzB,GAAS,2BACb,iBACA,uEACA,sCACA,6CACA,4BACA,kBACA,iBACA,4CAEA,SACA,WACA,2BACA,QACA,MAA8B,GAAY,4BAC1C,EAaA,MAbA,sDACA,IACA,MACA,MAAqB,OAAa,+DAElC,KACA,IACA,MACA,OAEA,0DAEA,EACA,iBACA,2BACA,MACA,MAEA,WAEA,aACA,oDACA,yCAEA,MADA,UACA,oBACA,mBACA,OACA,aAEA,wDACA,CAXA,IAYA,WAEA,GADA,+BACA,OACA,kEACA,yBACA,yBACA,CACA,EACA,iCACA,cACA,cACA,mBACA,MACA,MAEA,IAEA,IACA,KACA,kBACA,mBACA,MACA,IACA,KACA,iBACA,mBACA,QACA,IAEA,IAEA,IACA,KACA,iBACA,mBACA,IACA,IACA,KACA,aACA,mBACA,KACA,cACA,SAEA,CACA,CAAW,EACX,gCACA,kCAeA,GAdA,eACA,MACA,6EAEA,OADA,iCACA,CACA,CAAa,EACb,IACA,eACA,eACA,SACA,EAEA,WACA,IACA,SACA,yBACA,wCACA,gCACA,mCACA,qCAEA,wBACA,GACA,CACA,CAAW,EACX,2BACA,UACA,GACA,CAAW,CACX,CAAS,CACT,CACA,QACA,EACI,GAAS,mCAEb,GAEA,OAAmB,sBACnB,4BACA,eACA,aAEA,aADA,sCAEA,yBACA,2CACA,MAAyB,OAAoB,UAG7C,MAFA,mCACA,wBACA,CACA,CAGA,CACA,CAAC,EACD,GAAG,oBACH,2BACA,OACA,MAA+B,GAAG,yBAClC,+BACA,6CACA,8BACA,cACA,OACA,QACA,OACA,QACA,CAAO,CACP,gBACA,CAAK,EAgGL,kCAzDA,YACA,0BACA,sBACA,2BACA,wCACA,uBAFA,OAGA,mBACA,uBACA,iBACA,yBACA,OACA,MA3CA,cACA,YACA,QACA,WAEA,uBACA,gBACA,gBAEA,mBAGA,IAFA,IACA,IAEA,EADA,UACA,qBACA,gBACA,gBACA,WAEA,kBACA,CAAe,gBACf,EAuBA,WACA,KACA,UACA,QACA,6BACU,CACV,mBAA0C,GAAG,cAC7C,qCACA,IAEA,gDACA,IAGA,IADA,2BACA,MACA,CACA,CACA,sBACA,4BACA,MAEA,uCACA,KACA,KACA,0BAEA,mCACA,OAA2B,EAAa,IAExC,EAnDA,YAEA,cADA,cAGA,UADA,6CAEA,MACA,IAAmB,KAAc,OAEjC,CAEA,EAyCA,GACA,6BACA,YACA,gCACA,SAEA,GADA,YAnFA,KACA,2BACA,WAEA,eADA,KACA,aACA,EA8EA,MAEA,EAEA,IAAuB,EAAK,GAAG,EAAO,IAItC,yBACA,wCACA,iCACA,EAEA,CACA,CAAC,EACD,OAIA,wGACA,EACA,WACA,IAAO,OAAU,UACjB,MAAwB,OAAW,GACnC,+BACA,EAAwB,OAAgB,GACxC,EAAqB,OAAa,GAClC,UACA,mBACA,sDAEA,EACE,GAAG,oBACL,6BACA,UACA,CACA,8BACA,kDACA,uCACA,eACA,gBACA,UACA,CAAO,CACP,CACA,kCACA,uDACA,oCACA,eACA,gBACA,UACA,CAAO,CACP,CACA,+BACA,oDACA,oBACA,uEACA,aACA,gBACA,uBACA,6BACA,iBACA,GACA,0BACA,CACA,CAAO,CACP,CACA,0CACA,6BACA,yhBACA,WACA,gBACA,OACA,iBACmB,OAAoB,CACvC,yBAGA,CACA,CAAO,CACP,CACA,wCACA,2BACA,qCACA,WACA,gBACA,OACA,cAAyB,GAAoB,CAE7C,CAAO,CACP,CACA,yCACA,4BACA,yCACA,WACA,gBACA,OACA,cAAyB,GAAoB,CAE7C,EACA,CACA,UACA,CACA,0CACA,yBACA,yBACA,WACA,kBACA,CACA,CAAO,CACP,CACA,4CACA,2BACA,yBACA,WACA,oBACA,CACA,CAAO,CACP,CACA,6CACA,4BACA,yBACA,WACA,qBACA,CACA,CAAO,CACP,CACA,4CACA,2BACA,yBACA,WACA,oBACA,CACA,CAAO,CACP,CACA,iDACA,iCACA,yBACA,WACA,yBACA,CACA,CAAO,CACP,CACA,2CACA,oCACA,kBACA,WACA,mBACA,CACA,CAAO,CACP,CACA,gCACA,sBACA,kBACA,WACA,gBACA,CACA,CAAO,CACP,CACA,iCACA,2BACA,kBACA,WACA,qDACA,CACA,CAAO,CACP,CACA,mCACA,0BACA,kBACA,iBACA,IACA,+BACA,2BACA,CAAa,EACb,oCACA,OACA,gBACA,QAAyB,OAAC,gCAC1B,QACA,CAAe,EAUf,GAPA,MAAkC,OAAgB,YAClD,MAAqB,OAAC,mCACtB,kBACe,EACf,QAAuB,OAAC,yCACxB,cACA,CAAa,EAEb,IACA,qBACA,CAAgB,SACA,GAAG,qCACnB,OACA,iBACA,QAA2B,OAAC,YAC5B,OAA0B,OAAC,wCAC3B,QACA,CAAiB,CACjB,CAEA,CAAY,SACA,GAAG,wCACf,OACA,iBACA,QAAuB,OAAC,YACxB,OAAsB,OAAC,sCACvB,QACA,CAAa,CACb,CACA,CACA,CAAO,CACP,CACA,6BACA,kBACA,qBACA,iBAMA,MALgC,OAAgB,YAChD,QAAqB,OAAC,iCACtB,MAAmB,OAAC,0BACpB,gBACA,CAAW,GACX,aACA,CACA,CAAO,CACP,CACA,2BACA,gBACA,qBACA,WACA,cACA,CACA,CAAO,CACP,CACA,wBACA,aACA,sBACA,iBACA,kCACA,MAAoC,OAAgB,YACpD,QAAuB,OAAC,4BACxB,MAAqB,OAAC,qBACtB,cACA,CAAa,CALb,GAQA,QACA,CACA,EACA,CACA,cACA,CACA,cACA,yCACO,CACP,CACA,cACA,uCACA,CAAO,CACP,CACA,4BACA,UACA,uCACA,yCACA,0CACA,yCACA,8CACA,wCAEA,CAAO,CACP,CACA,cACA,sEAEA,CACA,aACA,CACA,oCACA,OACA,QACA,OACA,CACA,EACA,CACA,iBACA,CACA,4BACA,4CACA,mBACA,EACA,CACG,EACH,CAAC,GACD,2BAGA,iBAA0C,GAAiB,CAC3D,2BAFA,EAGA,eAHA,CADA,uBAAkF,kDAA6D,UAK/I,KAJA,sBAKA,uBACA,CACA,gBACA,MACA,gCACA,aACA,gCACA,8CACA,qCACA,mDACA,wDACA,MACA,YACA,4BAAoC,GAAK,uBAAuB,SAAS,YAAY,EAAK,GAG1F,OACA,OACA,uBACA,0BAEA,CACA,CACA,4BAEA,YADA,uBAAkF,kDAA6D,UAC/I,+BACA,eACA,YAiBA,iBAAgC,GAAa,CAE7C,eACA,QACA,eACA,4BACA,+BACA,wBACA,yBAA6C,EAC7C,oBACA,cACA,wBACA,uBACA,oBACA,yBACA,sBACA,qBACA,sBACA,oBACA,WACA,aAAmB,OAAG,8BACtB,qBACK,CACL,CACA,6BACA,gEAGA,aACA,2DACA,4DACA,yCACA,0CACA,kBACA,CAEA,gBACA,kCACA,8BACA,oEAEA,4CACA,yBACA,qDACA,0BAEA,uDACA,0BAEA,uDACA,yBAEA,iCACA,CACA,eACA,mBAAyB,GAAS,0BAA0B,IAAuB,KAAd,CAAc,CAAZ,YAAY,EACnF,8CACA,kDACA,CAEA,oBACA,KACA,sBACA,oBACA,oCA2BA,GA1BA,qBACA,OAAgB,OAAG,CACnB,oBACA,CACA,SACA,oBACA,CAAW,CACX,aACA,kBACA,CACA,CAAS,CACT,CACU,OAAG,qBACH,OAAG,CACb,MACA,CACA,4BACa,CACb,QAAsB,OAAG,SACzB,mBACa,MAEb,GAGA,uDACA,EACA,4BACA,uBACM,CAEN,MADA,6BACA,8CACA,oCACA,qBACA,CACA,mBACA,gCACA,mBAAyB,GAAa,2BACtC,gCACA,UAEA,EAAS,oBAAU,iBAA4B,IAC/C,UACA,+BACA,YAAwB,WAAoB,IAC5C,wBACA,qBACA,UACA,aACA,OACA,CAAW,EAEX,EAEA,CACA,qBACA,UACA,cAAY,4BAAkC,EAC9C,yDAA2F,CAC3F,uBAA2D,CAC3D,gDAAiG,CACjG,iBAA8D,CAC9D,mBAEA,cADA,eAAyD,CACzD,GAEA,MAEA,CAEA,+BACA,WACA,eACA,MAEA,4JAUA,OARA,IACA,cACA,WAEA,iBACA,eAGW,OAAG,QACR,OAAG,UACT,QACA,cACA,YAEA,aACA,wBACA,UACA,OACA,OAAqB,oBACrB,CAAW,CACX,CACA,CAAO,EACD,OAAG,UAAY,sBAAwB,EACrC,OAAG,UACX,gBACA,UACA,YAEA,aACA,wBACA,UACA,OACA,OAAuB,2BACvB,CAAa,CACb,CACA,CAAS,EACT,EACA,CACA,CACA,mBACA,QACA,oEACA,mBAA2C,EAE3C,oBADiB,GAAG,4CACpB,8DAaA,OAZA,oCACA,UACA,MACA,2BACA,QACA,EACA,KACA,EACA,sDAEA,CAAO,GAEP,WAEA,kBACA,QACA,6DACA,mBAA0C,EAE1C,sBADiB,CAAG,4CACpB,8DAiBA,OAhBA,mCACA,UACA,MACA,WACA,KAGA,2BACA,QACA,EACA,EACA,EACA,sDAEA,CAAO,mBAEP,WAEA,mBACA,QACA,oCACA,4BACA,gCAEA,gCACA,gEAEA,oBADiB,GAAG,4CACpB,+DAEA,oBADA,2DACA,KAqBA,OApBA,oCACA,cACA,UACA,0BACA,2CACA,8CACA,4DAIA,OAHA,UACA,OAEA,oBACA,SACA,EACA,EACA,EACA,EACA,EAEA,CAAO,mBAEP,WAGA,QACA,MACA,4BAA2C,GAAG,sCAAsD,OACpG,0BAEA,qBAA0B,OAAG,CAC7B,oCAEA,iBAAuB,OAAG,yCAC1B,gBAAsB,OAAG,yCACzB,iBAAuB,OAAG,yCAC1B,MAAkB,OAAG,QACrB,iBACA,gBACA,iBACA,CACA,YACA,2BACA,6BACA,6BAEA,oBACA,MACA,IAAa,OAAG,MAChB,aACA,iBACA,CAAW,CACX,aACA,CAAS,EACT,MACA,EACA,GACK,EAAI,EACT,MAAkB,OAAG,iCACf,OAAG,WACD,OAAG,qBACH,OAAG,CACX,SACA,CAEA,aACA,gCACA,CACA,CAAW,CACX,MACA,GAAmB,OAAG,WACtB,cACA,YAA2B,KAAyB,EAAE,EAAlB,EAAE,EACtC,OACA,CAAa,EAFqC,EAKlD,EACM,OAAG,SACD,OAAG,wDACH,OAAG,oCACD,OAAG,CACb,SACA,wCAEA,EACA,EACA,EACM,OAAG,WACD,OAAG,CACX,mBACA,CACA,aAIA,GAH2B,GAAG,kBAC9B,eAAqC,IAAuB,OAAZ,YAAY,EAE5D,WACgB,OAAa,YAC7B,iFAIA,QACA,8CAA8D,mBAAmB,MAEjF,OAAuB,GAAG,4CACV,GAAS,oBACzB,GAAqB,IAAuB,KAAd,CAAc,CAAZ,YAAY,GAG5C,WACA,CACA,CAAW,CACX,qBAEQ,OAAG,CACX,mBACA,CACA,sBACA,MACA,EACA,KACA,KACA,iCACA,MAA8B,GAAG,2BACjC,yBAA+D,CAC/D,iDACA,MACA,qBACA,eACA,SACA,KACA,KACA,gBACA,oBACA,iBACA,UACA,YACA,CACA,qBACA,uCACA,uCAEA,cACA,wBACA,mBAGA,eACA,MACA,2BAEA,WAEA,WACA,IACA,YACA,EACA,SAxZA,OACA,0CACA,gBACA,WACA,uBACA,WACA,eACA,SACA,EAAQ,IACR,MAEA,CAEA,QACA,EA0YA,IACA,CACA,OACA,GACA,GAAgC,GAAG,4BACnC,MAGA,OAFA,uBACA,kBACA,CACA,CAAmB,IAAI,EAEvB,WAA6C,IAAuB,GACpE,EADsD,EACtD,YACA,CAEA,aADA,kCAAkE,EAClE,GACA,YAEA,uBACA,qCACA,uCACA,CACA,CAAW,CACX,QAEQ,OAAG,CACX,mBACA,CAAY,iCAAqC,CACjD,SAEA,EACA,EACA,gCACA,iBACA,eAAuC,KAAyB,EAAE,EAAlB,EAAE,IAAgB,QAAJ,CAAI,EAElE,yBACA,2CACA,KACA,uCACA,qBACA,CAAK,CACL,CACA,CACA,aACA,iBAKA,WACA,UACA,aACA,eACA,yBACA,YACA,UACA,iBACA,EACA,KAGA,EAAW,IAFX,YAEW,IADX,UACW,GAsCX,UACA,MAAe,OAAgB,IAC/B,WACA,WASA,OALA,EAHsB,CAAO,OAAO,GAAO,SAAiB,GAAO,iBACnE,cAEA,UACA,WACA,OACA,cAAgC,GAAO,WAAkB,GAAO,SAChE,CAAG,EACH,IAAiC,UAA0B,MAC3D,EAeA,4BACA,MACA,kBACA,EAEA,YADA,uBAAkF,kDAA6D,UAC/I,+BAGA,cAFA,IAEA,IAFA,kCAEA,GAEA,qCACA,kBAA4B,GAAU,CACtC,eACA,SACA,CAPA,mHAOA,QACA,wBACA,mBACA,8CACA,0BACA,sBACA,wCACA,iCAEA,CACA,mBACA,gBACA,6DACA,UACA,6BAA0C,GAAG,oBAC7C,EACA,CACA,2CAIA,aAHA,wBACA,GAAU,OAAqB,CAAC,GAAG,WAEnC,IACA,6DACA,yCACA,OACA,2DACA,QACA,CACA,uCACA,OACA,uDACA,QACA,CACA,uDACA,OACA,aACA,0BAAoC,EAAW,aAAa,KAAQ,IAEpE,QACA,CACA,UACA,6BACA,EACA,QACQ,GAAG,QACX,EACQ,GAAG,oBACX,GAEA,CACA,CACA,qBACA,MACA,yCACA,oCACA,wCAAqD,GAAU,OAC/D,qCACA,4BACA,qBAGA,CACA,yBACA,QACA,iGAEA,GADA,uBACA,kCACA,YAAwB,6BAAgC,KACxD,sBACA,GACA,gCAEA,CAEA,sBACA,CACA,CACA,2BACA,MACA,GAAQ,GAAG,kBACX,OAEA,4BACA,EACA,sEACA,wBAGA,uBACA,2BACA,wBAGA,CACA,2BACA,MACA,0BAAyC,KACzC,SAEA,oDACA,+BAIA,OAHA,GACA,oBAA6B,6BAAwC,GAErE,CACA,CACA,QACA,CACA,iBACA,QACA,sDAGA,GAFA,uBACA,0BACA,wCACA,YAAsB,sBAAyB,IAC/C,2BAEA,0CAEA,mBACA,yBACA,+CACA,8BACA,sBACA,CACA,CAkKA,eACA,UACA,mCAAqD,IAAM,IAAkE,MAAlE,+BAAwD,IAAU,sBAC7H,IACA,GAEA,CACA,eACA,YACA,aAAU,GAAW,iBACrB,4JACA,CAQA,iBACA,cACA,EACA,SAAgB,GAAU,QAE1B,gBAEA,aACA,MAAiB,GAAG,yBACpB,MACA,MAAyB,GAAG,gCAC5B,GAAwB,OAAe,MACvC,EACA,mBACoB,GAAG,oBACvB,sBACA,sBAGA,CACA,CACA,CACA,2BApWA,GAqWA,IACA,UAEA,OAxWA,EAwWA,EAxWA,EAwWA,EAvWgB,OAAgB,MAChB,OAAgB,IAEhC,KAEM,OAAc,KAAW,OAAgB,IAC/C,CAzDA,QACA,IAlBA,IAkBA,OACA,WACA,WACA,OACA,OACA,4BACA,YAEA,gBACA,YACA,GAEA,0BACA,0BACA,KA/BA,UADA,EAgCA,IAhCA,EAgCA,IA/BA,MAgCA,EACA,SACA,IAAa,UAA+B,EAC5C,IAAa,UAA+B,EAE5C,GAoCA,KAEM,OAAgB,IACtB,CAtCA,QACA,eACA,WACA,EAAwB,OAAwB,IAChD,EAAwB,OAAwB,IAChD,EAAuB,GAAO,0BAC9B,aACA,KAEA,EACA,UAAgB,eAAoC,EACpD,UAAgB,eAAoC,GAEpD,EAyBA,KAEA,QA6VA,SACA,GACA,UAAoB,GAAM,KAE1B,kCACA,MACA,oBACA,sBACA,0BACA,gCACA,mBACA,CACA,CACA,OAAW,uCACX,CA7NA,cACA,kBACA,MAYA,EAgKA,EA3KA,sCACA,wBAGA,+BACA,sBACA,aACA,0CACA,wBACA,8BACA,aAEA,YAIA,eAJA,CACA,eAAwB,KAAY,OACpC,GAAe,aAAmB,GAAU,gBAAwB,EACpE,CAGA,CAHI,GAGJ,aAA+B,IAAU,mBACzC,aACA,SAAU,GAAO,CAwJjB,CADA,kBACA,OACA,YAEA,MAAW,GA1JX,wBACA,uBACA,yBACA,iBACA,KACA,EAAW,GAAM,KACjB,EACA,OAEA,EAEA,EACA,wBACA,YAMA,EALA,OACA,oBACA,YAEA,mBAQA,GALA,EADA,KAAc,GAAY,CAC1B,CAAc,GAAY,mBAAiC,GAAG,MAAO,QAErE,mCACA,CAAK,GAAI,EAET,+BACA,mCACA,IACA,iBAEA,CACA,4GACA,gDACA,GACA,YAEI,OAAsB,CAC1B,KACA,EACA,EACA,OACA,GAEA,gDACA,0CACA,yBAEA,CACA,yBACA,8HACA,YAAoB,WAA0B,IAC9C,6BAUA,GAPA,WAAoB,OAAgB,iBACpC,mBACA,CAAG,EACH,cACA,yBACA,yBACA,EACA,IACA,wBACA,oBACA,oBAEA,mBACA,oBAEA,2BACA,KACA,gDACA,CAAK,CACL,CACA,EACA,aACA,YACA,sBACA,cACA,iCAAoE,IAAM,EAI1E,GAHA,GACA,8BAAsD,IAAM,EAE5D,gCACA,UACA,sBAEA,MACA,CACA,2CAAmE,GAAU,oBAC7E,MACA,+BAEA,gBACA,MAAiB,GAAG,gBACpB,eACA,MAAsB,GAAG,gCACzB,eACA,8BACA,0BACA,CACA,EACA,gBACA,UACA,yCACA,uCAAoE,IAAU,yBAC9E,KACA,UACA,KACA,EACA,EACA,EACA,oBAEA,EACA,aACA,MACA,iBACA,0BACA,YACA,YAGA,uBACA,sDACA,YAAoB,sBAAyB,IAC7C,+CAEA,gBACA,qBACA,0BACK,KACL,qBACA,CACA,EACA,iBA8DA,GAAG,oBACH,0BACA,mCACA,4CAIA,OAHA,aACA,yHAEA,EACA,EACA,8BAA2C,OAAgB,CAC3D,8BACA,WACA,MACA,eAEA,cADA,gCACA,aACA,aACA,oBACA,SAA8B,GAAU,GACxC,UAA2B,GAAU,uBAGrC,CADA,sDAEA,iDAEA,CACA,CACA,GAEA,wBAAqC,OAAgB,CACrD,wBACA,WACA,oCACA,0BACA,uBAA8C,GAAU,GACxD,oBACA,SAA2B,GAAU,qBACrC,CACA,CAEA,GAUA,kCACA,kDACA,UACA,4CACA,iBACA,cACA,YAA4B,MAAY,GAA2E,MAA3E,GAA2E,MAA3E,+BAAiE,IAAU,kDACnH,SAGA,MAAmB,GAAS,6BAC5B,eACA,eACA,OACA,yBACA,YACA,CACA,KAzBA,YACA,2BACA,oCACA,SAGA,QACA,EAkBA,IACA,MAAkB,GAAS,mBAK3B,OAHA,QACA,oBACA,eACA,CACA,CACA,CAAG,CACH,sBACI,GAAS,kBACb,gBACA,kBACA,iBACA,CAAO,GAEP,mBACA,CACA,CAAC,EACD,6BACA,OACA,kBACA,EAEA,YADA,yBAAkF,kDAA6D,UAC/I,+BACA,sCACA,qEAIA,kBAEA,IACA,OACA,OACA,aACA,YACA,CAAG,CAEH,oBACA,QACA,SAAmB,MAAqB,CAAd,EAAE,CAC5B,CAD6C,EAC7C,MADsC,CACtC,WAAsB,GAAG,+CACzB,GAAU,GAAG,iCACb,gCAEA,2BAGA,oBACA,CAAG,CACH,oBACA,MAAgB,GAAG,aACnB,IAAgB,GAAG,mBACnB,mBACA,uBACA,MACA,CACA,CACA,UACA,eACA,iBACA,oBACA,YACA,CACA,cACA,2BACA,KAIA,OAHA,iBACA,iCACA,mCACA,MAAa,yBACb,CACA,gBACA,YAAuB,OAAgB,WACvC,MAAa,OAAC,qBACd,QAAe,OAAC,wBAChB,eACA,CAAK,EACL,MAEA,OADA,wBAEA,yBACQ,OAAa,YACrB,gIAEA,MACA,0BACA,YACA,gHAEA,MAGA,CACA,SACA,CACA,YACA,MAAyB,GAAG,gCAC5B,gCAA6C,2BAAyC,+DAAqE,EAAM,KACjK,CACA,cAQA,UACA,OACA,eACA,YAAsB,oBAAuB,KAC7C,oBACA,uCACA,YAA2B,mBAA4B,KACvD,SACA,eACA,SACA,sCACA,sBACA,MAAyB,GAAG,gBAC5B,OACA,oBACA,CAAiB,GAAG,sCACpB,KACA,KACA,CACA,CACA,GACA,yBAEA,CACA,CACA,CACA,EAEA,iBADyB,OAAS,YAAa,GAAG,gBAjClD,sBAEA,MADuB,GAAG,yBAC1B,mBACA,SACA,CAiCA,OADA,KACA,CACA,CAEA,CAFM,CAIN,eAEA,iBACA,gBACA,oBACA,sBACA,6BACA,6BACA,4BACA,6BACA,6BACA,yBACA,6BACA,6BACA,sBACA,4BACA,mBACA,kBACA,qBACA,mBACA,wBACA,CA3IA,oHA2IA,WACA,YACA,gBACA,gBACA,kBACA,0BACA,0BACA,yBACA,0BACA,0BACA,sBACA,0BACA,0BACA,mBACA,yBAEA,6BA1JA,CA2JA,eACA,UACA,eACA,kBAEA,oBACA,OA9JA,IA8JA,UACA,uBACA,0BACA,OAAe,YAAc,CAC7B,oCAA2C,8CAAkD,EAC7F,wCACA,CAAO,GAAK,QAEZ,eACA,SACA,KACA,YAAoB,6BAAgC,KACpD,6BACA,UACA,uBACA,CACA,wBACA,IAlLA,GAoLA,KApLA,EAoLA,EApLA,gCAoLA,WACA,MAAU,GAAG,oBAAoB,KAAmB,EAAZ,EAAE,CAAU,oBAChD,OAAe,2BACnB,CACA,WAIA,aAHA,kBACA,gBACA,qBACA,sBACA,cACA,WACA,mBACA,uBAEA,sBACA,0BAEA,6BACA,iBACA,qBAEA,qBACA,CACA,0BACA,oCACA,wBAGA,mCAFA,yBAAyC,YAMzC,CAEA,mBACA,UACA,yBACA,aACA,OAAqB,+EACrB,gDACA,oEACA,CAEA,cACA,QACA,gBACA,cACA,8BACA,6BACA,aACA,mBACA,gBACA,+BAEA,IADA,uCACA,CAEA,GADA,yCACA,IAYA,OAVA,6BACA,OACA,UACA,WAA4B,EAE5B,CAAS,CACT,WACA,eACA,kBAGA,CAAM,uBACN,4BACA,6DACA,YAEA,SACA,MACA,KACA,yBACA,6BACA,cAIA,GAHA,SACA,WAEA,UACA,gBACA,mEACA,WACA,KACA,CAEA,QACA,CAAe,CACf,EACA,GACA,KACA,GAEA,oCACA,CACA,MACQ,MACR,gBACA,0CACQ,IACR,iCACA,mBACA,OACA,KACA,CAEA,YACA,uDACA,GACA,KAEA,CACA,CAEA,OADA,gBACA,CACA,OACA,UACA,UAEA,CAAS,CACT,WACA,eACA,kBAEA,CACA,aACA,uEAEA,CAEA,0BACA,kBACA,sGACA,2BACA,8EACA,IACA,KAqBA,MApBA,8CACA,KAAkB,iBAAyB,EAC3C,OAAsB,EAAO,EAAE,EAAU,EACzC,QACA,MAAkB,EAAO,EAAE,MAAkB,EAAE,GAAU,GAGzD,iBACA,iCACA,UACA,4BAAwC,EAAO,yBAE/C,uBACA,UACA,SACA,0GAEA,GACA,UAA6B,cAAwB,EAErD,MAAa,0BACb,CAEA,6BACA,MACA,SACA,UACA,qCACA,eACA,GAAU,OAAc,wBACxB,4CAEA,IACA,MACA,yDACA,GAEA,QACA,WACA,cACU,CACV,SAAkB,YAAe,oBACjC,EACA,EACA,EACA,KAEA,kCACA,OACA,gCAA2C,cAC3C,CACA,EAAQ,IACR,UAGA,iBAAa,UACb,CAEA,gCAEA,yBADA,sBACA,MACA,eACA,wBACA,OACA,yBAEA,KADA,CAAuB,UAIvB,EACA,GACA,KACA,EAEA,gDAAuG,YAA0B,GACjI,sCACA,yBACA,+BACA,sBACA,gCACA,GACA,iCAEA,MACA,aAEA,OACA,gCACA,GACA,iCAEA,QAAsB,qBAAiC,CACvD,CACA,CAEA,+BACA,4BACA,YAAoB,WAAkB,KACtC,WACA,SACA,wCACA,QACA,CACA,SAAc,2BAA6B,oBAC3C,EACA,EACA,EACA,KAEA,+BACA,kCACA,iCACA,uBACA,CACA,CACA,uCACA,4CACA,YAAoB,WAA2B,KAC/C,WACA,kBACA,8BACA,cACA,EACA,GAEA,QACA,CACA,SAAc,YAAe,oBAC7B,EACA,EACA,EACA,KACA,CACA,eACA,EAEA,kCACA,gCAAuC,eACvC,iCACA,qCAEA,qCACA,+BACA,CACA,CAEA,yBAEA,qBACA,oBACA,cAAY,WAAmB,yBAC/B,EACA,EACA,EACA,GAEA,4BACA,oCAaA,OAZA,oCACA,gBACA,iCACA,EACA,EACA,EACA,EACA,EACA,EACA,IApBA,EAwBA,CAEA,0BACA,cACA,yCACA,YAA2B,kBAA8B,KACzD,8BACA,EAEA,2EAEA,mGACA,iCAEA,GADA,8BACA,GACA,QAEA,iCACA,oDACA,OACA,MACA,EACA,sCACA,sDACA,4BACA,OACA,qDACA,mCACA,2BACA,WAEA,CACA,QACA,WACA,SAA0B,iBAAyB,CAEnD,CADA,MAAkB,EAAO,EAAE,GAAM,IACjC,GACA,MAAoB,EAAO,EAAE,SAAY,EAAE,GAAM,CAEjD,CACA,OACA,gCACA,CACA,CAEA,uCACA,gBACA,WACA,KACA,qBACA,UAAwB,GAAS,yBACjC,QACA,YACA,yBAAsC,MAAqB,CAAd,CAAgB,CAAd,EAAc,CAClD,EACX,KAFyD,CAEzD,EACA,QAAqB,KAAmB,EAAZ,CAC5B,CAD8B,MAC9B,CACA,GAFwC,EAExC,uBAEA,aACA,YACA,+BACA,oCACA,yBACA,CACA,CACA,CAAW,EACX,MAGA,cACA,gBACA,uBACA,CACA,CACA,EACA,cACA,SACA,UACA,eACA,QACA,gBACA,qBACA,sBACA,YACA,4EAA6G,GAAK,EAClH,4BACA,kBACA,YAAmC,yBAAyC,KAC5E,yBAEA,aADA,mCACA,eACA,6BACA,uCAGA,WACA,mBACA,QACA,qEACA,WACA,iCAEA,4DACA,kBACA,oBACA,8BACA,CACA,EACA,mBACA,QACA,qEACA,YACA,+BACA,EAAwB,GAAG,gBAM3B,MALA,CACA,KACA,eACA,cACA,CAEA,CACA,mEACA,EACA,GACA,qBACA,iBACA,eACA,cACA,EANA,IAQA,CACA,CACA,EACA,6BAIA,EAHA,GAAe,MACf,sDACA,gCAEA,0CACA,oBACA,2BAEA,EAGA,qBACA,iBAEA,iBACA,qDACA,GAPA,IAQA,EACA,kDACA,MACA,oBACA,yDACA,iBACA,iBACA,wBAEA,0CACA,MAA8B,GAAS,oBAIvC,OAHA,eACA,QAA8B,aAAa,GAAG,EAAE,EAChD,wBACA,CACA,CAAW,GAGX,0BACA,0BACA,kDACA,SACA,UACA,8BACA,mCACA,kBACA,0BACA,YACA,EACA,EACA,EACA,EAEA,QACA,wBACA,SACA,CACA,QACA,EACA,6BACA,mBACA,iBACA,6BACA,EAAwB,GAAS,2BACjC,QACA,mBACA,EAAgB,GAAK,oBACf,GAAG,cACT,WAEA,yBAEA,yBACA,EAEA,MADA,UACA,cAGA,OAFA,EAAgB,GAAK,mCACrB,EAAgB,GAAK,kBACrB,CACA,EACA,8BACA,eACA,QAgBA,EACA,EAhBA,GAAoB,2BACpB,sBACA,gCACA,KACA,YAAwB,iBAAoB,KAC5C,sDACA,YACA,SAEA,UAEA,YAAyB,mBACzB,CACQ,OAAoB,mBAAoB,GAAG,SACnD,uBAGA,yBAA2D,GAAG,wBAC9D,KACA,YAAwB,WAAwB,KAChD,WACA,EAA0B,GAAG,sBAC7B,OAQA,GAPA,UACA,uBACA,aAEA,uBACA,aAEA,oBACA,gDACA,KAEA,aADA,eACA,CACA,WACA,eACA,kCACA,eAEA,UACA,4BACA,YAAiC,mBAA6B,IAC9D,mBACA,iCAEgB,CAChB,2BACA,iBACA,eAEA,cACA,iBACA,YAAgC,8CAAuE,IACvG,yBACA,yBAGA,CAEA,CACA,eACA,cACA,cAEA,gBAAiB,gBACjB,EACA,MACA,8CACA,WACA,EAA0B,GAAG,sBAC7B,qCACA,gBACA,WACA,oBACA,kBACA,yBACA,MAAyB,GAAG,qBAC5B,GAC+B,GAAG,gCAClC,2BACA,CACA,CACA,EACA,MACA,MACA,YAAoC,wCAAsE,KAC1G,mBACA,WAEA,YADA,aACA,CACA,0CACA,EAAyB,GAAG,gBAC5B,EAA+B,GAAG,gCACN,GAAG,oCAC/B,+BACA,CACA,CACA,EACM,GAAG,2BACT,IACA,aAAgB,iBAAwB,IAIxC,OAHA,KACA,KACQ,GAAG,yBACX,CACA,EAAQ,OACA,GAAG,yBACX,CACA,EACA,oCACA,4CACA,iCACA,4DACA,mBACA,IACA,SACA,EACA,EACA,KACA,CACA,2BAEA,aACA,qBAEA,CAAS,CACT,CACA,4BACA,0BACA,EAEA,EACA,+BACA,uCACA,iCACA,kBACA,cACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBACA,2BAAuC,GAAS,uBAChD,SACA,aACA,EACA,yBACA,0BACA,+BACA,KACA,4DACA,MAA4B,OAAiB,+BAC7C,8DACA,0CACA,aACA,iBAAmC,iBAAmB,GAAG,2BAA2B,GAAG,eAAuB,GAC9G,SACA,yBACA,sBACA,yBAAyC,GAAS,uBAClD,cACA,YACA,EACA,CAAW,GAAS,sBACpB,WACA,GACA,GAEA,SACA,mBACA,gBAAkC,GAAS,sBAC3C,WACA,CACA,EACA,iCACA,sCAEA,OADA,uBACA,sCACA,EACA,WACA,0BAuBA,kBACA,eAA0B,EAAQ,IAClC,MACA,WACA,OACsB,GAAG,sBADzB,OAGA,+DACA,OACA,kCACU,GAAG,qBACb,EAEA,OAAgC,aAAa,cAG7C,EAEA,OADM,GAAG,uBACT,CACA,CAzCA,mCACA,MACA,iBACA,OAEA,kCACA,KACA,gBACA,oCACA,gBACA,8BACA,0CACA,mCACA,IACA,gBACA,yBAEA,CACA,CAEA,6CACA,EAqBA,aACA,KACA,YAEA,KAEA,UAEA,SACA,KACA,WAEA,4DAEA,WACA,KACA,OACA,eACA,wBACA,CAAO,EAEP,cACA,+BACA,iCACM,GAAG,oCACH,GAAG,kCACT,EACA,iCACA,YACA,+CACA,4CACA,sCACA,0CACA,iBACA,6KACA,cACA,uBACA,uBACA,qCACA,4BACA,oBAEA,CACA,CACA,CACA,CACA,qBACA,QACA,+CACA,4CACA,eACA,cACA,sCACA,gCACA,6BAGA,aAFA,mBAEA,IADA,4CACA,KAEA,MADA,0BACA,qCACA,IACA,WAEA,CACA,QACA,CAAQ,uBACR,6CACA,KACA,0BACA,yBACA,cACA,aACA,wCAEA,0BAEA,IACA,WAEA,CACA,CAEA,CACA,gEACA,IACA,WAEA,CACA,CAEA,yBACA,QACA,gEACA,kBACA,gDACA,8BACA,eAEA,SACA,yBACA,mBACA,MACA,gEACA,MAEA,YAAsB,IAAS,IAC/B,gDAGA,QACA,CAEA,uBACA,cACA,6BACA,8EACA,aACA,aACA,mCACA,WAEA,IADA,gDACA,OACA,iEACA,2CACA,kBACA,0BACA,uCACA,IACA,WAEA,CACA,kBACA,YACA,qBACA,YAAyB,uCAA+C,KACxE,uCACA,0CACA,iBACA,kDACA,4BACA,QACA,CACA,QACA,YAAsB,WAAoB,KAC1C,WACA,OACA,8BACA,eAEA,uBACA,0CACA,yDAEA,eAEA,gEACA,CACA,WAGA,8BACA,YAAwB,8CAAoE,IAC5F,wDAEA,CACA,CACA,CAEA,gBACA,MACA,EACA,YAAoB,WAAkB,KACtC,UACA,wBACA,aAEA,uBACA,aAEA,sBACM,GAAG,iBACT,QAAmB,aAAa,GAAG,EAAE,CACrC,CACA,kBACA,oBAGA,iBACA,MACA,aACA,wBACA,WAEA,YADA,aACA,CACA,MAAqB,GAAG,gBACxB,eACA,MAA2B,GAAG,gCAC9B,8EACA,GACA,oCAEA,CACA,CACA,CACA,aACA,gDACA,gBACA,EAAyB,GAAG,sBAC5B,GACA,UACA,EAEA,aACA,sCAEA,CACA,CAEA,uBACA,QACA,kFAAsH,GAAK,EAE3H,sBACA,QACA,sEAAsG,GAAK,EAC3G,CACA,0BACA,gBACA,kBACA,aACA,SAAY,cAAiB,EAC7B,aACA,wBACA,MAAsB,GAAS,eAAe,MAAqB,CAAd,EAAE,EAKvD,OAJA,CADiE,CACjE,uBACA,EAAc,GAAK,oBACf,GAAG,cACP,EAAc,GAAK,wBACnB,CACA,CACA,CAgDA,oBACA,oBAA8B,GAAG,0BAA4B,EAC7D,gBACA,iCAEA,gBACA,qEAEA,gBACA,gBAAwB,GAAY,CACpC,sDAEA,qBACA,kDAEA,CACA,4BACA,CAUA,eACA,MAAwB,GAAG,SAC3B,CA+EA,iBACA,KACA,UACA,6BACA,CACA,iBACA,MAAkB,OAAe,2CACjC,kCACA,CATA,GAAG,mBA3EH,CACA,KAHA,kBAIA,UACA,CACA,qDACA,6CACA,qBACA,sBACA,WACA,CAAK,CACL,CACA,+CACA,qCACA,qBACA,sBACA,SA7BA,WACA,MAEA,aADA,cAA8B,GAAG,0BAA4B,EAE7D,mBACA,uCAGA,CAsBA,CAAK,CACL,CACA,sCACA,2BACA,iBACA,sBACA,WACA,EACA,CACA,aACA,CACA,4DACA,OACA,OACA,OACA,CACA,CAAK,CACL,CACA,sDACA,OACA,OACA,SACA,OACA,CACA,EACA,CACA,QAxHA,gBACA,oBAAmC,GAAG,0BAA4B,EAClE,2CACA,iBACA,6CACA,WACA,WACA,CAAK,CACL,CAWA,MAA+B,GAAY,gCACzC,GAAY,2CACd,8BACA,2DACA,wBAGA,OAFA,QACA,SAhBA,KACA,MACA,MAA6B,MAA7B,GAA0B,GAAG,kCAC7B,6BACA,iBACA,6BACA,WACA,iBACA,CAAK,CACL,EAOA,OACA,CACA,EACA,MAA6B,GAAY,8BACvC,GAAY,0CACd,8BACA,uBACA,gEACA,sBACA,MACA,CACA,QACA,CAqFA,CAAG,CACH,gCACA,MACA,2DACA,MAtFA,aAuFA,QAtFA,yDACA,wCAAsD,KAAmB,EAAZ,EAAE,KAsF/D,KAtFyE,kBAsFzE,KACA,CACA,CAAG,CACH,qBACA,GACA,CAAG,CACH,eACA,QACA,oBACA,EAAW,GAAK,YAChB,UAAiD,MAAjD,cAA4C,IAAK,0CACjD,4BAAiD,GAAK,sBAGtD,CAAG,CAEH,6BACA,MACA,mBACA,MAA4B,MAA5B,GAAyB,GAAG,kCAC5B,GACA,kCAA0D,CAE1D,CACA,GAWA,GAAG,oBACH,0BACA,QACA,MAAiB,GAAY,gCACzB,GAAY,2CAChB,MACA,8BACA,2BACA,oBACA,qBAEA,MAYA,OAXA,2BACA,QACA,uCACA,cACA,UAAiC,GAAW,CAC5C,yBACA,kBACA,mBACA,CACA,CAAW,EAEX,EAEA,yBACA,cASA,GARA,QACA,sCACA,uDACA,cACA,yBACA,mBACA,CACA,CAAO,EACP,aACA,SAEA,aAEA,SACA,YAAsB,WAAyB,IAC/C,0BACA,KACA,KACA,CAqBA,GAnBA,QACA,6BACA,cACA,yBACA,MAA0B,OAAe,OACzC,oCAEA,yBACA,mBACA,CACA,CAAO,EACP,QACA,uBACA,cACA,oBACA,oBACA,mBACA,CACA,CAAO,EACP,EAEA,OADA,WAEA,OACA,QACA,mCACA,cACA,eACA,OAEA,CACA,CAAa,EACb,QACA,6BACA,cACA,eACA,OAEA,CACA,CAAa,EACb,KACA,QACA,QACA,oCACA,cACA,eACA,OAEA,CACA,CAAa,EACb,QACA,6BACA,cACA,eACA,OAEA,CACA,CAAa,EACb,KACA,QACA,QACA,oCACA,cACA,eACA,OAEA,CACA,CAAa,EACb,QACA,mCACA,cACA,eACA,OAEA,CACA,CAAa,EACb,KACA,SACA,QACA,oCACA,cACA,eACA,OAEA,CACA,CAAa,EACb,QACA,mCACA,cACA,eACA,OAEA,CACA,CAAa,EACb,QACA,6BACA,cACA,eACA,OAEA,CACA,CAAa,CAEb,MAEA,QACA,oCACA,cACA,eACA,OAEA,CACA,CAAS,EACT,QACA,mCACA,cACA,eACA,OAEA,CACA,CAAS,EACT,QACA,6BACA,cACA,eACA,OAEA,CACA,CAAS,EAET,QACA,CACA,CACA,CAAC,EACD,QAAuB,uBACvB,IACA,MACA,yBACA,EACA,IAAuB,yCACvB,IACA,+EACA,OAAW,cACX,EACA,GAAoC,QAAe,EACnD,wBACA,OACA,aAAkB,CAClB,MAAW,CACX,eAAqB,aACrB,CAAG,CACH,mCACA,SAAmB,OAAc,EACjC,MAAqB,GAAO,CAG5B,EAAuB,QAAG,CAF1B,EAE0B,YAC1B,EAAiB,QAAG,CAHpB,EAGoB,KACpB,EAA0B,QAAG,CAJ7B,EAI6B,eAC7B,EAAoB,QAAG,KACnB,QAAK,CACT,IAPA,EAOA,IACA,IACA,SACA,GAEI,QAAK,CACT,oBACA,IACA,SACA,GAEI,QAAK,CACT,iBACA,IACA,SACA,GAEA,WAvBA,EAwBA,eACA,EACA,OACA,kBAEA,OA7BA,EA8BA,oBACA,EACA,EAA0B,QAAQ,MAjClC,EAkCA,yBAEA,MACA,SACA,sBACA,YAEA,EAOA,MANI,QAAS,MACb,oCACA,CAAK,EACD,QAAW,MACf,uCACA,CAAK,EACL,QACa,QAAS,GAAI,QAAkB,WACpC,QAAW,CAAC,QAAK,CAAC,GAAM,GAChC,uCACA,SACA,CAAS,EACT,QAAmB,QAAO,MACd,QAAc,CAAC,QAAkB,MAC7C,MAAqB,QAAc,qCACnC,CAAa,UACb,CACgB,QAAK,IACrB,CACA,MAAyB,QAAK,CAAC,GAAC,yBAChC,aACA,CAAiB,CACjB,OACA,CAAkB,UAClB,CACA,EACA,EACA,GACA,CAAS,EACT,SAA+B,QAAS,GAAI,QAAkB,WACpD,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CAAoB,MAAO,QAAK,CAAC,GAAC,8BAAiC,CACnE,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,CAAW,EACD,QAAc,CAAC,QAAkB,WAC/B,QAAW,CAAC,QAAK,CAAC,GAAM,GACpC,mBACA,gDACA,eACA,OACA,QACA,OACA,UACA,CAAa,wBACb,OACA,CAAa,IAAK,UAClB,EACA,GAAc,QAAkB,QAChC,EAEA,CACA,CAAC,EACD,IAAuB,uBACvB,IAAuB,sCACvB,IAAuB,2CACvB,IAAuB,4EACvB,IAAuB,uBACvB,GAAoC,QAAe,EACnD,wBACA,sBACA,SAAmB,OAAc,EACjC,MAAqB,GAAO,CAE5B,EAA8B,QAAG,KACjC,GACA,CAAQ,wBAA4B,CACpC,CAAQ,wBAA4B,CACpC,CAAQ,yBACR,CACA,OACA,kBAMA,MACA,SACA,iCACA,YAEA,EAOA,MANI,QAAS,MACb,oCACA,CAAK,EACD,QAAW,MACf,uCACA,CAAK,EACL,OACa,SAAS,GAAI,QAAkB,WACpC,QAAkB,WAChB,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CACA,MAA2B,QAAK,CAAC,GAAC,wBAClC,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,CAAW,EACD,QAAc,CAAC,QAAkB,WAC/B,QAAkB,YACf,QAAS,GAAI,QAAkB,CAAC,IAAQ,MAAQ,QAAU,MAClD,QAAW,CAAC,QAAK,CAAC,GAAM,GAC/C,YACA,iCACA,YAtDA,EAWA,cA2CA,SA1CA,WA2CA,CAAiB,EACjB,QAA2B,QAAO,MACd,QAAe,CAAC,QAAe,aACnD,EACA,GACA,CAAiB,oBACF,KACf,EACA,OACA,CAAa,IAAK,UAClB,EACA,EACA,EAEA,CACA,CAAC,EACD,IAAuB,uBACvB,IACA,MACA,qCACA,EACA,IAAuB,sCACvB,IACA,+EACA,OAAW,cACX,EACA,GAAoC,QAAe,EACnD,uBACA,OACA,iBAAsB,CACtB,0BAAgC,aAChC,CAAG,CACH,+BACA,SAAmB,OAAc,EACjC,MAAqB,GAAO,CAG5B,EAA2B,QAAG,mBAC9B,EAAqC,QAAG,6BACxC,EAA+B,QAAG,KAClC,EAAkC,OAAe,OACjD,sCAEA,EAAkC,OAAe,OACjD,sCAEA,EAAqC,OAAe,OACpD,yCAEI,QAAK,CACT,qBACA,IACA,SACA,GAEI,QAAK,CACT,IArBA,EAqBA,yBACA,IACA,SACA,GAEA,WACA,kBAEA,OACA,iCACA,EACA,MACA,SACA,kCACA,YAEA,EAOA,MANI,QAAS,MACb,oCACA,CAAK,EACD,QAAW,MACf,uCACA,CAAK,EACL,QACa,QAAS,GAAI,QAAkB,WAC5C,SAA0C,QAAS,GAAI,QAAkB,WAC/D,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CACA,MAA2B,QAAK,CAAC,GAAC,2BAClC,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,CAAW,EACD,QAAc,CAAC,QAAkB,WAC/B,QAAW,CAAC,QAAK,CAAC,GAAM,GACpC,mBACA,gDACA,eACA,IAAmB,QAAK,IACxB,IAAmB,QAAK,IACxB,KAAoB,QAAK,IACzB,UACA,CAAa,2CACb,OACA,CAAa,IAAK,UAClB,EACA,GAAc,QAAkB,QAChC,EAEA,CACA,CAAC,EACD,IAAuB,uBACvB,IAAuB,oCACvB,IAAuB,2CACvB,IAAuB,4EACvB,IAAuB,uBACvB,IAAuB,qCACvB,IAAuB,sCACvB,IAAuB,4EACvB,IAAuB,uBACvB,IACA,MACA,oCACA,EACA,IAAsB,4CACtB,IACA,+EACA,OAAW,cACX,EACA,IAAsB,uCACtB,GAAoC,QAAe,EACnD,uBACA,OACA,YAAiB,CACjB,cAAmB,CACnB,eAAoB,CACpB,gBACA,CAAG,CACH,uEACA,SAAmB,OAAc,EACjC,MAAqB,GAAO,CAG5B,EAAwB,QAAG,4BAC3B,EAAyB,QAAG,CAH5B,EAG4B,0BAC5B,EAA0B,QAAG,sBAC7B,EAA4B,QAAG,KAC/B,EAA6B,QAAG,KAChC,EAA8B,QAAG,KACjC,GACA,WACA,KACA,KACA,KACA,KACA,KACA,KACA,CACA,EAA0B,QAAQ,MAClC,OACA,WACA,SACA,YAEA,CAIA,OA3BA,EAwBA,uBAxBA,EAwBA,qBACA,kBAEA,CACA,CAAK,EACD,QAAK,CACT,kBACA,IACA,GACA,WAEA,GAEI,QAAK,CACT,IAtCA,EAsCA,aACA,IACA,GACA,WAEA,GAEI,QAAK,CACT,IA9CA,EA8CA,cACA,IACA,SACA,GAEA,WACA,iBACA,WACA,UACA,EAUA,OACA,iBACA,WACA,UACA,EASA,OACA,iBACA,WACA,UACA,EACA,OAlFA,EAmFA,8BACA,EACA,MACA,eACA,iCACA,aAEA,kCACA,aAEA,mCACA,YAEA,EAOA,MANI,QAAS,MACb,oCACA,CAAK,EACD,QAAW,MACf,uCACA,CAAK,EACL,QACa,QAAS,GAAI,QAAkB,WACpC,QAAkB,WAChB,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CACA,MAA2B,QAAK,CAAC,GAAC,wBAClC,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,CAAW,EACD,QAAc,CAAC,QAAkB,WAC/B,QAAkB,YACf,QAAS,GAAI,QAAkB,CAAC,IAAQ,MAAQ,QAAU,MAClD,QAAW,CAAC,QAAK,CAAC,GAAM,GAC/C,MACA,MAAyB,QAAc,8BAAgC,0BAAgD,GACvH,YA3EA,QA2EA,EA1EA,sBA0EA,GAzEA,WA0EA,CAAiB,EACjB,QAA2B,QAAO,MACd,QAAe,CAAC,QAAe,CAzEnD,aAyEmD,EAzEnD,WAyEmD,EAxEnD,eAwEmD,GACnD,EACA,GACA,CAAiB,4BACF,KACf,EACA,OACA,CAAa,IAAK,UAClB,EACA,EACQ,QAAkB,WAChB,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CACA,MAA2B,QAAK,CAAC,GAAC,yBAClC,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,CAAW,EACD,QAAc,CAAC,QAAkB,WAC/B,QAAkB,YACf,QAAS,KAAQ,QAAkB,CAAC,IAAQ,MAAQ,QAAU,YACtD,SAAS,GAAI,QAAW,CAAC,QAAK,CAAC,GAAM,GAC5D,MACA,MAAyB,QAAc,8BAAgC,0BAA4C,GACnH,YApGA,QAoGA,EA1KA,EAuEA,qBAmGA,GAlGA,WAmGA,CAAiB,EACjB,QAA2B,QAAO,MACd,QAAe,CAAC,QAAe,CAlGtC,OAAC,yBAAyB,EAAK,IAkGO,GACnD,EACA,GACA,CAAiB,6BACF,MACf,EACA,OACA,CAAa,IAAK,UAClB,EACA,EACA,qBAA4C,QAAS,GAAI,QAAkB,WACjE,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CACA,MAA2B,QAAK,CAAC,GAAC,0BAClC,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,CAAW,EACD,QAAc,CAAC,QAAkB,WAC/B,QAAkB,YAAuB,QAAe,CAAC,QAAK,CAAC,GAAC,gCAAoC,QAAe,oBACnH,QAAW,CAAC,QAAK,CAAC,GAAM,GACpC,mBACA,gDACA,eACA,MACA,QACA,OACA,UACA,CAAa,wBACb,OACA,CAAa,IAAK,UAClB,EACA,GAAc,QAAkB,QAChC,EAEA,CACA,CAAC,EACD,IAAuB,uBACvB,IAAuB,wCACvB,IAAuB,OACvB,IAAuB,0CACvB,aACA,IAAuB,OACvB,IAAuB,wCACvB,IAAuB,OACvB,IAAuB,wCACvB,GAAoC,QAAe,EACnD,uBACA,OACA,kBAAuB,CACvB,UAAgB,aAAe,CAC/B,oBAA0B,aAC1B,CAAG,CACH,qEACA,SAAmB,OAAc,EACjC,MAAqB,GAAO,CAG5B,EAA4B,QAAG,CAF/B,EAE+B,iBAC/B,EAAqB,QAAG,CAHxB,EAGwB,UACxB,EAA+B,QAAG,CAJlC,EAIkC,oBAClC,EAA2B,QAAG,OAC9B,EAA2B,QAAG,OAC1B,QAAK,CACT,IARA,EAQA,gBACA,IACA,SACA,GAEI,QAAK,CACT,IAdA,EAcA,SACA,IACA,SACA,GAEI,QAAK,CACT,yBACA,IACA,SACA,GAEA,WACA,iBACA,uBACA,EAIA,OACA,KACA,6BACA,EACA,OACA,KACA,6BACA,EACA,MACA,eACA,qBAzCA,EA0CA,mCAEA,EACA,OA7CA,EA8CA,6BACA,EACA,cACa,QAAS,GAAI,QAAkB,WACpC,QAAW,CAAC,QAAK,CAAC,GAAM,GAChC,MAAiB,QAAc,oCAAsC,4BAAqC,GAC1G,SACA,CAAS,EACT,QAAmB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC7C,CACgB,QAAK,IACrB,CAAkB,MAAO,QAAK,CAAC,GAAC,mCAAsC,CACtE,OACA,CAAkB,UAClB,CACA,EACA,EACA,GACA,CAAS,cACT,QA4Bc,QAAkB,QA5BK,SAAS,GAAI,QAAkB,WAC1D,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CACA,MAA2B,QAAK,CAAC,GAAC,4BAClC,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACc,QAAkB,UAChC,yBACA,MACA,aACA,cACA,+DACA,wBAzFA,EA6BA,wBA4DA,iBACA,CAAe,aACf,EACA,GACA,CAAW,EACX,GACA,QA4Bc,QAAkB,SA5BK,QAAS,GAAI,QAAkB,WAC1D,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CACA,MAA2B,QAAK,CAAC,GAAC,kCAClC,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACc,QAAkB,UAChC,yBACA,MACA,YACA,iBACA,+DACA,UACA,CAAe,WACf,EACA,GACA,CAAW,EACX,GACA,SAAoC,QAAS,GAAI,QAAkB,WACzD,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CACA,MAA2B,QAAK,CAAC,GAAC,kCAClC,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,CAAW,EACX,GAAc,QAAkB,QAChC,EAEA,CACA,CAAC,EACD,IAAuB,4GACvB,IAAuB,4BACvB,IAAuB,4EACvB,IAAuB,uBACvB,IAAuB,oBACvB,IAAuB,8CACvB,IAAuB,OACvB,GAAoC,QAAe,EACnD,wBACA,OACA,YAAiB,CACjB,kBAAuB,CACvB,UAAgB,aAAe,CAC/B,aAAmB,aAAe,CAClC,iBAAsB,CACtB,0BAAgC,aAAe,CAC/C,MAAW,CACX,eAAqB,aAAe,CACpC,mBAAyB,aAAe,CACxC,aAAkB,CAClB,oBAA0B,aAAe,CACzC,cAAmB,CACnB,eAAoB,CACpB,gBACA,CAAG,CACH,oNACA,SAAmB,OAAc,EACjC,MAAqB,GAAO,CAE5B,EAAuB,QAAG,KAC1B,EAA2B,QAAG,UAC9B,GACA,qBACA,qBACA,uBACA,qBACA,sBACA,EACA,EAAgC,QAAQ,MACxC,gDACA,wBAGA,EAFA,gBAGK,EACL,OACA,kBAiBA,EAA4B,QAAG,CAnC/B,EAmC+B,iBAC/B,EAAqB,QAAG,CApCxB,EAoCwB,UACxB,EAAwB,QAAG,CArC3B,EAqC2B,aAC3B,EAA2B,QAAG,CAtC9B,EAsC8B,gBAC9B,EAAwB,QAAG,CAvC3B,EAuC2B,yBAC3B,EAAyB,QAAG,CAxC5B,EAwC4B,0BAC5B,EAAqC,QAAG,CAzCxC,EAyCwC,0BACxC,EAAiB,QAAG,CA1CpB,EA0CoB,KACpB,EAA0B,QAAG,CA3C7B,EA2C6B,eAC7B,EAA8B,QAAG,sBACjC,EAA+B,QAAG,CA7ClC,EA6CkC,oBAClC,EAA0B,QAAG,CA9C7B,EA8C6B,eAC7B,OAbA,EAcA,eACA,EACA,OACA,iBACA,0BACA,EACA,MACA,iBACA,EACA,MACA,4BACA,EACA,MACA,4BACA,EACA,MACA,wBACA,EACA,MACA,yBACA,EACA,MACA,0BACA,EACA,MAtCA,EAuCA,yBACA,EACA,MACA,gBACA,EACA,MACA,kBACA,EACA,MACA,SACA,uBACA,YAEA,EAyFA,MAxFI,QAAK,CACT,IAxFA,EAwFA,YACA,IACA,GACA,WAEA,GAEI,QAAK,CACT,sBACA,IACA,SACA,GAEI,QAAK,CACT,UACA,IACA,SACA,GAEI,QAAK,CACT,qBACA,IACA,SACA,GAEI,QAAK,CACT,oBACA,IACA,SACA,GAEI,QAAK,CACT,IAxHA,EAwHA,yBACA,IACA,SACA,GAEI,QAAK,CACT,IA9HA,EA8HA,YACA,IACA,SACA,GAEI,QAAK,CACT,IApIA,EAoIA,aACA,IACA,SACA,GAEI,QAAK,CACT,wBACA,IACA,SACA,GAEI,QAAK,CACT,IAhJA,EAgJA,YACA,IACA,SACA,GAEI,QAAK,CACT,IAtJA,EAsJA,mBACA,IACA,SACA,GAEI,QAAK,CACT,mBACA,IACA,GACA,WAEA,GAEI,QAAK,CACT,IApKA,EAoKA,cACA,IACA,SACA,GAEI,QAAS,MACb,oCACA,CAAK,EACD,QAAW,MACf,uCACA,CAAK,EACL,QACa,QAAS,GAAI,QAAkB,WACpC,QAAkB,WAChB,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,qDACA,SACA,CAAW,EACX,QAAqB,QAAO,kBACd,QAAkB,MAAQ,sCAAwC,UAChF,GACA,GACA,CAAW,EACD,QAAc,CAAC,QAAkB,WAC/B,QAAkB,YACf,QAAS,KAAQ,QAAkB,CAAC,IAAQ,MAAQ,QAAU,aACtD,QAAS,GAAI,QAAW,CAAC,QAAK,CAAC,GAAM,GAC5D,MACA,MAAyB,QAAc,0DAA4D,0BAAkD,GACrJ,YA5KA,QA4KA,EA3KA,WA4KA,CAAiB,EACjB,QAA2B,QAAO,MACd,QAAkB,MACtC,MAA6B,QAAc,CArK3C,GAAgB,CANhB,oBACA,kBACA,sBACA,kBACA,uBACA,CACgB,CAqK2B,EArK3B,EAAiB,oBAsKjC,CAAqB,SACD,QAAkB,WAAuB,QAAe,CAAC,QAAK,CAAC,GAAC,YACpF,EACA,GACA,CAAiB,6BACF,MACf,EACA,OACA,CAAa,IAAK,UAClB,EACA,EACQ,QAAc,CAAC,QAAkB,WACzC,mBAA8C,QAAS,GAAI,QAAW,KACtE,MACA,uBACA,2BACA,oBACA,+BACA,eACA,0BACA,yBACA,CAAW,kEAAyE,QAAkB,QACtG,mBAA8C,QAAS,GAAI,QAAW,KACtE,MACA,uBACA,yBACA,uBACA,wBACA,yBACA,sBACA,uBACA,uBACA,CAAW,yEAAiF,QAAkB,QAC9G,oBAA+C,QAAS,GAAI,QAAW,KACvE,MACA,wBACA,2BACA,YACA,4BACA,iBACA,aACA,CAAW,oDAA2D,QAAkB,QACxF,mBAA8C,QAAS,GAAI,QAAW,KACtE,MACA,uBACA,0BACA,sCACA,wBACA,CAAW,4DAAkE,QAAkB,QAC/F,oBAA+C,QAAS,GAAI,QAAW,KACvE,MACA,wBACA,eACA,CAAW,YAAgB,QAAkB,QAC7C,OACA,CAAW,IAAK,UAChB,EACA,SAAmC,QAAS,GAAI,QAAkB,WACxD,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,MAC/C,MAAuB,QAAc,EACrC,KACA,gCACA,qBACA,CACA,CAAe,UACf,CACkB,QAAK,IACvB,CAAoB,MAAO,QAAK,CAAC,GAAC,wCAA2C,CAC7E,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,CAAW,EACX,GAAc,QAAkB,QAChC,EAEA,CACA,CAAC,EACD,IACA,MACA,qFACA,EACA,IAAuB,oCACvB,IAAuB,iCACvB,GAAoC,QAAe,EACnD,wBACA,SAAmB,SAAkB,EACrC,MAAyB,QAAG,KAC5B,EAA2B,QAAG,KAc9B,OAJA,GACA,aAVA,UACA,WAAwC,OAAC,wBACzC,WACA,MAAY,QAAQ,EACpB,EAOA,WANA,UACA,wCACA,UACA,CAIA,CAAK,EACL,QACa,QAAS,GAAI,QAAW,CAAC,IAAU,EAAI,YAAc,EAClE,QAAiB,QAAO,MACxB,SAAgC,QAAS,GAAI,QAAkB,WACnD,QAAkB,WAC9B,YAA0C,QAAkB,QAAU,gBAAkB,WAC1E,QAAkB,UAAsB,QAAe,aACrE,EACA,GAAgB,QAAkB,QAClC,EACA,GACA,EAAO,CAEP,CACA,CAAC,EACD,GAAuC,OAAW,uCAElD,IAAgB,wBAChB,IAAgB,2CAuDhB,cA4FA,UACA,iBACA,YACA,UAYA,WAGA,UACA,sBACA,+CACA,2BACA,UACA,UAEA,sBACA,YAEA,CACA,sBACA,qCACA,sBACA,0CACA,CACA,yBACA,mCAEA,MADA,gBACA,GACA,eACA,kBACA,SACA,aAEA,CACA,CACA,iBACA,mCAEA,MADA,gBACA,QACA,eACA,cACA,iBACA,uBAAwC,IAAO,IAC/C,iBAEA,cACA,CACA,CACA,CACA,ywCAEA,eACA,eACA,cACA,iCACA,6BACA,6BACA,6BAEA,MADA,mOACA,aACA,CACA,mBACA,gCACA,CAcA,mBACA,iBACA,CAoFA,iBACA,sBACA,kBACA,QACA,kBACA,mBACA,kBACA,cACA,iBACA,YACA,iBACA,gCACA,iBACA,2BACA,gBACA,yBACA,SACA,sCACA,CACA,CACA,iBACA,sBACA,kBACA,QACA,kBACA,+BACA,kBACA,0BACA,iBACA,wBACA,iBACA,+BACA,iBACA,0BACA,gBACA,wBACA,SACA,sCACA,CACA,CACA,QACA,WAOA,QASA,SA1GA,YACA,WACA,EAyGA,SAxGA,YACA,WACA,EA2GA,YAEA,CACA,UACA,qBACA,0BACA,SACA,QACA,CACA,YACA,cAEA,aACA,QACA,CACA,aACA,aACA,CACA,cACA,QACA,CACA,SAGA,OAFA,SACA,SACA,KAEA,aAGA,OAFA,SACA,SACA,KAEA,QAEA,OADA,SACA,KAEA,QAEA,OADA,SACA,KAEA,kBACA,UACA,OACA,SACA,KACA,QACA,SACA,KACA,SACA,wCACA,CACA,YAEA,gBACA,UACA,OACA,mBACA,EACA,sBAEA,wCACA,CACA,CACA,QACA,0CACA,CACA,QAGA,OAFA,WACA,WACA,IACA,CACA,OAGA,OAFA,YACA,YACA,KAEA,aAGA,OAFA,UACA,UACA,KAEA,gBAGA,OAFA,eACA,eACA,KAEA,qBAGA,OAFA,cACA,cACA,KAEA,OAGA,OAFA,YACA,YACA,KAEA,aAGA,OAFA,UACA,UACA,KAEA,gBAGA,OAFA,eACA,eACA,KAEA,YAGA,OAFA,YACA,YACA,IACA,CACA,kBAGA,OAFA,UACA,UACA,KAEA,UAGA,OAFA,YACA,YACA,KAEA,gBACA,+BACA,CACA,gBACA,sBACA,aAGA,OAFA,0BACA,0BACA,KAEA,OAGA,OAFA,4BACA,4BACA,KAEA,OAGA,OAFA,4BACA,4BACA,IACA,CACA,WAGA,OAFA,0CACA,0CACA,KAEA,iBAGA,OAFA,sCACA,sCACA,KAEA,iBACA,oBACA,wEACA,CACA,QAGA,OAFA,0BACA,0BACA,KAEA,OAGA,OAFA,yBACA,yBACA,KAEA,QAGA,OAFA,0BACA,0BACA,KAEA,cAGA,OAFA,0BACA,0BACA,KAEA,SAGA,OAFA,eACA,eACA,KAEA,OACA,6BAEA,SACA,6BAEA,WACA,mCAEA,SACA,6CACA,CACA,kBACA,wCACA,CACA,YACA,0CACA,CACA,QAEA,OADA,oCAGA,WACA,qDACA,gBAEA,aADA,cACA,MACA,CACA,cACA,2CACA,CACA,qBACA,8BACA,cACA,CACA,uBACA,gDACA,CACA,aACA,yCACA,CACA,UAGA,OAFA,uBACA,uBACA,KAEA,mBAGA,OAFA,uBACA,uBACA,KAEA,UACA,kCAEA,iBAGA,OAFA,YACA,cACA,KAEA,kBAGA,OAFA,YACA,cACA,CACA,CACA,yBAGA,OAFA,iBACA,iBACA,IACA,CACA,kBACA,gCACA,aACA,aAGA,OAFA,mBACA,mBACA,KAEA,SAGA,OAFA,qBACA,qBACA,KAEA,qBACA,aACA,aAEA,CACA,SACA,+BACA,0BACA,eACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,CACA,YACA,2BAEA,CACA,uBACA,oBAUA,OATA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,KAEA,WAYA,OAXA,SACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEA,KAEA,QACA,oBACA,aAUA,OATA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,KAEA,oBAIA,OAHA,+BACA,+BACA,+BACA,KAEA,kBACA,iBAYA,OAXA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,OAEA,IACA,CACA,YACA,oCACA,CACA,eACA,oCACA,CACA,sBACA,iBACA,aACA,gBACA,qBACA,qBACA,qBACA,qBACA,qBACA,qBAUA,OATA,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,KAEA,kBACA,oBAUA,OATA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,KAEA,cACA,oBACA,+DACA,0CACA,CACA,SACA,+HACA,4CACA,UAUA,OATA,SACA,iBACA,iBACA,SACA,iBACA,iBACA,SACA,iBACA,iBACA,KAEA,YAEA,IADA,EACA,gBAUA,OATA,OACA,UACA,OACA,OACA,UACA,OACA,OACA,UACA,OACA,KAEA,mBACA,kDACA,CACA,sBACA,oBAUA,OATA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,KAEA,8BACA,kBACA,cAYA,OAXA,SACA,IACA,IACA,iBACA,KACA,IACA,kBACA,EACA,EACA,GAEA,KAGA,WAEA,OADA,oCACA,KAEA,UAEA,OADA,sCACA,KAEA,eAEA,OADA,0CACA,KAGA,qBA0BA,OAzBA,YACA,SACA,EACA,EACA,IACA,EACA,EACA,IACA,EACA,EACA,GAGA,SACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAGA,KAEA,gBACA,kBACA,cAYA,OAXA,SACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEA,KAEA,eAYA,OAXA,SACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEA,KAGA,UACA,oBACA,aACA,YAAoB,IAAO,IAC3B,wBAEA,QACA,CACA,iBACA,YAAoB,IAAO,IAC3B,wBAEA,YAEA,kBACA,oBAUA,OATA,UACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,CACA,CACA,QACA,sDACA,CACA,CACA,cACA,eACA,qBAAiC,KAAQ,IACzC,wBAEA,QACA,CACA,eACA,iEACA,CAMA,UACA,eACA,UACA,SACA,gBACA,CAoCA,QACA,WACA,qBAmBA,SAAY,CACZ,8BACA,iCAGA,+BACA,YACA,YACA,aAEA,sDACA,qCACA,wCAEA,+BACA,YACA,YACA,cAdA,CAiBA,CAAG,CACH,oCACA,+CACA,CAAG,CACH,kCACA,+CACA,CAAG,CACH,yBACA,gCACG,CACH,8BACA,UACA,wBACG,CACH,8DACA,wDACA,CAAG,CACH,mBACA,4BACA,CAAG,CAEH,2BACA,oEACA,CAAG,CACH,wCACA,qEACG,CACH,wDACA,+DAEA,EACA,eACA,qEACA,CACA,eACA,uDACA,CACA,+BACA,uBACA,gBACA,gBACA,SACA,SACA,SACA,QACA,SACA,SACA,SACA,SACA,UAEA,gBACA,UACA,WACA,UACA,UACA,UACA,SACA,SACA,SACA,WAEA,WACA,MACA,aACA,cACA,YACA,SACA,WACA,yBACA,yBAA+B,oBAAkC,CACjE,wBAA8B,2BAC9B,CAAG,CACH,MACA,aACA,cACA,YACA,SACA,WACA,yBACA,wBAA8B,2BAC9B,CACA,CAAC,CAED,UACA,yBAOA,EANA,0BAGA,sCAFA,aAMA,kCACA,QACM,CACN,6BACA,gBACA,kBACA,wBACA,wBACA,sBAEA,oCAEA,GACA,QACA,6BACA,8FACA,8BAEA,wBAEA,CACA,uBACA,0MACA,kBACA,iBACA,kBACA,yBACA,oCACA,2CACA,SACA,YAAsB,WAAiB,IACvC,sBAGA,OADA,sBACA,CACA,CAAM,WAgBN,OADA,4GACA,CAhBM,EACN,sBACA,YAAsB,WAAiB,IACvC,wDACA,kCAEA,cAGA,OACA,OACA,cACA,gBAEA,CAIA,CACA,CACA,QACA,UACA,oBACA,iBACA,iCAAwC,WAAoB,EAC5D,eACA,YACA,kBACA,cACA,CACA,mBACA,sBACA,CACA,UACA,qCACA,oCACA,2BAEA,OACA,eACA,MACA,EACA,YACA,aACA,MACA,qBACA,KACA,uBAAyC,IAAO,IAChD,mBACA,uBAEA,gBAGA,EAAQ,IACR,OAEA,QACA,CAIA,OAHA,GACA,wBAEA,CACA,CACA,CACA,qBACA,sMACA,iBAEA,OACA,CACA,wBACA,cACA,gBACA,+BAGA,4DACA,GAGA,CACA,QACA,qBACA,sDAhqCA,IAgqCA,GAhqCA,IAgqCA,GA3pCA,IA2pCA,GAzpCA,IAypCA,GA1oCA,IA0oCA,GAxpCA,IAwpCA,2BA9kCA,EA8kCA,EACA,QACA,kBACA,iCAAwC,WAAqB,EAC7D,eACA,aACA,sBACA,gBACA,eACA,eACA,aACA,aACA,iBACA,iBACA,kBACA,cACA,yBACA,YACA,wBACA,wBACA,wBACA,gBACA,yBACA,mBACA,wBACA,yBACA,cACA,uBACA,kBACA,iBACA,eACA,mBACA,8BACA,mBACA,CACA,YACA,wBAEA,kBACA,kBACA,CACA,eACA,6HACA,CACA,QACA,wCACA,CACA,QA2BA,OA1BA,iBACA,qBACA,gCACA,uBACA,uBACA,mBACA,mBACA,2BACA,2BACA,6BACA,qBACA,qCACA,iBACA,2BACA,2BACA,2BACA,yBACA,yCACA,2BACA,uCACA,yCACA,mBACA,uCACA,6BACA,qDACA,oBACA,KAEA,UACA,qCACA,sCACA,6BAEA,OACA,UACA,YACA,eACA,0BACA,CAAO,CACP,eACA,eACA,iCACA,qBACA,qBACA,qCACA,qCACA,qCACA,uBACA,6BACA,mBACA,mCACA,eACA,2BACA,yBACA,yBACA,2BACA,iBACA,qCACA,uCACA,sCAMA,OAJA,gEACA,GACA,0BAEA,CACA,CACA,UACA,oBAAyB,eAAiB,CAC1C,CACA,eACA,+BAEA,GADA,4BACA,aACA,mBACA,KA5xCA,IA6xCA,wBACA,KACA,MA9xCA,KA+xCA,cACA,KACA,MAhyCA,KAiyCA,gCACA,uBAEA,uBAGA,CAEA,gBACA,mBACA,KA7yCA,IA8yCA,wBACA,KACA,MA/yCA,KAgzCA,cACA,KACA,MAjzCA,KAkzCA,gCACA,uBAEA,uBAGA,CAKA,OAHA,YACA,YAEA,CACA,CACA,mBACA,SACA,eACA,2BAEA,CACA,wBACA,QACA,mBAEA,CACA,CACA,sBACA,mBAp1CA,IAq1CA,uBACA,UACA,6BACA,0BACA,SACA,SACA,SACA,QACA,CACA,YACA,cAEA,aACA,QACA,CACA,aACA,cAEA,cACA,QACA,CACA,aAKA,OAJA,SACA,SACA,SACA,SACA,KAEA,aAKA,OAJA,SACA,SACA,SACA,SACA,KAEA,QAEA,OADA,SACA,KAEA,QAEA,OADA,SACA,KAEA,QAEA,OADA,SACA,KAEA,QAEA,OADA,SACA,KAEA,kBACA,UACA,OACA,SACA,KACA,QACA,SACA,KACA,QACA,SACA,KACA,QACA,SACA,KACA,SACA,wCACA,CACA,YAEA,gBACA,UACA,OACA,mBACA,EACA,mBACA,EACA,mBACA,EACA,sBAEA,wCACA,CACA,CACA,QACA,wDACA,CACA,QAKA,OAJA,WACA,WACA,WACA,0BACA,KAEA,OAKA,OAJA,YACA,YACA,YACA,YACA,KAEA,aAKA,OAJA,UACA,UACA,UACA,UACA,KAEA,gBAKA,OAJA,eACA,eACA,eACA,eACA,IACA,CACA,qBAKA,OAJA,cACA,cACA,cACA,cACA,KAEA,OAKA,OAJA,YACA,YACA,YACA,YACA,IACA,CACA,aAKA,OAJA,UACA,UACA,UACA,UACA,KAEA,gBAKA,OAJA,eACA,eACA,eACA,eACA,KAEA,YAKA,OAJA,YACA,YACA,YACA,YACA,KAEA,kBAKA,OAJA,UACA,UACA,UACA,UACA,IACA,CACA,gBACA,wCACA,aAKA,OAJA,oCACA,oCACA,qCACA,qCACA,KAEA,UAKA,OAJA,YACA,YACA,YACA,YACA,KAEA,gBACA,+BACA,CACA,8BACA,wBACA,2BAUA,OATA,QACA,SACA,SACA,WAEA,aACA,aACA,cAEA,KAEA,kCAEA,IADA,QACA,6EACA,4DACA,8EAEA,OADA,kBACA,KAEA,UACA,cACA,UACA,UACA,UACA,UACA,UAiCA,OAhCA,SACA,EAdA,KAeA,IACA,aACA,eAGA,IADA,iBAEA,OAEQ,IACR,EAxBA,KAyBA,aACA,IACA,eAGA,IADA,iBAEA,OAGA,EAlCA,KAmCA,aACA,aACA,MAGA,IADA,iBAEA,OAGA,kBACA,KAEA,qDAMA,OALA,wBACA,eACA,eACA,eACA,8BACA,IACA,CACA,yBACA,iBAKA,OAJA,aACA,aACA,aACA,aACA,IACA,CACA,OAKA,OAJA,4BACA,4BACA,4BACA,4BACA,KAEA,OAKA,OAJA,4BACA,4BACA,4BACA,4BACA,KAEA,WAKA,OAJA,0CACA,0CACA,0CACA,0CACA,KAEA,iBAKA,OAJA,sCACA,sCACA,sCACA,sCACA,KAEA,iBACA,oBACA,wEACA,CACA,QAKA,OAJA,0BACA,0BACA,0BACA,0BACA,IACA,CACA,OAKA,OAJA,yBACA,yBACA,yBACA,yBACA,KAEA,QAKA,OAJA,0BACA,0BACA,0BACA,0BACA,KAEA,cAKA,OAJA,0BACA,0BACA,0BACA,0BACA,KAEA,SAKA,OAJA,eACA,eACA,eACA,eACA,KAEA,OACA,mDAEA,WACA,+DAEA,SACA,yEACA,CACA,kBACA,0EACA,CACA,YACA,0CACA,CACA,aACA,yCACA,CACA,UAKA,OAJA,uBACA,uBACA,uBACA,uBACA,KAEA,mBAKA,OAJA,uBACA,uBACA,uBACA,uBACA,KAEA,UACA,8DAEA,iBAKA,OAJA,YACA,cACA,cACA,cACA,IACA,CACA,kBAKA,OAJA,YACA,cACA,cACA,cACA,CACA,CACA,yBAKA,OAJA,iBACA,iBACA,iBACA,iBACA,KAEA,SAKA,OAJA,qBACA,qBACA,qBACA,qBACA,KAEA,qBACA,aACA,aACA,aACA,aAEA,CACA,oBACA,wBAAiD,EACjD,QACA,uBACA,aACA,cACA,aACA,6BACA,oBACA,8BAcA,aAbA,CAAoB,0BAapB,CAZA,iBACA,mBACA,oBACA,UA/tDA,KAguDA,eACA,iBACA,sBACA,wBACA,kBACA,UACA,OACA,CAAK,KACL,0FACA,YACA,oCACA,kCACA,iBACA,cACA,YAAoB,IAAW,IAC/B,2BACA,yCAEA,gCACA,mCACA,6CACA,iDACA,iCACA,uBAEA,cACA,uBACA,CACA,eACA,kBACA,CACA,iBACA,oDACA,aACA,cACA,aACA,mCAAiD,IAAQ,IACzD,+BACA,gCACA,+BAEA,cACA,CACA,2BACA,yBACA,CACA,QACA,wCACA,CACA,QACA,mBACA,qBACA,mBACA,6BACA,+BACA,+BACA,uBACA,gCAAiD,IAAQ,IACzD,uCACA,0CAEA,sBAAkC,kBAQlC,OAPA,8BACA,+BACA,mCACA,6CACA,iDACA,kEACA,uBACA,KAEA,UACA,oBAAyB,eAAiB,CAC1C,CACA,CACA,oBACA,wBAAiD,EACjD,aACA,2BACA,CACA,CACA,oBACA,gCACA,YACA,2BACA,iBAAmB,4BACnB,eAzzDA,KA0zDA,eA1zDA,KA2zDA,WA7zDA,KA8zDA,wBACA,cACA,uBACA,yBACA,CACA,kBACA,wBACA,CACA,oBACA,yBACA,CACA,CACA,oBACA,gCACA,YACA,wBACA,iBAAmB,4BACnB,eA70DA,KA80DA,eA90DA,KA+0DA,WAj1DA,KAk1DA,wBACA,cACA,sBACA,CACA,CACA,SACA,6BACA,qBACA,UACA,UACA,UACA,SACA,CACA,gCACA,wCACA,oCACA,UACA,SACA,SACA,SACA,SACA,MACA,CACA,UACA,SACA,SACA,SACA,SACA,MACA,CACA,+BACA,UACA,sCACA,qBACA,uCACA,kBACA,iBACA,CACA,UAKA,GAJA,UACA,UACA,UACA,UACA,SACA,mCACA,KACA,KACA,KACA,IACA,CACA,CACA,OACA,SACA,SACA,QACA,CACA,4CACA,WACA,SACA,SACA,SACA,OACA,SACA,SACA,SAKA,OAJA,qBACA,uBACA,uBACA,uBACA,CACA,CACA,QACA,eAEA,SACA,UACA,wBACA,CACA,QACA,cACA,CACA,SACA,UACA,wBACA,CACA,QACA,eAEA,SACA,UACA,wBACA,CACA,QACA,eAEA,SACA,UACA,wBACA,CACA,aAMA,OALA,UACA,UACA,UACA,UACA,yBACA,KAEA,QACA,4DACA,CACA,QAMA,OALA,YACA,YACA,YACA,YACA,yBACA,KAEA,qBACA,oCACA,WACA,WACA,SACA,SACA,SACA,SACA,SACA,SACA,UACA,UACA,oBACA,oBACA,oBACA,oBACA,KACA,WACA,oBACA,oBACA,oBACA,oBACA,KACA,WACA,oBACA,oBACA,oBACA,oBACA,KACA,WACA,oBACA,oBACA,oBACA,oBACA,KACA,WACA,oBACA,oBACA,oBACA,oBACA,KACA,WACA,oBACA,oBACA,oBACA,oBACA,KACA,SACA,kFACA,CAEA,MADA,iCACA,KAEA,sBACA,wBAMA,OALA,cACA,cACA,cACA,oBACA,yBACA,KAEA,yBACA,yFACA,QACA,uBACA,eACA,gBACA,gBACA,eACA,EAAM,iBACN,0BACA,iBACA,cACA,gBACA,eACA,EAAM,YACN,0BACA,iBACA,gBACA,cACA,eACA,EAAM,IACN,0BACA,iBACA,gBACA,gBACA,aACA,CAEA,OADA,yBACA,KAEA,wBACA,iBAoBA,OAnBA,kBACA,IACA,6BACA,aACA,YACA,YAGA,UACA,aACA,eAIA,wBACA,wBACA,yBACA,UAEA,gBACA,CACA,WACA,kDACA,CACA,mBACA,sBACA,qBACA,sBAEA,OADA,gBACA,KAEA,WACA,wBACA,CACA,SACA,uBACA,CACA,YAKA,OAJA,YACA,YACA,YACA,yBACA,KAEA,OACA,0DACA,CACA,WACA,uEAEA,SACA,iFACA,CACA,YACA,oBAcA,OAbA,OACA,UACA,UACA,UACA,YAEA,MACA,kBACA,kBACA,kBACA,mBAEA,yBACA,KAEA,YACA,uCACA,CACA,eACA,uCACA,CACA,yBACA,gCACA,4BAMA,OALA,wBACA,wBACA,wBACA,wBACA,yBACA,KAEA,WACA,qBACA,6BACA,4CACA,8BAUA,GATA,KACA,cACA,cACA,cACA,cACA,MAEA,aAEA,KAKA,OAJA,UACA,UACA,UACA,UACA,KAEA,YACA,sBACA,UAMA,OALA,sBACA,sBACA,sBACA,sBACA,iBACA,KAEA,mBACA,kBACA,wCAMA,OALA,sBACA,sBACA,sBACA,sBACA,yBACA,KAEA,wBACA,8BACA,CACA,SACA,8BACA,0BACA,gBACA,iBACA,eACA,gBACA,cACA,cACA,cACA,cAEA,CACA,UACA,sEAEA,iBAMA,OALA,aACA,eACA,eACA,eACA,yBACA,KAEA,kBAKA,OAJA,aACA,eACA,eACA,eACA,CACA,CACA,yBAMA,OALA,kBACA,kBACA,kBACA,kBACA,yBACA,KAEA,SACA,qBACA,CACA,aAEA,OADA,yBACA,KAEA,oBACA,CACA,qBACA,cACA,cACA,cACA,cAEA,CACA,SACA,yBACA,0BACA,SACA,SACA,QACA,CACA,WAKA,OAJA,uBACA,SACA,SACA,SACA,KAEA,aAIA,OAHA,SACA,SACA,SACA,IACA,CACA,QAEA,OADA,SACA,KAEA,QAEA,OADA,SACA,KAEA,QAEA,OADA,SACA,KAEA,kBACA,UACA,OACA,SACA,KACA,QACA,SACA,KACA,QACA,SACA,KACA,SACA,wCACA,CACA,YAEA,gBACA,UACA,OACA,mBACA,EACA,aACA,QACA,sBAEA,wCACA,CACA,CACA,QACA,iDACA,CACA,QAIA,OAHA,WACA,WACA,WACA,KAEA,OAIA,OAHA,YACA,YACA,YACA,KAEA,aAIA,OAHA,UACA,UACA,UACA,KAEA,gBAIA,OAHA,eACA,eACA,eACA,KAEA,qBAIA,OAHA,cACA,cACA,cACA,KAEA,OAIA,OAHA,YACA,YACA,YACA,KAEA,aAIA,OAHA,UACA,UACA,UACA,KAEA,gBAIA,OAHA,eACA,eACA,eACA,KAEA,YAIA,OAHA,YACA,YACA,YACA,KAEA,kBAIA,OAHA,UACA,UACA,UACA,KAEA,qBAIA,OAHA,eACA,eACA,eACA,KAEA,cACA,+CACA,CACA,oBACA,qDACA,CACA,gBACA,+BACA,aAIA,OAHA,4BACA,4BACA,4BACA,KAEA,qBACA,uCACA,CACA,gBACA,+BACA,aACA,kCAIA,OAHA,sCACA,sCACA,uCACA,KAEA,mBACA,+BACA,wBACA,cACA,cACA,cAIA,OAHA,qBACA,qBACA,qBACA,KAEA,WACA,+EACA,CACA,aACA,+EACA,CACA,sBACA,+BACA,aAIA,OAHA,4BACA,4BACA,6BACA,gBACA,CACA,UAIA,OAHA,YACA,YACA,YACA,IACA,CACA,gBACA,+BACA,CACA,OAIA,OAHA,4BACA,4BACA,4BACA,KAEA,OAIA,OAHA,4BACA,4BACA,4BACA,KAEA,WAIA,OAHA,0CACA,0CACA,0CACA,KAEA,iBAIA,OAHA,sCACA,sCACA,sCACA,KAEA,iBACA,oBACA,wEACA,CACA,QAIA,OAHA,0BACA,0BACA,0BACA,IACA,CACA,OAIA,OAHA,yBACA,yBACA,yBACA,KAEA,QAIA,OAHA,0BACA,0BACA,0BACA,KAEA,cAIA,OAHA,0BACA,0BACA,0BACA,KAEA,SAIA,OAHA,eACA,eACA,eACA,KAEA,OACA,wCAGA,WACA,iDAEA,SACA,2DACA,CACA,kBACA,yDACA,CACA,YACA,0CACA,CACA,aACA,yCACA,CACA,UAIA,OAHA,uBACA,uBACA,uBACA,KAEA,mBAIA,OAHA,uBACA,uBACA,uBACA,KAEA,SACA,gCACA,CACA,kBACA,sBACA,kBAIA,OAHA,eACA,eACA,eACA,KAEA,mBACA,mBACA,gCACA,oBACA,qCACA,CACA,kBAEA,OADA,iCACA,YACA,CACA,WACA,yDACA,CACA,WACA,qDACA,gBAEA,aADA,cACA,MACA,CACA,cACA,2CACA,CACA,qBACA,2CACA,kBACA,CACA,uBACA,qEACA,CACA,oBACA,0DACA,CACA,8BACA,oBAIA,OAHA,qBACA,qBACA,qBACA,KAEA,sBACA,0DACA,CACA,gCAIA,OAHA,qBACA,SACA,qBACA,KAEA,yBACA,iBAIA,OAHA,aACA,aACA,aACA,KAEA,sBACA,6CACA,yCACA,yCAIA,OAHA,SACA,SACA,SACA,KAEA,yBACA,qCACA,CACA,0BACA,qCACA,CACA,gBAIA,OAHA,YACA,YACA,YACA,KAEA,gBAIA,OAHA,WACA,WACA,WACA,KAEA,UACA,+CACA,CACA,iBAIA,OAHA,YACA,cACA,cACA,KAEA,kBAIA,OAHA,YACA,cACA,cACA,CACA,CACA,yBAIA,OAHA,iBACA,iBACA,iBACA,KAEA,SAIA,OAHA,qBACA,qBACA,qBACA,KAEA,kBACA,8BACA,oBACA,mBAIA,OAHA,qBACA,SACA,qBACA,KAEA,qBACA,aACA,aACA,aAEA,CACA,cACA,SACA,UACA,4DACA,eACA,WACA,UACA,CACA,SAGA,OAFA,iBACA,iBACA,KAEA,gBACA,iBACA,uBAAuC,IAAQ,KAC/C,sCAEA,YAEA,0BACA,iBACA,sBAA0C,IAAQ,IAClD,gDAEA,YAEA,iBACA,iBACA,uBAAwC,IAAQ,IAChD,yBAEA,YAEA,0BACA,oCAGA,OAFA,wBACA,wBACA,KAEA,sBAEA,OADA,iBACA,wBACA,CACA,QACA,wCACA,CACA,QAGA,OAFA,qBACA,qBACA,KAEA,YAGA,OAFA,qCACA,sCACA,IACA,CACA,UACA,2EAEA,aACA,qFACA,CACA,WACA,kEACA,CACA,iBAGA,OAFA,gBACA,gBACA,KAEA,kBAGA,OAFA,gBACA,gBACA,IACA,CACA,kBAGA,OAFA,uBACA,sBACA,KAEA,uBACA,2BACA,iBACA,eACA,iCACA,8CACA,sBAAqD,IAAO,IAC5D,cACA,0BAEA,4BAEA,+BACA,4BAGA,wBACA,sBACA,uBAEA,yBAEA,sBACA,uBAEA,wBAEA,+BACA,cAEA,CACA,iBACA,uBAAyC,IAAO,IAChD,4BAEA,YAEA,iBACA,4GAEA,eACA,oIAEA,kBACA,aACA,yCACA,yCACA,yCAEA,CACA,iBACA,oIAEA,oBAEA,OADA,6BACA,kDAEA,mBACA,QAsBA,OArBA,cACA,wBACA,0BAEA,wBACA,yBAEA,cACA,yBACA,2BAEA,yBACA,0BAEA,cACA,yBACA,2BAEA,yBACA,0BAEA,+BAEA,sBACA,kBACA,SAEA,mBACA,2BACA,sBACA,sBACA,sBACA,qBACA,qBACA,qBACA,OACA,EACA,MACA,KACA,EACA,MACA,KACA,EACA,MACA,KACA,KACA,EACA,MACA,KACA,EACA,MACA,KACA,EACA,MACA,MACA,KACA,EACA,MACA,KACA,EACA,MACA,KACA,EACA,OACA,sBAIA,IADA,sBACA,eAGA,uBAEA,GADA,mBACA,aACA,CACA,gBACA,yCACA,CACA,mBACA,0CACA,CACA,qBAOA,OANA,eACA,eAEA,yBACA,uCAEA,CACA,CACA,aAIA,OAHA,oBACA,oBACA,iCACA,KAEA,SAGA,OAFA,oBACA,oBACA,IACA,CACA,uBACA,iBACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,4DACA,wBATA,KAYA,aAGA,OAFA,gBACA,gBACA,KAEA,UACA,qDACA,CACA,CACA,QACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,CACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,uBACA,yBAAuC,KAAQ,MAC/C,kBACA,+DACA,YACA,YACA,YACA,gDACA,QAEA,CACA,QACA,CACA,cACA,UACA,SACA,UACA,2BACA,iBACA,cACA,aACA,CACA,SAGA,OAFA,oBACA,cACA,KAEA,mBACA,uBACA,MACA,UAEA,iCAEA,QACA,uBAAwC,IAAQ,IAChD,wCAGA,OADA,yBACA,KAEA,QAGA,OAFA,2BACA,qBACA,KAEA,UACA,oBACA,CACA,YAGA,OAFA,uBACA,eACA,KAEA,iBACA,iEAEA,mBACA,6CAEA,oBACA,2BACA,mDACA,CACA,iBACA,+BACA,CACA,mBACA,6DAEA,gBACA,uCAMA,OALA,UACA,4BACA,+BACA,gDAEA,CACA,CACA,yBACA,eACA,eAGA,+BACA,+BACA,CACA,CACA,gBAGA,OAFA,4BACA,8CACA,KAEA,aAEA,OADA,mBACA,KAEA,iBACA,kBAGA,OAFA,oBACA,cACA,KAEA,6BACA,oBACA,8BACA,mBACA,qBACA,oCACA,cACA,CACA,YAEA,gBACA,cAGA,eACA,aAGA,kCACA,4CAEA,wDACA,8CACA,gDAXA,IAcA,CACA,UACA,4DAEA,QACA,wCACA,CACA,CACA,cACA,UACA,UACA,UACA,UACA,UACA,SACA,UACA,uCACA,cACA,gBACA,CACA,SAGA,OAFA,oBACA,uBACA,KAEA,QAGA,OAFA,2BACA,iCACA,KAEA,QACA,4DACA,CACA,UAEA,OADA,oDACA,KAEA,UAEA,OADA,gCACA,KAEA,yBACA,4BACA,mCACA,IACA,oBAEA,qDACA,CACA,mBACA,2CACA,CACA,qBACA,8DACA,IACA,kCAEA,uDACA,wBACA,CACA,iCAUA,QATA,qCACA,8BACA,6BACA,yBACA,0BACA,yBACA,cACA,gBACA,kBAEA,OAIA,GAHA,QACA,QACA,MACA,KACA,SACA,SACA,UACA,KACA,KACA,+BACA,EAAY,IAGZ,GADA,kBADA,MACA,KACA,mBAKA,GADA,kBADA,OACA,KACA,mBAGA,OAEA,EADA,0BACA,iCACA,oBACU,MACV,IAEA,GADA,+BACA,YAGA,EADA,yBACA,gCACA,yBAIA,WAEA,GADA,yBACA,cAQA,OANA,GACA,sDAEA,GACA,iCAEA,CACA,CACA,qBACA,oCACA,6BACA,iBACA,oBACA,mBACA,qBACA,MACA,aACA,SACA,iBACA,YACA,CACA,oBACA,2DAEA,mBACA,mCACA,gBACA,mCACA,EAEA,KAEA,gDACA,kBACA,CACA,oBACA,qCACA,SACA,KAEA,YACA,CACA,mBACA,8CACA,OAGA,6BACA,IAIA,CACA,kBAEA,IADA,YACA,+DACA,qBACA,MACA,kBACA,oBAEA,kBACA,mBAEA,MACA,kBACA,oBAEA,kBACA,mBAEA,WACA,uBACA,uBACA,MACA,kBACA,oBAEA,kBACA,mBAEA,WACA,mBACA,mBACA,YACA,mBACA,CACA,iBACA,qCACA,CACA,iCAKA,EAJA,mBACA,mBACA,uBACA,6BAEA,QACA,iBACA,GACA,EAAM,cAIN,YAHA,KACA,KAIA,6BACA,mDACA,OACA,YAEA,yCACA,QAGA,MAFA,YAKA,2BACA,IACA,KAEA,cACA,CACA,gBAGA,OAFA,4BACA,qCACA,KAEA,UACA,uEACA,CACA,QACA,wCACA,CACA,CACA,SACA,6CACA,0BACA,eACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,CACA,YACA,yCAEA,CACA,qCACA,oBAiBA,OAhBA,OACA,OACA,OACA,QACA,OACA,OACA,OACA,QACA,OACA,OACA,QACA,QACA,OACA,OACA,QACA,QACA,KAEA,WAmBA,OAlBA,SACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEA,KAEA,QACA,wCACA,CACA,QACA,oBACA,aAiBA,OAhBA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,YACA,YACA,YACA,YACA,YACA,YACA,KAEA,gBACA,iCAIA,OAHA,YACA,YACA,YACA,KAEA,kBACA,iBAmBA,OAlBA,SACA,KACA,KACA,KACA,EACA,KACA,KACA,KACA,EACA,KACA,KACA,KACA,EACA,EACA,EACA,EACA,GAEA,KAEA,oBAIA,OAHA,8BACA,8BACA,8BACA,KAEA,iBAmBA,OAlBA,SACA,IACA,IACA,IACA,EACA,IACA,IACA,IACA,EACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,GAEA,KAEA,mBACA,oBACA,aACA,yCACA,yCACA,yCAiBA,OAhBA,YACA,YACA,YACA,OACA,YACA,YACA,YACA,OACA,YACA,YACA,cACA,QACA,QACA,QACA,QACA,QACA,KAEA,yBACA,oBACA,kBACA,4BACA,4BACA,4BACA,oBACA,2BACA,UACA,UACA,OACA,WACA,WACA,UACA,WACA,WACA,SACA,EAAM,wBACN,2BACA,YACA,WACA,SACA,SACA,SACA,QACA,WACA,WACA,SACA,EAAM,wBACN,2BACA,YACA,UACA,WACA,WACA,SACA,WACA,UACA,OACA,SACA,EAAM,wBACN,2BACA,UACA,WACA,WACA,SACA,WACA,WACA,QACA,SACA,SACA,EAAM,wBACN,2BACA,UACA,WACA,WACA,OACA,SACA,UACA,UACA,WACA,WACA,EAAM,wBACN,2BACA,UACA,QACA,SACA,WACA,SACA,WACA,WACA,SACA,WACA,CAQA,OAPA,OACA,OACA,QACA,QACA,QACA,QACA,QACA,KAEA,8BACA,4BACA,CACA,cACA,oBA2BA,OA1BA,mBACA,mBACA,SAEA,eACA,sBACA,oBACA,kBACA,WAEA,WAEA,eACA,uBAEA,eACA,uBACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,WACA,KAEA,YACA,oCACA,CACA,eACA,oCACA,CACA,sBACA,iBACA,aACA,gBACA,6BACA,6BACA,8BACA,8BACA,6BACA,6BACA,8BACA,8BAiBA,OAhBA,qBACA,qBACA,qBACA,sBACA,qBACA,qBACA,qBACA,sBACA,qBACA,qBACA,sBACA,sBACA,qBACA,qBACA,sBACA,sBACA,KAEA,kBACA,oBAiBA,OAhBA,QACA,QACA,QACA,SACA,QACA,QACA,QACA,SACA,QACA,QACA,SACA,SACA,QACA,QACA,SACA,SACA,KAEA,cACA,oBACA,6BACA,6BACA,8BACA,cACA,wFADA,KACA,uCADA,KACA,sCACA,CACA,YACA,IACA,EADA,gBAoBA,OAlBA,OACA,UACA,OACA,OACA,UACA,OACA,OACA,UACA,OACA,OACA,WACA,QACA,OACA,WACA,QACA,QACA,YACA,QACA,KAEA,mBACA,oBAUA,OATA,aACA,UACA,UACA,YAEA,QACA,QACA,SAEA,KAEA,SACA,kSACA,kBACA,0DACA,UAiBA,OAhBA,SACA,6CACA,6CACA,6CACA,SACA,6CACA,6CACA,6CACA,SACA,6CACA,8CACA,8CACA,UACA,8CACA,8CACA,8CACA,KAEA,SACA,oBACA,kBAaA,OAZA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,SACA,QACA,QACA,SACA,KAEA,oBACA,oBACA,gCAGA,4BAFA,8BACA,iCAEA,CACA,uBAwCA,OAvCA,YACA,SACA,EACA,EACA,EACA,IACA,EACA,EACA,EACA,IACA,EACA,EACA,EACA,IACA,EACA,EACA,EACA,GAGA,SACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAGA,KAEA,iBACA,gCAmBA,OAlBA,SACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEA,KAEA,iBACA,gCAmBA,OAlBA,SACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEA,KAEA,iBACA,gCAmBA,OAlBA,SACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEA,KAEA,sBACA,kBACA,cACA,MACA,kBACA,YAmBA,OAlBA,SACA,MACA,QACA,QACA,EACA,QACA,MACA,QACA,EACA,QACA,QACA,QACA,EACA,EACA,EACA,EACA,GAEA,IACA,CACA,iBAmBA,OAlBA,SACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEA,KAEA,uBAmBA,OAlBA,SACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GAEA,IACA,CACA,eACA,oBACA,4BACA,kBACA,kBACA,kBACA,kBACA,kBAiBA,OAhBA,iBACA,aACA,aACA,OACA,aACA,iBACA,aACA,OACA,aACA,aACA,kBACA,QACA,UACA,UACA,UACA,QACA,KAEA,iBACA,oBACA,kCACA,kCACA,kCAEA,GADA,oBACA,OACA,UACA,UACA,UACA,cACA,UACA,MACA,MAcA,OAbA,kBACA,kBACA,kBACA,kBACA,kBACA,kBACA,kBACA,kBACA,mBACA,4BACA,MACA,MACA,MACA,IACA,CACA,8BAr0HA,GAq0HA,EACA,IAKA,IALA,gBAMA,WACA,eACA,oBACM,GA90HN,OA80HM,EACN,WACA,kBAEA,8EAkBA,OAhBA,KAdA,UAeA,OACA,KAdA,YAeA,QACA,OACA,KAlBA,UAmBA,KAjBA,YAkBA,QACA,OACA,OACA,QACA,QACA,OACA,OACA,SACA,QACA,KAEA,+BAv2HA,GAu2HA,EACA,IAMA,IANA,gBACA,UACA,UACA,UAIA,WACA,UACA,YACM,GAj3HN,OAi3HM,EACN,MACA,YAEA,+EAkBA,OAhBA,SACA,OACA,OACA,OAfA,UAgBA,OACA,SACA,OACA,OAlBA,UAmBA,OACA,OACA,QACA,SACA,OACA,OACA,QACA,QACA,KAEA,UACA,oBACA,aACA,YAAoB,KAAQ,IAC5B,wBAEA,QACA,CACA,iBACA,YAAoB,KAAQ,IAC5B,wBAEA,YAEA,kBACA,oBAiBA,OAhBA,UACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,cACA,cACA,cACA,cACA,cACA,cACA,CACA,CACA,CACA,cACA,UACA,iBACA,iBACA,UACA,UACA,UACA,UACA,SACA,UACA,4CACA,gBACA,UACA,UACA,UACA,aACA,CACA,QACA,cACA,CACA,SACA,UACA,wBACA,CACA,QACA,cACA,CACA,SACA,UACA,wBACA,CACA,QACA,cACA,CACA,SACA,UACA,wBACA,CACA,YACA,kBACA,CACA,aACA,cACA,wBACA,CACA,yBAMA,OALA,UACA,UACA,UACA,cACA,yBACA,KAEA,QACA,gEACA,CACA,QAMA,OALA,aACA,aACA,aACA,qBACA,yBACA,IACA,CACA,4CACA,iBACA,qBACA,qBACA,sBACA,UACA,UACA,8BACA,sBACA,yBACA,2BAEA,wBACA,WAEA,KACA,WACA,+BACA,sBACA,wBACA,0BAEA,yBACA,WAEA,KACA,WACA,8BACA,sBACA,yBACA,2BAEA,UACA,yBAEA,KACA,WACA,+BACA,sBACA,wBACA,0BAEA,UACA,0BAEA,KACA,WACA,8BACA,sBACA,yBACA,2BAEA,UACA,yBAEA,KACA,WACA,+BACA,sBACA,wBACA,0BAEA,yBACA,WAEA,KACA,SACA,sFACA,CAGA,OAFA,cACA,iCACA,KAEA,yBAEA,OADA,iCACA,kCACA,CACA,gCACA,8BACA,CACA,WAEA,OADA,sBACA,4BACA,CACA,UACA,8EAEA,aAMA,OALA,aACA,aACA,aACA,kCACA,yBACA,KAEA,kBAKA,OAJA,aACA,eACA,eACA,mBACA,CACA,CACA,aAEA,OADA,yBACA,KAEA,oBACA,CACA,qBACA,cACA,cACA,cACA,kBAEA,CACA,sBACA,UACA,cACA,WACA,CACA,OACA,kBACA,CACA,UACA,eACA,CACA,YACA,YACA,CACA,UACA,eACA,CACA,WACA,kBACA,CACA,aACA,WACA,CACA,QACA,2BACA,CACA,aACA,yBACA,CACA,CACA,SACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,iBACA,iBACA,iBACA,IAAsB,cACtB,IAAwB,gBACxB,IAA2B,8BAC3B,IAA6B,+BAC7B,qBACA,cACA,QACA,mBACA,iCAAwC,WAAsB,EAC9D,eACA,aACA,qBACA,iBACA,iBACA,8BACA,aACA,SACA,SACA,gBAOA,YANA,WACA,oBACA,GAKA,YAJA,WACA,gCACA,GAGA,8BACA,UACA,gBACA,cACA,OACA,CAAO,CACP,UACA,gBACA,cACA,OACA,CAAO,CACP,YACA,gBACA,cACA,OACA,CAAO,CACP,OACA,gBACA,cACA,OACA,CAAO,CACP,iBACA,YACA,CAAO,CACP,cACA,YACA,CACA,CAAK,EACL,mBACA,wBACA,oDACA,+DACA,+BACA,mBACA,gBACA,mBACA,sBACA,sBACA,mBACA,mBACA,gBACA,CACA,iBACA,CACA,gBACA,CACA,iBACA,CACA,gBACA,CACA,gBACA,2CACA,2BACA,+DACA,CACA,mBAEA,OADA,+BACA,KAEA,8BACA,qCACA,CACA,wBACA,kCACA,CACA,yBACA,wCACA,CACA,6BACA,uBACA,CACA,kBAGA,OAFA,yBACA,6BACA,KAEA,uBAGA,OAFA,yBACA,gCACA,KAEA,WACA,8BACA,CACA,WACA,8BACA,CACA,WACA,8BACA,CACA,qBAGA,OAFA,4CACA,wCACA,KAEA,cACA,iCACA,CACA,cACA,iCACA,CACA,cACA,iCACA,CACA,gBAEA,OADA,8BACA,gCACA,CACA,gBAEA,OADA,8BACA,kDACA,CACA,cACA,YACA,WAEA,cAEA,kBACA,8BACA,2CACA,4BACA,yBAEA,yBAEA,0CACA,IACA,kCACA,6BACA,yCAEA,CACA,OACA,uBACA,YAAsB,mBAAsB,IAC5C,uBAEA,mBAEA,SACA,mFAGA,iBACA,qBACA,cACA,sBACA,oBACA,WACA,uBACA,eAEA,iFAEA,KAEA,UACA,uBACA,YAAsB,mBAAsB,IAC5C,0BAEA,YAEA,+BASA,OARA,SACA,cACA,0BACA,oBACA,WACA,uBACA,eAEA,IACA,CACA,mBACA,kBAIA,OAHA,UACA,eAEA,IACA,CACA,QACA,oCACA,CACA,UAgBA,OAfA,8BACA,mCACA,kBACA,kCACA,mCAEA,mBACA,qBACA,cACA,sBACA,2BACA,oBACA,WACA,uBACA,cACA,KAEA,iBACA,uCACA,CACA,mBACA,yCACA,CACA,yBACA,2BACA,mCAA8C,IAAO,KAErD,MADA,iBACA,yBACA,cACA,QAEA,CAEA,CACA,+BACA,0BACA,oBACA,uBAAyC,IAAO,IAChD,iCAEA,QACA,CACA,oBAEA,OADA,8BACA,yCACA,CACA,sBAGA,OAFA,8BACA,oCACA,CACA,CACA,iBAGA,OAFA,8BACA,oCACA,CACA,CACA,qBACA,8BACA,gCACA,yCACA,CACA,UACA,CACA,YACA,QACA,oBACA,uBAAyC,IAAO,IAChD,gBAEA,CACA,mBACA,4BACA,QACA,oBACA,uBAAyC,IAAO,IAChD,uBAEA,CACA,qBACA,yBACA,IACA,KACA,uBAEA,CACA,eACA,8DACA,8BACA,CACA,qBACA,2CACA,mCACA,kCACA,mBACA,mCAEA,wEAGA,+BACA,MAEA,oBACA,uBAAyC,IAAO,IAChD,KACA,oBAEA,CACA,uBACA,kBAYA,GAXA,kBACA,2BAEA,2CACA,kCACA,mBACA,mCAEA,wEAGA,QACA,oBACA,uBAA2C,IAAO,IAElD,CADA,IACA,wBAEA,CACA,CACA,UACA,qCACA,KACA,IACA,GACA,aAAsB,CACtB,YAAqB,CACrB,WAAoB,CACpB,SAAkB,CAClB,SAAkB,CAClB,YAAqB,CACrB,aAAsB,CACtB,QACA,EACA,YACA,YACA,cACA,2BACA,GAEA,SAwDA,gBAIA,OAHA,oBACA,wBAEA,MACA,CACA,GA7DA,iBACA,iBACA,mCACA,wCACA,8CACA,kCACA,8CACA,uDACA,gEACA,0BACA,+BACA,uBACA,oDACA,uBACA,uBACA,mBACA,8CACA,0EAEA,qBACA,qBACA,qDACA,+BACA,8BACA,sCACA,8BACA,sBACA,+BACA,gCACA,2BACA,2BACA,sCACA,6BACA,sCACA,EAAO,EACP,0CACA,sCACA,oCACA,gDACA,oCACA,kDACA,4EACA,4BACA,mBACA,yCACA,+BACA,EAEA,yBACA,gBACA,gCACA,+BACA,IASA,aACA,kBACA,wBACA,sCACU,2BACV,+CAGA,2FACA,qDAEM,4CACN,yCACA,+BACA,kCACA,eACA,oBACA,uBAA6C,IAAO,KACpD,WACA,aACA,MAEA,aAEA,CACA,CASA,GARA,qBACA,yBACA,uCACA,yBACA,6BACA,gCAGA,uBACA,iCACA,SACA,mCAAkD,IAAO,IACzD,uCAEA,aACA,EAAQ,IACR,wCAGA,2BACA,cACA,YAAsB,uBAA0B,IAChD,kDAEA,CACA,6BACA,gBACA,YAAsB,yBAA4B,KAClD,yBACA,oCACA,CACA,CACA,MACA,sBACA,iBACA,gBACA,cACA,cACA,iBACA,kBACA,YACA,8BACA,4BACA,2BACA,yBACA,yBACA,4BACA,6BACA,uBACA,CAEA,OADA,WACA,EACA,cACA,SACA,gBACA,kBACA,WACA,SACA,CACA,QACA,CACA,CACA,SACA,0CACA,CACA,aAoBA,GAnBA,iBACA,mBACA,+BACA,qCACA,mCACA,yBACA,2BACA,qCACA,yCACA,mDACA,qDACA,+BACA,uBACA,6BACA,mCACA,mCACA,+BACA,qCACA,qDACA,OACA,YAAsB,oBAA4B,KAClD,oBACA,mBACA,CAEA,WACA,CACA,CACA,4BACA,iCACA,uCACA,cACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,SACA,UACA,wCACA,SACA,SACA,QACA,CACA,0BACA,kBACA,mBACA,YACA,0BACA,IACA,iCAEA,YACA,CAGA,+BACA,mBACA,mBACA,mBACA,iBACA,aACA,aACA,aACA,aACA,UACA,SAEA,OADA,aACA,KAEA,UACA,cACA,cACA,uBACA,CACA,qCACA,sCAGA,8BACA,CACA,gDACA,sCACA,MACA,MACA,iBACA,iBACA,OAEA,eACA,0BACA,0BACA,0BACA,EACA,CACA,6CAWA,OAVA,gBACA,gBACA,gBACA,4BACA,4BACA,4BACA,eACA,0BACA,0BACA,0BACA,CACA,CACA,8BAGA,OAFA,mBACA,mBACA,qBACA,CACA,WAIA,OAHA,eACA,eACA,eACA,IACA,CACA,iCAIA,OAHA,kBACA,kBACA,kBACA,KAEA,oCAIA,OAHA,gCACA,gCACA,gCACA,KAEA,QACA,wCACA,CACA,QAIA,OAHA,iBACA,iBACA,iBACA,KAEA,UAGA,OAFA,6BACA,6BACA,wBACA,CACA,eACA,kEACA,CACA,aACA,2CACA,CACA,YACA,oDACA,CACA,kBACA,gDACA,CACA,4BACA,0DACA,CACA,iBACA,+CACA,CACA,iBACA,+CACA,CACA,iBACA,iCACA,CACA,yBACA,IACA,IADA,2BAEA,mBACA,mBACA,mBACA,iBACA,aACA,cACA,iBAEA,mBACA,iBACA,aACA,cACA,iBAEA,cACA,oBAEA,OADA,UACA,gCAEA,mBACA,iBACA,aACA,cACA,iBAEA,cACA,oBAEA,OADA,UACA,gCAEA,cACA,wBAGA,OAFA,mBACA,oBACA,gCAEA,gBAGA,OAFA,MACA,MACA,qDACA,CACA,UACA,iEACA,CACA,CACA,QACA,mBACA,sBACA,WACA,mBACA,eACA,eACA,gBACA,QACA,wBACA,SACA,mBACA,eACA,mBACA,kBACA,mBACA,mBACA,eACA,uBACA,kBACA,iBACA,WACA,aACA,eACA,uBACA,kBACA,gBACA,kBACA,mBACA,oBACA,uBACA,oBACA,oBACA,gBACA,oBACA,qBACA,sBACA,sBACA,sBACA,oBACA,mBACA,kBACA,kBACA,gBACA,gBACA,mBACA,mBACA,qBACA,oBACA,iBACA,mBACA,oBACA,cACA,mBACA,aACA,YACA,qBACA,aACA,kBACA,iBACA,mBACA,eACA,eACA,eACA,kBACA,uBACA,kBACA,sBACA,mBACA,oBACA,mBACA,8BACA,mBACA,mBACA,mBACA,mBACA,qBACA,sBACA,qBACA,uBACA,uBACA,wBACA,qBACA,WACA,kBACA,eACA,iBACA,eACA,yBACA,eACA,sBACA,qBACA,uBACA,wBACA,wBACA,wBACA,yBACA,qBACA,mBACA,mBACA,kBACA,qBACA,SACA,iBACA,cACA,kBACA,gBACA,mBACA,gBACA,uBACA,mBACA,uBACA,uBACA,oBACA,mBACA,cACA,cACA,cACA,oBACA,eACA,sBACA,aACA,mBACA,kBACA,oBACA,gBACA,oBACA,iBACA,kBACA,gBACA,gBACA,gBACA,kBACA,kBACA,kBACA,cACA,kBACA,kBACA,aACA,WACA,iBACA,gBACA,kBACA,gBACA,eACA,eACA,oBACA,gBACA,oBACA,EACA,IAAgB,aAChB,IAAgB,aAChB,yBAGA,CAFA,YACA,YACA,mBACA,OACA,wBACA,CACA,CACA,SACA,mBAKA,OAJA,gBACA,SACA,SACA,SACA,eACA,CACA,WAaA,OAZA,uBACA,KACA,QACA,UAFA,GAGQ,iBAHR,EAIA,YAJA,GAKQ,iBALR,GAMA,cANA,GASA,mBAEA,IACA,CACA,aAIA,OAHA,SACA,SACA,SACA,IACA,CACA,eAMA,OALA,gBACA,uBACA,sBACA,mBACA,+BACA,KAEA,qCAKA,OAJA,SACA,SACA,SACA,+BACA,KAEA,yCA9/JA,EAkgKA,GAHA,EA9/JA,CA8/JA,KA//JA,EA+/JA,EA9/JA,IA+/JA,YACA,YACA,MACA,2BACM,CACN,4BACA,OACA,sBACA,iBACA,oBACA,CAEA,OADA,+BACA,KAEA,qBAOA,EANA,cACA,YACA,iBACA,sEAEA,CAEA,mCAEA,IADA,EACA,OACA,OACA,UACA,UACA,WACA,4EAEA,OADA,QACA,YACA,oCACA,oCACA,oCACA,GAGA,kFAEA,OADA,QACA,YACA,oCACA,oCACA,oCACA,GAGA,KACA,WACA,WACA,kGAEA,OADA,QACA,YACA,qBACA,qBACA,qBACA,GAGA,KACA,SACA,mDACA,CACA,EAAM,sCACN,WACA,WACA,SACA,mBACA,4BACA,4BACA,4BACA,GAEQ,SACR,qCAEA,iDAEA,EAAM,qBACN,8BAEA,YAEA,qBACA,0BAMA,OALA,WACA,iBAEA,8CAEA,KAEA,QACA,iDACA,CACA,QAIA,OAHA,WACA,WACA,WACA,KAEA,oBAIA,OAHA,eACA,eACA,eACA,KAEA,oBAIA,OAHA,eACA,eACA,eACA,KAEA,sBAEA,OADA,4BACA,IACA,CACA,sBAEA,OADA,4BACA,KAEA,aAEA,OADA,0CACA,sGACA,CACA,mBACA,sDACA,CACA,qCAKA,IAJA,0CACA,yBACA,kBACA,kBAEA,UACA,SACA,IACA,QACM,CACN,UAEA,OADA,0BACA,GACA,OACA,kBACA,KACA,QACA,YACA,KACA,QACA,WAEA,CACA,IACA,CAIA,OAHA,MACA,MACA,MACA,CACA,CACA,iCAKA,OAJA,0CACA,SACA,SACA,SACA,CACA,CACA,eACA,0CACA,gCACA,OACA,SAAsB,GAAY,EAAE,cAAc,EAAE,cAAc,EAAE,aAAa,GAEjF,OAAkB,kBAAoB,GAAG,kBAAoB,GAAG,kBAAoB,GAEpF,iBAEA,OADA,gBACA,iCACA,CACA,OAIA,OAHA,YACA,YACA,YACA,KAEA,eAIA,OAHA,eACA,eACA,eACA,KAEA,aAIA,OAHA,UACA,UACA,UACA,KAEA,OAIA,OAHA,8BACA,8BACA,8BACA,KAEA,YAIA,OAHA,YACA,YACA,YACA,KAEA,kBAIA,OAHA,UACA,UACA,UACA,KAEA,UAIA,OAHA,uBACA,uBACA,uBACA,KAEA,kBAIA,OAHA,uBACA,uBACA,uBACA,KAEA,aACA,gBACA,aACA,sBACA,kBACA,kBAEA,OADA,mBACA,KAEA,kBAIA,OAHA,WACA,WACA,WACA,KAEA,gBACA,+BACA,aAIA,OAHA,4BACA,4BACA,4BACA,KAEA,UACA,gDAEA,iBAIA,OAHA,YACA,cACA,cACA,KAEA,kBAIA,OAHA,YACA,cACA,cACA,CACA,CACA,yBAIA,OAHA,iBACA,iBACA,iBACA,KAEA,SACA,oBACA,CACA,qBACA,aACA,aACA,aAEA,CACA,cACA,YACA,QACA,qBACA,kBACA,gBACA,CACA,WACA,6BAEA,YACA,CACA,cACA,QACA,mBACA,iCAAwC,WAAsB,EAC9D,eACA,aACA,cA3/KA,EA4/KA,UAhgLA,EAigLA,qBACA,eACA,oBACA,kBACA,cAn/KA,IAo/KA,cAn/KA,IAo/KA,mBA9/KA,IA+/KA,wBACA,wBACA,6BACA,8BACA,kBACA,eA7+KA,EA8+KA,kBACA,mBACA,0BACA,iBAh4KA,IAi4KA,kBACA,yBACA,iBAp4KA,KAq4KA,kBAr4KA,KAs4KA,kBAt4KA,KAu4KA,qBACA,yBACA,yBACA,oBACA,qBACA,mBACA,oBACA,sBACA,2BACA,0BACA,kBACA,wBACA,2BACA,wBACA,gBACA,mBACA,iBACA,eACA,iBACA,CACA,gBACA,uBAEA,iBACA,wBACA,eAEA,iBACA,CAEA,iBACA,CACA,kBACA,CACA,wBACA,sCACA,CACA,aACA,cACA,gBACA,WACA,eACA,2CAAmD,EAAI,4BACvD,QACA,CACA,cACA,eACA,iCAAyC,EAAI,+BAA+B,UAAU,IACtF,QACA,CACA,aACA,SACQ,+BACR,UAEA,SAEA,CACA,CACA,UACA,oCACA,IACA,IACA,WAAoB,CACpB,SACA,GAEA,OACA,UACA,YACA,gBACA,2BACA,CACA,EA8IA,cACA,SACA,gBACA,kBACA,WACA,SACA,CACA,QACA,CACA,GAtJA,iBACA,iBACA,mCACA,8DACA,sDACA,sDACA,0CACA,kFACA,qEACA,0EACA,0GACA,0EACA,8EACA,8FACA,sDACA,sDACA,iFACA,gDACA,kDAEA,kEACA,oEAEA,6DACA,4DACA,4DAEA,yDACA,4DACA,qEACA,sGACA,oDACA,sDAEA,sEACA,wEAEA,yDACA,iFACA,kDACA,oDAEA,8DACA,0EACA,kFACA,yCACA,wCACA,4CAEA,mCACA,kCACA,sCAEA,uCACA,sCACA,4BAEA,2CACA,0CACA,mCACA,0CAEA,uDACA,sDACA,2CACA,0CAEA,kGACA,kGACA,8FACA,8FACA,kIACA,kHACA,qCACA,oCACA,iDAEA,+EACA,wEACA,+DACA,wEACA,8CACA,gDAEA,+DACA,8GACA,sDACA,kGACA,oHACA,oFACA,uCACA,uDACA,wEACA,8CA9rLA,IA+rLA,8BACA,4CACA,yCACA,0CAhrLA,MAirLA,0CACA,gDA3rLA,MA4rLA,yDACA,gEACA,gEACA,+EACA,kFACA,oDA1qLA,IA2qLA,6CACA,kDACA,qDACA,qDACA,wEACA,yDACA,oDACA,qEAlkLA,OAmkLA,mDAnkLA,OAokLA,sDApkLA,OAqkLA,sDACA,2DACA,sEACA,8CACA,+EACA,4EACA,0EACA,mDACA,gDACA,0CACA,sCACA,+CACA,sCACA,kDACA,wDACA,kDACA,sCACA,0EACA,4EACA,+EACA,0CACA,kCACA,wCACA,0BACA,gEAUA,GACA,oBACA,aACA,4BACA,wBACA,CACA,QACA,CACA,QACA,wCACA,CACA,QACA,iBACA,yBACA,iBACA,iCACA,uBACA,+BACA,yBACA,yBACA,mCACA,mCACA,mCACA,6CACA,mCACA,6BACA,2BACA,2BACA,6BACA,yCACA,+BACA,6BACA,uCACA,+BACA,iCACA,iCACA,iCACA,uBACA,OACA,aACA,eACA,WACA,YAAsB,MAAS,IAC/B,iBAEA,CAmBA,OAlBA,sBACA,yCACA,+BACA,6BACA,6BACA,2BACA,mCACA,+CACA,6CACA,2BACA,2BACA,2BACA,uCACA,6CACA,uCACA,uBACA,6BACA,qDACA,KAEA,UACA,oBAAyB,eAAiB,CAC1C,CACA,mBACA,sBACA,CACA,UACA,qDACA,CACA,CACA,oBACA,kBACA,yBACA,CACA,eACA,QACA,4BACA,4BACA,cACA,mBACA,yBACA,gBACA,sBACA,sBACA,mBACA,iBACA,2BACA,aA/yLA,EAgzLA,oBACA,yBACA,kBACA,0BACA,8BACA,+BACA,YACA,iBACA,CACA,QAoBA,OAnBA,cACA,yBACA,eACA,yBACA,2CACA,mBACA,qCACA,+BACA,yBACA,qBACA,2CACA,uBACA,iCACA,uCACA,2BACA,6CACA,yCACA,2CACA,eACA,KAEA,CACA,cACA,SACA,UACA,sBACA,oBACA,wEAEA,2BACA,aACA,aACA,gBACA,mCACA,kBACA,WAxuLA,MAyuLA,qBACA,aA7zLA,KA8zLA,cACA,CACA,mBACA,CACA,mBACA,sBACA,CACA,YAEA,OADA,aACA,KAEA,oBACA,8BAA6B,UAAc,CAC3C,CACA,oBACA,0BACA,CACA,QAQA,OAPA,iBACA,4CACA,yBACA,mBACA,6BACA,mBACA,uBACA,KAEA,cACA,iBACA,cACA,4BAAuC,IAAO,IAC9C,6BAEA,YAEA,aAEA,OADA,kBACA,KAEA,gBACA,qBACA,yBAAsC,IAAO,IAC7C,+BACA,mBACA,6BAEM,qBACN,yBAAsC,IAAO,IAC7C,+BACA,mBACA,8BAGA,YAEA,gBACA,yBAAoC,IAAO,IAC3C,+BACA,mBACA,8BAEA,YAEA,qBACA,yBAAoC,IAAO,IAC3C,+BACA,wBACA,8BAEA,YAEA,sBACA,yBAAoC,IAAO,IAC3C,+BACA,yBACA,8BAEA,YAEA,WAEA,OADA,oBACA,IACA,CACA,kBACA,oCAEA,OADA,sCACA,CACA,CACA,oBAGA,OAFA,sCACA,gCACA,KAEA,QACA,kCAEA,OADA,sCACA,CACA,CACA,UAGA,OAFA,sCACA,8BACA,KAEA,QACA,oCAEA,OADA,sCACA,CACA,CACA,UAGA,OAFA,sCACA,gCACA,IACA,CACA,QACA,oCAEA,OADA,sCACA,CACA,CACA,UAGA,OAFA,sCACA,gCACA,KAEA,QACA,oCAEA,OADA,sCACA,CACA,CACA,UAGA,OAFA,sCACA,gCACA,KAEA,aAQA,OAPA,iBACA,kBACA,mBACA,oBAEA,kBACA,kBACA,KAEA,gBAUA,OATA,iBACA,kBACA,mBACA,mBACA,oBAEA,kBACA,kBACA,kBACA,KAEA,mBAYA,OAXA,iBACA,kBACA,mBACA,mBACA,mBACA,oBAEA,kBACA,kBACA,kBACA,kBACA,KAEA,YAEA,OADA,wBACA,KAEA,QACA,gEACA,CACA,SACA,OACA,uBACA,iCACA,6BACA,4BAIA,MAFA,mCACA,yCACA,CACA,CACA,CACA,oBACA,mBACA,6BACA,CACA,CACA,oBACA,mBACA,6BACA,CACA,CACA,oBACA,mBACA,8BACA,CACA,CACA,SACA,UACA,UACA,UACA,UACA,UACA,SACA,qBACA,cACA,QACA,yBACA,iCAAwC,WAAgB,EACxD,eACA,aACA,2BACA,gBACA,mBACA,mBACA,wBACA,6BACA,eACA,sBACA,yBACA,gBAAuB,mBACvB,gBACA,CACA,WACA,kBAEA,YAMA,OALA,iBACA,iCAEA,aAEA,KAEA,eAEA,OADA,gBACA,KAEA,cACA,qBAEA,gBACA,0BAEA,kBAEA,OADA,qBACA,KAEA,mBAEA,OADA,0BACA,KAEA,gBACA,mCAEA,kBACA,kBACA,QACA,QACA,eACA,CAAK,CACL,CACA,cACA,eAEA,kBACA,uBACA,sBACA,CACA,gBACA,oCACA,QACA,kBACA,kBAEA,6BACA,eACA,kCACA,uBACA,gBACA,CACA,8BAWA,OAVA,aACA,wBACA,kBAEA,yBACA,0BAEA,4BACA,6BAEA,KAEA,mBAGA,OAFA,iCACA,sBACA,KAEA,WAGA,OAFA,oBACA,sBACA,KAEA,WAGA,OAFA,oBACA,sBACA,KAEA,WAGA,OAFA,oBACA,sBACA,KAEA,iBAGA,OAFA,0BACA,sBACA,IACA,CACA,aAGA,OAFA,oBACA,sBACA,KAEA,UAIA,OAHA,aACA,kBACA,6BACA,KAEA,SAIA,OAHA,0BACA,wCACA,+BACA,IACA,CACA,iBACA,oCACA,eACA,SACA,uBAAyC,IAAO,KAChD,WACA,sBACA,CACA,yCACA,EAAM,IACN,sBAAmD,IAAO,KAC1D,WACA,0BACA,CACA,kBACA,uHAEA,gBACA,CACA,YAEA,qBACA,yBACA,0BAEA,+BACA,gCACA,6BACA,mHACA,qBACA,uBACA,qBAEA,MACA,CACA,cAEA,IADA,2CACA,EACA,uBAA6D,IAAQ,KACrE,WACA,6BACA,2BACA,2CACA,mCACA,2CACA,qCAEA,uCACA,uCAEA,CACA,MAEA,4BAEA,gGACA,yJAEA,CACA,wBACA,4BACA,6BAEA,+BACA,gCACA,6BACA,yHACA,oCACA,MACA,CACA,MACA,iCAEA,GADA,6BACA,EACA,uBAA6D,IAAQ,KACrE,WACA,6BACA,2BACA,6BACA,qBACA,6BACA,uBAEA,yBACA,yBAEA,CAEA,gBACA,QACA,sBAA2C,IAAQ,IACnD,4BACA,sCAEA,KACA,uBAA6D,IAAQ,KACrE,WACA,4BACA,sBAAqD,IAAQ,IAC7D,4BACA,IACA,4BACA,YAEA,qCAEA,CAEA,wCACA,mCACA,kJAEA,CACA,CACA,kBACA,iBACA,kBACA,+EACA,8HAGA,iBACA,WACA,QACA,kCACA,mEAEA,mCACA,UACA,YAAoB,UAA6B,IACjD,YACA,YAEA,4EAuBA,aACA,eACA,KACA,QACA,aACA,EAAO,EAEP,uBAAwC,IAAQ,KAChD,WACA,UACA,UACA,kBAA8C,IAAQ,MACtD,SAlCA,OACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,SACA,SACA,SACA,SACA,0BACA,cACA,wEACA,wEACA,YACA,YACA,YACA,YACA,YACA,YACA,EAcA,YACA,YACA,YAGA,CACA,sBACA,kBACA,cACA,2BACA,UACA,WACA,UACA,8CACA,oBACA,kBAEA,wBADA,SAEA,CACA,uBAAwC,IAAQ,KAChD,WACA,UACA,UACA,kBAA8C,IAAQ,KACtD,eACA,eACA,cAEA,CACA,CACA,uBACA,iBACA,gCACA,eACA,kCACA,cACA,wCACA,mCAEA,sBAAoD,IAAQ,IAC5D,kBAGA,+BACA,2BACA,kBACA,KACA,sBAA0C,IAAQ,MAClD,kBACA,cACA,cACA,2BACA,2BACA,2BACA,kBACA,kBACA,WACA,2BACA,2BACA,2BACA,SACA,SACA,SACA,wBACA,wBACA,uBACA,MAEA,sBAAsD,IAAQ,KAC9D,6BACA,6BACA,6BACA,kBACA,kBACA,WACA,0BACA,0BACA,0BAGA,wBACA,gBACA,CACA,CACA,mBACA,6BACA,sBAAwC,IAAQ,IAChD,4BACA,eACA,0BAEA,CACA,eACA,gBACA,cACA,aACA,eACA,gCACA,QACA,uBAA2C,IAAO,KAElD,EADA,+BACA,4BAEA,OAEA,YAAwB,IAAc,IACtC,cAGA,oBACA,CACA,qBAEA,OADA,4FACA,KAEA,aACA,mBACA,kBACA,gBAEA,QADA,KACA,GACA,mBACA,CACA,2BACA,gBACA,SACA,OACA,uBAAkD,IAAQ,KAE1D,QADA,KACA,GACA,SACA,CACA,sBACA,CACA,iDACA,kBACA,uBAAuC,IAAO,KAC9C,WACA,2CACA,CACA,QACA,CACA,SACA,OACA,UACA,YACA,sBACA,iCACA,CACA,EAKA,GAJA,iBACA,iBACA,mCACA,gEACA,0BACA,sBACA,eACA,2BAEA,QACA,CACA,QAAkB,eAClB,wBACA,GACA,eACA,8BACA,yCACA,GAEA,sBACA,gBACA,WACA,qCACA,CACA,SACA,KACA,mCACA,8BACA,KACA,uBAAkD,IAAQ,KAC1D,WACA,wBACA,CACA,aACA,OACA,KAEA,CACA,IACA,yBACA,uDAEA,iBACA,aACA,8CAEA,0BAOA,OANA,UACA,wBACA,0BACA,gBACA,EAEA,CACA,CACA,QACA,wCACA,CACA,QACA,gBACA,mBACA,wBACA,eACA,sBACA,yBACA,QACA,kBACA,aACA,WACA,0BAEA,mBACA,gBACA,WACA,+BACA,CACA,wBACA,gBACA,SACA,OACA,uBAAiD,IAAO,IACxD,qBAEA,0BACA,CACA,iDACA,eACA,uBAAuC,IAAO,KAC9C,WACA,8CACA,CACA,2BACA,GACA,6BAEA,uBAOA,OANA,UACA,gCAEA,uCACA,uCACA,yBACA,KAEA,UACA,oBAAyB,eAAiB,CAC1C,CACA,CACA,cACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,SACA,qBACA,+BACA,QACA,eACA,iBACA,gBACA,gBACA,yBACA,CACA,UAUA,OATA,gBACA,kCACA,6DAEA,kCACA,4CAAmD,2BAEnD,sEACA,yBACA,KAEA,qBAEA,MADA,cACA,gBACA,iBACA,eACA,cACA,eACA,8BACA,8BACA,uBAAoD,IAAQ,KAC5D,2BACA,mCACA,+BACA,CACA,CACA,CACA,CACA,uBACA,oBACA,wBACA,6BACA,yBACA,2BACA,iCACA,SACA,cACA,uBAAiD,IAAQ,KACzD,WACA,OACA,QACA,4BACA,EACA,yBAEA,gCAEA,CACA,SACA,CACA,QACA,CACA,aACA,oBACA,gBACA,mBACA,cACA,mDACA,0BACA,mBACA,8BACA,mCACA,kCACA,qDAEA,oBACA,gCACA,uBACA,oCADA,GAGA,mCACA,CACA,6BAEA,IADA,EACA,gBACA,gBACA,UACA,wBACA,kBACA,mBACA,sBACA,WACA,cACA,YACA,oBACA,uBAA4C,IAAQ,KACpD,WACA,qBACA,4BACA,8DACA,YAAwC,EAAxC,EAAgD,MAChD,gBAGA,yBAFA,YACA,YACA,IAEA,4BACA,qCACA,UAEA,CACA,KACQ,CACR,0BACA,oCACA,YAAsC,EAAtC,EAA8C,MAC9C,gBAGA,yBAFA,YACA,YACA,IAEA,4BACA,UAEA,CACA,MACM,cACN,oBACA,uBAA4C,IAAQ,KACpD,WACA,qBACA,4BACA,8DACA,YAAwC,EAAxC,EAAgD,KAIhD,uBAHA,EACA,IACA,IACA,IAEA,4BACA,qCACA,UAGA,KACQ,CACR,0BACA,oCACA,YAAsC,EAAtC,EAA8C,KAI9C,uBAHA,EACA,IACA,IACA,IAEA,4BACA,UAGA,CAEA,CACA,CAmBA,iCACA,0BACA,0BACA,0BACA,eAtBA,iBAOA,WAzzNA,IAozNA,OACA,gCAEA,yCAEA,YACA,WACA,+BACA,yCACA,uBACA,CACA,WACA,iBACA,QACA,CACA,EAKA,qBACA,MACA,aACA,+BACA,GACA,qDAEA,GACA,sDAEA,IACA,uDACA,6BACA,6BAGA,OACA,IACA,IACA,IACA,cACA,eACA,EACA,gCACA,SACA,aACA,CACA,QACA,CACA,oBACA,qCACA,QACA,wBACA,iBACA,QACA,SACA,QACA,gBACA,iBACA,eACA,EACA,WACA,gBACA,gBAEA,SACA,KACA,KACA,KACA,IACA,IAWA,kCACA,UACA,MACA,MACA,MACA,MACA,MACA,MACA,IACA,IACA,SACA,YAAuB,IAAa,KACpC,YACA,YAAyB,IAAa,KACtC,WACA,UACA,SACA,OACA,oBACA,OACA,OACA,cACA,oBACA,YACA,cACA,IACA,CACA,CACA,YAAuB,IAAY,IACnC,YAAyB,IAAY,KACrC,cACA,cACA,kBACA,cACA,cACA,cACA,IACA,CAEA,kBACA,KACA,IACA,CApDA,0BAPA,gBAOA,KACA,iCACA,+BACA,iCACA,gCACA,kCACA,iBACA,0CACA,wCACA,mCA4CA,CACA,QAGA,OAFA,cACA,gCAAsC,eACtC,KAEA,mBACA,wFACA,CACA,CACA,eACA,SACA,eAEA,aADA,QACA,MACA,cACA,6GACA,yBACA,mHACA,cAEA,kBAEQ,iBACR,kBAEA,SAEA,CAEA,QACA,CACA,eACA,SACA,YAAkB,WAAsB,KACxC,eACA,eACA,SAEA,CACA,QACA,CAQA,eACA,iCACA,SACA,mBAEA,wBACA,qBAEA,qBAEA,QAAwB,kBAGxB,qBACA,kBACA,sBACA,CACA,eACA,QACA,yBACA,gBACA,iBACA,uBACA,kBAZA,cAAmC,4EAA4E,GAAG,EAalH,oBAZA,cAAqC,6CAA6C,GAAG,EAarF,iBACA,kBACA,0BACA,YACA,eACA,iBACA,wBACA,iBACA,oBAEA,YAEA,EACA,6BACA,cACA,SACA,WAEA,gCACA,2BACA,sBACA,YACA,iBAEA,CACA,QAcA,OAbA,cACA,qCACA,iCACA,6BACA,oBA9DA,YACA,SACA,YAAkB,WAAgB,IAClC,qBAEA,QACA,EAwDA,kBACA,6BAAmC,YACnC,2BACA,6CACA,eACA,qBACA,yBACA,gCAAsC,eACtC,+BACA,KAEA,UACA,sBAGA,aAFA,+BACA,cACA,eAEA,MADA,iBACA,MACA,eACA,eACA,SACA,wBAEQ,aACR,eACA,SACA,gBACA,EACQ,eACR,eACA,UACA,iBACA,EACQ,eACR,eACA,UACA,iBACA,EACQ,eACR,eACA,UACA,iBACA,EACQ,eACR,eACA,UACA,iBACA,EACQ,eACR,eACA,UACA,iBACA,EAEA,eACA,OACA,CAEA,CACA,6DACA,iCACA,qCACA,qBACA,yBACA,SACA,6BACA,mCAGA,OADA,0CACA,CACA,CACA,CACA,oBACA,cACA,QACA,iBACA,mBACA,+BACA,6BACA,oCACA,sBA78NA,GA88NA,CACA,UAMA,OALA,gBACA,mDACA,+CACA,6DACA,yCACA,IACA,CACA,qBACA,0CACA,CACA,qBACA,2BACA,uDACA,CACA,uBACA,6BACA,uDACA,CACA,QACA,wCACA,CACA,CACA,cACA,UACA,SACA,qBACA,iCACA,QACA,4BACA,8BACA,WACA,YACA,YACA,WACA,cACA,cACA,eACA,kBACA,kBACA,6BACA,CACA,UAWA,OAVA,gBACA,eACA,iBACA,iBACA,eACA,mBACA,qBACA,6CAA8D,SAC9D,2BACA,6BACA,KAUA,kBACA,+BACA,4BACA,6BACA,CAIA,iBACA,+BACA,gCACA,CACA,kBACA,sBACA,mCAEA,CACA,eACA,6CACA,CACA,gBACA,6CACA,CAKA,qBACA,4DACA,yCACA,0DACA,wCACA,CAKA,iBAEA,OADA,4BACA,mBACA,CAoCA,2BACA,gBACA,kBACA,YACA,WACA,YACA,aACA,UACA,UACA,QACA,QACA,GAEA,qBACA,sBACA,uBACA,oBACA,oBACA,kBACA,mBACA,6BACA,CACA,kBACA,kBACA,uBAEA,6BACA,CACA,yBACA,gBACA,uCACA,MACA,gBACA,QACA,YACA,wCACA,iCACA,iBACA,iBACA,aACA,aACA,CACA,sBACA,oCACA,oFACA,iEACA,CACA,UACA,sBAUA,OATA,sBACA,wBACA,wBACA,sBACA,0BACA,4BACA,iDAA+D,aAC/D,kCACA,oCACA,CACA,CACA,CAGA,oBACA,mBACA,QACA,uBACA,oBACA,2BACA,yBACA,aATA,IACA,EAQA,IACA,sBACA,YACA,aAZA,IACA,EAWA,IACA,sBACA,YACA,aAfA,IACA,EAcA,IACA,sBACA,YACA,aAlBA,IACA,EAiBA,IACA,sBACA,YACA,aArBA,IACA,EAoBA,IACA,sBACA,YACA,aAxBA,IACA,EAuBA,IACA,sBACA,WACA,CACA,yBACA,4BACA,yBACA,gBACA,8BACA,WACA,gBACA,gBACA,gBACA,iBACA,iBACA,gBACA,gBACA,iBACA,gBACA,gBACA,gBACA,sBACM,YACN,iBACA,iBACA,iBACA,gBACA,gBACA,gBACA,iBACA,iBACA,iBACA,gBACA,iBACA,sBAEA,wFAEA,eACA,YACA,qBAEA,CACA,YACA,6CACA,IAAY,oCAAkC,KAC9C,6CACA,yCACA,+BAEA,+BACA,sBACA,wBACA,2BACA,eACA,gBACA,gCACA,6BACA,yBACA,cACA,yBACA,cACA,yBACA,cACA,yBACA,cACA,yBACA,cACA,4BACA,yBACA,cACA,yBACA,eACA,6BACA,CACA,CACA,oBACA,iCAGA,MAFA,kBACA,eAv2OA,IAw2OA,iBACA,sBACA,aACA,CACA,aACA,kBAEA,cACA,YACA,CACA,CACA,oBACA,oBAAoC,EACpC,aACA,gCACA,OAAoB,yBAEpB,qBADA,cACA,6FACA,sCACA,2EACA,wDAj3OA,IAk3OA,CACA,gCACA,yBACA,qCACA,+CACA,mCACA,mCACA,OACA,UACA,WAAqB,WACrB,CAAO,CACP,aAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAEA,eAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,MAGA,gBACA,UACA,2BACA,wBACA,4BACA,gCACA,KA5+OA,EA6+OA,SA3+OA,CA4+OA,CAAK,CACL,8BACA,kBACA,cAOA,OANA,iCAr7OA,IAq7OA,EACA,kBACA,YACA,cACA,qBACA,qBACA,KAEA,eACA,0BACA,YAAoB,IAAO,IAC3B,0BACA,eAEA,oBACA,CACA,CACA,cACA,UACA,SACA,UACA,iCACA,gBACA,cACA,eACA,CACA,SAGA,OAFA,oBACA,gBACA,KAEA,uBAGA,OAFA,uBACA,gBACA,KAEA,mCAGA,OAFA,oBACA,kCACA,KAEA,6BACA,+DAEA,OADA,wCACA,KAEA,QAGA,OAFA,2BACA,yBACA,KAEA,YACA,6BAGA,OAFA,8BACA,iBACA,KAEA,SAGA,OAFA,kBACA,qBACA,KAEA,mBACA,wCAEA,oBACA,+CAEA,kBACA,sEACA,CACA,mBACA,kBACA,qBACA,gBACA,kCACA,gBAEA,KAEA,yDACA,SACA,KAEA,oCACA,CACA,kBACA,oCACA,8BACA,yBACA,CACA,iBACA,8BACA,CACA,oBACA,8BACA,CACA,iBACA,yDACA,CACA,kBACA,+BACA,yCACA,0CAEA,OADA,wBACA,KAEA,aAEA,OADA,kCACA,KAEA,UACA,gEAEA,QACA,wCACA,CACA,CACA,cACA,SACA,UACA,mEACA,0BAEA,iBACA,kBAOA,OANA,aACA,aACA,aACA,aACA,aACA,aACA,IACA,CACA,QACA,kBACA,YAAoB,IAAO,IAC3B,uBAEA,YAEA,4BAp+OA,GAo+OA,EACA,kBACA,aACA,4BACA,4BACA,8BACA,gCAMA,GALA,gDACA,gDACA,gDACA,gDACA,gDACA,QACA,qDACM,YACN,6CAEA,sFAEA,YAEA,oBACA,6BACA,mDACA,0DACM,CACN,wBACA,4CACA,qDACA,CACA,gCACA,CACA,oBAIA,OAHA,qBACA,4BACA,+BACA,yBACA,CACA,oBACA,kBACA,WACA,YACA,YAAoB,IAAO,IAE3B,IADA,uBACA,EACA,SAGA,QACA,CACA,iBACA,kBACA,YAAoB,IAAO,KAC3B,WAIA,GAHA,kCACA,kCACA,kCACA,wBACA,QAEA,CACA,QACA,CACA,iBACA,kBACA,YAAoB,IAAO,IAC3B,6BACA,SAGA,QACA,CACA,QACA,wCACA,CACA,CACA,cACA,WACA,KACA,OACA,OACA,gBACA,OACA,4BACA,CACA,OACA,iBACA,QACA,WACA,6BACA,KACA,CAAK,CACL,gBACA,0BACA,IACA,CAAK,CACL,6BACA,GACA,CAAK,CACL,uBACA,GACA,CACA,CACA,CACA,eACA,kBAmHA,OACA,IAtCA,YAEA,OADA,2CACA,QACA,EAoCA,OAnCA,YACA,2CACA,eACA,IACA,yBACA,YAEA,EA6BA,OA5BA,cAEA,GADA,2CACA,uBACA,cACA,4BACA,SACA,gBACA,YACA,8BACA,kBACS,EAET,MACA,CACA,eACA,cACA,iBAzGA,KACA,IAOA,EAPA,UACA,UACA,eACA,mBAKA,GAJA,kBACA,oBACA,qBAEA,0BACA,eACM,4BAEN,EADA,2BACA,aAEA,sBAEM,2BACN,eACM,4BACN,sBACM,2BACN,aACM,0BACN,cACM,2BACN,uBACM,kCACN,uBAEA,yEAEA,OACA,SACA,OACA,oCACA,kBACA,MACA,CACA,EAkEA,WACM,wBACN,+BACA,sKAEA,SAtEA,OACA,cACA,iBAEA,GADA,kBACA,aACA,2BACM,CACN,+BACA,QACA,YAAsB,WAAyB,KAC/C,WACA,OACA,2BACA,iBACA,QACA,yBAIA,QAEA,CACA,aACA,uBAA+C,IAAO,KACtD,WACA,gBACA,EACA,4BACA,EACA,QACA,QAEA,CACA,qBACA,CACA,oBACA,EAkCA,cACA,mBACA,CACA,CAKA,CACA,CACA,oBACA,6BACA,QACA,0BACA,iBACA,QACA,SACA,gBACA,gBACA,EACA,UACA,MACA,gBACA,gBACA,MACA,MACA,MACA,MACA,KACA,KACA,KACA,KACA,YAAqB,IAAa,KAClC,YACA,YAAuB,IAAa,KACpC,YACA,eACA,cACA,YACA,aACA,CACA,CACA,YAAqB,IAAY,IACjC,YAAuB,IAAY,KACnC,YACA,YACA,cACA,UACA,cACA,aACA,CAEA,iBACA,0CACA,wCACA,mCACA,CACA,QAGA,OAFA,cACA,gCAAsC,eACtC,KAEA,mBACA,gEACA,CACA,CA8IA,QACA,mBA9IA,2FAAoH,UA+IpH,wBA9IA,4DAA0F,+BAA+B,qHAAqH,IAAI,+BAA+B,yDAAyD,IAAI,iDAAiD,sGAAsG,2DAA2D,4GAA4G,iIAAiI,iDAAiD,oEAAoE,kDAAkD,0KAA0K,gGAAgG,4CAA4C,IAAI,UA+I9uC,kBA9IA,8EAAsG,UA+ItG,uBA9IA,kDAA+E,UA+I/E,mBA9IA,kJAA2K,wCAAwC,qDAAqD,mBA+IxQ,wBA9IA,gDAA8E,UA+I9E,eA9IA,6GAAkI,sDAAsD,kFAAkF,mFAAmF,iIAAiI,+GAA+G,mBA+I7kB,oBA9IA,4CAAsE,gCAAgC,UA+ItG,qBA9IA,oHAA+I,oDAAoD,8CAA8C,+CAA+C,mDAAmD,yBAAyB,qBAAqB,qBAAqB,8DAA8D,kEAAkE,kEAAkE,kEAAkE,kCAAkC,IAAI,6CAA6C,qDAAqD,qBAAqB,qBAAqB,wEAAwE,IAAI,6EAA6E,8CAA8C,wDAAwD,qBAAqB,qBAAqB,qBAAqB,oEAAoE,IAAI,UA+IltC,gBA9IA,gGAAsH,UA+ItH,aA9IA,qCAAwD,sDAAsD,UA+I9G,mBA9IA,oCAA6D,gEAAgE,UA+I7H,MA9IA,iCAA6C,eAAe,GAAG,wEAAwE,8EAA8E,GAAG,sJAAsJ,kDAAkD,oDAAoD,qDAAqD,mDAAmD,sCAAsC,8CAA8C,wBAAwB,IAAI,cA+I5qB,qBA9IA,mLAA8M,wCAAwC,mCAAmC,+DAA+D,IAAI,iEAAiE,uGAAuG,IAAI,mEAAmE,sFAAsF,IAAI,kDAAkD,0CAA0C,0DAA0D,0DAA0D,0DAA0D,wGAAwG,uIAAuI,qBAAqB,mCAAmC,eAAe,IAAI,gHAAgH,WAAW,+FAA+F,0FAA0F,0CAA0C,8BAA8B,wBAAwB,KAAK,0CAA0C,2DAA2D,gDAAgD,2BAA2B,sBAAsB,kDAAkD,6BAA6B,mEAAmE,mDAAmD,+CAA+C,6BAA6B,yDAAyD,yDAAyD,yDAAyD,qEAAqE,qCAAqC,iDAAiD,6BAA6B,0DAA0D,uBAAuB,WAAW,wBAAwB,qBAAqB,QAAQ,QAAQ,gBAAgB,2EAA2E,kBAAkB,KAAK,iCAAiC,IAAI,UA+I5uF,sBA9IA,gDAA4E,2BAA2B,qBAAqB,oCAAoC,oCAAoC,+DAA+D,6EAA6E,6EAA6E,4BAA4B,IAAI,4FAA4F,qDAAqD,qDAAqD,wBAAwB,mCAAmC,mCAAmC,oDAAoD,gEAAgE,wDAAwD,IAAI,UA+Ij5B,yBA9IA,0CAAyE,uEAAuE,4BAA4B,kDAAkD,2BAA2B,QAAQ,iCAAiC,mEAAmE,wDAAwD,wFAAwF,uCAAuC,KAAK,gHAAgH,wEAAwE,yBAAyB,QAAQ,kCAAkC,oEAAoE,yDAAyD,oGAAoG,MAAM,uEAAuE,4CAA4C,yCAAyC,0DAA0D,2BAA2B,QAAQ,iCAAiC,8DAA8D,KAAK,uGAAuG,wEAAwE,yBAAyB,QAAQ,kCAAkC,yEAAyE,MAAM,wDAAwD,6BA+IztD,8BA9IA,0DAA8F,sDAAsD,UA+IpJ,4BA9IA,0DAA4F,UA+I5F,uBA9IA,gEAA6F,UA+I7F,eA9IA,yDAA8E,0DAA0D,UA+IxI,oBA9IA,sDAAgF,mDAAmD,UA+InI,kBA9IA,sDAA8E,uHAAuH,UA+IrM,aA9IA,uDAA0E,wHAAwH,6CAA6C,wEAAwE,6GAA6G,mCAAmC,UA+Ivc,OA9IA,2WAAwX,aAAa,iCAAiC,aAAa,mCAAmC,eAAe,mCAAmC,gBAAgB,eAAe,kCAAkC,qCAAqC,qCAAqC,qCAAqC,wCAAwC,6DAA6D,kEAAkE,iCAAiC,GAAG,gEAAgE,qBAAqB,+CAA+C,0CAA0C,qDAAqD,IAAI,gCAAgC,cAAc,kBAAkB,gBAAgB,IAAI,yBAAyB,sBAAsB,uBAAuB,wBAAwB,yBAAyB,IAAI,gDAAgD,kEAAkE,yDAAyD,GAAG,iEAAiE,yDAAyD,GAAG,yCAAyC,YAAY,mDAAmD,mDAAmD,mDAAmD,cAAc,GAAG,sCAAsC,+BAA+B,GAAG,kCAAkC,yDAAyD,sEAAsE,uBAAuB,GAAG,mDAAmD,uCAAuC,GAAG,gFAAgF,mEAAmE,qDAAqD,GAAG,kFAAkF,mEAAmE,qDAAqD,IAAI,cA+I5jF,4BA9IA,kIAAoK,yCAAyC,uBAAuB,4CAA4C,sFAAsF,oDAAoD,MAAM,MAAM,sFAAsF,oDAAoD,KAAK,gBAAgB,IAAI,6CAA6C,YAAY,wBAAwB,gEAAgE,MAAM,yBAAyB,oEAAoE,MAAM,yBAAyB,kEAAkE,MAAM,yBAAyB,kEAAkE,MAAM,yBAAyB,kEAAkE,MAAM,MAAM,gEAAgE,KAAK,8BAA8B,IAAI,0EAA0E,sCAAsC,8DAA8D,+CAA+C,oCAAoC,wEAAwE,uBAAuB,sBAAsB,iBAAiB,KAAK,4BAA4B,iDAAiD,wDAAwD,+BAA+B,gCAAgC,oGAAoG,iDAAiD,cAAc,mSAAmS,oBAAoB,mCAAmC,yGAAyG,MAAM,oCAAoC,yGAAyG,MAAM,oCAAoC,yGAAyG,MAAM,oCAAoC,yGAAyG,MAAM,MAAM,+CAA+C,eAAe,IAAI,4EAA4E,gFAAgF,8BAA8B,gCAAgC,8DAA8D,wBAAwB,gCAAgC,MAAM,MAAM,qEAAqE,qDAAqD,KAAK,IAAI,UA+I/2G,qBA9IA,uCAAkE,+DAA+D,iEAAiE,0GAA0G,8CAA8C,sEAAsE,4EAA4E,0GAA0G,8CAA8C,sEAAsE,wEAAwE,8DAA8D,8GAA8G,kEAAkE,mBA+IhgC,4BA9IA,gEAAkG,mCAAmC,kCAAkC,UA+IvK,uBA9IA,uKAAoM,UA+IpM,qBA9IA,wFAAmH,6FAA6F,uDAAuD,UA+IvQ,0BA9IA,wDAAwF,UA+IxF,oBA9IA,oDAA8E,EA+I9E,yBA9IA,2CAA0E,gBAAgB,GAAG,0CAA0C,qLAAqL,GAAG,0CAA0C,sKAAsK,GAAG,EA+IlhB,gBA9IA,8DAAoF,2BAA2B,gHAAgH,MAAM,MAAM,iEAAiE,KAAK,uEAAuE,6FAA6F,sFAAsF,iDAAiD,gJAAgJ,wCAAwC,mJAAmJ,+HAA+H,2GAA2G,mBA+IjpC,4BA9IA,mDAAqF,4BAA4B,+BAA+B,yDAAyD,qCAAqC,sBA+I9O,qBA9IA,gDAA2E,0LAA0L,kCAAkC,kCAAkC,mBA+IzU,mBA9IA,gNAAyO,kCAAkC,kCAAkC,mBA+I7S,8BApIA,oEAAwG,sGAAsG,mFAAmF,mDAAmD,iCAAiC,cAAc,iGAAiG,kFAAkF,+EAA+E,sEAAsE,wFAAwF,8CAA8C,iCAAiC,cAAc,wLAAwL,mFAAmF,+DAA+D,kHAAkH,8DAA8D,mCAAmC,gBAAgB,mBAqI76C,cA/IA,+EAAmG,gCAAgC,2BAA2B,kHAAkH,MAAM,MAAM,sEAAsE,KAAK,kFAAkF,wFAAwF,iFAAiF,6BAgJlmB,WA/IA,6CAA8D,UAgJ9D,gBA/IA,0CAAgE,UAgJhE,aA/IA,sHAAyI,uEAAuE,4EAA4E,UAgJ5R,kBA/IA,wCAAgE,2BAA2B,+CAA+C,kCAAkC,yBAAyB,mBAgJrM,0BA/IA,wDAAwF,0EAA0E,+CAA+C,+CAA+C,8EAA8E,4CAA4C,0FAA0F,YAAY,EAgJhe,uBA/IA,kDAA+E,mCAAmC,UAgJlH,wBA/IA,0BAAwD,2CAA2C,+CAA+C,EAgJlJ,6BA/IA,4BAA+D,0BAA0B,qBAAqB,0BAA0B,IAAI,4QAA4Q,0EAA0E,+CAA+C,sFAAsF,GAAG,2QAA2Q,wFAAwF,GAAG,kGAgJh9B,kBA/IA,4BAAoD,iCAAiC,iEAAiE,iFAAiF,kDAAkD,gDAAgD,sDAAsD,sDAAsD,sDAAsD,0DAA0D,0DAA0D,mEAAmE,0DAA0D,gEAAgE,iBAAiB,GAAG,uFAAuF,sEAAsE,kEAAkE,qBAAqB,GAAG,qEAAqE,uCAAuC,qBAAqB,GAAG,6HAA6H,kFAAkF,gCAAgC,wFAAwF,IAAI,0BAA0B,GAAG,oHAAoH,gEAAgE,GAAG,oDAAoD,mBAAmB,eAAe,KAAK,gEAAgE,wGAAwG,yCAAyC,iDAAiD,yBAAyB,IAAI,wDAAwD,kBAAkB,eAAe,mBAAmB,gBAAgB,KAAK,sDAAsD,sHAAsH,0DAA0D,2CAA2C,4CAA4C,mCAAmC,kGAAkG,mDAAmD,IAAI,sDAAsD,kBAAkB,mBAAmB,eAAe,mBAAmB,gBAAgB,kBAAkB,sBAAsB,KAAK,mDAAmD,mHAAmH,yDAAyD,2CAA2C,iEAAiE,qGAAqG,kCAAkC,6CAA6C,qDAAqD,iGAAiG,oDAAoD,MAAM,MAAM,+BAA+B,2BAA2B,KAAK,IAAI,+DAA+D,eAAe,kBAAkB,mBAAmB,oBAAoB,KAAK,4BAA4B,wBAAwB,gEAAgE,4DAA4D,mBAAmB,kBAAkB,qBAAqB,KAAK,+DAA+D,kGAAkG,qDAAqD,gDAAgD,0FAA0F,sBAAsB,IAAI,UAgJr4I,qBA9IA,uBAAkD,2CAA2C,EA+I7F,0BA9IA,4BAA4D,uBAAuB,qBAAqB,IAAI,sQAAsQ,wGAAwG,sFAAsF,GAAG,qQAAqQ,wFAAwF,GAAG,4FA+In5B,sBA9IA,6BAAyD,2CAA2C,oCAAoC,yCAAyC,+CAA+C,EA+IhO,2BA9IA,4BAA6D,6BAA6B,qBAAqB,sBAAsB,2BAA2B,0BAA0B,IAAI,kRAAkR,0EAA0E,+CAA+C,sFAAsF,2MAA2M,GAAG,iRAAiR,wFAAwF,GAAG,wGA+IztC,yBA9IA,2BAA0D,uEAAuE,yFAAyF,8DAA8D,sDAAsD,wCAAwC,sDAAsD,kCAAkC,4EAA4E,6CAA6C,mHAAmH,2IAA2I,0FAA0F,gDAAgD,2CAA2C,+BAA+B,2MAA2M,0FAA0F,8BAA8B,gEAAgE,oDAAoD,uCAAuC,+BAA+B,iGAAiG,+IAA+I,iEAAiE,yEAAyE,oDAAoD,yEAAyE,mEAAmE,sEAAsE,4CAA4C,yGAAyG,kPAAkP,wEAAwE,uEAAuE,wGAAwG,yEAAyE,sHAAsH,qLAAqL,4EAA4E,+GAA+G,gDAAgD,wDAAwD,qCAAqC,mCAAmC,KAAK,MAAM,uCAAuC,0DAA0D,IAAI,yFAAyF,8EAA8E,8EAA8E,UA+Ix1H,8BA9IA,0BAA8D,qBAAqB,mBAAmB,sBAAsB,qBAAqB,oBAAoB,2CAA2C,6BAA6B,qBAAqB,uBAAuB,wDAAwD,yBAAyB,+BAA+B,4BAA4B,uBAAuB,gDAAgD,yBAAyB,oCAAoC,0DAA0D,4BAA4B,oBAAoB,8BAA8B,0BAA0B,sDAAsD,iBAAiB,qBAAqB,qBAAqB,aAAa,6CAA6C,+CAA+C,yCAAyC,0CAA0C,mFAAmF,+CAA+C,uBAAuB,mDAAmD,qDAAqD,GAAG,mGAAmG,4BAA4B,gEAAgE,gEAAgE,wCAAwC,GAAG,6DAA6D,4BAA4B,oDAAoD,6CAA6C,GAAG,uPAAuP,+EAA+E,+EAA+E,gCAAgC,uBAAuB,IAAI,8IAA8I,+BAA+B,sEAAsE,iCAAiC,uBAAuB,4CAA4C,IAAI,oKAAoK,mCAAmC,sCAAsC,kDAAkD,oCAAoC,mDAAmD,sDAAsD,qDAAqD,qDAAqD,sDAAsD,yCAAyC,2DAA2D,oCAAoC,yBAAyB,IAAI,oIAAoI,oCAAoC,oCAAoC,wCAAwC,mCAAmC,kDAAkD,qDAAqD,oDAAoD,oDAAoD,qDAAqD,wCAAwC,6FAA6F,yFAAyF,uDAAuD,uDAAuD,wDAAwD,uDAAuD,uDAAuD,oHAAoH,+EAA+E,mEAAmE,oCAAoC,iCAAiC,GAAG,6EAA6E,+BAA+B,yDAAyD,yCAAyC,yCAAyC,oDAAoD,kCAAkC,aAAa,GAAG,wDAAwD,yBAAyB,oDAAoD,GAAG,uEAAuE,2BAA2B,sBAAsB,2DAA2D,+CAA+C,mBAAmB,8FAA8F,2CAA2C,GAAG,6HAA6H,+CAA+C,+CAA+C,sCAAsC,0EAA0E,eAAe,yCAAyC,yBAAyB,wDAAwD,oBAAoB,+CAA+C,+CAA+C,+CAA+C,+CAA+C,0CAA0C,0CAA0C,0CAA0C,0CAA0C,uCAAuC,4EAA4E,4EAA4E,4EAA4E,4EAA4E,kEAAkE,yBAAyB,GAAG,6EAA6E,mCAAmC,gCAAgC,+BAA+B,+CAA+C,2EAA2E,GAAG,+CAA+C,wEAAwE,GAAG,0IAA0I,kDAAkD,qDAAqD,oDAAoD,oDAAoD,gDAAgD,uCAAuC,iCAAiC,GAAG,uGAAuG,oDAAoD,oCAAoC,8GAA8G,0GAA0G,6FAA6F,yCAAyC,GAAG,2FAA2F,oDAAoD,yDAAyD,mDAAmD,gCAAgC,qEAAqE,iDAAiD,cAAc,GAAG,0JAA0J,sDAAsD,sDAAsD,GAAG,gTAAgT,2NAA2N,8DAA8D,wFAAwF,oCAAoC,2DAA2D,6BAA6B,yBAAyB,6CAA6C,gDAAgD,2BAA2B,6BAA6B,GAAG,wTAAwT,iCAAiC,mCAAmC,qCAAqC,2CAA2C,6CAA6C,+CAA+C,0CAA0C,yCAAyC,yBAAyB,0DAA0D,oDAAoD,wDAAwD,wDAAwD,mDAAmD,qCAAqC,qCAAqC,2GAA2G,uGAAuG,wHAAwH,4IAA4I,IAAI,sRAAsR,0EAA0E,+CAA+C,6GAA6G,oDAAoD,8IAA8I,uLAAuL,uIAAuI,sFAAsF,GAAG,6QAA6Q,wFAAwF,GAAG,sUAAsU,kNAAkN,qKAAqK,gDAAgD,sCAAsC,8DAA8D,0PAA0P,2KAA2K,sEAAsE,0HAA0H,kEAAkE,iFAAiF,wEAAwE,GAAG,2UAA2U,iHAAiH,GAAG,EA+I7qd,sBA9IA,2CAAuE,+BAA+B,2FAA2F,6CAA6C,mEAAmE,6FAA6F,gDAAgD,+BAA+B,KAAK,MAAM,4DAA4D,IAAI,sCAAsC,iJAAiJ,uFAAuF,IAAI,oCAAoC,+EAA+E,mGAAmG,yDAAyD,sBAAsB,QAAQ,kCAAkC,mEAAmE,mIAAmI,2UAA2U,6IAA6I,IAAI,8GAA8G,kBAAkB,uBAAuB,uBAAuB,gGAAgG,yDAAyD,qBAAqB,QAAQ,gCAAgC,iEAAiE,yeAAye,sFAAsF,sFAAsF,gGAAgG,yKAAyK,0PAA0P,6IAA6I,IAAI,2HAA2H,6GAA6G,yDAAyD,oBAAoB,QAAQ,8CAA8C,6DAA6D,6IAA6I,qSAAqS,6IAA6I,IAAI,oIAAoI,gDAAgD,0BAA0B,QAAQ,wCAAwC,8IAA8I,IAAI,yGAAyG,oEAAoE,0GAA0G,yFAAyF,qBAAqB,QAAQ,yFAAyF,KAAK,+GAA+G,wCAAwC,UA+IthL,qBA9IA,oHAA+I,oEAAoE,qCAAqC,sJAAsJ,iPAAiP,8FAA8F,iJAAiJ,mBA+I92B,oBA9IA,4KAAsM,uNAAuN,UA+I7Z,qBA9IA,mIAA8J,UA+I9J,0BA9IA,8DAA8F,4BAA4B,gCAAgC,UA+I1J,wBA9IA,mDAAiF,gCAAgC,UA+IjH,mBA9IA,2DAAoF,qEAAqE,UA+IzJ,aA9IA,sEAAyF,gGAAgG,gDAAgD,UA+IzO,kBA9IA,wCAAgE,UA+IhE,sBA9IA,mGAA+H,6FAA6F,yEAAyE,8EAA8E,UA+InX,2BA9IA,iDAAkF,wFAAwF,0DAA0D,2DAA2D,UA+I/R,sBA9IA,mCAA+D,6FAA6F,uCAAuC,UA+InM,2BA9IA,0DAA2F,UA+I3F,qBA9IA,iFAA4G,+FAA+F,oBAAoB,wBAAwB,QAAQ,+FAA+F,IAAI,UA+IlW,kBA9IA,qEAA6F,oBAAoB,wBAAwB,QAAQ,qJAAqJ,qJAAqJ,cAAc,UA+Izc,mBA9IA,oEAA6F,oBAAoB,wBAAwB,QAAQ,4HAA4H,IAAI,UA+IjR,wBA9IA,kGAAgI,8DAA8D,uDAAuD,yCAAyC,kGAAkG,wEAAwE,mDAAmD,uDAAuD,oDAAoD,yDAAyD,IAAI,UA+InqB,mBA9IA,mEAA4F,oBAAoB,wBAAwB,QAAQ,2HAA2H,IAAI,UA+I/Q,sBA9IA,oDAAgF,wDAAwD,oCAAoC,gDAAgD,6CAA6C,kDAAkD,kOAAkO,wNAAwN,+FAA+F,4BAA4B,qJAAqJ,0FAA0F,gGAAgG,6BAA6B,oDAAoD,EA+IhxC,qBA9IA,kGAA6H,0CAA0C,mEAAmE,wDAAwD,iHAAiH,0BAA0B,oCAAoC,kHAAkH,UA+InkB,qBA9IA,4CAAuE,+CAA+C,4BAA4B,mBA+IlJ,mBA9IA,4CAAqE,+CAA+C,4BAA4B,mBA+IhJ,cA9IA,gEAAoF,oEAAoE,qEAAqE,mBA+I7N,wBA9IA,oDAAkF,4BAA4B,uEAAuE,2NAA2N,kCAAkC,kCAAkC,6BAA6B,6BAA6B,uBAAuB,iCAAiC,iCAAiC,6CAA6C,6CAA6C,gDAAgD,4DAA4D,2CAA2C,IAAI,UA+I51B,gCA9IA,kEAAwG,UA+IxG,+BA9IA,8HAAmK,4CAA4C,uDAAuD,UA+ItQ,wBA9IA,0DAAwF,gFAAgF,qCAAqC,sFAAsF,UA+InS,0BA9IA,8DAA8F,0FAA0F,UA+IxL,gBA9IA,qCAA2D,gFAAgF,+DAA+D,EA+I1M,QA9IA,+CAA6D,0CAA0C,GAAG,+CAA+C,8BAA8B,GAAG,wCAAwC,0CAA0C,oCAAoC,iCAAiC,oFAAoF,2EAA2E,4FAA4F,6FAA6F,4CAA4C,mDAAmD,mDAAmD,aAAa,6CAA6C,6CAA6C,6CAA6C,uEAAuE,GAAG,2CAA2C,+CAA+C,+CAA+C,aAAa,6CAA6C,6CAA6C,qDAAqD,GAAG,0CAA0C,2CAA2C,2CAA2C,aAAa,oCAAoC,mCAAmC,GAAG,8CAA8C,mCAAmC,GAAG,6CAA6C,mCAAmC,GAAG,4CAA4C,0DAA0D,GAAG,2CAA2C,yEAAyE,iEAAiE,GAAG,6CAA6C,+DAA+D,GAAG,mGAAmG,4CAA4C,GAAG,mGAAmG,wCAAwC,GAAG,kGAAkG,kEAAkE,GAAG,kGAAkG,4DAA4D,GAAG,EA+IvrF,6BA9IA,iEAAoG,UA+IpG,eA9IA,4CAAiE,iEAAiE,2EAA2E,oDAAoD,8CAA8C,EA+I/S,mBA9IA,qEAA8F,UA+I9F,wBA9IA,kDAAgF,kDAAkD,8EAA8E,6FAA6F,oCAAoC,IAAI,UA+IrV,sBA9IA,mCAA+D,6FAA6F,uCAAuC,UA+InM,2BA9IA,0DAA2F,UA+I3F,wBA9IA,uFAAqH,8FAA8F,kIAAkI,kEAAkE,mCAAmC,2BAA2B,sBAAsB,4BAA4B,wBAAwB,wBAAwB,MAAM,oFAAoF,wGAAwG,4BAA4B,2BAA2B,sBAAsB,4BAA4B,wBAAwB,wBAAwB,MAAM,uEAAuE,2GAA2G,8DAA8D,6BAA6B,2BAA2B,sBAAsB,4BAA4B,wBAAwB,wBAAwB,4BAA4B,2BAA2B,MAAM,0EAA0E,gFAAgF,yEAAyE,IAAI,4DAA4D,wDAAwD,IAAI,+DAA+D,0BAA0B,4DAA4D,yDAAyD,8BAA8B,gDAAgD,sEAAsE,kFAAkF,6FAA6F,wEAAwE,KAAK,qBAAqB,IAAI,8IAA8I,uBAAuB,qCAAqC,gCAAgC,kHAAkH,yDAAyD,wBAAwB,uFAAuF,8CAA8C,8CAA8C,8CAA8C,8CAA8C,2BAA2B,2BAA2B,2BAA2B,2BAA2B,y9CAAy9C,8FAA8F,4BAA4B,4BAA4B,8BAA8B,gDAAgD,yBAAyB,g3CAAg3C,2GAA2G,oFAAoF,eAAe,+CAA+C,IAAI,8CAA8C,yBAAyB,mEAAmE,wBAAwB,kDAAkD,uBAAuB,0CAA0C,yCAAyC,gCAAgC,gDAAgD,MAAM,iCAAiC,+BAA+B,0CAA0C,MAAM,iCAAiC,+BAA+B,wCAAwC,kCAAkC,KAAK,8DAA8D,IAAI,kMAAkM,uBAAuB,2CAA2C,gEAAgE,8GAA8G,yGAAyG,iBAAiB,8CAA8C,yEAAyE,6KAA6K,+xBAA+xB,0FAA0F,gBAAgB,+CAA+C,IAAI,UA+Ir4R,sBA9IA,uFAAmH,yDAAyD,gIAAgI,kEAAkE,mCAAmC,2BAA2B,sBAAsB,4BAA4B,wBAAwB,wBAAwB,MAAM,oFAAoF,sEAAsE,2BAA2B,sBAAsB,4BAA4B,wBAAwB,wBAAwB,MAAM,uEAAuE,yGAAyG,8DAA8D,6BAA6B,2BAA2B,sBAAsB,4BAA4B,wBAAwB,wBAAwB,4BAA4B,2BAA2B,MAAM,0EAA0E,mBA+Ih0C,iBA9IA,yNAAgP,4BAA4B,wHAAwH,2BAA2B,QAAQ,wHAAwH,uFAAuF,KAAK,wHAAwH,6BAA6B,QAAQ,kHAAkH,2EAA2E,KAAK,2HAA2H,2BAA2B,QAAQ,wCAAwC,+KAA+K,gFAAgF,IAAI,oCA+In6C,yBA9IA,wBAAuD,sBAAsB,kGAAkG,gDAAgD,2BAA2B,QAAQ,oDAAoD,uOAAuO,IAAI,iGAAiG,gDAAgD,4BAA4B,QAAQ,sCAAsC,4LAA4L,IAAI,oGAAoG,gDAAgD,6BAA6B,QAAQ,wCAAwC,iQAAiQ,IAAI,6DAA6D,GAAG,EA+Il+C,gBA9IA,oEAA0F,gDAAgD,gDAAgD,gDAAgD,UA+I1O,qBA9IA,+CAA0E,kCAAkC,uCAAuC,2CAA2C,+CAA+C,yBAAyB,qBAAqB,qBAAqB,0DAA0D,8DAA8D,8DAA8D,8DAA8D,kCAAkC,IAAI,UA+I1kB,gBA9IA,+EAAqG,8BAA8B,mDAAmD,mDAAmD,mDAAmD,mDAAmD,qDAAqD,UA+IpY,kBA9IA,qDAA6E,yCAAyC,yCAAyC,yCAAyC,yCAAyC,4DAA4D,qEAAqE,6FAA6F,mBA+I/c,qBA9IA,wBAAmD,yFAAyF,sCAAsC,iCAAiC,UA+InN,0BA9IA,wDAAwF,UA+IxF,qBA9IA,kFAA6G,UA+I7G,0BA9IA,yGAAyI,wCAAwC,kDAAkD,GAAG,0CAA0C,gCAAgC,sDAAsD,GAAG,wCAAwC,gCAAgC,6CAA6C,2GAA2G,GAAG,+BAA+B,gDAAgD,wDAAwD,gBAAgB,GAAG,4CAA4C,sJAAsJ,gKAAgK,sCAAsC,gCAAgC,iCAAiC,iCAAiC,4BAA4B,GAAG,uKAAuK,2JAA2J,2CAA2C,mBAAmB,qBAAqB,iIAAiI,GAAG,qCAAqC,sPAAsP,gRAAgR,sCAAsC,gCAAgC,gCAAgC,iDAAiD,kCAAkC,gCAAgC,sBAAsB,0DAA0D,oCAAoC,6CAA6C,mCAAmC,yDAAyD,iDAAiD,oCAAoC,gBAAgB,GAAG,yCAAyC,6CAA6C,mCAAmC,gCAAgC,qDAAqD,qDAAqD,mBAAmB,wDAAwD,+CAA+C,mCAAmC,gEAAgE,2BAA2B,kEAAkE,2CAA2C,GAAG,yCAAyC,eAAe,EA+IphH,sBA9IA,gEAA4F,oCAAoC,kCAAkC,sDAAsD,gDAAgD,6GAA6G,0GAA0G,sCAAsC,8CAA8C,4DAA4D,uTAAuT,wGAAwG,8EAA8E,UA+I5lC,2BA9IA,sDAAuF,2BAA2B,qCAAqC,iCAAiC,mEAAmE,sEAAsE,iDAAiD,4CAA4C,4BAA4B,iCAAiC,+BAA+B,wBAAwB,qEAAqE,IAAI,wBAAwB,gEAAgE,IAAI,uBAAuB,2EAA2E,IAAI,wBAAwB,yCAAyC,IAAI,wBAAwB,6BAA6B,IAAI,wBAAwB,6BAA6B,IAAI,wBAAwB,mDAAmD,IAAI,wBAAwB,iDAAiD,IAAI,sEAAsE,iCAAiC,2BAA2B,2BAA2B,4BAA4B,4BAA4B,4BAA4B,4BAA4B,4BAA4B,4BAA4B,wEAAwE,wEAAwE,wEAAwE,wEAAwE,6LAA6L,IAAI,iEAAiE,+DAA+D,qEAAqE,sCAAsC,sCAAsC,uFAAuF,sFAAsF,iDAAiD,IAAI,+IAA+I,sEAAsE,oBAAoB,0DAA0D,0DAA0D,0DAA0D,kEAAkE,IAAI,8EAA8E,0DAA0D,IAAI,wGAAwG,0FAA0F,uEAAuE,IAAI,sIAAsI,yCAAyC,wBAAwB,MAAM,MAAM,kFAAkF,oFAAoF,qBAAqB,KAAK,IAAI,gbAAgb,0BAA0B,uBAAuB,oFAAoF,iEAAiE,sBAAsB,OAAO,QAAQ,iGAAiG,yDAAyD,gFAAgF,mDAAmD,8BAA8B,8BAA8B,oGAAoG,sDAAsD,iDAAiD,0IAA0I,MAAM,+BAA+B,2GAA2G,wDAAwD,2EAA2E,kDAAkD,6BAA6B,6BAA6B,kFAAkF,0HAA0H,8EAA8E,4EAA4E,8FAA8F,2GAA2G,IAAI,UA+Ij5L,iBA9IA,uEAA8F,+CAA+C,yDAAyD,yDAAyD,mDAAmD,uDAAuD,2DAA2D,+DAA+D,iEAAiE,iEAAiE,mEAAmE,iEAAiE,8EAA8E,oFAAoF,qEAAqE,wFAAwF,oEAAoE,4EAA4E,+DAA+D,0EAA0E,kFAAkF,6EAA6E,mCAAmC,uEAAuE,gCAAgC,UA+I1mD,eA9IA,uEAA4F,qDAAqD,uBAAuB,+DAA+D,4BAA4B,+DAA+D,4BAA4B,yDAAyD,yBAAyB,6DAA6D,2BAA2B,iEAAiE,6BAA6B,6EAA6E,mCAAmC,qEAAqE,+BAA+B,uEAAuE,gCAAgC,uEAAuE,gCAAgC,yEAAyE,iCAAiC,uEAAuE,gCAAgC,oFAAoF,sCAAsC,0FAA0F,yCAAyC,0EAA0E,iCAAiC,kFAAkF,qCAAqC,2EAA2E,kCAAkC,8FAA8F,2CAA2C,qEAAqE,+BAA+B,gFAAgF,oCAAoC,wFAAwF,wCAAwC,6EAA6E,mCAAmC,uEAAuE,gCAAgC,UA+I79E,UA9IA,6EAA6F,4EAA4E,gGAAgG,gGAAgG,oFAAoF,4FAA4F,oGAAoG,4HAA4H,4GAA4G,gHAAgH,gHAAgH,oHAAoH,gHAAgH,0IAA0I,sJAAsJ,wHAAwH,8JAA8J,sHAAsH,sIAAsI,4GAA4G,kIAAkI,kJAAkJ,4HAA4H,gHAAgH,UA+IvsF,gBA9IA,4LAAkN,yEAAyE,oFAAoF,wDAAwD,UA+Iva,gBA9IA,kBAAmC,2BAA2B,eAAe,4CAA4C,+CAA+C,GAAG,EA+I3K,gBA9IA,uBAA0C,oCAAoC,mBAAmB,eAAe,yCAAyC,oOAAoO,gDAAgD,2BAA2B,sEAAsE,EA+I9gB,oBA9IA,8BAA+C,kCAAkC,iEAAiE,uFAAuF,GAAG,EA+I5O,oBA9IA,sDAAyE,kEAAkE,mCAAmC,qCAAqC,oCAAoC,kCAAkC,+BAA+B,uDAAuD,qJAAqJ,+IAA+I,uDAAuD,gDAAgD,2BAA2B,sEAAsE,EA+I31B,UA9IA,8BAA+C,kCAAkC,iEAAiE,uFAAuF,GAAG,EA+I5O,UA9IA,2BAA8C,sBAAsB,wBAAwB,+BAA+B,eAAe,+FAA+F,2BAA2B,6BAA6B,sEAAsE,EA+IvW,WA9IA,uSAAwT,eAAe,2fAA2f,GAAG,EA+Ir0B,WA9IA,mDAAsE,qUAAqU,eAAe,mCAAmC,+FAA+F,gPAAgP,yFAAyF,+EAA+E,2FAA2F,+FAA+F,YAAY,EA+I1nC,kBA9IA,+CAAgE,mPAAmP,yfAAyf,GAAG,EA+I/yB,kBA9IA,kDAAqE,6BAA6B,4BAA4B,8BAA8B,uQAAuQ,mCAAmC,4NAA4N,mEAAmE,2BAA2B,0CAA0C,GAAG,EA+I7yB,cA9IA,8BAA+C,kCAAkC,iEAAiE,yDAAyD,EA+I3M,cA9IA,6BAAgD,+BAA+B,kCAAkC,iDAAiD,2CAA2C,mDAAmD,sEAAsE,EA+ItU,gBA9IA,qBAAsC,+BAA+B,8BAA8B,uOAAuO,wCAAwC,uSAAuS,EA+IzpB,gBA9IA,sBAAyC,wBAAwB,yBAAyB,0BAA0B,8BAA8B,2OAA2O,gDAAgD,4FAA4F,YAAY,IAAI,oCAAoC,4HAA4H,uKAAuK,EA+Ih2B,eA9IA,uUAAwV,8nBAA8nB,EA+It9B,eA9IA,sBAAyC,wBAAwB,6CAA6C,ojBAAojB,gDAAgD,uWAAuW,kFAAkF,4FAA4F,0DAA0D,2FAA2F,uDAAuD,oOAAoO,EA+IvpD,iBA9IA,6CAA8D,ibAAib,ukBAAukB,iHAAiH,EA+IvqC,iBA9IA,uCAA0D,wBAAwB,wBAAwB,00BAA00B,gDAAgD,8IAA8I,yCAAyC,qlBAAqlB,oOAAoO,EA+Ip9D,gBA9IA,4CAA6D,gXAAgX,+lBAA+lB,GAAG,EA+I/gC,gBA9IA,sCAAyD,wBAAwB,2BAA2B,6BAA6B,ieAAie,gDAAgD,+UAA+U,6DAA6D,gCAAgC,sEAAsE,mEAAmE,0EAA0E,oEAAoE,uMAAuM,EA+IpiD,gBA9IA,4IAA6J,8TAA8T,6mBAA6mB,WAAW,EA+InlC,gBA9IA,uCAA0D,6HAA6H,+PAA+P,sDAAsD,iNAAiN,yCAAyC,YAAY,EA+IlvB,eA9IA,2CAA4D,ibAAib,ukBAAukB,iHAAiH,EA+IrqC,eA9IA,qCAAwD,wBAAwB,wBAAwB,0BAA0B,wBAAwB,w0BAAw0B,gDAAgD,8IAA8I,yCAAyC,qpBAAqpB,oOAAoO,EA+IlkE,kBA9IA,8CAA+D,wDAAwD,0ZAA0Z,ukBAAukB,kJAAkJ,WAAW,EA+IrvC,kBA9IA,sGAAyH,wBAAwB,0BAA0B,0BAA0B,wBAAwB,iCAAiC,gEAAgE,8BAA8B,sEAAsE,uFAAuF,kEAAkE,oCAAoC,2DAA2D,6DAA6D,gCAAgC,6CAA6C,6CAA6C,qDAAqD,gCAAgC,gEAAgE,iFAAiF,yEAAyE,+DAA+D,8CAA8C,oiCAAoiC,gDAAgD,8IAA8I,yCAAyC,0rBAA0rB,wFAAwF,gHAAgH,yFAAyF,kGAAkG,gHAAgH,iFAAiF,sJAAsJ,gNAAgN,EA+I5lI,cA9IA,0CAA2D,kZAAkZ,ukBAAukB,sFAAsF,EA+I1mC,cA9IA,oCAAuD,wBAAwB,wBAAwB,8vBAA8vB,gDAAgD,8IAA8I,yCAAyC,gjBAAgjB,uMAAuM,EA+In0D,YA9IA,oBAAqC,sBAAsB,uOAAuO,4BAA4B,uBAAuB,oEAAoE,iNAAiN,8FAA8F,oEAAoE,qIAAqI,EA+Ij5B,YA9IA,sBAAyC,wBAAwB,+RAA+R,gDAAgD,0EAA0E,qMAAqM,uKAAuK,EA+It0B,YA9IA,yOAA0P,scAAsc,EA+IhsB,YA9IA,oBAAuC,wBAAwB,mPAAmP,uGAAuG,gGAAgG,EA+Izf,YA9IA,wBAAyC,sBAAsB,qKAAqK,iEAAiE,uFAAuF,+FAA+F,iDAAiD,sFAAsF,wBAAwB,iGAAiG,iGAAiG,oCAAoC,+CAA+C,+FAA+F,EA+I9+B,YA9IA,sBAAyC,wBAAwB,sTAAsT,gDAAgD,0EAA0E,+LAA+L,6HAA6H,CA+I7yB,EACA,IACA,QACA,SAAe,uBAA4C,CAC3D,SAAe,QAAU,CACzB,KAAW,WAAa,CACxB,cAAoB,aAAsC,CAC1D,UAAgB,WAAa,CAC7B,mBAAyB,aAAsC,CAC/D,WAAiB,QACjB,CAAG,CACH,aACA,aAAmB,WAAa,CAChC,sBAA4B,aAC5B,CAAG,CACH,QACA,QAAc,WAAa,CAC3B,gBAAsB,aAAsC,CAC5D,YAAkB,SAAW,CAC7B,cAAoB,QAAU,CAE9B,KAAW,UAAY,CAEvB,iBAAuB,UAEvB,CAAG,CACH,OACA,OAAa,WAAa,CAC1B,gBAAsB,QAAU,CAChC,gBAAsB,aACtB,CAAG,CACH,UACA,UAAgB,WAAa,CAC7B,mBAAyB,QAAU,CACnC,mBAAyB,aACzB,CAAG,CACH,SACA,SAAe,WAAa,CAC5B,kBAAwB,aAAsC,CAC9D,WAAiB,QACjB,CAAG,CACH,WACA,WAAiB,WAAa,CAC9B,oBAA0B,aAAsC,CAChE,aAAmB,kBACnB,CAAG,CACH,iBACA,iBAAuB,WAAa,CACpC,0BAAgC,aAAsC,CACtE,mBAAyB,QAAU,CACnC,kBAAwB,QACxB,CAAG,CACH,aACA,aAAmB,WAAa,CAChC,sBAA4B,aAC5B,CAAG,CACH,cACA,cAAoB,WAAa,CACjC,uBAA6B,aAC7B,CAAG,CACH,cACA,cAAoB,WAAa,CACjC,uBAA6B,aAC7B,CAAG,CACH,aACA,aAAmB,WACnB,CAAG,CACH,KACA,YAAkB,YAAc,CAChC,SAAe,QAAU,CACzB,QAAc,UAAY,CAC1B,UAAgB,uBAChB,CAAG,CACH,QACA,mBAAyB,SAAW,CACpC,YAAkB,SAAW,CAC7B,mBAAyB,qBACzB,YAAmB,CACnB,QACA,EAAO,CACP,yBAA+B,qBAC/B,kBACA,aAAoB,CACpB,mBAA0B,CAC1B,eAAsB,CACtB,gBACA,EAAO,CACP,sBAA4B,SAAW,CACvC,yBAA+B,SAAW,CAC1C,YAAkB,qBAClB,QAAe,CACf,WAAkB,CAClB,YAAmB,CACnB,WAAkB,CAClB,UAAiB,CACjB,cAAqB,CACrB,QACA,EAAO,CACP,kBAAwB,qBACxB,kBACA,aAAoB,CACpB,mBAA0B,CAC1B,eAAsB,CACtB,gBACA,EAAO,CACP,cAAoB,SAAW,CAC/B,eAAqB,SAAW,CAChC,iBAAuB,SAAW,CAClC,aAAmB,qBACnB,QAAe,CACf,WAAkB,CAClB,QAAe,CACf,WACA,EAAO,CACP,mBAAyB,qBACzB,kBACA,aAAoB,CACpB,mBAA0B,CAC1B,eAAsB,CACtB,gBAAuB,CACvB,mBAA0B,CAC1B,kBACA,EAAO,CACP,gBAAsB,SAAW,CACjC,mBAAyB,SAAW,CACpC,kBAAwB,qBACxB,YAAmB,CACnB,WAAkB,CAClB,cACA,EAAO,CAEP,gBAAsB,qBACtB,QAAe,CACf,WAAkB,CAClB,QAAe,CACf,SACA,EAAO,CACP,OAAa,WAAa,CAC1B,OAAa,WACb,CAAG,CACH,QACA,SAAe,uBAA4C,CAC3D,SAAe,QAAU,CACzB,MAAY,QAAU,CACtB,OAAa,QAAU,CACvB,KAAW,WAAa,CACxB,UAAgB,WAAa,CAC7B,mBAAyB,aAAsC,CAC/D,WAAiB,QAAU,CAC3B,aAAmB,aACnB,CAAG,CACH,QACA,SAAe,uBAA4C,CAC3D,SAAe,QAAU,CACzB,QAAc,oBAA8C,CAC5D,UAAgB,QAAU,CAC1B,KAAW,WAAa,CACxB,cAAoB,aAAsC,CAC1D,UAAgB,WAAa,CAC7B,mBAAyB,aAAsC,CAC/D,WAAiB,QACjB,CACA,EACA,IACA,OACA,aACA,UACA,eACA,UACA,SACA,YACA,OACA,EACA,+BACA,iCACG,CACH,SACA,aACA,UACA,eACA,UACA,SACA,YACA,eACA,WACA,aACA,mBACA,OACA,UACA,CACA,UAAoB,gBACpB,EACA,EACA,iCACA,mCACG,CACH,OACA,aACA,UACA,eACA,UACA,SACA,YACA,eACA,WACA,aACA,mBACA,OACA,UACA,CACA,UAAoB,gBAAqC,CACzD,UAAoB,sBAA2C,CAC/D,WAAqB,SACrB,EACA,EACA,+BACA,iCACG,CACH,UACA,aACA,UACA,UACA,SACA,YACA,eACA,WACA,aACA,mBACA,gBACA,gBACA,OACA,UACA,CACA,UAAoB,gBAAqC,CACzD,WAAqB,QAAU,CAC/B,WAAqB,QAAU,CAC/B,iBAA2B,QAC3B,EACA,EACA,kCACA,oCACG,CACH,MACA,aACA,UACA,SACA,YACA,eACA,WACA,aACA,mBACA,eACA,OACA,UACA,CACA,UAAoB,gBACpB,EACA,EACA,8BACA,gCACG,CACH,QACA,aACA,UACA,WACA,aACA,mBACA,OACA,CACA,QAAkB,WAClB,EACA,EACA,gCACA,kCACG,CACH,QACA,aACA,UACA,OACA,EACA,4BACA,8BACG,CACH,QACA,aACA,UACA,OACA,CACA,OAAiB,QAAU,CAC3B,UAAoB,QAAU,CAC9B,WAAqB,QACrB,EACA,EACA,gCACA,kCACG,CACH,OACA,aACA,UACA,mBACA,EACA,2BACA,6BACG,CACH,QACA,aACA,UACA,WACA,aACA,mBACA,CACA,SAAmB,QACnB,EACA,EACA,gCACA,kCACG,CACH,QACA,aACA,UACA,OACA,EACA,4BACA,8BACG,CACH,YACA,UACA,aAAqB,aAAsC,CAC3D,KAAa,WAAa,CAC1B,qBAA6B,QAC7B,CAAK,CACL,gCACA,kCACG,CACH,gBACA,UACA,QAAgB,WAAa,CAC7B,YAAoB,SAAW,CAC/B,sBAA8B,QAAU,CACxC,qBAA6B,QAAU,CACvC,oBAA4B,aAC5B,CAAK,CACL,oCACA,sCACG,CACH,MACA,UACA,OAAe,WAAa,CAC5B,OAAe,SAAW,CAC1B,SAAiB,QACjB,CAAK,CACL,0BACA,4BACG,CACH,UACA,UACA,WAAmB,WACnB,CAAK,CACL,8BACA,gCACG,CACH,cACA,aACA,UACA,mBACA,CACA,mBAA6B,aAAsC,CACnE,cAAwB,QAAU,CAClC,aAAuB,UACvB,EACA,EACA,kCACA,oCACG,CACH,QACA,aACA,UACA,OACA,CACA,OAAiB,gBAAqC,CACtD,SAAmB,QACnB,EACA,EACA,4BACA,8BAEA,EACA,aACA,aACA,qBACA,CACA,WAAmB,QAAU,CAC7B,cAAsB,WAAa,CACnC,uBAA+B,aAAsC,CACrE,oBAA4B,WAAa,CACzC,6BAAqC,aAAsC,CAC3E,sBAA8B,kBAA0C,CACxE,oBAA4B,QAAU,CACtC,uBAA+B,WAAa,CAC5C,gCAAwC,aAAsC,CAC9E,YAAoB,QAAU,CAC9B,aAAqB,QAAU,CAC/B,gBAAwB,WAAa,CACrC,yBAAiC,aAAsC,CACvE,gBAAwB,UAAY,CACpC,6BAAqC,UAAY,CACjD,6BAAqC,UAAY,CACjD,yBAAiC,WAAa,CAC9C,kCAA0C,aAAsC,CAChF,OAAe,QAAU,CACzB,YAAoB,gBAAqC,CACzD,eAAuB,WAAa,CACpC,wBAAgC,aAAsC,CACtE,gBAAwB,QAAU,CAClC,mBAA2B,WAAa,CACxC,4BAAoC,aAAsC,CAC1E,cAAsB,QAAU,CAChC,iBAAyB,WAAa,CACtC,0BAAkC,aAAsC,CACxE,yBAAiC,aAAsC,CACvE,wBAAgC,WAAa,CAC7C,WAAmB,QAAU,CAC7B,cAAsB,WAAa,CACnC,uBAA+B,aAAsC,CACrE,qBAA6B,QAAU,CACvC,kBAA0B,gBAAqC,CAC/D,eAAuB,oBAA2C,CAClE,kBAA0B,WAAa,CACvC,2BAAmC,aAAsC,CACzE,mBAA2B,QAAU,CACrC,sBAA8B,WAAa,CAC3C,+BAAuC,aAAsC,CAC7E,kBAA0B,aAAsC,CAChE,eAAuB,WAAa,CACpC,wBAAgC,aAChC,EACA,EACA,kCACA,qCAEA,QAAe,aACf,UACA,UACA,2BACA,IAEA,EACA,EAHA,YACA,YAGA,OACA,IACA,OACA,cACA,uCAKA,OAJA,gBAEA,MADA,uBACA,aAEA,CACA,CAkHA,gBACA,mBACA,4CACA,CACA,OACA,yBACA,QACA,CAAK,CACL,8BACA,SAEA,IADA,IAEA,CAAK,CACL,yBACA,QACA,CAAK,CACL,0BAEA,IADA,IAEA,CAAK,CACL,OArIA,YACA,SACA,MACA,UACA,OACM,eACN,OACA,MAEA,oCACA,gBACA,oCACM,mBACN,oCAEA,mBACA,4BACA,4BACA,4BACA,8DAEA,EAiHA,gBAhHA,cACA,UACA,sBAjmRA,MAimRA,YACA,aACA,UACA,cACA,QACA,8BACA,wCACA,4CACA,gDACA,KAhqRA,EAiqRA,aACA,cACA,MACA,CAAW,EACX,EACA,mCACA,iCACA,iCACA,4CACA,EACA,2CACA,eACA,kCAEA,CAAS,EACT,aAEA,8BACA,SACA,SACA,SACA,gDACA,SACA,UAEA,mCACA,wFACA,sEACA,oEACA,0FACA,wDACA,4CACA,0BACA,IACA,YACA,iBAEA,qBACA,6CACM,iBACN,aAcA,CAbA,SACA,YACA,QACA,0BACA,oCACA,wCACA,4CACA,KAltRA,EAmtRA,aACA,cACA,MACA,CAAW,EACX,EACA,mCACA,wCACA,eACA,+BAEA,CAAS,EACT,aAEA,gCACA,oEACA,wDACA,yBACA,iBAEA,qDACA,4CACA,0BACA,IACA,YACA,iBAEA,qBACA,4CAEA,CAuBA,CACA,CACA,iBACA,2CACA,KACA,UACA,IACA,KAwBA,cACA,2BACA,CACA,cACA,6BACA,CAoBA,cACA,SACA,KACA,KACA,YAAoB,IAAyB,IAC7C,OACA,OACA,OAEA,OAEA,cACA,aACA,aACA,gBACA,oBACA,oBACA,SACA,aAAoB,CACpB,UACA,CACA,CAmDA,aACA,sBACA,uBAA+C,IAAQ,IACvD,MAEA,CACA,cACA,MACA,CACA,gBACA,sBACA,sBACA,sBACA,OACA,WACA,6BACA,QAEA,WACA,2BACA,OAEA,CACA,aACA,sBACA,sBACA,uBAAmD,IAAQ,IAC3D,cACA,8BACA,OAGA,CACA,0BACA,OACA,kCAEA,kCAEA,CA2IA,aACA,IACA,KACA,OAEA,GADA,KACA,OACA,CACA,aACA,gBACA,eACA,cACA,CACA,OACA,MAvTA,oBACA,SACA,WA2BA,OACA,uBACA,eACA,QACA,KACA,WAEA,mBACA,QACA,KACA,WAEA,WAKA,OAJA,aACA,IAtBA,uBAuBA,QAEA,CACA,EA7CA,OACA,OAEA,GADA,KACA,QAEA,GA+DA,kBACA,mBACA,eACA,IACA,oBACA,eAEA,GADA,KACA,aACA,WACA,OAKA,GAJA,aACA,6DACA,2DAEA,YACA,iBACA,mBAFA,QAGA,IACA,QAEA,qBACA,WAEA,EAtFA,WACA,SAsFA,SACA,SACA,eACA,IACA,oBACA,eAEA,IADA,IACA,aACA,gBACA,QACA,6DACA,2DAEA,QACA,eACA,WACA,gBAEA,OACA,GACA,CAEA,eACA,kBACA,SACA,EA/GA,SACA,UACA,mCAEA,SACA,KACA,SAkJA,SACA,IACA,mBACA,oBACA,2BACA,gBACA,WACA,kBACA,WAKA,GAJA,aACA,6DACA,2DAEA,YACA,mBACA,aACA,WACA,uBACA,eACA,SACA,oBACA,iCA/3RA,OA+3RA,UACA,mCACA,aACA,WACA,WACA,mCACA,YAA8B,iBAAmC,IACjE,kCAEA,uDACA,gDAEA,EAAc,IACd,YAA8B,iBAAmC,IACjE,gBAGA,+BACA,YAA4B,iBAAmC,IAC/D,EACA,aACA,iBACA,EACA,EACA,IACA,yBACA,EAGA,EAAY,IACZ,iCACA,YAA8B,iBAAmC,IACjE,kCAEA,uDACA,gDAEA,EAAc,IACd,YAA8B,iBAAmC,IACjE,gBAGA,+BACA,YAA4B,iBAAmC,IAC/D,EACA,aACA,iBACA,EACA,EACA,IACA,qBACA,EAGA,CACA,EAAU,mBACV,WACA,cACA,iBACA,OACA,gCACA,KACA,QACA,gCACA,KACA,QACA,gCACA,KACA,SACA,+BACA,CAEA,CACA,CACA,CACA,GACA,EAnPA,SACA,UACA,qDAGA,EAqSA,QACA,oBACA,QAxDA,WAEA,aADA,IACA,GACA,WACA,gBACA,WACA,eACA,eACA,mBAEA,KAEA,WACA,CACA,EA2CA,wBA1CA,YACA,2BACA,cACA,gBACA,WACA,eACA,eACA,mBAEA,KAEA,cACA,EA+BA,uBA9BA,YACA,gBACA,WACA,6BACA,cACA,eACA,eACA,mBAEA,QAEA,EAoBA,iBACA,kBACA,yBACA,CACA,CACA,mBACA,MAQA,kBACA,QACA,+BACA,gBACA,CA2BA,aAtCA,YACA,GACA,EAqCA,YApCA,cACA,oBACA,eACA,EAkCA,uBACA,qBA7BA,gBACA,gBAEA,EADA,wBACA,kCACA,QACA,YAAoB,IAAe,IACnC,QAEA,eACA,EAqBA,8BApBA,kBACA,gBACA,gCACA,YACA,YAAsB,WAAmB,IACzC,sBAEM,CACN,iDACA,QACA,YAAsB,IAAe,IACrC,aAEA,eACA,CACA,CAMA,CACA,yBACA,EAyBA,cACA,gBACA,gJACA,cAEA,WACA,OACA,eACA,iJACA,UAGA,MACA,CACA,+CACA,OACA,QACA,2EACA,KAEA,oCACA,uDACA,4CACA,mDACA,qCACA,8CACA,uCACA,+CACA,wCAIA,OACA,YAEA,iBA3DA,WACA,uBACA,iDACA,8CACA,kDACA,EAAM,IACN,IAEA,QACA,EAmDA,kBACA,sBAnDA,mBACA,2EAIA,EA+CA,oBA9CA,YACA,+FAjlSA,OAklSA,oEACA,aAIA,EAwCA,YACA,yBACA,qBACA,cACA,oBACA,iBACA,iBACA,gBACA,oBACA,cACA,oBApBA,+CAqBA,eApBA,IAqBA,WApBA,6BAqBA,CACA,CACA,eACA,WACA,qBACA,qBAA2E,2BAoD3E,oBACA,0BACA,OACA,UAEA,GADA,UACA,kBACA,mCACA,qBACA,wBACA,wBAEA,gBAAwC,MAAe,SACvD,+BACA,sBACA,kBAGA,UACA,gBACA,CAGA,OAFA,cACA,oBACA,CACA,CA1EA,eACA,iBACA,uBACA,wBACA,uBAEA,SAGA,OAFA,IACA,WACA,CACA,EACA,6BACA,KACA,OACA,EACA,2BACA,IACA,EACA,kCACA,UACA,EACA,8BACA,4DACA,WACA,sCAMM,CACN,kBACA,uBACA,WACA,aACA,YAAsB,MAAe,IACrC,UAEA,kBACA,wCACA,iBACA,MAhBA,EACA,SAkBA,cACA,UACA,mBAEA,cACA,oBAPA,CAiCA,CACA,eACA,kBACA,gBAMA,OALA,QACA,UAhvSA,IAivSM,SACN,WAjvSA,GAivSA,EAEA,CACA,CAwBA,cACA,eACA,mCACA,cACA,cACA,YACA,YAEA,CAIA,OACA,IApCA,YACA,mBACA,gBACA,YAtvSA,MAsvSA,EACA,YAEA,SADA,iBACA,eACU,CACV,cACA,qBAOA,WAPA,EACA,uBAIA,OAHA,kCACA,WACA,gCACA,sBACA,CAGA,CAEA,CACA,QACA,EAeA,QALA,WACA,aACA,CAIA,CACA,CACA,oBACA,0CACA,QACA,6BACA,+BACA,YACA,eACA,YACA,aACA,WACA,cACA,YACA,WACA,6BACA,CACA,UAUA,OATA,gBACA,iBACA,mBACA,eACA,qBACA,iBACA,eACA,iBACA,6CAA8D,SAC9D,KAEA,2BACA,kBACA,YACA,WACA,YACA,aACA,UACA,UACA,QACA,QACA,GAEA,qBACA,sBACA,uBACA,oBACA,oBACA,kBACA,mBACA,6BACA,CACA,kBACA,kBACA,uBAEA,6BACA,CACA,yBACA,2CACA,uCACA,2BACA,2BACA,MACA,MACA,MACA,MACA,wCACA,2DACA,wDACA,uBACA,sBACA,uBACA,uBAEA,yFACA,iEACA,CACA,UACA,sBASA,OARA,wBACA,wBACA,0BACA,sBACA,4BACA,wBACA,sBACA,iDAA+D,aAC/D,CACA,CACA,CAEA,sCAEA,UACA,UACA,QACA,KACA,KACA,MACA,sBACA,QACA,IACA,iBACA,gBACA,iBACA,gBACA,iBACA,gBACA,gBACA,eACA,eACA,cACA,OACA,GACA,eACA,iBACA,gCACA,eACA,iBACA,mBACA,kBACA,gBACA,wBACA,2BACA,4BACA,yCACA,CAQA,4BACA,oCACA,sCACA,yCACA,6BACA,6BACA,mBACA,8BAQA,OAPA,iBACA,6BACA,KACA,oBAEA,oBACA,iBACA,CACA,CAOA,8BACA,6BACA,CAOA,sBACA,6BACA,CAKA,uBACA,+BACA,2BACA,6CAEA,CAKA,+BACA,gCACA,4BACA,8CAEA,CAMA,UACA,gBACA,8DACA,+DACA,CAEA,YACA,sCACA,uCACA,CACA,WACA,wDACA,wEACA,YAAoB,yBAA4B,IAChD,4BAEA,CACA,YACA,yCACA,6BACA,iBACA,0BACA,CACA,kBACA,iCACA,8EAEA,+BAEA,oCACA,sCACA,yCACA,6BACA,6BACA,iCAIA,OAHA,2BACA,oBACA,iBACA,CACA,CACA,mBACA,qCACA,mBACA,GACA,UA9/SA,KA+/SA,UA//SA,KAggTA,mBACA,KAv/SA,KAw/SA,OAj/SA,KAk/SA,cACA,cACA,EACA,YACA,uHAuQA,CAtQA,oCACA,gBAEA,qCACA,YAAc,GAAU,KACxB,EAAS,uEAA6E,SAmLtF,GACA,SACA,KACA,KACA,IACA,IA3VA,EA2VA,YACA,YAAkB,IAAe,KACjC,oBACA,UACA,SACA,KAhWA,EAiWA,SAjWA,EAiWA,GACM,OACN,MAEA,UACA,cACA,KACA,MACA,4BAMA,wBACA,uBACA,uBACA,YAAuB,EARvB,EAQyC,KACzC,gBACA,WACA,GACA,EACA,EACA,EACA,MACA,EACA,EACA,MACA,IACA,EACA,EACA,EACA,EACA,MACA,IACA,EACA,EACA,IACA,EACA,CACA,cACA,cACA,oBACA,YACA,CACA,aACA,mCAnCA,IAoCA,6BAnCA,IAoCA,oCAnCA,IAoCA,UACA,EAnZA,GAoZA,GAEA,CACA,iBAAW,sBACX,EArPsF,IACtF,oBAgQA,EAhQA,EAmQA,QACA,6BACA,SACA,EAxaA,GAyaA,qBAvQA,EAwQA,sBAxQA,EAyQA,kBAA2B,EAAO,IAC7B,CACL,UACA,QAAkB,WAAa,CAC/B,SAAmB,QAAU,CAC7B,SAAmB,MAbnB,iBAnaA,GAgbmB,CAAgB,CACnC,aAAuB,SAAc,CACrC,QAAkB,QAAU,CAC5B,QAAkB,QAAU,CAC5B,UAAoB,MAhBpB,aAgBoB,CACpB,CAAK,CACL,kBACA,eAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,qBAAqB,OAAO;;AAE5B;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,IAEA,SA95TA,EA+5TA,aACA,aACA,CAAG,EAvVH,CACA,QACA,CACA,oBACA,mCACA,4BACA,CACA,wBAGA,aAFA,GACA,EACA,KACA,iBACA,mBACA,iBACA,cACA,gBACA,oBACA,cAtjTA,EAujTA,eACA,cACA,wBACA,KAjmTA,EAkmTA,cACA,YACA,CAAK,EACL,mBACA,KACA,eACA,EACA,YACA,gBACA,kBACA,OAGA,iBACA,MAEA,YAAoB,IAAO,KAC3B,SACA,QACA,mBACA,oBACQ,OACR,mBACA,qBAEA,mBACA,oBAEA,qBACA,sBACA,qBACA,GACA,cAEA,aACA,CACA,qBACA,qBACA,gBACA,cACA,cACA,CACA,sBACA,qBACA,EA5lTA,MA4lTA,WA3lTA,MA2lTA,UACA,GACA,8BACA,6BAEA,mFAEA,+BACA,8BAGA,qDACA,8BACA,YACA,eACA,qBACA,kBACA,qBACA,cACA,CACA,eACA,qBACA,aACA,gBACA,6BACA,YAAoB,IAAO,KAC3B,qFACA,wBACA,uBACA,CACA,aACA,CAQA,iBACA,iCACA,eACA,EACA,EACA,EACA,EACA,EACA,cACA,GAEA,eACA,EACA,EACA,EACA,EACA,EACA,eACA,EAEA,CACA,yBACA,qBACA,qBACA,uCACA,cACA,8DAIA,mCACA,aACA,sBACA,yCACA,MACA,2BANA,EAMA,GA/SA,EAgTA,GAhTA,IAiTA,8BAAoC,aAAa,qCAAgD,SAAS,gCAAiD,EAE3J,GAF+I,CAE/I,KACA,IACA,EAJ2J,EAI3J,QAAoB,EArTpB,GAqTqC,KACrC,UACA,mBACA,UACA,MACA,KACQ,KACR,QAEA,CACA,YAAoB,WAAoB,IACxC,WAEA,0BACA,kBACA,kBACA,sCACA,GACA,qBAEA,YAAY,GAAU,KACtB,iBACA,mBACA,wBAEA,uBACA,KAFA,SA/UA,EA+UA,IA/UA,EA+UA,GAEA,WACA,qBACA,cACA,CACA,CAoEA,mBACA,oBAIA,OAHA,kBA5wTA,IA6wTA,8BACA,iBACA,CACA,CACA,uBACA,wBACA,sBACA,CA4FA,cACA,eACA,+BACA,UACA,QAAkB,WAClB,CAAK,CACL,kBACA,eAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,IAEA,SAl8TA,EAm8TA,aACA,aACA,CAAG,CACH,CACA,cACA,eACA,uBACA,UACA,QAAkB,WAAa,CAC/B,YAAsB,SACtB,CAAK,CACL,kBACA,eAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,IAEA,SAn+TA,EAo+TA,aACA,aACA,CAAG,CACH,CACA,cACA,MAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,2BAA2B;AAC3B;;AAEA;;AAEA;;AAEA;;AAEA,+BAA+B;;AAE/B,KAAK;;AAEL;AACA,0BAA0B;;AAE1B,KAAK;;AAEL,yBAAyB;;AAEzB,KAAK;;AAEL;AACA,0BAA0B;;AAE1B,KAAK;;AAEL;AACA,0BAA0B;;AAE1B,KAAK;;AAEL,yBAAyB;;AAEzB;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,GAGA,eACA,kBACA,OA4CA,cACA,eACA,mCACA,cACA,cACA,YACA,YAEA,CAQA,OACA,IA5DA,YACA,mBACA,gBACA,EAz/TA,MAy/TA,WACA,mBACA,SACA,eACA,sCACA,+CAKA,OAJA,wBAEA,CADA,mDACA,oCACA,WACA,WAEA,cACA,iBAEA,qBACA,iCAgBA,GACA,QAEA,YAAoB,EADpB,EACgC,IAChC,mBAEA,OAJA,IAIA,CACA,EAvBA,IACA,wBACA,gDACA,oCACA,WACA,gCACA,WAEA,IAEA,CAEA,CACA,CACA,QACA,EA2BA,QATA,WACA,cACA,WACA,YACA,OAEA,CAIA,CACA,CACA,eACA,SACA,kBAIA,EAHA,iBACA,YAGA,UACA,0BACA,iIACA,KACA,sCACA,kKACA,KACA,qCACA,+JACA,KACA,sCACA,4GACA,KACA,SACA,mBACA,CAEA,OADA,OACA,CACA,CACA,OACA,gBACA,kBACA,CAAK,CACL,gBACA,4BACA,8BACA,8BACA,iCACA,0CACA,iCACA,CAAK,CACL,gBACA,WAIA,OAHA,UACA,0DAEA,CACA,CACA,CACA,CACA,qBACA,SACA,cACA,cACA,eAIA,aAHA,gBACA,kBAEA,aACA,0BAEA,gCACA,2BACA,uBAAwC,IAAO,IAC/C,cAEA,CACA,mCACA,eACA,eACA,IACA,YACA,aAEA,6BACA,kCACA,2BAEA,qBACA,CAqBA,cACA,SACA,UACA,wBACA,IACA,aACA,cACA,YACA,uBAAwC,IAAO,MAC/C,aACA,SACA,SACA,mBACA,CACA,EAAM,kBAUN,OATA,cACA,YACA,2BAAgD,IAAO,MACvD,UACA,MACA,MACA,mBACA,CACA,CAGA,CAHM,GAGN,uBACA,aACA,cACA,gBACA,UACA,CAeA,OACA,IAnEA,oBACA,eACA,gCACA,WACA,uBAHA,CAKA,EA8DA,OA7DA,YACA,mBACA,eACA,8BAEA,wBACA,gBACA,WACA,uBAAwC,IAAO,IAC/C,6BAEA,CACA,EAkDA,sBAjBA,YACA,eACA,MACA,qBACA,GACA,qBACA,IAGA,EAAM,IACN,KAEA,eACA,CAKA,CACA,CACA,uBACA,EAIA,IASA,kBACA,QACA,qCACA,gBACA,CA2BA,aA3CA,YACA,GACA,EA0CA,cAxCA,YACA,SACA,qBAuCA,YArCA,cACA,0BACA,eACA,EAmCA,uBACA,qBA9BA,gBACA,gBACA,0BACA,sCACA,QACA,YAAoB,IAAe,IACnC,QAEA,eACA,EAsBA,8BArBA,kBACA,gBACA,gCACA,YACA,YAAsB,WAAmB,IACzC,wBAEM,CACN,qDACA,QACA,YAAsB,IAAe,IACrC,aAEA,eACA,CACA,CAOA,CACA,eAKA,OACA,QACA,QACA,YACA,SACA,OACA,EA8BA,OACA,OAzCA,CACA,aACA,UACA,EAuCA,SACA,cACA,aACA,MAXA,WACA,UACA,cACA,WACA,SACA,EAOA,OAnCA,gBAEA,OADA,UACA,GACA,iBACA,mBACA,KACA,cACA,eACA,KACA,mBACA,iBACA,KACA,kBACA,aACA,KACA,eACA,cACA,KACA,SACA,sDAEA,CACA,CAcA,CACA,CACA,mBACA,kBACA,SAsFA,OACA,OAtFA,gBACA,8BACA,gFACA,wBACA,WACA,4BACA,iBACA,YACA,YACA,kCACA,CACA,iCACA,0CACA,oCACA,mCACA,iCACA,+BACA,8BACA,GACA,eACA,cACA,cACA,oCACA,IACA,qBACA,gCACA,oBAEA,gCACA,iBACA,QAh0UA,KAi0UA,iBACA,UACA,YAAsB,IAAuB,KAC7C,WACA,OACA,OACA,UACA,YAAwB,UAAuB,KAC/C,SACA,UACA,2BACA,aACA,aACA,aACA,YAEA,SACA,2BACA,aACA,aACA,aACA,YAEA,SACA,2BACA,aACA,aACA,cACA,+BAEA,CACA,CACA,GACA,QACA,UACA,gBACA,EACA,WACA,+BACA,CACA,iDACA,gEACM,CACN,QACA,YAAsB,WAA6B,IACnD,QAEA,mCACA,yDACA,qDACA,CACA,8DACA,4DACA,CAGA,CACA,CACA,qBACA,kBAiCA,cACA,eACA,mCACA,2BACA,iDACA,CACA,OACA,OAvCA,YACA,qBACA,aACA,aAiBA,GAhBA,eACA,YACA,YAEA,oBACA,sCACA,gCAEA,eACA,0CACA,wBACA,yCAEA,aAGA,iBACA,iBACA,eACA,WACA,WAEA,CACA,QACA,EAYA,QAXA,WACA,aACA,CAUA,CACA,CACA,oBACA,gCA95UA,IA85UA,EACA,aA95UA,OA85UA,EACA,+FAEA,0BA96UA,IA86UA,EACA,yBA16UA,IA06UA,EACA,4BACA,uBACA,kBAAmB,YACnB,4BA97UA,KA+7UA,4BA/7UA,KAg8UA,cACA,wBACA,yBACA,CACA,QAGA,OAFA,cACA,uCACA,KAEA,UACA,sBAEA,OADA,sEACA,CACA,CACA,CACA,cACA,eACA,UACA,UACA,UACA,MACA,MACA,wBACA,uBACA,uBACA,mBACA,WACA,sBACA,UACA,QAKA,GAJA,aACA,sBACA,SAEA,OACA,eACA,gBAAgC,MAAe,IAC/C,KACA,iBAEA,CACA,QACA,CACA,iBACA,gCACA,uBAAgC,IAAO,IACvC,wBAEA,QACA,CACA,iBACA,uBAAgC,IAAO,IACvC,UAGA,iBACA,iBACA,QACA,oBACA,SAEA,YAAkB,MAAS,IAC3B,6BAEA,QACA,CACA,iBACA,iBACA,WACA,yBACA,OACA,CACA,iBACA,iBACA,gBACA,2BACA,+BACA,SACA,cAEI,CACJ,kBACA,0BACA,OACA,CACA,CACA,iBACA,iBACA,gBACA,uCACA,mCACA,SACA,SACA,eAEI,gBACJ,uCACA,mCACA,SACA,SACA,cAEI,CACJ,kBACA,0BACA,OACA,CACA,CACA,iBACA,iBACA,gBACA,mDACA,uCACA,SACA,SACA,SACA,cAEI,CACJ,kBACA,0BACA,OACA,CACA,CACA,iBACA,iBACA,aACA,eACA,kBACA,mCACA,OACA,EAAI,IACJ,kBACA,UACA,oCACA,OACA,CACA,CACA,iBACA,iBACA,aACA,eACA,kBACA,mCACA,OACA,EAAI,IACJ,kBACA,UACA,oCACA,OACA,CACA,CACA,iBACA,iBACA,aACA,eACA,kBACA,mCACA,OACA,EAAI,IACJ,kBACA,UACA,oCACA,OACA,CACA,CACA,iBACA,iBACA,WACA,yBACA,OACA,CACA,iBACA,iBACA,gBACA,2BACA,+BACA,SACA,cAEI,CACJ,kBACA,0BACA,OACA,CACA,CACA,iBACA,iBACA,gBACA,uCACA,mCACA,SACA,SACA,cAEI,CACJ,kBACA,0BACA,OACA,CACA,CACA,iBACA,iBACA,gBACA,mDACA,uCACA,SACA,SACA,SACA,cAEI,CACJ,kBACA,0BACA,OACA,CACA,CACA,iBACA,iBACA,WACA,0BACA,OACA,CACA,iBACA,iBACA,gBACA,2BACA,gCACA,SACA,cAEI,CACJ,kBACA,2BACA,OACA,CACA,CACA,iBACA,iBACA,gBACA,uCACA,oCACA,SACA,SACA,cAEI,CACJ,kBACA,2BACA,OACA,CACA,CACA,iBACA,iBACA,gBACA,mDACA,wCACA,SACA,SACA,SACA,cAEI,CACJ,kBACA,2BACA,OACA,CACA,CACA,mBACA,IAMA,EANA,aACA,yBACA,YACA,yBACA,QAGA,iCACA,mBA3nVA,IA4nVA,MAEA,KAEA,sBACA,CACA,mBACA,iBACA,yBACA,YACA,yBACA,QAEA,uBACA,CACA,mBACA,iBACA,yBACA,YACA,yBACA,QAEA,yBACA,CACA,mBACA,iBACA,yBACA,YACA,yBACA,QAEA,4BACA,CA2DA,iBACA,yBACA,CACA,iBACA,wBACA,yBACA,CACA,iBACA,wBACA,yBACA,CACA,iBACA,wBACA,yBACA,CACA,iBACA,wBACA,kCACA,CACA,iBACA,wBACA,kCACA,CACA,iBACA,yBACA,kCACA,CACA,iBACA,yBACA,CACA,iBACA,yBACA,CACA,iBACA,yBACA,CACA,iBACA,yBACA,CACA,iBACA,0BACA,CACA,iBACA,0BACA,CACA,iBACA,0BACA,CACA,iBACA,0BACA,CACA,mBACA,iBACA,WACA,UACA,UACA,0BACA,SAEA,YAAkB,MAAS,IAC3B,6BAEA,CACA,mBACA,iBACA,WACA,UACA,UACA,0BACA,SAEA,YAAkB,MAAS,IAC3B,6BAEA,CACA,mBACA,iBACA,WACA,UACA,UACA,0BACA,SAEA,YAAkB,MAAS,IAC3B,+BAEA,CACA,mBACA,iBACA,WACA,UACA,UACA,0BACA,SAEA,YAAkB,MAAS,IAC3B,kCAEA,CA2DA,SACA,mBACA,UACA,YACA,cACA,iBACA,cA7NA,YACA,UACA,UACA,SACA,YACA,SACA,YACA,SACA,YACA,SACA,YACA,SACA,YACA,SACA,YACA,SACA,WACA,WACA,SACA,YACA,WACA,SACA,YACA,WACA,SACA,YACA,WACA,SACA,WACA,SACA,YACA,SACA,YACA,SACA,YACA,SACA,YACA,WACA,WACA,WACA,WACA,SACA,YACA,WACA,WACA,SACA,YACA,WACA,WACA,WACA,SACA,YACA,WACA,WACA,WACA,SACA,CACA,EAoKA,OACA,CACA,CACA,SACA,mBACA,UACA,YACA,cACA,iBACA,iBACA,cA1EA,YACA,UACA,UACA,SACA,YACA,SACA,YACA,SACA,YACA,SACA,YACA,SACA,YACA,SACA,YACA,SACA,WACA,WACA,SACA,YACA,WACA,SACA,YACA,WACA,SACA,YACA,WACA,SACA,WACA,SACA,YACA,SACA,YACA,SACA,YACA,SACA,YACA,WACA,WACA,WACA,WACA,SACA,YACA,WACA,WACA,SACA,YACA,WACA,WACA,WACA,SACA,YACA,WACA,WACA,WACA,SACA,CACA,EAiBA,OACA,CACA,CACA,SACA,eACA,UACA,YACA,WACA,CACA,gBACA,eACA,uBAAoC,MAAS,KAC7C,WACA,uBACA,CACA,CACA,CACA,6BACA,iBACA,cACA,aACA,CAuBA,SACA,iBACA,YACA,YACA,iDACA,YAAoB,IAAO,KAC3B,gEA5BA,gBACA,wBAEA,IADA,iBACA,CACA,gCACA,OACA,oBAEA,GADA,UACA,8BACA,6CACA,KACA,CAAM,KAEN,IADA,GACA,SACA,OAEA,KADA,aAGA,GACA,CACA,CACA,EAQA,SACA,CACA,CACA,kBACA,uBACA,wBACA,CACA,mBACA,gBACA,2BACA,CACA,uBACA,uBAAoC,MAAS,KAC7C,sBACA,mBACA,uBAEA,CACA,CACA,yBACA,SACA,uBAAoC,MAAS,KAC7C,WACA,oBACA,CACA,QACA,CACA,CACA,mBACA,wBAGA,OAFA,oBACA,mBACA,CACA,CAEA,SAYA,UAcA,mBACA,+CACA,+BACA,sBACA,+BACA,MAIA,QAJA,EACA,qBACA,uCAhCA,cACA,oBACA,KACA,kBACA,yBACA,YAAqB,IAAQ,KAC7B,UACA,UAAmB,eAAgC,EAAE,EAAK,IAAI,KAAS,EACvE,CACA,mBACA,EAsBA,uBACA,CAGA,CAHI,IA0CJ,UA+CA,eACA,YACA,CACA,iBACA,6EACA,0jBACA,CACA,iBACA,wIACA,CACA,0CACA,eACA,uBACA,CACA,eACA,iBACA,YACA,eACA,gBACA,cACA,QACA,uGAEA,+CAEA,CACA,YACA,CACA,sEAAyF,oBAAoB,oBAAoB,WAAW,6BAC5I,eACA,uBACA,CACA,qBACA,SACA,sBAAgC,cAAmB,IACnD,2EAEA,QACA,CACA,eACA,mBAAqC,aAAsB;AAC3D,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,aAAa,aAAsB;AACnC,GAQA,MAPA,sBACA,8BACI,wBACJ,gCACI,sBACJ,+BAEA,CACA,CA+DA,qBACA,IAYA,IAmUA,EAOA,EApZA,EA0BA,EAoCA,iBACA,YACA,iBACA,mBACA,GAlEA,yBACA,IAiEA,EAjEA,cACA,uBAlzWA,IAk3WA,EA/DI,cACJ,4BACI,qBACJ,yBAEA,GA2DA,WAzDA,GACA,yBACA,YACA,qBACA,KAzwWA,IA0wWA,KAzwWA,IA0wWA,qBACA,KACA,MAzwWA,IA0wWA,uBAEA,CAEA,QACA,EA2CA,GACA,GA1CA,2BA0CA,EAzCA,QArxWA,MA8zWA,EAxCA,YAEA,6BAIA,GAmCA,EAjCA,YACA,6BACA,YACA,kBACA,KAjzWA,EAkzWA,6BACA,KACA,MAnzWA,EAozWA,wBACA,KACA,MArzWA,EAszWA,uBAEA,CAEA,QACA,EAiBA,GACA,EAjBA,YACA,2BACA,wBACA,qBAGA,OAAW,WADX,kCACW,YAFX,IAEW,SACX,EAUA,GACA,EAxKA,CAHA,kFA2KA,EA1KA,iEACA,CACA,sBAyKA,WAvKA,GACA,SACA,gBACA,UACA,SACA,0BACA,CACA,mBACA,EA+JA,GACA,oBAEA,iDACA,wBACA,IACA,oCACA,oCACA,EACA,wBACA,UACA,UAOA,CALA,GACA,oCACA,oCACA,EACA,wBACA,UACA,YAGA,GACA,MACA,oCACA,oCACA,EACA,2DACA,qCACA,gDACA,yCACA,oDACA,oDACA,qCACA,0CACA,2BACA,iCACA,yBACA,qCACA,+BACA,mCACA,uCACA,8DACA,gEACA,mDACA,2CACA,yCACA,+CACA,6CACA,gEACA,0DACA,iDACA,oEACA,2CACA,sDACA,8DACA,6CACA,6CACA,qCACA,uCACA,6CACA,mDACA,6CACA,gDACA,wDAEA,qCACA,oDACA,oDACA,2CACA,6DACA,iDACA,uDACA,yEACA,gEACA,gEACA,mEACA,gEACA,mFACA,4FACA,sEACA,kGACA,oEACA,gFACA,6DACA,6EACA,yFACA,yEACA,gEAEA,8DACA,sCACA,4CACA,kCACA,kCACA,kCACA,uCACA,uCACA,qCACA,6CACA,iEACA,2CACA,qFACA,2EACA,wCACA,oCACA,8CACA,mCACA,mDACA,iDACA,sDACA,sDACA,0BAAgC,EAChC,8BAAoC,EACpC,+BAAqC,EACrC,yBAA+B,EAC/B,2BAAiC,EACjC,6BAAmC,EACnC,6BAAmC,EACnC,wBACA,gCAAsC,EACtC,SACA,8BACA,+BAAqC,EACrC,SACA,8BACA,iCAAuC,EACvC,SACA,yBAA+B,EAC/B,uBAA6B,EAC7B,mBAAyB,EACzB,iBACA,qBAA2B,EAC3B,SACA,iBACA,qBAA2B,EAC3B,SACA,iBACA,qBAA2B,EAC3B,SACA,qBACA,yBAA+B,EAC/B,SACA,iCACA,uBAA6B,EAC7B,6BACA,uBAA6B,EAC7B,SACA,sBACA,2BAAiC,EACjC,4BAAkC,EAClC,SACA,KACA,uBACA,GACA,MACA,oCACA,oCACA,EACA,qCACA,0CACA,iDACA,2BACA,iCACA,iCACA,yBACA,yBACA,yBACA,gDACA,kDACA,6CACA,qCACA,+BACA,mCACA,uCACA,8DACA,gEACA,2CACA,yCACA,+CACA,uCACA,6CACA,gEACA,0DACA,yCACA,2CACA,iDACA,oEACA,2CACA,sDACA,8DACA,6CACA,6CACA,qCACA,uCACA,uCACA,+BACA,gDACA,wDACA,6CACA,mDACA,6CACA,8DACA,0EACA,4CACA,kCACA,kCACA,kCACA,uCACA,2CACA,uCACA,wCACA,oCACA,8CACA,mCACA,sDACA,iDACA,uDACA,wEACA,sDACA,sDACA,yBAA+B,EAC/B,6BAAmC,EACnC,6BAAmC,EA7iXnC,IA8iXA,wCACA,kDA/iXA,IAijXA,cA5bA,cACA,MACA,UACA,KAvnWA,EAwnWA,WACA,KACA,MAznWA,EA0nWA,aACA,KACA,MA3nWA,EA4nWA,WACA,KACA,MA7nWA,EA8nWA,eACA,KACA,MA9nWA,EA+nWA,QACA,KACA,MAhoWA,EAioWA,YACA,KACA,MAroWA,EAsoWA,WACA,KACA,SACA,+DACA,UACA,CACA,kCAAoD,mCAAqD,CACzG,EA+ZA,gCACA,mCACA,6BACA,4BAvcA,cACA,MA1BA,YACA,yCACA,eAAkC,kCAAuC,GACzE,0BACA,QACA,oCACA,GACA,qCAGA,OADA,gEACA,yBAEA,EAcA,GACA,cACY,aAAa,gBAAgB;UAC1B,KAAc,sBAAsB,KAAc,cAAc;EAE/E,EAmcA,0CAlaA,WACA,gCACA,sBACA,kBACA,kBACA;8BAEmC,EAAE,IAAI,EAAE,IAAI,GAAG,EAAE;;EAGpD,IA0ZA,6DACA,KACA,wBAIA,KADA,KADA,QACA,GACA,GAGA,KADA,KADA,QACA,GACA,GACA,QACA,QACA,6BACA,sBACA,GACA,yEAIA,CALA,IAKA,cACA,wBAEA,wEAAgG,EAChG,8aAWA,CAdA,IAcA,eAEA,YACA,QACA,0BACA,4BASA,cACA,8BACA,oCACA,+BACA,+BACA,KACA,KACA,+CAEA,GADA,KACA,yCACA,mCACU,CACV,uBACA,qBACA,cACA,mNAEA,KACQ,OACR,wDACQ,kBACR,MAEA,IACA,gBACA,WACA,aACA,cACA,MACA,QACA,CAAW,CACX,gBACA,MACA,QACA,CACA,EAEA,CACA,kBACA,kBACA,cACA,EAjeA,cACA,SACA,+CACA,YAAkB,IAAO,KACzB,6BACA,SACA,GACA,8BACA,6BACA,6BACA,MACA,YACA,kCACA,cACA,CACA,CACA,QACA,EAgdA,IACA,CAlDA,oBACA,oBACA,+BACA,gDACI,qBACJ,qCAEA,iBA6CA,4BAIA,OAHA,YACA,QAEA,CACA,EAEA,8BAIA,OAHA,YACA,QAEA,CACA,EACA,oDAoBA,OAnBA,wBAIA,MAHA,QACA,2BA9lBA,MA8lBA,EAEA,CACA,EACA,wBACA,+BACA,mBACA,mBACA,EACA,uBACA,uBACA,aACA,gBACA,iBACA,eACA,oBACA,sBACA,KAEA,QACA,UACA,cACA,yBACA,0BACA,CACA,UACA,qBACA,mBACA,0BACA,0BACA,qCASA,MARA,gBACA,SACA,eAEA,gBACA,SACA,eAEA,KAEA,UAEA,aADA,0BAEA,cACA,iDAGA,OADA,6BACA,KAEA,qBACA,+CAEA,uBACA,iDAEA,UACA,yBACA,0BACA,CACA,8BACA,yBACA,WAKA,OAJA,aACA,UACA,YAEA,CACA,CACA,mBACA,uBACA,WAKA,OAJA,aACA,YACA,YAEA,CACA,CACA,CACA,SACA,eACA,aACA,YACA,gBACA,CACA,CACA,2BACA,aACA,SACA,UACA,KACA,2BACA,mBACA,cACA,GACA,0BACA,oCACA,4BACA,0BACA,8BACA,0BACA,wBACA,gCACA,gCACA,4BACA,0BACA,4BACA,wBACA,wBACA,uBACA,EACA,oBAEA,CADA,SACA,YACA,KAAgB,EAAM,EAwatB,OACA,cAvaA,oBACA,IAkBA,IACA,IAnBA,QACA,aACA,8CACA,kDACA,yCACA,WACA,qBACA,qCACA,aACA,kGAGA,oFACA,wBACA,IAMA,GALA,2CACA,yCACA,wCAGA,GACA,YACA,iBACA,oBACM,IACN,iBACA,mBACA,YACA,yBACA,2BAEA,0BACA,sCACA,yBACA,uBACA,UACA,aACA,MACA,YACA,eACA,cACA,gBACA,sBACA,kBACA,mBACA,mBACA,iBACA,gBACA,iBACA,kBACA,YACA,mBACA,uBACA,uBACA,6BACA,gCACA,yBACA,kCACA,wBACA,4BACA,mBACA,wBACA,4BACA,0BACA,uBACA,mBACA,gBACA,iBACA,iBACA,kBACA,GA/1XA,CAg2XA,eACA,qCACA,mBAGA,QACA,WACA,kBACA,kBACA,eACA,iBACA,kBACA,uBACA,yBACA,+CACA,0BACA,YACA,WACA,yCACA,aACA,0CACA,yCACA,yBACA,6FACA,oCACA,MACA,SACA,SACA,wBACA,qBACA,QACA,WACA,UACA,YACA,qBACA,cACA,4CACA,yBApyXA,IAoyXA,gBACA,eACA,eACA,aACA,gBACA,YACA,gBACA,sBACA,yBACA,aACA,cACA,kBACA,2BACA,QACA,iBACA,qBACA,eACA,oBACA,wBACA,eACA,mBACA,gBACA,eACA,2BAh8XA,IAg8XA,mCACA,YACA,aACA,aACA,kBAEA,0BACA,8BACA,oCACA,kCACA,sCACA,kDACA,0CACA,4CACA,4CACA,8CACA,6CACA,yDACA,+DACA,iDACA,mEACA,+CACA,uDACA,2CACA,qDACA,6DACA,mDACA,6CACA,qCAEA,8CACA,4BACA,wFACA,sDACA,QACA,kBACA,yBACA,+BACA,uCACA,yBACA,qBACA,8BACA,iDACA,+CACA,6CACA,oBACA,qBACA,kCACA,8BACA,4BACA,uCACA,oCACA,4BACA,iDACA,6CACA,2CACA,0DACA,gCACA,8BACA,sCACA,sBACA,iDACA,+BACA,eACA,uFACA,+GACA,wCACA,YArgYA,IAqgYA,OACA,qBACA,kCACA,+BACA,0CACA,oGACA,mFACA,4EACA,+CACA,EAKA,OAJA,uBACA,uBACA,uBACA,UACA,EACA,EAkNA,mBAjNA,gBAsBA,IAkDA,IAvEA,SAOA,GANA,WACA,oBAEA,+BACA,kCAEA,mBACA,uBACA,UACA,qBASA,MANA,6BAQA,EAPA,EAOA,EAPA,EAQA,oBACA,2BACA,qBACA,6BACA,gBACA,qBACA,qBACA,kBACA,oBACA,sBACA,4BACA,wBACA,yBACA,yBACA,0BACA,yBACA,+BACA,kCACA,2BACA,oCACA,0BACA,8BACA,wBACA,6BACA,iCACA,4BACA,yBACA,kBACA,kBACA,0BACA,4BACA,8BACA,uBACA,yBACA,wBACA,2BACA,wBACA,4BACA,6BACA,+BACA,8BACA,sCACA,yBACA,wBACA,sBACA,4BACA,8BACA,uBAEA,EAxDA,EAwDA,EAxDA,EAyDA,eACA,0BACA,YACA,cACA,YACA,mBACA,YACA,mBACA,YACA,UACA,YACA,UACA,YACA,wBACA,YACA,yBACA,YACA,aACA,YACA,eACA,YACA,aACA,aACA,gBACA,aACA,gBACA,aACA,cACA,aACA,cACA,aACA,cACA,aACA,kBACA,aACA,cACA,aACA,aACA,aACA,YACA,aACA,cACA,aACA,iBACA,aACA,eACA,eACA,OACA,YACA,UACA,YACA,eACA,YACA,0BACA,YACA,sBACA,YACA,YACA,YACA,gBACA,YACA,gBACA,YACA,eACA,YACA,sBACA,YACA,oBACA,aACA,eACA,aACA,aACA,aACA,mBACA,aACA,aACA,aACA,gBACA,aACA,SACA,aACA,UACA,aACA,aACA,aACA,sBACA,aACA,8BACA,aACA,mBACA,aACA,eAnJA,4BAEA,gCACA,QACA,EA6LA,YA5CA,YACA,IACA,EADA,YAEA,MACA,YACA,sBACA,EAAM,IACN,aAEA,QACA,EAmCA,eAlCA,cACA,MACA,uBAA0C,IAAQ,KAClD,WACA,mBACA,IACA,cACA,KACA,CACA,CAKA,OAJA,aACA,kBACA,WAEA,CACA,EAoBA,eAnBA,YACA,qBACA,kBACA,oBACA,QACA,WACA,CACA,EAaA,mBAZA,YACA,WACA,EAYA,WACA,QAZA,WACA,WACA,CAWA,CACA,CACA,cACA,kBAqBA,OACA,IArBA,YACA,eACA,EAoBA,IAnBA,YACA,eAKA,OAJA,aACA,KACA,YAEA,CACA,EAaA,OAZA,YACA,WACA,EAWA,OAVA,gBACA,aACA,EASA,QARA,WACA,aACA,CAOA,CACA,CACA,wBACA,4BACA,0BACI,8BACJ,4BACI,8BACJ,4BACI,UACJ,QAEA,UAGA,wBACA,4BACA,0BACI,8BACJ,4BACI,UACJ,QAEA,UAGA,cACA,SACA,IACA,KACA,KACA,KAOA,wBACA,WAwBA,OAvBA,YACA,GACA,QACA,SACA,WACA,WACA,aACA,0BACA,IACA,OACA,EACA,SAEA,UACA,WACA,aACA,aACA,eACA,4BACA,MACA,WAEA,IACA,CACA,CAqCA,OACA,SACA,eACA,cACA,KAzEA,WACA,IACA,WACA,WACA,UACA,EAqEA,KAzCA,sBACA,oBACA,kBACA,UACM,mBACN,UAEA,SAEA,EAiCA,QAhCA,sBACA,oBACA,kBACA,aACM,mBACN,aAEA,YAEA,EAwBA,OAlBA,WACA,uBAA4D,IAAQ,KACpE,WACA,oBACA,WACA,cACA,gBACA,gBACA,YACA,CACA,EASA,KAxBA,cACA,0BACA,0BACA,yBACA,CAqBA,CACA,CACA,cACA,kBAoBA,OACA,IApBA,cACA,IACA,EADA,WAaA,OAXA,YACA,SACA,cAEA,aACA,SACA,WAEA,OAGA,CACA,EAMA,QALA,WACA,aACA,CAIA,CACA,CACA,cACA,SACA,OACA,oBAIA,EAHA,oBACA,eAGA,eACA,uBACA,GACA,iBACA,YACA,EACA,KACA,iBACA,GACA,gBACA,iBACA,aACA,WACA,UACA,cACA,OACA,EACA,KACA,kBACA,GACA,gBACA,aACA,WACA,OACA,EACA,KACA,uBACA,GACA,iBACA,gBACA,kBACA,EACA,KACA,qBACA,GACA,aACA,gBACA,iBACA,iBACA,CAEA,CAEA,OADA,UACA,CACA,CACA,CACA,CA6CA,SACA,iBACA,2DAEA,eACA,aACA,aAjDA,SACA,OACA,oBAIA,EAHA,oBACA,eAGA,eACA,uBASA,gBARA,GACA,kBACA,aACA,mBACA,eACA,oBACA,EACA,KAUA,kBACA,GACA,kBACA,aACA,mBACA,eACA,qBACA,mBACA,mBACA,CAEA,CAEA,OADA,UACA,CACA,CACA,CACA,IAQA,GACA,UACA,MACA,qBACA,eACA,cACA,kBACA,cACA,yBACA,mBACA,kBACA,eACA,iBACA,CAAK,CACL,gBACA,SACA,eACA,qBACA,wBACA,2BACA,QACA,gBACA,cACA,iBACA,mBACA,YACA,kBACA,kBACA,SACA,eACA,kBACA,qBACA,QACA,8BACA,gBACA,EACA,YAAkB,IAAO,yBACzB,aACA,SACA,SAkNA,OACA,MAlNA,YACA,gBACA,YAAoB,IAAO,0BAC3B,QACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,WACA,uBAAuC,IAAO,KAC9C,WACA,UACA,cACA,aACA,mDACA,oBACA,SACA,SACA,cACQ,mBACR,YAAwB,IAAO,IAC/B,kDAEA,IACA,EAAQ,6BACR,eAEA,GADA,kDACA,cACA,eACA,UACA,+BACA,oBACA,gCACA,wBACA,0BACA,yBACA,4BACA,6CACA,GACA,CACA,mBACA,GACA,EAAQ,sBACR,eACA,gDACA,kCACA,aACA,4BACA,+CACA,gBACA,YACA,eAQA,GAPA,QACA,wBACA,IACA,oBACA,mBAEA,8BACA,cACA,cACA,+BACA,oBACA,gCACA,wBACA,0BACA,kBACA,qBACA,GACA,CACA,GACA,EAAQ,0BACR,eACA,kCACA,gCACA,kCACA,gBACA,GACA,EAAQ,uBACR,eAIA,GAHA,kDACA,sBACA,gBACA,cACA,eACA,UACA,+BACA,oBACA,gCACA,wBACA,0BACA,iCACA,+BACA,mBACA,sBACA,uCACA,GACA,CACA,aACA,GACA,EAAQ,4BACR,eACA,2CACA,oDACA,YACA,GACA,CACA,CACA,MACA,wCACA,8BACA,gCAEA,6BACA,+BAGA,eACA,eACA,eACA,aACA,4NACA,uBACA,gBACA,oBACA,iBACA,gBACA,6BACA,gCACA,uBACA,0BACA,sBACA,yBACA,mCACA,6BACA,+BACA,wBACA,gCACA,mBACA,sBACA,gBACA,eACA,mBACA,eACA,0BACA,oBACA,mBACA,gBACA,mBACA,eAEA,EAsDA,UArDA,cACA,QACA,IACA,IACA,IACA,IACA,uBACA,uBAAuC,IAAO,KAC9C,WACA,yBACA,uBACA,iDACA,8CACA,mBACA,kCACA,GACA,EAAQ,sBACR,gBACA,gDACA,2BACA,iDACA,8CACA,mBACA,kCACA,GACA,EAAQ,0BACR,oBACA,gDACA,2BACA,aACA,sBACA,iBACA,qBACA,gCACA,kCACA,4BACA,6BACA,GACA,EAAQ,uBACR,iBACA,gDACA,2BACA,GACA,EAAQ,4BACR,gBACA,iDACA,kCACA,GACA,CACA,CACA,EAIA,OACA,CACA,CACA,eACA,gBACA,KACA,KAkBA,GACA,cACA,eACA,YACA,SACA,2BACA,EACA,OACA,KAzBA,YACA,WACA,WACA,UACA,EAsBA,QACA,YAhBA,WACA,UACA,EAeA,gBAdA,YACA,gBACA,EAaA,UAxBA,YACA,SACA,EAuBA,WAtBA,YACA,SACA,CAqBA,CACA,CACA,eACA,kBAoBA,OACA,IApBA,gBACA,IACA,EADA,WAaA,OAXA,YACA,YACA,cAEA,aACA,YACA,WAEA,OAGA,CACA,EAMA,QALA,WACA,aACA,CAIA,CACA,CACA,oBACA,kBACA,yBACA,CACA,eACA,QACA,4BACA,kBAhsZA,KAisZA,cACA,mBACA,0BACA,yBACA,wBACA,kBACA,0BACA,iBACA,CACA,QAUA,OATA,cACA,iCACA,eACA,yBACA,uCACA,2CACA,yCACA,2BACA,6CACA,KAEA,CACA,oBACA,kBACA,4BACA,CACA,eACA,QACA,+BACA,cACA,mBACA,0BACA,yBACA,wBACA,iBACA,CACA,QAOA,OANA,cACA,eACA,yBACA,uCACA,2CACA,yCACA,KAEA,CAGA,mBACA,aACA,qCAA4I,aAlvZ5I,IAkvZ4I,CAAgC,eAAsE,oBAClP,GA33ZA,CA23ZuB,CA13ZvB,IADA,EAEA,GAy3ZuB,EACvB,UACA,SACA,aACA,CAAK,CACL,UACA,aAAqB,WAAa,CAClC,YAAoB,aAAsB,CAC1C,QAAgB,QAChB,CAAK,CACL,aAfA,cAA6B,uCAAuC,GAAG,EAgBvE,eAfA,+BAAgD,0BAA0B,uBAAuB,mCAAmC,8CAA8C,oBAAoB,4BAA4B,mEAAmE,gDAAgD,wBAAwB,aAAa,QAAQ,4CAA4C,oKAAoK,4BAA4B,uFAAuF,6IAA6I,mBAAmB,mCAAmC,cAAc,yBAAyB,yCAAyC,sDAAsD,2DAA2D,GAAG,CAgB5kC,CAAG,EACH,WACA,6BACA,aACA,eACA,WACA,OACA,6CACA,IAGA,kBACA,OACA,gBACA,mBACA,oBACA,UA15ZA,EA25ZA,gBAiGA,oBACA,WACA,qEACA,cACA,SAGA,GADA,0BACA,uMACA,sBACA,MACA,cACA,KACA,QAEA,gBACA,QACA,YACA,OACA,iCAEA,GACA,CAwBA,OAtBA,oBACA,wBACA,MACA,+CAEA,kDAEA,sBACA,wBACA,YACA,4BACA,kCACA,sCACA,oCACA,wCACA,sCACA,0CACA,wBACA,oDAEA,CADA,oBACA,SAEA,CACA,CAkCA,cAGA,aAFA,SACA,iCACA,GACA,WACA,gBACA,SAEA,CADA,IACA,UACA,YAEA,CACA,CA5LA,4BACA,mBACA,uCACA,aAFA,OAGA,0BACA,wBACA,2BACA,UACA,cA95ZA,GA+5ZA,kCACA,4BACA,qBACA,MAt6ZA,IAs6ZA,iBACA,uBACA,uBAAwC,IAAQ,KAChD,WACA,WACA,eACA,yDACA,QACA,CACA,kDACA,kBACA,0BAeA,GAdA,cACA,kBACA,iBACA,QACA,sBACA,YACA,iBAEA,QACA,sBACA,YACA,kBAGA,8BACA,MAj8ZA,IAi8ZA,WAAoD,UAr4ZpD,KAq4ZoD,UAr4ZpD,IAq4ZoD,EAAqD,EACzG,eACA,gBAEA,wBACA,uCACA,iCACA,CACA,yBACA,UACA,2BACA,YAAuB,IAAoB,KAC3C,uBACA,MACA,QACA,QACA,QACA,SAEA,cACA,sBACA,iBAmFA,sBACA,yBAEA,GADA,yBACA,kCACA,mFACA,uEACA,kBACA,aACA,qBACA,eACA,uBAA8C,IAAQ,KACtD,WACA,qBACA,iBACA,iBACA,gCACA,qCACA,8BACA,CACA,CACA,EAAU,kBACV,iBACA,mCACA,wCACA,iCACA,CACA,CAEA,iBACA,uBAAyC,IAAO,IAChD,eAEA,EAlHA,yBACA,CACA,0CACA,SAQA,KACA,iBACA,yCACA,oCACA,oCACA,iBACA,kBAEA,kBACA,4BAEA,2CACA,sCACA,iCACA,6BACA,UACA,wCACA,+CACA,sCACA,iCACA,yBACA,UACA,uCACA,EA/BA,KAEA,gBACA,CACA,YACA,iBACA,wBACA,CAsHA,CACA,QA1jaA,EACA,EACA,EAIA,EAFA,EAGA,EAJA,EAEA,EAJA,EADA,EAMA,EAJA,EAKA,EAHA,EACA,EAFA,CAgkaA,EACA,iBA+LA,UA9LA,WACA,SACA,SACA,OACA,kBACA,OACA,oBACA,WACA,qBACA,IAEA,CAAO,CACP,sBACA,GACA,CAAO,CACP,6BACA,SACA,KACA,KACA,MAEA,eACA,mBACA,sBACA,UAEA,CAAO,CACP,iBACA,KACA,OACA,eACA,CACA,CACA,EA8JA,MA7JA,WACA,SACA,KACA,OACA,OACA,OACA,OACA,wBACA,UACA,gCACA,EACA,qDAEA,6DAEA,QACA,OACA,gBACA,CACA,GACA,CAAO,CACP,uBACA,QACA,CAAO,CACP,oBACA,EACA,gBAEA,eAEA,CAAO,CACP,oBACA,WACA,eACA,IAEA,CAAO,CACP,oBAEA,GADA,aACA,OACA,UACA,KAhpaA,EAipaA,qBACA,KACA,MAlpaA,EAmpaA,sBACA,KACA,MAppaA,EAqpaA,oBACA,KACA,MAtpaA,EAqqaA,QAdA,sBACA,KACA,MAxpaA,EAypaA,qBACA,KACA,MA1paA,EA2paA,sBACA,KACA,MA5paA,EA6paA,uBACA,KACA,MA9paA,EA+paA,uBAIA,CACA,GACA,CACA,CAAO,CACP,sBACA,GACA,CAAO,CACP,qBACA,QACA,GACA,QAEA,gBACA,IAEA,CAAO,CACP,iBACA,KACA,OACA,OACA,OACA,IACA,CACA,CACA,EAmEA,MAlEA,WACA,SACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,oBACA,IACA,EACA,kBAEA,kBAGA,CAAO,CACP,oBACA,WACA,iBACA,IAEA,CAAO,CACP,wBACA,wBACA,qBACA,IACA,IACA,IAEA,CAAO,CACP,sBACA,wBACA,mBACA,IACA,IACA,IAEA,CAAO,CACP,sBACA,GACA,CAAO,CACP,qBACA,QACA,kBACA,IAEA,CAAO,CACP,iBACA,KACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,MACA,CACA,CACA,EAIA,cACA,cACA,KACA,KACA,cACA,KACA,OACA,KACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,gBACA,IACA,KACA,OACA,OACA,OACA,OACA,OACA,qDACA,KAEA,2BACA,yBAEA,EADA,sCACA,EACI,6BAEJ,GADA,0CACA,GAEA,WACA,KACA,gCACA,6BACA,wBACA,wBACA,oBACA,wBACA,oBACA,mBACA,kDACA,kDACA,YAAoB,IAAW,IAC/B,yCACA,0DAEA,0DAGA,QACA,CACA,SAcA,cACA,YACA,YACA,QAEA,CACA,cACA,YACA,aACA,QAEA,CAxBA,+CACA,4EACA,mEACA,iDACA,oBACA,cACA,cACA,gBACA,UAn0aA,GAo0aA,MACA,EA12aA,GA22aA,eACA,EAp2aA,GAk6aA,OA55aA,IA65aA,WA55aA,IA65aA,gBA55aA,IA65aA,wBAEA,GA95aA,IA85aA,OACA,EA95aA,IA85aA,OACA,OA95aA,IA+5aA,OA95aA,IA+5aA,MA95aA,IA+5aA,YA75aA,IA85aA,YAx5aA,IAy5aA,qBA35aA,IA45aA,YA95aA,IA+5aA,YAl6aA,IAm6aA,sBAj6aA,IAk6aA,sBA95aA,IA+5aA,sBAj6aA,IAk6aA,sBA95aA,IA+5aA,iBA95aA,IA+5aA,2BA95aA,IA+5aA,iBA95aA,IA+5aA,4BAEA,gCACA,GA37aA,IA27aA,GACA,SACA,WACA,MAEA,MACA,CAKA,GAJA,SACA,WACA,MA/7aA,IAi8aA,GACA,iBAMA,GALA,CAl8aA,MAk8aA,cACA,4BACA,EAp8aA,IAq8aA,EAr8aA,KAu8aA,EACA,UACA,KA98aA,EA+8aA,6EACA,KACA,MAh9aA,EAi9aA,yBACA,KACA,MAl9aA,EAm9aA,+DACA,KACA,MAp9aA,EAq9aA,2DACA,KACA,SACA,uDAEA,MAEA,UACA,KAh+aA,EAi+aA,mFACA,KACA,MAl+aA,EAm+aA,+BACA,KACA,MAp+aA,EAq+aA,+DACA,KACA,MAt+aA,EAu+aA,gCACA,KACA,SACA,uDAEA,CAEA,OACA,OACA,OACA,OACA,aACA,IACA,IACA,GACA,CACA,MACA,CACA,OACA,OACA,OACA,iBACA,mCACA,IACA,KAEA,+BACA,yCACA,IACA,IACA,IACA,KAEA,4BACA,4BACA,UACA,KAEA,IACA,IACA,CAqBA,cACA,QACA,EACA,kBAEA,mBAEA,IAEA,CACA,cACA,OACA,eACA,QACA,MACA,mBACU,MACV,oBAEA,+BAIA,eAEA,GACA,CAOA,kBACA,GACA,yBACA,iBACA,qBACA,IACA,MAGA,wBAEA,CAkNA,OACA,SACA,QACA,QACA,SACA,CAAK,CACL,SACA,UACA,gBA7bA,qBACA,WACA,uBACA,OACA,wBACA,qBAEA,mBACA,0BAEA,GAGA,EAibA,YAhbA,cACA,QACA,KACA,MAEA,SADA,eAEA,KACA,YAEA,iBACA,oDACA,uBAA8C,IAAQ,IACtD,0BAEA,mBACA,IACA,CACA,EAAM,IACN,gBACA,YACA,KAGA,IACA,gBAEA,EAuZA,WAtZA,mBACA,QACA,gBACA,IACA,GAGA,EAgZA,cACA,YA9RA,cACA,yCACA,iBACA,UACA,KACA,qCAzhbA,GAyhbA,wJACA,uBACA,uBACA,wBACA,wBACA,qBACA,aACA,IACA,8BACA,wDACA,sDAEA,8DACA,kFACA,EA4QA,eACA,cACA,aAlPA,YACA,QACA,kBACA,IAEA,EA8OA,mBACA,eAlOA,YACA,EACA,kBAEA,iBAEA,EA6NA,cA5NA,YACA,+BACA,QACA,mBACA,IAEA,EAuNA,YAtNA,gBACA,aAEA,EADA,SACA,eAEA,GAGA,UACA,cACA,GAAuB,4BACvB,QAEA,8BACA,QACA,mBACA,KAEA,yBACA,SACA,YAEA,EAiMA,cAhMA,WACA,gBACA,yBACA,2BACA,cACA,iBAEA,EA0LA,qBAzLA,WACA,IACA,yCACA,CAAM,SACN,oCACA,CACA,EAoLA,qBAnLA,WACA,IACA,yCACA,CAAM,SACN,oCACA,CACA,EA8KA,WAnIA,WACA,IACA,+BACA,CAAM,SACN,oCACA,CACA,EA8HA,WA7HA,WACA,IACA,+BACA,CAAM,SACN,oCACA,CACA,EAwHA,iBA3GA,cACA,cACA,cACA,cACA,YAEA,cACA,cACA,mCACA,WAEA,EAiGA,oBAhGA,cAEA,QADA,OACA,OACA,eACA,iDACA,WAEA,EA0FA,aArJA,WACA,IACA,iCACA,CAAM,SACN,oCACA,CACA,EAgJA,aA/IA,WACA,IACA,iCACA,CAAM,SACN,oCACA,CACA,EA0IA,cAnLA,WACA,IACA,kCACA,CAAM,SACN,oCACA,CACA,EA8KA,cA7KA,WACA,IACA,kCACA,CAAM,SACN,oCACA,CACA,EAwKA,wBAvKA,WACA,IACA,4CACA,CAAM,SACN,oCACA,CACA,EAkKA,wBAjKA,WACA,IACA,4CACA,CAAM,SACN,oCACA,CACA,EA4JA,QA/HA,YACA,mBACA,2BACA,UAEA,EA2HA,SA1HA,YACA,mBACA,4BACA,UAEA,EAsHA,MAjGA,WACA,mBACA,uBACA,wBACA,iCACA,0BACA,0BACA,sCACA,4BACA,0BACA,+CACA,sBACA,yBACA,sBACA,gBACA,oBACA,kBACA,gBACA,0BACA,qCACA,kCACA,kBACA,mBACA,mBACA,qBACA,4BACA,sCACA,2CACA,2CACA,mBACA,eACA,8CACA,+CACA,KACA,OACA,KACA,KACA,cACA,KACA,OACA,KACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,gBACA,IACA,KACA,OACA,OACA,OACA,OACA,OACA,0CACA,0CACA,UACA,UACA,SACA,CAqCA,CACA,CACA,qBACA,eAkFA,GACA,UACA,KAn2bA,KAo2bA,KAn2bA,KAo2bA,OAAe,0BACf,MAn2bA,KAo2bA,KAr2bA,KAs2bA,KAj2bA,KAk2bA,OAAe,0BACf,MAl2bA,KAm2bA,KAl2bA,KAm2bA,OAAe,0BACf,MAx2bA,KAy2bA,KA12bA,KA22bA,KAz2bA,KA02bA,OAAe,0BACf,MAt2bA,MAu2bA,OAAe,0BACf,CACA,oCAA0C,EAAK,GAC/C,EAtGA,GACA,UACA,KArwbA,KAuwbA,KApwbA,KAmwbA,UAGA,MArwbA,KAswbA,YACA,MApwbA,KAswbA,KArwbA,KAowbA,0CAnwbA,KAwwbA,KAvwbA,KAswbA,sCAGA,MAlxbA,KAmxbA,4CAlxbA,KAqxbA,KA5wbA,KA2wbA,4CA1wbA,MA8wbA,KA7wbA,MAwxbA,KAjxbA,MAkxbA,KAjxbA,MAswbA,gDACA,MA9wbA,MA+wbA,KA9wbA,MAyxbA,KAlxbA,MAoxbA,KAnxbA,MAuwbA,iDACA,MA9wbA,MA+wbA,KA7wbA,MA8wbA,qCACA,MAlxbA,MAmxbA,KAjxbA,MAkxbA,oCAQA,MApxbA,MAqxbA,iDACA,MArxbA,MAsxbA,iDACA,MAtxbA,MAuxbA,iDACA,MAvxbA,MAwxbA,iDACA,MAxxbA,MAyxbA,iDACA,MAzxbA,MA0xbA,iDACA,MA1xbA,MA2xbA,iDACA,MA3xbA,MA4xbA,kDACA,MA5xbA,MA6xbA,kDACA,MA7xbA,MA8xbA,kDACA,MA9xbA,MA+xbA,mDACA,MA/xbA,MAgybA,oDACA,MAhybA,MAiybA,qDACA,MAjybA,MAkybA,KAjybA,MAkybA,KAjybA,MAsybA,KAnybA,MAoybA,KAnybA,MA8xbA,uCACA,MAlybA,MAmybA,KAlybA,MAmybA,sCAIA,CACA,YACA,+CAAmD,GAAQ,SAE3D,CAsBA,2BACA,IAIA,EAJA,mGACA,4EACA,SACA,cAEA,cACA,KACA,IACA,uFACA,CAAI,SACJ,CACA,gBACA,SAEA,yBACA,YACA,CACA,kBACA,QACA,OAIA,GAHA,yBACA,iCAEA,IACA,mQACA,4BACA,wBACA,wBACA,iBAMA,OALA,UACA,WAEA,EADA,iBACA,qBACA,gHACA,CACA,EAAQ,GACR,YACA,iGAKA,QACA,CACA,cACA,wBACA,CACA,cACA,mBACA,CAOA,yBACA,aACA,6BACA,8FACA,CACA,QA8CA,GA7CA,YACA,wBACA,6BACA,+BAEA,oBACA,gCACA,kCACA,gCACA,sBACA,wBACA,uBAEA,WACA,yBACA,8BACA,gCAEA,mBACA,iCACA,mCACA,iCACA,uBACA,yBACA,wBAEA,oBACA,kCACA,oCACA,kCACA,wBACA,0BACA,yBAEA,qBACA,mCACA,qCACA,mCACA,yBACA,2BACA,0BAEA,WACA,8CAEA,YACA,4BACA,4BACA,gCACA,uDACA,0CACA,2CACA,CAIA,MAHA,kFACA,gCAEA,CACA,CACA,gBACA,MAmBA,OAlBA,EACA,UA7+bA,OA6+bA,GAx+bA,OAw+bA,EACA,qBA7+bA,OA8+bQ,EACR,sBAl/bA,OAm/bQ,IACR,qBACA,+GAGA,UAt/bA,OAs/bA,YACA,sBAt/bA,OAu/bQ,EACR,uBACQ,UACR,wBAGA,CACA,CACA,sBACA,0EACA,wCACM,uCACN,iBACM,8CACN,iBAEA,CAEA,CACA,cACA,eACA,mCACA,SAUA,GACA,eACA,iCACA,eACA,WACA,MACA,sBACA,cACA,iBACA,KAEA,2BACA,WAEA,CACA,WACA,EA1BA,GACA,kBACA,WAEA,CACA,cACA,eACA,mCACA,SA2BA,GACA,eAKA,GAJA,iBACA,yBACA,0BAEA,0BACA,YAAsB,IAAO,KAC7B,0CACA,YAA8B,iCAA6D,yDAE3F,4CAEA,oEACA,KACM,CACN,uCACA,YAA4B,8BAA0D,sDAEtF,0CAIA,GAFA,iEACA,wFACA,2BACA,YAAwB,oCAA4D,IACpF,kFAGA,6EACA,CACA,iBACA,uBAA0C,IAAQ,KAClD,iBACA,oBACA,kCACA,qBAEA,cACA,CACA,WACA,EAnEA,EACA,CAkBA,cACA,eACA,kCACA,eACA,UACA,wBACA,mBACA,CA0CA,QA8BA,gBACA,eAEA,GADA,2BAszBA,GACA,qBACA,eACA,WACA,WAEA,EA5zBA,GACA,oEACA,cACA,YACA,6FACQ,mBAEA,YACR,SAFA,uFAKA,CACA,yDACA,CAyBA,OA9qcA,IA+qcA,SA9qcA,KA+qcA,gBA9qcA,KA+qcA,mBAEA,GAhrcA,KAircA,UAhrcA,KAircA,yBAhrcA,KAircA,wBAhrcA,KAircA,SAhrcA,KAircA,wBAhrcA,KAircA,wBAEA,GAjmcA,IAkmcA,QA3lcA,IA4lcA,SAlmcA,IAmmcA,OAjmcA,IAkmcA,SAnmcA,IAomcA,QAhmcA,IAimcA,SAnmcA,IAomcA,UAnmcA,IAomcA,YAEA,gBAeA,IArscA,OAurcA,qEA/rcA,OA+rcA,aAjscA,OAiscA,kHACA,yJAEA,+CACA,+CACA,4CACA,+CAEA,uDACA,uDACA,oBACA,mEACA,gEAEA,+CAjtcA,OAktcA,aACA,CAjtcA,OAitcA,kCACA,CAxscA,OAwscA,iDACA,gDACA,8CACA,4FACA,0CAGA,CACA,gBACA,QACA,0BACA,iBACA,iCAEA,eACA,UACA,cACA,KACA,YAEA,eAvHA,GACA,SAeA,OAdA,gBACA,gBACA,mBACA,oBACA,oBACA,qBACA,yBACA,iBACA,eACA,0BACA,2BACA,gBACA,0BACA,qBACA,QACA,EAsGA,GACA,qBACA,gBACA,MACA,0BACA,WACA,EACA,oBACA,MAEA,iBACA,2BACA,QACA,4BACA,iBACA,MAGA,eACA,8BAEA,QACA,CACA,kBACA,mBACA,2EACA,oCACA,aACA,WACA,+CACA,eACA,wCAeA,EAdA,8BACA,4CACA,uDACA,EA3rcA,KA2rcA,mDACA,6CACA,mEACA,oDACA,sDACA,qCACA,SACA,uCACA,oBACA,wDACA,OAEA,gBACA,wBACA,+BACA,cACA,SACA,oBACA,IArwcA,OAqwcA,iBACA,IACA,EACA,kDAEA,iEAGQ,mBACR,eACA,MACA,wDAEA,uBAA+C,IAAQ,IACvD,OACA,EACA,GACA,gEAGA,4DAGA,qBACA,EAAU,IACV,GACA,GACA,kDAEA,GACA,iEAGA,kEAGQ,yBACR,+BACA,MACA,sEAEA,uBAA+C,IAAQ,IAEvD,GADA,OAnzcA,OAozcA,SACA,YACA,KACA,MACA,0BACA,2CACA,6BACA,sBACA,6BACA,kCAEA,4EACA,CACA,qBACA,EAAsB,IACtB,uFAEA,MAEA,0FAGA,oHAGA,EACA,GACA,gFAGA,0EAIA,EAAU,IACV,MACA,wDAEA,uBAA+C,IAAQ,IACvD,OA31cA,OA41cA,SACA,SACA,EACA,GACA,wEAGA,mEAGA,+GAGA,EACA,GACA,gEAGA,4DAIA,MACQ,wBACR,KAIA,IAHA,GACA,gEAEA,EACA,0BACA,2CACA,6BACA,sBACA,6BACA,kCAEA,oEACA,CACA,qBACA,EAAc,IACd,+EAEA,MAEA,gFAEQ,qBACR,GACA,GACA,0DAEA,GACA,2EAGA,0EAEQ,0BACR,MACA,KACA,sDACY,CACZ,yBACA,YAA4B,IAAY,IACxC,8CACA,MACA,KAEA,CACA,MAEA,eACA,SACA,cACA,iDACA,CACA,uBAA+C,IAAQ,IACvD,OACA,EACA,GACA,0CAGA,oCAGA,qBACA,EAAU,IACV,MACA,MACA,WACA,iDACA,CACA,GACA,yCAEA,EAAY,IACZ,oCAIA,OACA,KAEA,sBACA,yBACA,CACA,sBA0HA,wBACA,uCACA,oBACA,uCACA,WACA,WAEA,GADA,mBACA,0BACA,6BACA,yBACA,0CACA,2CAEA,kCAEA,CACA,mCACA,KACA,gFACM,wFACN,6DAEA,qCACA,CACA,kBAEA,GADA,qCACA,eACA,qBACA,kCACA,uBACA,gEACA,OACA,KAEA,yEACQ,EACR,sEAEA,yDAEA,2DACA,EAAM,IACN,iBACA,YAAsB,WAAqB,KAC3C,WACA,mCACA,oBACA,uCACA,MACA,cACA,sEACU,KACV,yEAEA,wDAEA,CACA,CACA,uCACA,CAkCA,cACA,eACA,iCACA,2CACA,qBAIA,GAHA,0BACA,2BAEA,GACA,WACA,6BACA,gCACA,kCACA,EACA,gCACA,0BACA,CACA,uBACA,CACA,iDACA,8EArDA,cAEA,GADA,6BACA,uEAEA,GADA,mCACA,iDACA,mFAEA,2BACA,oBACA,iGACA,mCACA,qCACA,+BAEA,oBACA,uBACA,OACA,GA3odA,OA2odA,sBACA,KACA,0FAEA,+EAEM,gCACN,KACA,kGAEA,uFAGA,0CAEA,EAsBA,uBACA,EAAM,IACN,MACA,wBACA,YAAwB,IAAO,IAE/B,GADA,yDACA,iCACA,+CACA,oCACY,CACZ,oEACA,0BACA,qCACA,2DACA,CAEA,EAAQ,IAER,GADA,sDACA,8BACA,4CACA,iCACU,CACV,oEACA,uBACA,qCACA,2DACA,CAGA,qCACA,CA8IA,SACA,KAgEA,cACA,uCACA,CACA,cACA,eACA,oGASA,gBACA,mBACA,WACA,eACA,mDACA,QAv3dA,KAu3dA,IACA,uBACA,CAr7dA,OAq7dA,cACA,wGAGA,0EAPA,CAWA,CACA,cAWA,MAVA,qEACA,gCACA,oCACM,yDACN,uBACA,2BAEA,gBACA,mBAEA,CACA,CACA,yBAt3BA,WACA,QAKA,OAJA,kBACA,mHAEA,KACA,CACA,EAg3BA,uBA13BA,WACA,GACA,EAy3BA,oBACA,uBA/0BA,cACA,eACA,oDACA,SAGA,+DACA,EAy0BA,kBAx0BA,cACA,eACA,oDACA,SAGA,yDACA,EAk0BA,oBAj0BA,cACA,eACA,oDAwTA,gBACA,6BACA,aACA,WACA,gEACA,eACA,wCA0BA,EAzBA,8BACA,4CACA,uDACA,EAv5cA,KAu5cA,mDACA,6CACA,mEACA,oDACA,sDACA,4DACA,uCACA,KACA,YAAsB,IAAO,IAC7B,KAGA,mCAFA,uCAIA,eAEA,yGACA,wBACA,+BACA,cACA,SAGA,GAFA,wBAEA,GACA,MACA,wDAEA,YAAwB,IAAO,KAC/B,eACA,YAA0B,WAAoB,KAC9C,UAj/cA,QAk/cA,SACA,SACA,EACA,GACA,2FAGA,sFAGA,gHAGA,EACA,GACA,mFAGA,+EAGA,CACA,CACA,EAAQ,IAER,GADA,YACA,MACA,gBACA,cACA,uDACA,CACA,YAAwB,IAAO,IAC/B,MACA,EACA,GACA,4FAGA,yFAEA,YAA4B,WAAoB,KAEhD,MADA,KACA,eACA,EACA,GACA,qFAGA,iFAEA,CACA,EAAY,IACZ,EACA,GACA,gEAGA,2DAEA,YAA4B,WAAoB,KAChD,WACA,EACA,GACA,wEAGA,kEAEA,CACA,CAEA,CACA,MACA,sBAEA,sBACA,yBACA,CACA,qBACA,EA9aA,OAGA,+DACA,EA2zBA,oBA/PA,gBACA,cACA,aACA,uEAEA,YACA,IAEA,EAwPA,uBAvPA,YACA,gBACA,WACA,WACA,gCACA,iBACA,iCACA,aAQA,GAPA,KACA,2BACA,qCAEA,sBACA,qBAEA,GACA,wBACA,YAAsB,IAAO,IAC7B,kCACA,2BACA,YAA8B,mBAAgC,IAC9D,gDAEA,EAAU,IACV,6CAGA,EAAM,IACN,kCACA,wBACA,YAA4B,mBAAgC,IAC5D,6CAEA,EAAQ,IACR,2CAEA,KACA,uBAA8C,IAAQ,KACtD,iBACA,6BACA,mCACA,oBAEA,CAEA,2BACA,uDACA,8BACA,kEACA,YAAwB,WAAqB,KAC7C,WACA,qDACA,iEACA,uCACA,oBACA,+DACA,OACA,sEACA,2GACA,CACA,wCACA,gBACA,kDACA,oCAEA,qCACA,CACA,CACA,MACA,mDACA,wBACA,YAAsB,IAAO,IAC7B,iCACA,YAA8B,mBAAgC,IAC9D,6FAGA,oFAGA,OACA,sBAEA,iBACA,EAAM,UACN,uBAA4C,IAAQ,KACpD,WACA,WACA,6CACA,kBACA,iEACA,MACA,eAEA,CACA,iBACA,EAAM,IACN,mBAMA,GALA,uDACA,4DAEA,kCACA,OACA,8BACA,YAA4B,mBAAgC,IAC5D,4DAGA,mDAEA,OACA,KAEA,iBACA,CACA,eACA,IAEA,EAkIA,8BAjIA,YACA,iBACA,uBAA0C,IAAQ,KAClD,WACA,SACA,MA37BA,6CACA,qCACA,0EACA,aAy7BA,0BACA,mBACA,KACA,iBACA,CACA,CACA,EAsHA,mCAnHA,YACA,eACA,eACA,iBACA,UACA,WACA,qBACA,gEACA,WACA,aACA,KACA,YAA0B,WAAqB,IAC/C,kEACA,mFACA,sDACA,qFAGA,uEACA,2DACA,YAAwB,WAAqB,KAK7C,GAJA,uBACA,uCACA,oEAEA,GACA,+GACA,iCACA,+EACA,CACA,+CACA,SACA,WACA,WACA,8BACA,2CACA,UACA,UACA,+CAEA,8CAEA,CAGA,GAFA,2CACA,2CACA,EACA,YAA0B,WAAqB,KAC/C,kEACA,4GACA,iCACA,sDACA,iFACA,CAEA,sEACA,EAAQ,IACR,gDACA,oEACA,+CACA,CACA,CAEA,EAsDA,8BACA,+BACA,yBACA,CACA,iBAmHA,OAAW,QAlHX,aA95dA,EA85dA,EAEA,IADA,EACA,oBACA,GA3+dA,OA2+dA,yBACA,4CACA,4CACA,+CACA,GA9+dA,OA8+dA,gBACA,GA9+dA,OA8+dA,iBACA,GA9+dA,OA8+dA,0BACA,GA9+dA,OA8+dA,eACA,GA9+dA,OA8+dA,wBACA,2BACA,gCACA,2BACA,yBACA,GA1+dA,OA0+dA,gBACA,+BACA,qCACA,GA1+dA,OA0+dA,2BACA,GA1+dA,OA0+dA,yBACA,GA1+dA,OA0+dA,eACA,GA1+dA,OA0+dA,uBACA,GA1+dA,OA0+dA,cACA,GA1+dA,OA0+dA,sBACA,kCACA,cAz+dA,QAy+dA,GAx+dA,QAw+dA,aACA,WAEA,UADA,gDAOA,YALA,oDACA,0DACA,0DACA,2DAIQ,IAER,UADA,2CAOA,YALA,GAx/dA,QAw/dA,wCACA,GAx/dA,QAw/dA,yCACA,oDACA,GAx/dA,QAw/dA,yCAMA,cA5/dA,QA4/dA,GA3/dA,QA2/dA,GA1/dA,QA0/dA,GAEA,UADA,4CAOA,YALA,GAhgeA,QAggeA,2CACA,sDACA,uDACA,uDAKA,GApgeA,QAogeA,GAngeA,QAmgeA,GAlgeA,QAkgeA,GAEA,UADA,0CAKA,YAHA,cAtgeA,QAsgeA,+DACA,GAtgeA,QAsgeA,+EAKA,GA1geA,QA0geA,GAzgeA,QAygeA,GAxgeA,QAwgeA,GAvgeA,QAugeA,GAtgeA,QAsgeA,GArgeA,QAqgeA,GApgeA,QAogeA,GAngeA,QAmgeA,cAjgeA,QAigeA,GAhgeA,QAggeA,GA//dA,QA+/dA,cA7/dA,QA6/dA,GAEA,UADA,2CAiBA,YAfA,iGACA,iGACA,iGACA,GA7geA,QA6geA,sFACA,GA7geA,QA6geA,sFACA,GA7geA,QA6geA,sFACA,iGACA,GA7geA,QA6geA,sFACA,GA7geA,QA6geA,wFACA,GA7geA,QA6geA,wFACA,mGACA,qGACA,GA7geA,QA6geA,0FACA,qGAKA,GAjheA,QAiheA,cA/geA,QA+geA,GAEA,UADA,0CAMA,YAJA,mGACA,GApheA,QAoheA,gDACA,6DAKA,GAxheA,QAwheA,oCAEA,UADA,0CAOA,YALA,+CACA,sDACA,qDACA,mEAxkeA,OA6keA,sBACA,uBACA,CACW,CACX,CACA,oBACA,kBACA,QACA,sBACA,cACA,CACA,CACA,oBACA,cACA,QACA,gBACA,iBACA,CACA,CACA,QAAqB,YACrB,UACA,cACA,qBACA,gBACA,eACA,CACA,eAQA,OAPA,oBACA,kBACA,+BACA,sBACA,qBACA,uBAAgC,cAEhC,WAEA,oBAUA,OATA,yBACA,uBACA,oCACA,2BACA,qCACA,sCACA,sCACA,wCAEA,gBAEA,eAUA,OATA,oBACA,kBACA,+BACA,sBACA,gCACA,iCACA,iCACA,mCAEA,WAEA,iBAUA,OATA,wBACA,iCAEA,mBACA,4BAEA,mBACA,4BAEA,KAEA,WACA,cACA,iBACA,KACA,6BACA,uBAGA,CAEA,OADA,oBAAyB,wBAAsC,EAC/D,KAEA,cAWA,OAVA,oBAAyB,2BAAyC,EAClE,wBACA,6BAEA,mBACA,wBAEA,mBACA,wBAEA,KAEA,cACA,WACA,OACA,OACA,kBACA,aACA,aACA,qDACA,cAEA,aADA,KACA,kBACA,0BACA,yBACA,YACA,uCACA,kDACA,4BACA,wBAEA,kBACA,CACA,mCACA,wBACA,mCAGA,gCACA,yBACA,oBACA,gBACA,wBACA,YACW,GACD,kCACV,yBACA,oBACA,kBACA,wBACA,YACW,EAEX,EAAQ,IACR,uBAEA,OADA,+BAEA,uCACA,kDACA,4BACA,kBACA,uBACA,yCAEA,uBAEA,mBACA,wBACA,2CAEA,wBAKA,YAEA,OADA,mCACA,UACA,MAEA,WACA,uCACA,kDACA,4BACA,kBACA,uBACA,yCAEA,uBAEA,mBACA,wBACA,2CAEA,wBAEA,wBAGA,CAUA,OATA,UACA,qBAEA,UACA,qBAEA,UACA,qBAEA,KAGA,mBACA,mCACA,YACA,uBACA,aACA,wBACA,QACA,CACA,6BAEA,CACA;AACA;;AAEA;;AAEA,CAAC,EACD;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,CAAC,QACD,GACA,cACA,kBACA,eACA,iBACA,eACA,CACA,YACA,wBACA,YAEA,CADA,oBACA,yBACA,qDACA,2BACA,0BAEA,cACA,CACA,CACA,WACA,wBACA,kBACA,4BACA,UACA,gBACA,kBACA,UACA,YAA0B,mBAAqB,CAC/C,YAA0B,UAAmB,CAC7C,aAA2B,UAC3B,CACA,CAAS,CACT,kCACA,CAEA,iBAEA,QACA,kBACA,cACA,CACA,kBACA,oBAEA,CACA,oBACA,iBACA,QACA,WACA,OACA,IACA,OACA,gBACA,IACA,OACA,OACA,OACA,OACA,OACA,OACA,SACA,2BACA,OACA,OACA,KACA,KACA,SACA,OACA,QACA,mBACA,YACA,mBACA,YACA,SACA,OACA,OA4BA,cACA,+BACA,UACA,OAEA,gBACA,QACA,qCACA,iBAAmC,+BAA2C,EAE9E,CACA,aACA,kCACA,uCACA,qCACA,mCACA,wCACA,sCACA,+BACA,8CACA,YAAsB,WAAwB,KAC9C,UACA,YACA,UACA,mBACA,CACA,OACA,OACA,UACA,qBACA,OACA,OACA,OACA,OACA,OACA,SACA,kBACA,mBACA,+BACA,iBAA4B,kBAAoB,CAChD,CAyHA,cACA,YAAsB,mBAA0B,KAChD,mBACA,eACA,OACA,UACA,mBAEA,CACA,YAAsB,iBAAwB,KAC9C,iBACA,eACA,WACA,YAA2B,WAAyB,IACpD,gBACA,UACA,IACA,KACA,EAAc,oBACd,OACA,IACA,KACA,CAEA,eACA,CACA,WACA,GACA,YAEA,CACA,CA3NA,yBACA,gBACA,qBACA,+BACA,WAKA,OAJA,aACA,SACA,QAEA,qBACA,EACA,mCACA,WAKA,OAJA,aACA,SACA,QAEA,gBACA,EACA,yBACA,WAKA,OAJA,aACA,SACA,QAEA,gBACA,EA0CA,2CACA,IACA,qBACA,qFAEA,EACA,uCACA,IACA,qBACA,wFAEA,EACA,kCACA,WACA,EACA,mCACA,GACA,EACA,6BACA,mBACA,EACA,2BACA,QACA,EACA,yBACA,QACA,EACA,2BACA,QACA,EACA,kCAEA,UADA,MACA,CAeA,GAdA,sBACA,+BACA,oCACA,kCACA,gCACA,qCACA,mCACA,4BACA,2CACA,qBACA,2BAEA,oBACA,aACA,+BACA,OACA,sBACA,SACA,cACA,kBACA,wBACA,EACA,0BACA,qBAAsC,YAAwB,EAC9D,mBACA,qDACA,SACA,mBACA,oBACA,CACA,OAlgfA,KAmgfA,KAjhfA,KAkhfA,8BACA,yBAGA,EAAU,IACV,WACA,OACA,MACA,WACA,mDACA,YA1gfA,KADA,KA4gfA,YAnhfA,KALA,MA0hfA,OACA,oBACA,cACA,aACA,EAEA,EADA,4BACA,yBACA,qBAAsC,WAAuB,EAC7D,mBACA,6CACA,SACA,eACA,gBACA,CACA,OA/hfA,KAgifA,KA9ifA,KA+ifA,kGACA,wBACA,8BACA,wBACA,6CAGA,CACA,sBACA,qBACA,OACA,mCACA,gBACA,UACA,kBACA,iBAA8B,oBAAsB,CACpD,CACA,EACA,wCACA,YACA,6BAEA,EACA,gCACA,0BACA,EAiCA,aACA,SAoCA,gBACA,SACA,6BAEA,uDAEA,iDACA,CACA,kCAkCA,MAjCA,mBACA,aACA,OACA,oBACA,+BACA,8BAEA,uBACA,oBACA,0BACA,qBACA,iBACA,eACS,EACT,SACA,SAEA,8BACA,8BACA,0CACA,eACA,YACA,OACA,YAAsB,WAAqB,IAC3C,SAEA,cACA,SAvEA,OACA,uCACA,uCACA,sBACA,8BACA,8BACA,kBACA,kBACA,gBACA,gBACA,gBACA,gBAGA,WACA,SAMA,GALA,yDACA,gBACA,gBACA,uDACA,kDACA,WACA,4CACA,8DACQ,CACR,UACA,MAKA,mCAJA,EAfA,EAeA,EACA,EAfA,EAeA,MACA,QACA,QACA,KACA,2DACA,CACA,EAqCA,OAEA,4CAIA,EAFA,EAEA,EAFA,EAGA,QADA,EAFA,GAIA,8BAEA,6BACA,kBACA,kCAEA,oDACA,wBACA,4CACA,0DACA,wBACA,uDACA,SAfA,EAkBA,0BACA,QACA,EACA,6BACA,sBAGA,QACA,EACA,8BACA,IACA,UACA,qBAEA,qCACA,oBAEA,EACA,gCACA,yBAEA,oCACA,mBACA,EACA,WAyEA,SACA,mBAzEA,cAGA,GAFA,wBACA,IACA,UACA,aACA,YACA,8CACA,sBAEA,QACA,+BACA,mBACA,MAEA,YAAwB,WAAkB,KAC1C,WACA,OACA,YACA,uBACY,CACZ,6BACA,aACA,QACA,0BACA,EACA,eACA,kDAEA,qBAEA,CACA,UACA,cACA,WACA,iBACA,kBACA,QAEA,uCACA,oDACA,iDACA,4DACA,yCACA,QACA,wBACA,qDAEA,QACA,iBAEA,CACA,wBACA,mCACA,iCACA,0BACA,yBAEA,CACA,CACA,YAAsB,WAAwB,KAC9C,WACA,cACA,eACA,kBAEA,CACA,UACA,kBACA,iBAA8B,6BAAqC,EAEnE,MACA,GAGA,kCACA,GACA,EACA,wBACA,CACA,CACA,CACA,cACA,UACA,iBACA,gBACA,yBACA,iBAEA,sBACA,CAqDA,gBACA,0BACA,SACA,8BAEA,YACA,sEAEA,QACA,kBACA,yBAEA,aACA,4BACA,mCAEA,YACA,0BACA,gCACA,8BACA,YACA,yBAGA,cACA,8BACA,oCACA,wCACA,YACA,8BAGA,oBACA,0CACA,gDACA,8CACA,6CAEA,gBACA,kCACA,yCAEA,gBACA,kCACA,yCAEA,eACA,gCAEA,eACA,WACA,mBACA,IACA,iBACA,WACA,SACA,SACA,SACA,gDACA,SACA,UAEA,oEACA,sEACA,oCACA,kBACA,2CAEA,aACA,4BACA,8CACA,mCAEA,UACA,sBACA,wCACA,4BAEA,CAuKA,OACA,mBA1SA,cACA,uCACA,SACA,uBACA,sBACM,aACN,8BAEA,EAmSA,wBAlSA,wBA4KA,IAJA,IASA,IAeA,MAqFA,IA3JA,IAQA,IAKA,QAiBA,GAvJA,wBAEM,wBACN,OACM,sBACN,OAsKA,EArKA,EAsKA,CADA,EArKA,GAsKA,aACA,qCAtKM,uBACN,OA+JA,EA9JA,EA8JA,EA9JA,EA+JA,kCACA,8CA/JM,0BACN,OAqKA,EApKA,EAoKA,EApKA,EAqKA,8BACA,iBACA,oCACA,2CAEA,8BACA,iBACA,oCACA,2CAEA,UACA,4CA/KA,2BAkLA,EAjLA,EAiLA,EAjLA,EAiLA,EAjLA,EAkLA,kBACA,YACA,8DACA,wCACA,kBACA,sCACA,6CAEA,sBACA,8CACA,sDAGA,gBACA,8BACA,gDACA,iBACA,oCACA,2CAEA,0BACA,sDACA,6DAEA,uBACA,gDACA,sDACA,0DAjmgBA,IAkmgBA,QACA,wCAIA,gBACA,kCAEA,kBACA,kCACA,wCACA,mEACA,mEACA,mBACA,wCACA,+CAEA,4BACA,0DACA,kEAGA,mBACA,oCACA,yCACA,sDACA,oBACA,0CACA,iDAEA,8BACA,iBACA,oCACA,2CAEA,kDACA,mDAEA,iBACA,sHACA,kBACA,sCACA,8CAGA,8CACA,4CACA,qBACA,4CACA,mDAEA,yBACA,oDACA,6DAjQM,wBACN,OAmQA,EAlQA,EAmQA,CADA,EAlQA,GAmQA,QACA,2BAnQM,sBACN,OACM,0BACN,OACA,SAkQA,KACA,qBACA,+DACA,0CACA,yCAtQA,MACM,uBACN,OACM,uBA+FN,EA9FA,EA8FA,EA9FA,EA+FA,8BACA,0BACA,QACA,kBACA,yBAlGA,yBAqGA,EApGA,EAoGA,EApGA,EAqGA,4BACA,uCACA,wBArGM,oBAuGN,EAtGA,EAsGA,EAtGA,EAsGA,EAtGA,EAsGA,EAtGA,EAuGA,8BACA,0BACA,sBACA,mBACA,QACA,kBACA,wBAEA,aACA,4BACA,mCAEA,eACA,iCAnHM,oBAsHN,EArHA,EAqHA,EArHA,EAsHA,8BACA,0BACA,4BACA,QACA,kBACA,yBAEA,aACA,4BACA,mCAEA,eACA,iCAjIM,oBACN,4BACA,2BACM,oBACN,yBAEA,CAyPA,CACA,CACA,qBACA,SACA,KACA,KACA,gDA+IA,cACA,OACA,WAEA,SAEA,EAwBA,MAvBA,yCACA,aACA,aACM,aACN,aACA,aACM,wBACN,cACA,cACM,aACN,cACA,cACM,aACN,cACA,cACM,aACN,cACA,cACM,YACN,4FAEA,uEAEA,CACA,CACA,cACA,eACA,mCACA,uCACA,cACA,wBACA,eACA,eAUA,OACA,KAhMA,cACA,gBACA,0BACA,EA8LA,OA7LA,cACA,mBACA,QACA,SAwGA,GACA,iBACA,IAEA,uBAA0C,IAAO,KACjD,sCACA,uBAAgD,IAAQ,KACxD,WACA,2CACA,uBAA4C,IAAQ,KAEpD,QADA,MAEA,IATA,GAUA,eACA,MACA,KACA,OAbA,GAaA,aACA,IAdA,GAcA,GAEA,oEACA,aACA,aAEA,CACA,CACA,QAtBA,EAuBA,UAvBA,GAuBA,GACA,WACA,YAEA,EAtIA,GACA,WAYA,GACA,iBAYA,YAAoB,IAAsB,IAC1C,qBAEA,OADA,UACA,EAIA,OADA,uGACA,CACA,GAnBA,yBACA,uBACA,WACA,UAKA,OAJA,iCACA,mCACA,oCACA,uCACA,CACA,EAvBA,GACA,UACA,iCAEA,gBACA,wBACA,oBACA,eACA,SA0BA,GACA,cACA,aACA,YACA,iCACA,uBAA2C,IAAQ,KACnD,sCACA,uBAAgD,IAAQ,KACxD,WACA,QAkCA,kBACA,cACA,UACA,iBAMA,MALA,wCACA,OAEA,eAEA,EACM,EACN,WACA,2CACA,UAEA,OADA,OACA,EACA,MAEA,oBAEA,OADA,UACA,EAGA,CACA,QACA,EA3DA,UACA,iBACA,2CACA,IACA,YAA0B,WAAmB,KAC7C,WACA,MACA,0CACA,cACA,gDACc,aACd,0BACA,0BACA,0BACA,cACA,0BACA,0BACA,0BACA,cACA,0BACA,0BACA,2BACA,iBAEA,sBACA,4CAEA,CACA,4CACA,CACA,CACA,CACA,mCACA,EApEA,GACA,UAEA,EA+KA,QAXA,WACA,eACA,qBAEA,KACA,KACA,IACA,CAKA,CACA,CACA,SACA,gBAA6B,EAC7B,IAcA,EAwGA,QACA,cACA,YACA,QACA,MA1HA,CACA,oBAz8eA,mBAEA,OADA,wBACA,CACA,GAs8eA,CACA,eACA,WACA,aACA,WACA,eACA,wBACA,2BACA,4BACA,kCACA,wBACA,CAAM,EAGN,GAFA,wBAEA,UACA,iFACA,yEAEA,kCACM,IACN,IAEA,yBACA,oBACA,OACA,OACA,KACA,KACA,kBACA,YAKA,qBAKA,kBACA,EACA,kBACA,uBACA,uBACA,yBACA,oBACA,uBACA,6BACA,0BACA,iBAj4gBA,EAk4gBA,2BACA,WACA,KACA,IACA,IACA,OACA,KACA,OACA,SACA,SACA,OACA,aACA,KACA,WACA,YACA,KACA,QACA,QACA,qBACA,qBACA,MACA,UACA,MACA,MACA,UACA,UACA,UACA,UACA,IAA0B,4EAC1B,MACA,cACA,oBACA,CACA,SACA,iBACA,wBACA,CACA,IAeA,GAJA,8DAAoF,IACpF,KAD6F,aAC7F,2BACA,iDACA,sDACA,WACA,eAEA,GADA,QAhBA,CACA,SACA,QACA,UACA,YACA,qBACA,wBACA,kBACA,8BACA,GAQA,UACA,SACA,gFAEA,4CAGA,CACA,CAAM,SAEN,MADA,iDACA,CACA,CAMA,cACA,eACA,OACA,eACA,mBACA,eACA,yBACA,gCAEA,aACA,SACA,yBACA,YACA,YACA,aACA,eACA,mBACA,mBACA,iBACA,YACA,wBACA,cACA,SACA,YACA,wBACA,gBACA,mBACA,iBACA,iBACA,sBACA,iBACA,eACA,eACA,gBACA,cACA,UACA,QACA,CACA,KACA,oBA2KA,eACA,mBACA,kDACA,IACA,CACA,cACA,sDACA,KACA,kBACA,YACA,eACA,gBACA,SACA,KACA,cACA,YACA,eACA,gBACA,QACA,CACA,eACA,oGACA,CACA,mBAKA,EAJA,eACA,oCAIA,SAGA,GACA,6BACA,QACA,sBACA,mBACA,CAAS,EACT,oBACA,wBAGA,EAdA,EAFA,GAIA,WAHA,CAwGA,mBACA,oBAt0hBA,IAs0hBA,gCACA,OAx0hBA,EAy0hBA,iBACA,UACA,OA50hBA,EA60hBA,iBACA,UACA,OA70hBA,GA+0hBA,SAEA,CAzTA,WACA,2BACA,SACA,EACA,qCACA,gCACA,EACA,iCACA,iCACA,mBACA,EACA,oCACA,iCACA,sBACA,EACA,8BACA,SACA,EACA,+BACA,aACA,KACA,uBACA,EACA,yBACA,mBACA,EACA,gCACA,+BACA,sFAGA,KACA,KACA,yBACA,0BACA,SACA,qBACA,uBAEA,yBACA,EACA,sCACA,iCACA,EACA,0CACA,KACA,KACA,KACA,wBACA,yBACA,yBACA,EACA,oCACA,gBACA,EACA,6BACA,iBACA,EACA,mCACA,YACA,wBAEA,gBAEA,iDACA,EACA,4BACA,iBACA,EACA,kCACA,YACA,wBAEA,gBAEA,gDACA,EACA,+BACA,SACA,EACA,gCACA,sBACA,EACA,+BACA,IACA,EACA,oCACA,IACA,EACA,+BACA,gCACA,EACA,8BACA,kCACA,EACA,8BACA,wBACA,EACA,8BACA,kCACA,EACA,oCACA,QACA,MACA,SACA,aACA,uBACA,sBAhjhBA,OAgjhBA,CACA,CACA,MACA,qBACA,EAxkhBA,OAwkhBA,uBA9jhBA,OA8jhBA,GAhkhBA,OAgkhBA,GA/jhBA,OA+jhBA,EACA,oBACA,oBACA,MACA,MACA,MACA,GACA,OACA,OACA,OACA,OACA,kCAEA,OACA,OACA,OACA,OACA,+BAEA,EAAU,IACV,uBAGA,GACA,yBAEA,IACA,yBACA,gDAEA,WACA,EACA,2BACA,oBACA,EACA,2BACA,oBACA,EACA,6BACA,oBACA,EACA,wBACA,gDACA,oDACA,yDACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,aACA,0CACA,wCACA,SACA,EA4CA,kDA8BA,CA7BA,kBACA,8CACA,WAqhBA,eAoMA,GAnMA,wBACA,sBACA,YACA,8CACA,8EACA,kDACA,6EACA,0DACA,+BACA,6BACA,4BACA,EA3uiBA,CA4uiBA,eACA,qCACA,kBAGA,oFACA,wBACA,WACA,iBACA,YACA,kBACA,sBACA,iBACA,CAEA,QACA,yBACA,uDAEU,wBAEA,iCACV,KACU,iCAEA,8DAEA,8DAEA,qCACV,KACU,qCAEA,iCACV,KACU,iCAEA,mEAEA,mEAEA,kEAEA,kEAEA,cAEA,uBAEA,0GAEA,oBAEA,sBAEA,oBAEA,oBAEA,mBAEA,kBACV,KACU,yBACV,OA5BA,KAJA,KARA,MA2CA,KACA,uBAEA,sBACA,SACA,cAEA,SACA,KACA,KACA,+BAUA,GATA,0BACA,KACA,KACA,MAEA,WACA,OACA,MAEA,UAEA,GADA,8BACA,CACA,4BAn6gBA,MAo6gBA,GAp6gBA,SACA,qBACA,qBACA,wBACA,wBAGA,kBACA,YAEA,eACA,eAEA,aACA,gBAw5gBA,oCACA,EAAU,IACV,qDAEA,iDACA,0BACA,aACA,uDAEA,0BACA,WACA,GACA,gBACA,gCAGA,6IACA,4DAEA,QACA,IACA,KACA,KAEA,CACA,oBACA,iCACA,wCACA,iBACA,IACA,6CACA,6CAEA,CACA,kBACA,sCACA,sDACA,wCACA,wDACA,2CACA,yBACA,0DAGA,wBAoCA,GAnCA,4DACA,gBAEA,yCACA,gCACA,gDAEA,2CACA,iBACA,uEAEA,iEACA,iDAEA,IACA,2DACA,gBA6BA,EA5BA,EA4BA,EA5BA,EA6BA,kCACA,2BACA,kCACA,wCACA,4BACA,kCACA,2BACA,iCACA,+BACA,kCApCA,eACA,0BAEA,4EACA,yBAEA,gDACA,wBACA,yBAEA,oBACA,iCAEA,mDACA,6CACA,2CACA,2CACA,uBACA,uBAA2C,IAAO,KAClD,WACA,cACA,WACA,CACA,CACA,QACA,EAxtBA,WACA,mBACA,cACA,IACA,qBAEA,YADA,+BACA,OACA,GACA,CACA,kBACA,wBACA,YACA,qBACA,YACA,wBACA,mCAEA,UACA,gBACA,6BACQ,IACR,gBACA,uBAEA,UACA,uBACA,mBAEA,QAMA,GALA,WACA,WACA,MACA,aAEA,SACA,kBACA,0CACA,qBAEA,6BAEQ,aACR,uBACA,aACA,uBACA,iBACA,oBACU,aACV,wBAEA,wBAEA,EAAQ,eACR,qBACQ,YACR,wBAEA,mBACA,gCACA,+GAEA,6BAWA,+EAXA,CACA,yBACA,qBACA,oBACA,+BACA,wCACA,YAA4B,IAAgB,IAC5C,8BACA,qBAEA,EAAY,IAIJ,qBACR,oCACQ,gCACR,2DACA,8BACA,wBACA,EAAQ,IACR,aAEA,EAcA,kCACA,gBACA,aACA,QACA,UACA,8BACA,qCACA,eACA,cACA,gBAGA,CAAO,EACP,OACA,8BACA,qCACA,eACA,cACA,gBAGA,CAAS,EAET,gBACA,cAqBA,OApBA,uBACA,iDACA,OAEA,iBACA,KACA,oBACA,YAA4B,WAAqB,KACjD,WACA,UACA,QACA,MAEA,UACA,QAGA,CAAO,EACP,QACA,OACA,CACA,EACA,uCACA,0BACA,uBACA,aAQA,GAPA,sBACA,SACA,eACA,WACA,WAEA,CAAW,EACX,uBACA,KAGA,gBACA,CACA,4CACA,IAEA,gBAEA,CAAO,CACP,EACA,YAIA,cACA,SACA,CACA,cACA,UACA,CACA,cAiGA,qBACA,yBAEA,GADA,wBAEA,cACA,qBACU,WACV,oCACU,aACV,eACA,cACA,qBAEU,cACV,8CACA,GACA,yDAEA,kBACA,aACA,WACA,yBAEA,OACU,qCACV,4CACA,kBACA,aAWA,GAVA,IACA,2BACA,mDACA,mCAEA,mDACA,kCAEA,iDAEA,kBACA,eACA,uBAAiD,IAAO,KACxD,WACA,qBACA,cACA,sBAEA,CACA,EAAc,eACd,yBAEA,CACA,CAEA,iBACA,uBAA2C,IAAO,IAClD,cAEA,CACA,qBACA,eACA,iBACA,gBACA,qBACA,8CACA,yBACA,sBACA,sBACA,sBACA,4BACA,4BACA,4BACA,sBACA,CACA,qBAEA,UADA,yCAEA,MAEA,kDACA,oDACA,mBACA,2EA/giBA,KAPA,KAuhiBA,UAxhiBA,KAyhiBA,UACA,gBACA,sBACA,wBACA,iCACS,EAET,6CACA,gBACA,mBACA,0BACA,qBACA,oBACA,uBACA,gCACA,UACA,gBACA,oBACA,cAnkiBA,EAokiBA,iBAOA,GANA,yCACA,qBACA,8CACA,UACA,mCACA,8BACA,oDACA,SACA,uBAAwD,IAAO,KAC/D,WACA,WACA,aACA,aACA,UACA,GAzniBA,IAyniBA,iCACA,aACA,OA5niBA,EA6niBA,iBACA,gBACA,SACA,iBACA,IACA,CACA,CACA,SACA,mCACA,8BAEA,CACA,qBACA,uBACA,2BACA,eACA,CACA,mBACA,6CACA,uBAA8C,IAAO,KACrD,WACA,WACA,aACA,wBACA,UACA,yBACA,eAEA,CACA,CACA,yBACA,8BACA,uEACA,kDACA,8BACA,wDACA,OAjqiBA,EAkqiBA,iBACA,kCACA,OArqiBA,EAsqiBA,iBACA,kCACA,OAtqiBA,GAwqiBA,kCAEA,4BACA,CACA,uBAySA,CAxSA,wBACA,eACA,iBACA,uBACA,kBACA,mCACA,0BACA,aACA,0DACA,YACA,qEACA,8FACA,aACA,iCAEA,WADA,WAGA,eACA,cACA,mDAEA,OADA,QACA,CACA,MAEA,4BACA,uBACA,wBACA,WACA,sBAEA,iBA8BA,MA7BA,8DACA,6BAEA,QACA,cAsQA,CADA,EArQA,GAsQA,oJArQA,uBACA,gBACA,0CACA,iCACA,8CACA,0DACA,gCACA,4CACA,wCACA,mCACA,mCACA,kCACA,8CACA,sCACA,0DACA,gEACA,4CACA,gDACA,0CACA,8CACA,qDAEA,mBACA,oBACA,CACA,CACA,eACA,0BACA,oCACA,iDACA,CACA,sBAEA,iBACA,cACA,uCACA,sBACA,gCACA,0BACA,oCACA,oCACA,sBACA,8BACA,8BACA,4BACA,wCACA,wCACA,wCACA,8BACA,kCACA,4BA/VA,oBAVA,YACA,SACA,GASA,8CACA,kCACA,KACA,uBACA,6BACA,EACA,uCACA,qCACA,0BACA,2CACA,wFAGA,iBAkBA,GAjBA,oDACA,qEACA,wCACA,6CACA,kBAEA,0CACA,sBACA,QACA,UACA,6DACA,+BACA,6BACA,kCACA,sBACA,OACA,UACA,uCACA,gCACA,WACA,0BAEA,CACA,wBACA,WACA,oBACA,cAGA,CADA,sEAEA,uBAEA,yBACA,0BACA,2BACA,gBACA,wBACA,4CACA,eACA,iBAEA,GADA,gBACA,iBACA,gBACA,cACA,uBAA8C,IAAO,IAErD,SADA,KAIA,iBACA,uBAA4C,IAAO,KACnD,WACA,oBACA,CACA,EAAQ,IACR,wBACA,gBACA,SAEA,YACA,mCACA,+BAEA,uCACA,sBACA,KACA,OACA,QACA,YACA,gBACA,4DAEA,OAEA,QAEA,EADA,WACA,cAEA,IAEA,EAqdA,kCACA,QACA,EACA,qCACA,QACA,EACA,gCACA,QACA,EACA,6CACA,kCACA,uCACA,cACA,4BACA,uCACA,6BACA,qDACA,uHACA,0BAGA,EACA,8CACA,cACA,wBACA,oCACA,EACA,yCACA,IACA,IACA,IACA,SACA,OACA,KACA,KACA,MACA,eACA,sCACA,uCACA,UACU,iCACV,4BACU,2BACV,8FACU,kBACV,qBACA,8BACA,4EACA,8FAEA,2BACA,CACA,CACA,gBACA,uEACA,OAEA,kCACA,2BAEA,EADA,oBACA,QAEA,KAEA,MAEA,EADU,0CACV,wCAEA,iBACA,KAEA,EAGA,mBACA,kBACA,iBACQ,IACR,sCACA,sCACA,KASA,GAPA,qCACA,GACA,mBAEA,cACA,aACA,oBACA,GACA,uBACA,gHACA,EAAQ,UACR,uBAEA,qFADA,KAEA,CACA,IACA,EACA,oDACA,2CACA,0GAGA,kCAIA,GAHA,uCACA,SAEA,GACA,oCACA,IACA,gBACA,WACA,SACA,2CACA,2HAGA,yCACA,oIAGA,0CACA,kDAEA,EAAU,OACV,gDACA,mCACA,CACA,CACA,EACA,+DACA,+BACA,wGAEA,kCAIA,GAHA,uCACA,SAEA,GACA,gBACA,WACA,SACA,+BACA,8HAEA,6BACA,wIAEA,gDAtrhBA,EAurhBA,oCACA,wBACA,sCACA,gEACA,mDACA,gDACA,oCACA,oDAOA,OANA,WACA,OAhshBA,EAgshBA,GA/rhBA,0BAaA,WAZA,aACA,wBA6rhBA,EA7rhBA,8BACA,mBACA,IACA,KACA,wBACA,aAwrhBA,GAvrhBA,KACA,SACA,GACA,CACA,EAmrhBA,EAjrhBA,CAAG,GAkrhBH,sCACA,8CACA,mBACA,iBACA,CACA,CACA,CADU,KACV,iGAEA,CACA,EACA,qDACA,mBACA,8EACA,qBACA,gBAEA,qBACA,8BACA,+BACA,iBACA,iBACA,oBACA,kDACA,iBACA,EACA,8DASA,YACA,MA4BA,CArCA,oBACA,0EACA,qBACA,eACA,eACA,kBACA,QAIA,wDACA,GACA,kBACA,kBACA,6BACA,UACA,UACA,uBAEA,UACA,WACA,aACA,IACA,IACA,KAEA,UACA,MACA,MACA,QAEA,IACA,IACA,KAEA,0BACA,mBAEA,oBACA,oBACA,iBACQ,kDACR,yBACA,wBAEA,oBACA,iBAEA,+CACA,qEACA,sDACA,4CACA,0CACA,yCACA,uCACA,yCACA,6CACA,gDACA,wCACA,sCACA,wCACA,8CACA,0CACA,8CACA,eACA,WACA,0BACA,0BACA,4DACA,4DACA,YAAwB,IAAY,IACpC,GACA,mGAEA,kBACA,GACA,mGAEA,oEACY,EACZ,0CAEA,0CAGA,4CACA,2CACA,EAAQ,IACR,EACA,mCACA,6CACY,2BACZ,qDAEA,wCAGA,gBACA,qDACY,sBACZ,0EAEA,gDAIA,uCACA,yCACA,wCACA,sCACA,wCACA,0BACA,qBAEA,iBACA,EACA,4DAUA,MATA,mBACA,4EACA,qBACA,qBACA,eACA,eACA,mBAEA,8GACA,oCACA,EACA,kCACA,sCACA,sBAEA,EACA,6BACA,gBACA,sBACQ,kBACR,oBACQ,iDACR,yBAEA,oBAEA,iBACA,EACA,2BACA,IACA,IACA,OACA,UACA,SACA,EACA,wCACA,4DAAoE,YAAc,EAElF,CACA,uBACA,OArpjBA,GAspjBA,CACA,uBACA,6BACA,CACA,wBACA,yBACA,uBACA,6DACA,4CACA,CACA,CACA,oBACA,cACA,QACA,gBACA,kBACA,qBACA,sBACA,cACA,4BACA,2BACA,+BACA,4BACA,gCACA,2BACA,wCACA,4DAAoE,YAAc,EAElF,CACA,UAYA,OAXA,gBACA,4DACA,+DACA,uCACA,iDACA,+CACA,mDACA,iDACA,qDACA,8EACA,yCACA,IACA,CACA,UACA,sBAOA,OANA,kDACA,uFACA,sFACA,8DACA,yFACA,gEACA,CACA,CACA,CACA,SACA,iBACA,4BACA,aACA,cACA,mCACA,WAptjBA,MAqtjBA,qBACA,eACA,cACA,CACA,mBACA,CACA,mBACA,sBACA,CACA,YAEA,OADA,aACA,KAEA,oBACA,8BAA6B,UAAc,CAC3C,CACA,oBACA,0BACA,CACA,QAKA,OAJA,4CACA,mBACA,qBACA,mBACA,KAEA,cACA,eACA,YACA,0BAAqC,IAAO,IAC5C,6BAEA,YAEA,WAEA,OADA,oBACA,KAEA,SACA,yBACA,oBAEA,kCACA,+BAEA,kDACA,qEAEA,0EACA,sCAEA,OADA,uBACA,CACA,CACA,YAEA,OADA,wBACA,KAEA,UAUA,OATA,yBACA,oBAEA,kCACA,+BAEA,kDACA,yFAEA,CACA,eACA,+BACA,iCACA,kBACA,CACA,CACA,CACA,aACA,UACA,wBACA,qCACA,aACA,YACA,gBACA,cACA,iBACA,CACA,YACA,uBAEA,YACA,uBAEA,mBACA,uBACA,CACA,gBACA,8BAAyC,IAAO,IAChD,+BACA,mBACA,8BAEA,YAEA,qBACA,yBAAoC,IAAO,IAC3C,+BACA,wBACA,8BAEA,YAEA,sBACA,yBAAoC,IAAO,IAC3C,+BACA,yBACA,8BAEA,YAEA,kBACA,mDAEA,OADA,sCACA,CACA,CACA,oBAGA,OAFA,sCACA,oDACA,KAEA,UAGA,OAFA,sCACA,kDACA,KAEA,UAGA,OAFA,sCACA,oDACA,KAEA,UAGA,OAFA,sCACA,oDACA,KAEA,UAGA,OAFA,sCACA,oDACA,KAEA,QACA,sDAEA,OADA,sCACA,CACA,CACA,QACA,wDAEA,OADA,sCACA,CACA,CACA,QACA,wDAEA,OADA,sCACA,CACA,CACA,QACA,wDAEA,OADA,sCACA,CACA,CACA,aAQA,OAPA,iCACA,kBACA,mBACA,oBAEA,uBACA,uBACA,KAEA,gBAUA,OATA,iCACA,kBACA,mBACA,mBACA,oBAEA,uBACA,uBACA,uBACA,KAEA,mBAYA,OAXA,iCACA,kBACA,mBACA,mBACA,mBACA,oBAEA,uBACA,uBACA,uBACA,uBACA,KAEA,SACA,cAiBA,OANA,+BACA,0BAEA,+CACA,0DAEA,sFAjBA,EACA,iIACA,SACA,YAAsB,aAAgB,KACtC,qCACA,YAAwB,gBAAmB,IAC3C,4BAEA,CACA,0EACA,CASA,CATM,OAUN,GACA,cAsBA,OANA,+BACA,0BAEA,+CACA,2DAEA,CACA,gCACA,uBACA,oBACA,mBACA,2BA3BA,EACA,sIACA,SACA,YAAsB,aAAgB,KACtC,qCACA,YAAwB,gBAAmB,IAC3C,4BAEA,CACA,OACA,uBACA,iCACA,QACA,2BAEA,CAeA,CAfM,CAiBN,oBACA,kBACA,sBACA,CACA,eACA,QACA,yBACA,4BACA,cACA,mBACA,gBACA,wBACA,oBACA,YACA,iBACA,CACA,QAQA,OAPA,cACA,yBACA,eACA,yBACA,yBACA,uCACA,eACA,KAEA,CAEA,cACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,SACA,qBACA,sBAIA,GAHA,QACA,iBACA,mBACA,YACA,SAuBA,aAtBA,kBACA,IACA,IACA,EACA,EACA,EACA,GACA,IACA,EACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,IACA,GACA,EACA,EACA,EACA,EACA,GACA,0BACA,4CACA,qCACA,CACA,gBACA,gBACA,yBACA,CACA,iBAYA,GAXA,kBACA,uGAEA,wCACA,8BACA,oFACA,+CACA,kEACA,yBAEA,6BAEA,QACA,cACA,eAEA,kBACA,kCACA,iCACA,gCACA,YACA,YACA,YACA,8CACA,cACA,iCACA,YAEA,OADA,6CAEA,OAGA,kCACA,mBACA,QACA,WACA,iBACA,oDACA,UACA,YACK,CACL,CACA,UAIA,OAHA,gBACA,8CACA,yBACA,KAEA,CACA,yBACA,6CACA,YACA,mBACA,oBAEA,YAEA,UACA,UACA,UACA,kBACA,CACA,cACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,SACA,qBACA,iBACA,WACA,sBACA,wBACA,iBACA,uBACA,8BACA,sBACA,wBACA,CACA,qBACA,2BACA,kBACA,0BAEA,6BACA,iCACA,YAAoB,UAA6B,IACjD,6BACA,kCAEA,CACA,wBACA,2BACA,qBACA,6BAEA,gCACA,iCACA,YAAoB,UAA6B,IACjD,6BACA,qCAEA,CACA,UAQA,OAPA,gBACA,yBACA,mCACA,iDACA,yBACA,+DACA,wEACA,KAEA,aACA,oBACA,mBACA,cACA,yDACA,6BACA,mBACA,kCACA,oBACA,gCACA,0BACA,uCADA,GAGA,mCACA,CACA,uBAGA,OAFA,6BACA,6BACA,CACA,CACA,UACA,gBACA,aACA,2BACA,kCACA,oBAEA,wBACA,uCACA,CACA,OACA,oBACA,CACA,uBACA,aACA,sCACA,sBAA0C,IAAO,KACjD,2BACA,2BACA,SACA,oBAEA,eAEA,4BACA,CACA,CACA,qBACA,2BACA,mBACA,uDACM,2BACN,sDAEA,wEAEA,CACA,wBACA,oBACA,gBACA,iDACA,kDACA,yCACA,aACA,YAAoB,IAAO,KAC3B,yBACA,UACA,yBACA,8DACA,iDACA,CACA,CACA,6CACA,CACA,CACA,oBACA,cACA,QACA,eACA,gBACA,CACA,CACA,oBACA,uCA50kBA,IA40kBA,GA50kBA,IA40kBA,MACA,8BACA,sBACA,iBAAmB,oBACnB,wBACA,cACA,sBACA,CACA,CACA,cACA,SACA,UACA,uBACA,eACA,sBACA,oBACA,uBACA,sBACA,WACA,CACA,OACA,iBACA,oBAEA,GADA,gDACA,aACA,8BAEA,wBACA,gGACA,qBACA,gCAAgD,IAAQ,IACxD,8BAEA,CAEA,CACA,oBACA,2BACA,gCAA4C,IAAQ,KACpD,YACA,gBACA,2CAEA,yBACA,CACA,CACA,OACA,gCAA4C,IAAQ,KACpD,oBACA,GACA,iDAEA,CACA,gCAA4C,IAAQ,KACpD,oBACA,IACA,2BACA,6CACA,kCAEA,6BAEA,oDAEA,CACA,CACA,SACA,iBACA,oBACA,oBACA,mBACA,uBAAuC,IAAQ,KAC/C,+BACA,4BACA,kBACA,CACA,UACA,kBAEA,CACA,QACA,2CACA,CACA,qBACA,qCAGA,mBADA,YADA,mBACA,IACA,KACA,yBACA,mBAj5kBA,KARA,MA65kBA,OAHA,iBACA,oBACA,mBACA,KAEA,iBACA,gCAA4C,IAAQ,KACpD,oBACA,cACA,QAEA,CAEA,CACA,UACA,0BACA,2BACA,sBAEA,CACA,cACA,iBACA,6BAA2C,IAAO,KAClD,iBACA,YACA,QACA,2DACA,UAEA,mBACA,6DACA,CAEA,OADA,YACA,KAEA,SACA,OACA,UACA,YACA,gBACA,2BACA,CAAO,CACP,SACA,eACA,CACA,kBACA,iBACA,oBACA,uBAAsC,IAAO,KAC7C,WACA,qBACA,WACA,gCACA,CACA,QACA,CACA,CACA,oBACA,uBACA,aACA,mCACA,uBACA,CACA,QAGA,OAFA,cACA,yCACA,KAEA,SACA,qBAGA,OAFA,yCACA,gCACA,CACA,CACA,CACA,cACA,UACA,MACA,UACA,UACA,UACA,SACA,qBACA,mBACA,WACA,wBACA,sDACA,wBACA,uBACA,aACA,sBACA,yBACA,YAAoB,IAAW,IAC/B,sBAEA,CACA,qBACA,oBACA,oBACA,kBACA,0BAEA,sBACA,uBAEA,6BACA,YAAoB,IAAW,IAC/B,uBACA,wCACA,0BAEA,CACA,wBACA,oBACA,oBACA,qBACA,6BAEA,yBACA,0BAEA,gCACA,YAAoB,IAAW,IAC/B,uBACA,2CACA,6BAEA,CACA,UAQA,OAPA,gBACA,2CACA,kEACA,qEACA,mBACA,+DACA,wEACA,KAEA,gBACA,yCACA,CACA,iBACA,2CACA,CACA,gBACA,8BACA,qCAEA,IADA,aACA,EACA,YAAoB,WAA6B,IACjD,YAGA,aACA,uBACA,aAGA,IAFA,0BACA,0BACA,wBACA,yDACA,6BACA,mBACA,iCACA,YAA6B,IAA2B,KACxD,uBACA,0BACA,kBACA,iBACA,wBAAsD,IAAO,KAC7D,YACA,eACA,cACA,SACA,CACA,WACA,CACA,CACA,gBACA,2BACA,qFAEA,uCACA,CACA,iBACA,yCACA,CACA,gBACA,8BACA,YACA,2BACA,sEA3klBA,KAbA,KAwllBA,EAEA,yCACA,IACA,YAAoB,WAA6B,IACjD,QAEA,+CACA,KACA,QACA,YACA,CACA,qBACA,CACA,UAMA,OALA,oBAAyB,eAAiB,EAC1C,2BACA,4BACA,wBAEA,KAEA,CACA,oBACA,kBACA,yBACA,CACA,eACA,QACA,4BACA,4BACA,cACA,iBACA,qBACA,sBACA,YACA,iBACA,CACA,QAQA,OAPA,cACA,yBACA,eACA,2BACA,uBACA,yBACA,eACA,KAEA,CACA,cACA,UACA,UACA,UACA,UACA,UACA,SACA,qBACA,+BACA,QACA,eACA,iBACA,gBACA,gBACA,yBACA,CACA,UAIA,OAHA,gBACA,sEACA,yBACA,KAEA,uBACA,oBACA,mBACA,4BACA,MACA,sBAAmD,IAAO,IAC1D,8BACA,4BACA,YACA,wBAEA,0CACA,EAAM,IACN,8GAEA,WACA,CACA,aACA,oBACA,mBACA,0BACA,cAKA,GAJA,mDACA,0BACA,mBACA,aACA,uCACA,oBACA,gCACA,qDACA,MACA,0BACA,UAEA,EADA,aACA,SACA,aACA,0BACA,oCACA,kBAAuC,IAAO,MAC9C,IAEA,iBAFA,UACA,YAEA,IACA,SAEA,CACA,oBACA,IAEA,iBAFA,YACA,UAEA,IACA,SAEA,CACA,EAAM,IACN,0BACA,oCACA,kBAAuC,IAAO,MAC9C,2BACA,IACA,SAEA,CACA,oBACA,2BACA,IACA,SAEA,CACA,CACA,CACA,qBAEA,UADA,UACA,gBACA,iBACA,eACA,cACA,eACA,8BACA,8BACA,uBAAoD,IAAQ,KAC5D,2BACA,mCACA,+BACA,CACA,CACA,CACA,CACA,CACA,yBACA,qCAIA,GAHA,4BACA,4BACA,mCACA,SACA,+BACA,kCACA,2BACA,OACA,WAGA,6CACA,QACA,UACA,eACA,eACA,QACA,CACA,CACA,cACA,SACA,qBACA,iBACA,WACA,uBACA,wBACA,CACA,uBACA,oBACA,mBACA,4BACA,KACA,sBAAmD,IAAO,KAC1D,4BACA,8BACA,oBACA,8BAEA,0CACA,EAAM,IACN,sHAEA,YAEA,CACA,oBACA,iBACA,WACA,mBACA,oBACA,CACA,CACA,oBACA,kBACA,sBACA,CACA,eACA,QACA,yBACA,4BACA,cACA,mBACA,YACA,wBACA,YACA,iBACA,CACA,QAQA,OAPA,cACA,yBACA,eACA,yBACA,iBACA,uCACA,eACA,KAEA,CACA,cACA,UACA,UACA,SACA,qBACA,+BACA,QACA,iBACA,mBACA,gBACA,gBACA,yBACA,CACA,UAIA,OAHA,gBACA,sEACA,yBACA,KAEA,aACA,oBACA,mBACA,4BACA,cAKA,GAJA,mDACA,0BACA,mBACA,aACA,uCACA,oBACA,gCACA,qDACA,MACA,UAEA,EADA,aACA,SACA,aACA,0BACA,oCACA,YAAoC,EAApC,EAA4C,KAC5C,gBACA,4BACA,qBACA,CACA,EAAM,IACN,0BACA,oCACA,YAAmC,EAAnC,EAA0C,IAC1C,4BACA,qBAEA,CACA,CACA,qBAEA,MADA,cACA,gBACA,iBACA,eACA,cACA,eACA,8BACA,8BACA,uBAAoD,IAAQ,KAC5D,2BACA,mCACA,+BACA,CACA,CACA,CACA,CACA,CACA,2BACA,8BACA,QACA,aACA,4BACA,kBACA,iCACA,4BACA,QACA,WACA,2BACA,QACA,QACA,UACA,eACA,eACA,QACA,CAAK,CACL,CACA,CACA,oBACA,qCACA,8BACA,4BACA,YAAmB,kBACnB,eACA,cACA,uBACA,CACA,CACA,oBACA,+BACA,yBACA,wBACA,mBACA,CACA,CACA,SACA,cACA,kBACA,2BACA,CAGA,WAEA,OADA,0DACA,IACA,CAGA,gBACA,6BACA,yBACA,CAEA,eACA,SACA,YAAoB,KAAgB,IACpC,2BAEA,QACA,CAEA,qBACA,SACA,YAAoB,KAAgB,IACpC,6BAEA,QACA,CAEA,YACA,wBACA,oBACA,CAEA,sCACA,8EACA,4BAEA,oBACA,SACA,qBACA,IACA,UACA,YAAoB,KAAgB,IAGpC,OADA,IADA,sBACA,eAEA,IAGA,OADA,uBACA,CACA,CACA,mBACA,oBACA,iBACA,CAEA,oBACA,IAGA,EAHA,oBACA,IACA,WAGA,EADA,GAGA,SAEA,gBACA,WAGA,GADA,KADA,wBACA,IACA,EACA,WACQ,OACR,UACQ,CACR,IACA,KACA,CAGA,KADA,IACA,KACA,eAEA,WACA,SAIA,MADA,GADA,MADA,KAEA,OAEA,CAKA,gBAEA,QADA,KAEA,IAFA,IAGA,YACA,WACA,uBACA,mBACA,iCAEA,OADA,6BACA,CACA,CACA,kBACA,6BACA,2BACA,CACA,yBACA,aACA,KACA,KACA,KACA,SACA,SACA,YAAoB,KAAe,KACnC,SACA,iCACA,CACA,YACA,YACA,uBACA,mBACA,mBACA,mBACA,OACA,IACA,cAEA,OACA,IACA,cAEA,MACA,aAEA,mCACA,0BACA,6BACA,YAAoB,KAAe,KAInC,GAHA,oBACA,oBACA,4BACA,2BACA,cACA,2CACA,0CACA,CACA,4BACA,CACA,WACA,yCACA,KACA,uCACA,OAEA,YAAsB,KAAe,IACrC,gDACA,4BAEA,CACA,OACA,WACA,UACA,WACA,CACA,CACA,QACA,wCACA,CACA,QAEA,OADA,6CACA,KAEA,SACA,OACA,UACA,YACA,aACA,wBACA,CACA,EAGA,OAFA,6CACA,iBACA,CACA,CACA,YAEA,OADA,6CACA,KAEA,CACA,oBACA,uDACA,QACA,6BACA,iBACA,YACA,eACA,SACA,iBACA,iBACA,YACA,aACA,aACA,EACA,WACA,gBACA,gBACA,SACA,KACA,KACA,KACA,IACA,KACA,MACA,IAsDA,cACA,QACA,SACA,SACA,IACA,aACA,cACA,YAAsB,KAAqB,IAC3C,gBACA,cACA,cACA,IAEA,QACA,YAAsB,KAAqB,KAE3C,MADA,IACA,IACA,cACA,aACA,SACA,QACA,QACA,oBACA,cACA,YACA,cACA,gBACA,GACA,CACA,YAAsB,IAAoB,KAC1C,UACA,KACA,QACA,gBAEA,gBAEA,IACA,CACA,2BACA,IACA,CA9FA,CASA,WACA,aACA,SACA,IACA,UACA,YAAsB,KAAqB,KAC3C,SACA,MACA,YACA,YAAwB,KAAqB,KAC7C,UACA,QACA,cACA,aACA,SACA,WACA,QACA,oBACA,yBACA,oBACA,cACA,WACA,CACA,SACA,CACA,YAAsB,IAAoB,IAC1C,YAAwB,IAAoB,KAC5C,cACA,YACA,cACA,YACA,eACA,cACA,MAEA,iBACA,cACA,KAEA,CAEA,kBACA,IACA,KAnDA,SACA,WACA,YAEA,iBACA,0CACA,wCACA,mCAuFA,CACA,QAGA,OAFA,cACA,gCAAsC,eACtC,KAEA,mBACA,2HACA,CACA,CACA,cACA,UACA,UACA,SACA,qBACA,wBAOA,GANA,QACA,0BACA,iBACA,WACA,gBACA,EACA,UAGA,qBACA,eACA,6BACA,oBACA,UACA,gBACA,QACA,KACA,KACA,YAAsB,IAAgB,MACtC,GACA,eACA,iBACA,mBAEA,OACA,SACA,UAEA,MAAgB,SAAU,GAQ1B,GAPA,8BACA,8BACA,8BACA,iBACA,QAAuB,WAzBvB,IAyBuB,KAA4B,GAAG,oBAA4B,GAAG,oBAA4B,EACjH,QAAuB,oBAA4B,GAAG,oBAA4B,GAAG,WA1BrF,IA0BqF,KAA4B,EACjH,QAAuB,oBAA4B,GAAG,oBAA4B,GAAG,oBAA4B,EACjH,sCAGA,YAAwB,IAAO,KAC/B,cACA,OACA,OACA,WACA,WACA,KAA0B,EAAS,GAAG,EAAS,EAC/C,KAAiC,EAAS,GAAG,EAAS,EACtD,cACA,yBACA,oBACA,qBAEA,WACY,QACZ,OACA,YACA,YACA,iBACA,EAEA,CACA,CACA,eACA,SACA,WAAkB,YAAiB,KACnC,4BACA,4BACA,uBACA,sBACA,CAEA,yCACA,CACA,CACA,QAGA,OAFA,cACA,gCAAsC,eACtC,KAEA,CACA,QACA,8BACA,IAKA,cALA,cACA,oBACA,iBACA,KACA,gCAGA,GADA,eAoJA,SACA,IACA,UADA,KAEA,mBAAwC,IAAS,IACjD,SACA,0BACA,qBACA,uBACA,gBAqHA,GACA,YACA,EACA,qCACA,eACI,OACJ,QACA,EA5HA,IAGA,IADA,WACA,IAAc,WAAkB,IAChC,WAOA,KACA,eAQA,KACA,iBACA,YACA,GACA,wCACA,gDACA,eACA,IACA,wBACA,eAEA,CACA,UACI,YACJ,kBACA,oBACA,QACA,IACA,OAYA,IAXA,+DACA,0BACA,4CASA,EATA,EASA,EATA,EAUA,6CAVA,KACA,IACA,MAGA,eACI,OACJ,QACA,EArCA,KACA,MACA,SAEA,cAEA,OADA,aACA,YACA,EAfA,QAEA,QACA,EAnKA,UACA,eACA,SACA,SACA,YAAwB,IAAc,KACtC,OACA,SACA,WACA,WACA,WACA,WAGA,MADA,sBACA,SACA,CAEA,OADA,SAkCA,iBACA,YACA,iBA8JA,SACA,QACA,GACA,iCACA,eACA,eACA,eACI,OACJ,mBACA,aACA,SAEA,GACA,wBACA,GAKA,IAJA,IACA,OACA,OACA,IACA,IAIA,IAHA,IACA,IACA,IACA,IAAkB,MAClB,IACA,WAF8B,KAM9B,IADA,IACA,aACA,8BACA,IACA,UACA,MAEA,IACA,UACA,KAEA,YACA,IACA,UACA,IAEA,GACA,CACA,aACA,IACA,EAAI,SAEJ,EAxCA,EACA,EAzKA,SACA,YACA,uBAGA,GAFA,SACA,SACA,WAmCA,SACA,sBACA,QADA,EACA,eACA,YAFA,EAEA,gBAFA,EAEA,QACA,wFACA,gCACA,oBACA,4BACA,mGACA,UACA,+FAFA,SAGA,UAEA,iBACA,0GACA,UAEA,iBACA,0GACA,UAEA,QACA,EAzDA,SAuBA,YACA,sBACA,QADA,EACA,eACA,8BAFA,EAEA,QACA,wFACA,SACA,aACA,4FACA,QACA,CACA,QACA,EAlCA,IACA,gBACA,gBACA,gBACA,MACA,SACA,SACA,QACA,CAEA,IADA,OACA,GACA,EAEQ,MAER,EADA,WA4CA,OACA,QACA,GACA,4BACA,8CACA,gBACA,gBACA,gBACA,MACA,WACA,OAEA,UACI,YACJ,YACA,EA3DA,WACA,aACQ,OACR,SAyDA,aACA,QACA,GACA,kBACA,sBAsJA,IArJA,eAqJA,EArJA,EAqJA,EArJA,EAsJA,0CA6BA,KACA,QACA,GACA,mFACA,UACI,YACJ,QACA,EApCA,MACA,4BAuCA,KACA,aACA,4BACA,GACA,gFACA,OACA,eACI,OACJ,QACA,EAhDA,MACA,uCACA,wDAzJA,CACA,cACA,eACA,eACA,iBACA,iBACA,MACA,CACA,SAEA,UACI,aAzEJ,aALA,qBAOA,KACA,CACA,CACA,EA/DA,eACA,CACA,CACA,EACA,uBACA,QACA,gBAoWA,SACA,QACA,kBAAqC,IAAS,KAC9C,+BACA,IAEA,QACA,EA3WA,WACA,QAAoB,IAAS,gCAE7B,UAAwB,KAAY,2BAMpC,OAJA,kBACA,MACA,UAEA,CACA,CACA,iBACA,cACA,UACA,UACA,GAEA,GADA,KACA,qDAGA,GAFA,MAEA,CADA,cACA,aACA,IACA,EAAM,IACN,eAEI,UACJ,QACA,CAoHA,iBACA,eA+FA,uBAWA,MALA,IADA,KADA,GADA,IAFA,cAEA,gBACA,iBACA,kBACA,kBAIA,IADA,KADA,IADA,IALA,aAKA,gBACA,iBACA,kBACA,mBACA,CACA,CASA,6BACA,kFACA,CAOA,mBACA,6CACA,CACA,iBACA,4BAEA,qBACA,oBACA,gBACA,gBACA,yBACA,cACA,kBACA,kBACA,kBACA,iBAEA,CACA,mBACA,qGACA,CACA,eACA,qBACA,CASA,iBACA,oGACA,CAWA,iBACA,kEASA,OARA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,CACA,CACA,qBACA,oBAUA,OATA,GAIA,cACA,SACA,cACA,WANA,SACA,UAOA,CACA,CACA,eACA,mBACA,mBACA,iCACA,gCACA,CACA,mBACA,SACA,SACA,SACA,eACA,eACA,SACA,gBACA,gBACA,eACA,CASA,SAEA,eACA,eACA,IACA,kBAA+B,IAAO,MACtC,+BAEA,WACA,CACA,sBACA,mBACA,CACA,6BACA,SACA,KACA,KACA,MACA,QACA,eACA,cACA,YAAoB,WAAkB,IACtC,UACA,eACA,WAEA,0BACA,YAAoB,WAAsB,KAC1C,uBAEA,QACA,CACA,CACA,eACA,eACA,0BACA,OAEA,CACA,iBACA,YAAkB,WAAoB,IACtC,eACA,cAEA,CACA,oBACA,oBAMA,GALA,QACA,8BACA,iBACA,UACA,EACA,UACA,SACA,UACA,SACA,SACA,mBACA,4BACA,UACA,WACA,cACA,KAAsB,uCAAkD,EAExE,uBAA4C,IAAQ,KACpD,WACA,UACA,UACA,kBAAgE,IAAO,KACvE,YAA4B,IAAO,KACnC,kBACA,oBACA,2BACA,2BACA,iBACA,oBACA,oBAEA,CAEA,CACA,EAAQ,IACR,4BACA,wBAAgD,IAAO,IACvD,YAA0B,IAAO,KACjC,YACA,cACA,2BACA,2BACA,iBACA,oBACA,oBAEA,CAEA,CACA,yCACA,CACA,CACA,QAGA,OAFA,cACA,gCAAsC,eACtC,IACA,CACA,CACA,mBACA,SAAmB,IAAQ,GAAG,IAAQ,GAAG,IAAQ,GAAG,IAAM,GAAG,IAAM,GAAG,IAAM,EAC5E,KAAmB,IAAM,GAAG,IAAM,GAAG,IAAM,GAAG,IAAQ,GAAG,IAAQ,GAAG,IAAQ,QAC5E,+BAGA,SACA,SACA,GAEA,CACA,oBACA,kBACA,4BACA,CACA,eACA,QACA,+BACA,cAAqB,aACrB,4BACA,iBACA,iBACA,cACA,mBACA,yBACA,gBACA,sBACA,wBACA,yBACA,sBACA,kBACA,iBACA,oBACA,mBApynBA,EAqynBA,6BACA,0BACA,yBACA,wBACA,uBACA,uBACA,mBACA,iBACA,2BACA,uBACA,kBACA,0BACA,8BACA,+BACA,oBACA,YACA,iBACA,CACA,QAkCA,OAjCA,cACA,cAAqB,aACrB,yBACA,2BACA,2BACA,eACA,yBACA,2CACA,mBACA,qCACA,+BACA,+BACA,2CACA,uBACA,2BACA,2BACA,mCACA,qCACA,uCACA,2CACA,yCACA,iCACA,iCACA,yBACA,qBACA,2CACA,uCACA,2BACA,6CACA,yCACA,2CACA,+BACA,eACA,KAEA,CACA,oBACA,kBACA,4BACA,CACA,eACA,QACA,+BACA,cACA,YACA,WACA,EACA,0BACA,wBACA,uBACA,0BACA,gCACA,sCACA,6BACA,aACA,2CACA,eACA,4CACA,CAAO,CACP,gBACA,0BACA,CACA,CAAK,EACL,yBACA,wBACA,yCACA,kCACA,0BACA,wBACA,sBACA,4BACA,0BACA,iBACA,uBACA,6BACA,oCACA,yBACA,+BACA,iCACA,2BACA,mBACA,kBACA,mBACA,oBACA,cACA,qBACA,iBACA,CACA,iBACA,uBACA,CACA,kBACA,yBACA,eAEA,kBACA,CACA,gBACA,uBAEA,iBACA,wBACA,eAEA,iBACA,CACA,kBACA,yBAEA,mBACA,0BACA,eAEA,mBACA,CACA,iBACA,wBAEA,kBACA,yBACA,eAEA,kBACA,CACA,YACA,mBAEA,aACA,oBACA,eAEA,aACA,CACA,mBACA,0BAEA,oBACA,2BACA,eAEA,oBACA,CACA,QAqCA,OApCA,cACA,cACA,YACA,WACA,EACA,6BACA,6CACA,mCACA,2BACA,iCACA,6CACA,mDACA,6CACA,uDACA,6BACA,eACA,+BACA,qCACA,qCACA,gEACA,uDACA,mBACA,mCACA,mCACA,qCACA,2CACA,iCACA,uCACA,2BACA,iCACA,+CACA,+CACA,2CACA,iDACA,yCACA,yCACA,KAEA,CACA,oBACA,kBACA,yBACA,CACA,eACA,QACA,4BACA,4BACA,8BACA,kBACA,cACA,mBACA,yBACA,gBACA,sBACA,wBACA,yBACA,sBACA,kBACA,iBACA,oBACA,mBAngoBA,EAogoBA,6BACA,0BACA,yBACA,wBACA,sBACA,mBACA,iBACA,2BACA,aAhnoBA,EAinoBA,oBACA,yBACA,kBACA,0BACA,8BACA,+BACA,oBACA,YACA,iBACA,CACA,QAkCA,OAjCA,cACA,yBACA,+BACA,2BACA,eACA,yBACA,2CACA,mBACA,qCACA,+BACA,+BACA,2CACA,uBACA,2BACA,2BACA,mCACA,qCACA,uCACA,2CACA,yCACA,+BACA,yBACA,qBACA,2CACA,uBACA,iCACA,uCACA,2BACA,6CACA,yCACA,2CACA,+BACA,eACA,KAEA,CACA,oBACA,kBACA,0BACA,CACA,eACA,QACA,6BACA,kBACA,iBACA,oBACA,mBAtkoBA,EAukoBA,6BACA,0BACA,yBACA,wBACA,kBACA,0BACA,oBACA,iBACA,CACA,QAaA,OAZA,cACA,uBACA,2BACA,2BACA,mCACA,qCACA,uCACA,2CACA,yCACA,2BACA,6CACA,+BACA,IACA,CACA,CACA,oBACA,kBACA,2BACA,CACA,eACA,QACA,8BACA,4BACA,cACA,mBACA,yBACA,gBACA,sBACA,wBACA,yBACA,sBACA,kBACA,iBACA,oBACA,mBAnnoBA,EAonoBA,6BACA,0BACA,yBACA,wBACA,sBACA,mBACA,iBACA,2BACA,aAhuoBA,EAiuoBA,oBACA,yBACA,kBACA,0BACA,8BACA,+BACA,oBACA,YACA,iBACA,CACA,QAgCA,OA/BA,cACA,yBACA,eACA,yBACA,2CACA,mBACA,qCACA,+BACA,+BACA,2CACA,uBACA,2BACA,2BACA,mCACA,qCACA,uCACA,2CACA,yCACA,+BACA,yBACA,qBACA,2CACA,uBACA,iCACA,uCACA,2BACA,6CACA,yCACA,2CACA,+BACA,eACA,IACA,CACA,CACA,0BACA,GACA,uBACA,qCACA,SAEA,8BAJA,CAKA,CAcA,mBACA,eACA,uBACA,gBAAiC,MAAuB,KACxD,aACA,YAAoB,MAAc,IAClC,cAGA,QACA,CACA,qBACA,eACA,gCACA,SAEA,qBACA,WACA,cACA,oBACA,GAEA,SADA,WAEA,eACA,mBAEA,eACM,iBACF,sBACJ,GAEA,SADA,WAEA,eACA,uBAEA,eACM,iBAEN,GAEA,SADA,WAEA,eACA,WAEA,eACM,YAGN,SACA,qBACA,0BACA,oBACA,oDACA,oBACA,iBACA,mBACA,wBACA,CACA,YACA,8BACA,oCACA,GACA,GACA,MACA,GACA,aACA,gBAA0C,IAC1C,YACA,eAGA,OAFA,WACA,oBACA,0BACA,CACA,eAGA,GAFA,IAEA,EADA,WAEA,OAEA,CACA,WACA,OACA,CACA,YACA,WACA,MACA,IACA,KAEA,gBAA0C,IAC1C,WAEA,OADA,oBACA,yBAEA,eAGA,GAFA,IAEA,GADA,aAEA,OAEA,CACA,IACA,IACA,OACA,CACA,OACA,CACA,WACA,aACA,QACA,IAEA,KAEA,CAGA,GAFA,OAEA,SADA,WAGA,OADA,oBACA,yBAEA,cAGA,OAFA,WACA,oBACA,0BAEA,CACA,oBACA,4BACA,CACA,iCACA,CACA,eACA,4CAEA,oBACA,mEACA,YAAoB,MAAc,IAClC,YAEA,QACA,CAEA,eACA,sCACA,CACA,mBACA,CACA,CACA,oBACA,qBACA,eACA,oBACA,oBACA,oBACA,oBACA,uBACA,YAt2oBA,KAu2oBA,UAv2oBA,IAw2oBA,CACA,CACA,wBACA,8BACA,0BACA,cACA,wCACA,KA92oBA,KA+2oBA,IACA,QACA,KACA,MAj3oBA,KAk3oBA,aACA,gBACA,KACA,SACA,IACA,GACA,CAEA,cACA,sCACA,KA73oBA,KA83oBA,IACA,QACA,KACA,MAh4oBA,KAi4oBA,IACA,cACA,KACA,SACA,MACA,GACA,CAEA,gCACA,yBACA,yBACA,qBACA,oBACA,CACA,sBACA,+KACA,iBACA,mCACA,0BACA,UACA,YAAoB,MAAc,IAClC,yCAEA,QACA,CACA,CACA,oBACA,qBACA,cACA,CACA,sBACA,6FACA,YAAoB,MAAc,IAClC,uBAEA,QACA,CACA,CACA,oBACA,qBACA,cACA,CACA,gBACA,iCACA,CACA,CACA,SACA,qBACA,0EACA,8FACA,aACA,qCACA,uCACA,mDACA,CAGA,iBACA,IACA,EADA,gBAEA,0BACA,kBACM,CACN,GACA,YACA,wBACA,yBACA,EACA,0BACA,6BACA,mBAEA,CAEA,OADA,uBACA,CACA,CACA,oCACA,2DACA,CACA,kCACA,2DACA,CACA,kCACA,2DACA,CACA,oBACA,MACA,UACA,KA99oBA,KA+9oBA,wCACA,KACA,MAh+oBA,KAi+oBA,sCACA,KACA,MAl+oBA,KAm+oBA,sCAGA,eACA,6FACA,mCACA,iCACA,sDAEA,eAIA,OADA,uCACA,KAGA,OADA,yBACA,KAEA,mBACA,+BACA,2CACA,OA1/oBA,IA2/oBA,0CACA,OA3/oBA,IA4/oBA,0CACA,OA5/oBA,IA6/oBA,CACA,CACA,eACA,4CAGA,SACA,UACA,iBACA,uBAAwC,MAAS,IACjD,OAEA,CACA,YAGA,SACA,UACA,iBACA,uBAAwC,MAAS,IACjD,OAEA,CACA,YAIA,UACA,4BACA,UACA,oBACA,IAEA,qBACA,IAGA,GADA,IACA,cACA,MAEA,GADA,kBACA,GAEA,yBACA,yBACA,sCACA,CACA,WACA,CAEA,eAjXA,EAkXA,SACA,sBACA,qBACA,wEACA,MAEA,0CACA,QACA,2DACA,MAEA,WACA,YAAoB,MAAa,KACjC,WACA,iCACA,2EACA,KACA,KACA,CACA,kBACA,oEACA,KACA,KACA,CACA,GACA,CACA,eA3YA,mBADA,EA6YA,IA5YA,yBA6YA,uBAA2C,MAAS,KACpD,WACA,aACA,4EACA,KACA,KACA,CACA,CAGA,QACA,CAGA,WACA,mHACA,IACA,YAAoB,IAAe,KACnC,SACA,OAEA,OADA,QACA,kBACA,KAUA,SAVA,CACA,sBACA,YAA0B,MAAc,KACxC,aACA,2BACA,KACA,KACA,CACA,CACA,CAIA,CAJU,EAIV,GACA,UACA,UACA,gBACA,YAA0B,MAAc,IACxC,cAGA,GACA,CACA,CACA,QACA,UACA,wBAA0F,MAAc,IACxG,gBAEA,CACA,CAQA,OAPA,cACA,wBACA,6BAEA,aACA,eAEA,KAEA,QACA,yBACA,sBAEA,MADA,iBACA,eAEA,OADA,2CACA,CACA,CACA,CACA,yCACA,0CACA,kCArppBA,IAsppBA,qBAEA,mBACA,YACA,CACA,CACA,kCACA,mCACA,kCA/ppBA,KAgqpBA,mDACA,kDACA,qBACA,CACA,kCACA,qBACA,CACA,mCACA,qBACA,qBACA,cACA,CACA,sBACA,2EACA,MACA,cAAoC,MAAgB,KACpD,8BAEA,QACA,CACA,CACA,oBACA,kCACA,2DACA,CACA,CACA,wCACA,kDACA,qBAEA,mBACA,YACA,CACA,CACA,oCACA,mCACA,kCApspBA,KAqspBA,mDACA,kDACA,qBACA,CACA,mCACA,UACA,6BArspBA,IAqspBA,EACA,YACA,cACA,gBACA,iBACA,eACA,iBACA,oBAEA,CACA,gBACA,mCACA,uBAA2C,MAAS,IACpD,iBAiOA,GACA,mBACA,wEAEA,MA7BA,YACA,wBACA,aACA,aACA,YACA,aACA,cACA,SACA,cACA,cACA,cACA,cACA,SACA,aACA,SACA,kBACA,SACA,YACA,cACA,SACA,cACA,SACA,CACA,4DACA,EAKA,QACA,qBACA,cACA,uBACA,UACA,UACA,QACA,iBACA,WAEA,+CAEA,EAjPA,gBAEA,gDAEA,OADA,cACA,CACA,CACA,iBACA,oBACA,GACA,YACA,oBACA,SACA,YACA,uBAEA,uBAA2C,MAAS,IACpD,wBAEA,QACA,CACA,8CACA,eACA,KACA,YAAoB,IAAqB,KACzC,SACA,KACA,OACA,UACA,EACA,SAEA,cACA,eAtjBA,GAIA,eACA,WACA,YAAkB,MAAS,WAE3B,OADA,OANA,cACA,mBAMA,CACA,EA6iBA,GACA,YACA,YACA,cACA,UACA,cAEA,OACA,OACA,wCACA,EACA,GACA,WAEA,CACA,uBACA,CACA,uBACA,QACA,kBAEA,eADA,EACA,mCAEA,YAAoB,WAAsB,IAC1C,iBACA,YAGA,WACA,CACA,kDACA,SACA,uBACA,uBAA8C,IAAQ,KACtD,WACA,kBACA,kBACA,WACA,OACA,GACA,YAEA,SACA,CACA,CACA,SACA,eACA,uDAEA,QACA,CAEA,2BACA,MAEA,OADA,uEACA,KAEA,0BACA,iBACA,SACA,KACA,YACA,cACA,oBAEA,CACA,EACA,KACA,oBACA,YACA,cACA,eACA,kBACA,YAAoB,WAA4B,KAChD,gBACA,mBACA,sBACA,IACA,EADA,KAEA,QAAoB,WAA0B,IAC9C,qBACA,YAA4B,2BAA0C,IACtE,2BAIA,gBACA,SACA,KACA,YAA0B,6BAA4C,KACtE,WACA,eACA,4BACA,CACA,kDACA,CACA,YACA,EAAQ,IACR,8BACA,EACA,GACA,cACA,EACA,MACA,GAEA,EACA,GACA,gBACA,EACA,MACA,GAEA,EACA,GACA,WACA,EACA,MACA,EAEA,CACA,QACA,aACA,KAEA,iBAEA,CACA,gBACA,kBACA,IACA,uBAAuC,MAAS,KAChD,qBACA,uCACA,CAEA,OADA,gBACA,KAEA,OACA,YAAoB,qBAAwB,IAC5C,qCAEA,YAEA,WACA,SACA,YAAoB,qBAAwB,IAC5C,+BAEA,QACA,CACA,WACA,YAAoB,qBAAwB,IAC5C,0BAEA,YAEA,QACA,SACA,YAAoB,qBAAwB,IAC5C,+BAEA,qEACA,CACA,SACA,oCACA,CACA,CA2CA,QACA,WACA,QAAW,CACX,kBACA,mBACA,iBACA,CAAG,CACH,gBACA,qBACA,qBACG,CACH,mBACA,qBACG,CACH,iBACA,aACA,CACA,CACA,UACA,mBACA,IAIA,EAJA,OACA,KACA,IACA,IAEA,KACA,oBACA,cACA,kBACA,eACA,2BACA,IACA,QACA,oBACA,iBAGA,IACA,EACA,yBACA,IACA,uBACA,oBAEA,QACA,KACA,mBACA,WAGA,EACA,2BACA,oBACA,YAEA,EACA,mCACA,EACA,KAEA,CACA,EACA,gCAEA,OADA,IACA,MAEA,8BAEA,OADA,YACA,IACA,EACA,+BACA,mBAIA,OAHA,QACA,cAEA,MAEA,4BACA,uBAA2C,IAAO,MAClD,WACA,SAEA,GADA,0BACA,UACA,QAEA,CACA,WACA,CACA,CACA,CACA,aACA,UACA,eACA,6BACA,6BACA,wBACA,aACA,qBACA,qBACA,CACA,OACA,CACA,eACA,WACA,iCACA,eACA,CAAK,CACL,CACA,QACA,CACA,kBAEA,OADA,mBACA,KAEA,sBAEA,OADA,uBACA,KAEA,WAEA,OADA,YACA,IACA,CACA,mBAEA,OADA,oBACA,IACA,CACA,oBAEA,OADA,qBACA,KAEA,CACA,qCACA,SACA,wBACA,iBACA,SACA,eACA,CACA,CACA,oBACA,eACA,QACA,CACA,cACA,mBACA,oCACA,6BACA,gBACA,cAMA,OALA,0BACA,gBACA,QACA,uBACA,CAAO,IACP,EAEA,8BACA,YACA,SACA,aACA,SACA,CAAO,CAGP,UACA,YACA,SACA,aACA,SACA,CAAK,EACL,qBACA,wCACA,wDAEA,CAAK,EACL,gBACA,oBACA,kBACA,iCAIA,GAHA,cACA,0DAEA,+EACA,SAEA,YACA,qBACA,gEACA,kBACA,QACA,IAwBA,oBAvBA,oBACA,UACA,SACA,IACA,gBAAoC,eAAa,IACjD,KACA,cACkB,CAElB,qDAAgE,SADhE,gBACgE,QAAiC,EACjG,uBAAyD,IAAQ,KACjE,WACA,6BACA,CACA,aACA,GACA,CACA,CAAe,KACf,UACA,CAAe,CACf,GACA,CACA,CAAS,EAET,CACA,CADQ,KACR,qBAA0C,MAAa,mBAAmB,SAAgB,IAAI,aAAoB,IAElH,CAAK,WACL,UACA,kBACA,sBACA,YACA,eACA,gBACA,wBACA,gBACA,qBAEA,YACA,eACA,SACA,cACA,eACY,EAEZ,MADA,eAAsC,WACtC,QAEA,kBADA,mCAEA,2CACA,CACA,CACA,CAAK,WACL,YACA,mBACA,MACA,uBAA6C,IAAQ,KACrD,WACA,qBACA,CACA,CAAK,YACL,YACA,cAEA,MADA,0BACA,CAEA,cACA,uBAA6C,IAAQ,KACrD,WACA,uBACA,CACA,yBACA,CAAK,eACL,uBACA,CAAK,EACL,yBACA,CACA,mBAEA,OADA,oBACA,KAEA,eAEA,OADA,gBACA,KAEA,CACA,oBACA,eACA,QACA,CACA,cACA,oCACA,6BACA,WACA,YACA,cAMA,OALA,uBACA,sBACA,QACA,oBACA,CAAO,IACP,EAEA,gBACA,aACA,IACA,eACA,WACA,oBACA,CACA,cACA,IACA,QACA,uBACA,oBACA,CACA,aACA,mCACA,mCACA,CAQA,OAPA,gCACA,iCACA,wBACA,4DAEA,uBACA,QACA,CACA,CACA,CACA,oBACA,eACA,QACA,CACA,cACA,aACA,uBAUA,OATA,mCACA,qBACA,qBACA,UACA,iBACA,YACA,IAEA,CAAK,MACL,CACA,CACA,CACA,oBACA,mBACA,QACA,gBACA,kBACA,qBACA,gBACA,CACA,UACA,CACA,UAIA,OAHA,gBACA,yBACA,2BACA,KAEA,UACA,sBAUA,OATA,mCACA,kCACA,4EACA,0DACA,iDACA,iDACA,0DACA,6DACA,yDACA,CACA,CACA,CACA,cACA,UACA,SACA,UACA,eACA,cACA,iBACA,YACA,kBACA,cACA,mBACA,6BACA,cACA,kBACA,mBACA,mBACA,oBACA,qBACA,+BACA,sBACA,iBACA,gBACA,CAEA,mBACA,2BAEA,aACA,qBAEA,kBACA,kBACA,cACA,wCACA,oBACA,+CACA,aACA,sBACA,6DACA,0CACA,MACA,GACA,EACA,EACA,GACA,EACA,GACA,EACA,GACA,EACA,EACA,GACA,GACA,EACA,EACA,EACA,GAEA,cACA,CACA,eACA,0BAEA,kBACA,0BAEA,UACA,UACA,mBAEA,cACA,sBAEA,CACA,QAMA,OALA,6BACA,2BACA,iBACA,qBACA,6BACA,KAEA,QACA,wCACA,CACA,SACA,SAQA,OAPA,iDACA,kCACA,oDACA,wCACA,iFACA,uCACA,uBACA,CACA,CACA,CACA,oBACA,cACA,2BACA,0BACA,YACA,CACA,kBACA,kBACA,0BACA,yCACA,oBACA,uCACA,QACA,WACA,QACA,4BAEA,uBACA,CACA,QAGA,OAFA,cACA,mBACA,KAEA,CACA,oBACA,yCACA,WACA,oBACA,sBACA,kCACA,oBACA,mBACA,gBACA,aACA,gBACA,aACA,cACA,kBACA,CACA,YACA,8BAEA,aACA,yBAEA,UACA,qBACA,CACA,UAQA,OAPA,gBACA,yBACA,mBACA,yBACA,mBACA,6BACA,6BACA,KAEA,CACA,cACA,UACA,SACA,qBACA,cACA,2BACA,2BACA,+BACA,sBACA,iBAcA,gBAEA,gBAEA,gBAEA,gBAEA,gBAEA,gBACA,CACA,sBACA,cACA,eACA,cACA,eACA,cACA,eACA,CACA,eACA,cACA,cACA,cACA,cACA,cACA,eACA,CAEA,sBACA,kBACA,cACA,oBACA,YACA,QACA,4BAEA,wCACA,oBACA,oBACA,gCACA,4BACA,aACA,sBACA,qCACA,6DACA,yCACA,CACA,CACA,oBACA,yBACA,WACA,qBACA,uBACA,gBACA,aACA,kBACA,CACA,YACA,gCAEA,aACA,4BACA,CACA,UACA,qBACA,CACA,UAKA,OAJA,gBACA,yBACA,mBACA,6BACA,KAEA,CACA,oBACA,cACA,gCACA,gCACA,CACA,CACA,oBACA,iBACA,WACA,2BACA,6BACA,kCACA,oBACA,mBACA,kBACA,CACA,UACA,qBACA,CACA,QAIA,OAHA,cACA,6BACA,6BACA,KAEA,CACA,oBACA,iBACA,WACA,uBACA,wBACA,CACA,CACA,SACA,qBAEA,GADA,sIACA,gCACA,mCAEA,SACA,uBAAuC,IAAQ,IAC/C,6BAEA,IACA,oCACA,CAAM,SACN,QACA,CACA,CACA,yBACA,gCACA,YACA,cACA,CACA,6BACA,+BACA,wCACA,8CAEA,4BACA,yBACA,sBAFA,EAGA,GACA,CACA,CACA,oBACA,cACA,QACA,kCACA,oCACA,sBACA,CACA,QAGA,OAFA,cACA,mCACA,KAEA,SACA,qBAGA,OAFA,mCACA,+BACA,CACA,CACA,CACA,oBACA,eACA,SACA,4BACA,uCACA,4EAEA,2BACA,gEAEA,cAAqB,wBACrB,CACA,cAEA,OADA,eACA,KAEA,cACA,mBACA,oCACA,6BACA,WACA,YACA,oBAEA,CADA,uBACA,aACA,WACA,QACA,oBACA,CAAS,YACT,OACA,CAAS,GAGT,sBACA,QACA,oBACA,CAAO,IACP,GAEA,QACA,sEACA,6BACA,kCACA,eACA,CAAK,mBACL,oDAAqE,4BAA8B,EACnG,CAAK,mBAIL,OAHA,YACA,QACA,qBACA,CACA,CAAK,oBACL,QACA,aACA,uBACA,oBACA,CAAK,EACL,YACA,sBACA,CACA,CACA,SACA,kBACA,iBACA,iBACA,eACA,mBACA,eACA,CACA,QACA,oBACA,4BACA,mBACA,eACA,CACA,OACA,sBACA,gBACA,iBACA,CACA,iBAEA,OADA,gBACA,iBAEA,WACA,QACA,iCAEA,OADA,aACA,EAEA,iBACA,WACA,uBACA,eACA,mBACA,CACA,QACA,CACA,CACA,cACA,wBACA,CACA,SACA,uBAGA,MACA,OAHA,eACA,iBAEA,GACA,iBACA,cACA,sBACA,sCACA,kCACA,kBACA,KACA,cACA,WACA,eACA,eACA,iCACA,uBACA,KACA,SACA,aACA,qBACA,mCACA,iCACA,CACA,wBACA,gCACA,oBACA,kBACA,iBACA,wBACA,gCACA,gBACA,qBACA,CAEA,gBACA,2CACA,wBACA,UACA,YAAsB,MAAc,IACpC,YAEA,GACA,EAAM,IACN,KACA,UACA,gCACA,CACA,uBACA,CAEA,sBACA,sDACA,mCACA,oBAEA,yCACA,gCACA,CAEA,SACA,kHAGA,GAFA,wBACA,gCACA,KACA,wBACA,sBACA,EACA,EACA,EACA,IACA,EAEA,CACA,KACA,wDAEA,kBAA8C,MAAS,IACvD,kBACA,gBACA,KACA,CAEA,CAEA,oBACA,mBACA,mDACA,gBACA,YAAkD,IAAlD,EAA2D,IAC3D,cAEA,oBACA,wBACA,+BACA,CAEA,uBACA,uBACA,oCACA,CACA,8BACA,oCACA,mBACA,YAA6B,IAAc,IAC3C,gBAEA,CACA,iCACA,mCACA,8CACA,CACA,4BACA,qCACA,gCACA,YAAoB,iBAAoB,IACxC,kCAIA,mBACA,SACA,YAAsB,MAAc,IACpC,cAIA,gBACA,2BACA,CACA,0BACA,wBACA,wCACA,2BACA,CACA,iBACA,UACA,YAAoB,MAAc,KAClC,SACA,qBACA,CACA,CACA,yBACA,YAAoB,MAAc,KAClC,SACA,mBACA,CACA,CACA,CACA,uBACA,0BACA,eACA,iCACA,6CACA,wCAGA,UACA,UAHA,oDACA,+CAEA,KAEA,gDACA,GACA,mBACA,6BACA,qBACA,gCACA,CACA,cACA,YACA,iEACA,sBACA,CACA,cACA,qBACA,uDAAyE,MAAS,IAClF,kBAEA,CACA,OACA,qBACA,uDAAyE,MAAS,IAClF,WAEA,CACA,SACA,qBACA,uDAAyE,MAAS,IAClF,aAEA,CACA,CACA,SACA,mBACA,YACA,wCACA,kDACA,gBACA,qCACA,qCAEA,4BACA,4BAGA,wBAFA,aAIA,CAQA,2BACA,0CACA,CACA,yBACA,iBACA,YACA,2DAEA,OAEA,cACA,gBACA,iBACA,kBAEA,oBAEA,0CACA,uBACA,+BACA,sBACA,qCACA,eAEA,CACA,oDACA,8EAEA,QACA,CACA,qBACA,+DACA,SAEA,eACA,kCACA,cACA,QAEA,CACA,eACA,kBACA,YAAwB,WAAqB,KAC7C,WACA,0BACA,SAEA,oBACA,aACA,CACA,WACA,EACA,gBACA,KACA,QAEA,CACA,WACA,CAEA,wBACA,CACA,wBACA,CAEA,sBACA,0CAEA,qBACA,4BACA,uBAAuC,MAAS,IAChD,YAGA,4BACA,+CAEA,uBACA,kCACA,CAEA,sBACA,0CAEA,qCACA,0CACA,gCACA,CACA,gDACA,0CACA,2CACA,CAEA,qBACA,4BACA,uBAAqC,MAAS,IAC9C,YAGA,oCACA,4BACA,uBAAqC,MAAS,IAC9C,YAEA,gCACA,CACA,+CACA,4BACA,uBAAqC,MAAS,IAC9C,YAEA,2CACA,CAEA,4BACA,+CAEA,2CACA,+CACA,gCACA,CACA,sDACA,+CACA,2CACA,CAEA,yBACA,oCACA,CACA,wCACA,qCACA,gCACA,CACA,mDACA,qCACA,2CACA,CACA,uBACA,YACA,kBACA,CACA,uBACA,YACA,kBACA,CAEA,OACA,gBACA,kBACA,eACA,iBACA,kBAOA,GANA,IACA,wCACA,aAEA,yCACA,yCACA,eACA,sFAGA,MACA,oBACA,UACA,gBACA,2BACA,wGAGA,qCACA,kIAGA,uBACA,KACA,aACA,2BACA,qGAGA,mBACA,YAA0B,WAAyB,IACnD,kBACA,IACA,KACA,CAEA,KACA,WACA,cACA,QACA,KACA,CACA,2BACA,wGAGA,+BACA,gHAGA,iBACA,KACA,SACA,6BACA,2FAGA,OAEA,eACA,6BACA,8GAGA,OAEA,CACA,WACA,0BAEA,6EADA,WACA,iCAGA,2BACA,oBACA,uBACA,8BACM,mCACN,2CAEA,8BACA,eACA,gCACA,2BACA,0HAGA,2CACA,yIAGA,sCACA,8BAEA,CACA,gCACA,wBACA,oBACA,EAAM,8CACN,kCACA,yBACM,kBACN,+BACA,yBAEA,mBAEA,2CACA,0DAEA,SACA,eACA,qCACA,qCAEA,CACA,gBACA,0BACA,SACA,cACA,eACA,gBACA,EACA,yBACA,OACA,cACA,wBACA,EACA,kCACA,8BACA,6BACA,oCACA,+BACA,CACA,+CACA,CAEA,8BACA,6CACA,wDACA,CACA,CAEA,6BACA,4CACA,uDACA,CACA,CAEA,oCACA,mDACA,8DACA,CACA,CAEA,iCACA,gDACA,2DACA,CACA,OACA,GACA,sCACA,cACA,aACA,kBACA,iBACA,qCACA,GACA,YAzwsBA,KA0wsBA,UA1wsBA,IA2wsBA,EACA,YAAoB,MAAe,KACnC,kCACA,QACA,YACA,CACA,4BACA,qBACA,gCACA,sBACA,4BACA,gCACA,6BACA,UA7xsBA,KA8xsBA,mBACA,qBACA,YACA,iBACA,2BACA,cACA,wBACA,qBACA,eACA,gBACA,0BACA,yBACA,sBACA,CAEA,OAEA,OADA,kCACA,KAEA,OAEA,OADA,oCACA,YACA,CACA,QAMA,OALA,eACA,gBACA,YACA,mBACA,qBACA,+BACA,CACA,YACA,gHACA,CAEA,cACA,wCACA,CACA,WAEA,OADA,kBACA,KAEA,aAGA,OAFA,YACA,mBACA,KAMA,sBAGA,OAFA,cACA,uCACA,iBACA,CAEA,qBACA,4BACA,CACA,UACA,kCACA,CACA,WACA,kCACA,CACA,qBAGA,GAFA,aACA,eACA,GACA,6CACA,SADA,IACA,GACA,UAFA,IAEA,IACA,CACA,YAEA,mBACA,gCACA,CACA,aACA,8BAKA,OAJA,WACA,6BACA,4CAEA,KAMA,yBAGA,OAFA,iBACA,yCACA,kBACA,CAEA,wBACA,gCAEA,eAEA,OADA,qCACA,kBACA,CACA,YAGA,OAFA,iBACA,2BACA,kBACA,CACA,QACA,8CACA,CACA,YACA,4CACA,oCACA,IACA,8BACA,8BAEA,4CAKA,OAJA,OACA,SACA,SACA,SACA,KAEA,cACA,iCAKA,OAJA,WACA,gCACA,4CAEA,KAGA,WACA,mBAEA,UACA,kBAEA,UACA,0CAGA,iBACA,6BACA,sBAGA,sBACA,aACA,aACA,YACA,KAEA,qBACA,MAEA,CACA,4BACA,0BACA,wBACA,QACA,yBACA,yBACA,GA37sBA,OA27sBA,eAEA,uBAAmD,MAAS,IAC5D,iBACA,gCAKA,uBAAmD,MAAS,IAC5D,iBACA,oBAGA,CACA,CACA,iBACA,QACA,iBACA,cACA,8BACA,aACA,uBACA,KACA,4BACA,kBACA,OACA,kBAGA,CACA,CAEA,OADA,wBACA,CACA,CACA,oBACA,QACA,iBACA,iBACA,wCACA,IAEA,GADA,iBAEA,4BACA,mBACA,MACA,eAEA,kBAIA,CAEA,OADA,2BACA,CACA,CACA,eACA,0BACA,YACA,cACA,kBACA,WACA,gBACA,SACA,kBAEA,aACA,SACA,kBACA,4BAEA,GACA,QACA,SACU,OACV,QACU,CACV,YACA,OACA,CACA,sCACA,gBACA,YACA,2BACA,gBACA,YACA,kBACA,CAAS,CACT,CACA,EAAM,IASN,GARA,SACA,MACA,IACA,6CAEA,6CAGA,WACA,sBACA,OACA,eACA,yBACA,QACA,sCACA,gBACA,UACA,YACA,2BACA,gBACA,YACA,kBACA,CAAW,MACD,CACV,UACA,UACA,wBACA,EAAY,IACZ,yBAEA,mBACA,YACA,2BACA,YACA,YACA,WACA,CAAW,CACX,CACA,EAAQ,IACR,YAEA,eACA,UAEA,CACA,QACA,CACA,mBACA,gCACA,GACA,cA1ktBA,KA2ktBA,YA3ktBA,OA6ktBA,EACA,oCA9ktBA,KADA,KAiltBA,cA/ktBA,KAiltBA,EACA,gCAnltBA,KADA,KAsltBA,YApltBA,KAultBA,CACA,uBACA,2BACA,yBACA,YACA,8BACA,2BAEA,4CAKA,OAJA,OACA,OACA,SACA,OACA,KAEA,CACA,0BACA,qBACA,eACA,QACA,aACA,0BACA,kBACA,YACA,gBACA,CACA,iBACA,0IACA,MACA,cACA,KACA,QAEA,YAAoB,MAAe,KACnC,oBACA,OACA,cACA,mBACA,WACQ,CAER,YADA,SACA,CACA,uBACA,mBACA,iCAEA,QACA,CACA,mDACA,SACA,iBACA,gBACA,kBAEA,mBACA,gCACA,MACA,CACA,2BAEA,CACA,mBACA,6BACA,yBACA,8EACA,iBACA,EACA,sBAEA,8BACA,CACA,0BACA,uBAA2C,MAAS,KACpD,UACA,mBACA,qBACA,sBAEA,CACA,mBACA,CACA,CACA,qBACA,4BACA,0BACA,uBAA2C,MAAS,KACpD,WACA,kBACA,yBACA,yBAEA,CACA,uBACA,CACA,CAEA,qBACA,iBACA,uBACA,uBACA,kBACA,wBACA,+BACA,6BACA,mCACA,WACA,YACA,SACA,YACA,yBACS,CACT,YACA,yBAEA,CAAO,CACP,UACA,YACA,0BACS,CACT,YACA,0BAEA,CAAO,CACP,qBACA,YACA,qCACS,CACT,YACA,qCAEA,CACA,CACA,CAEA,mBACA,oBACA,wCAEA,0BACA,0CACA,OACA,cACA,GACA,iBACA,eACA,EACA,sBACA,WACM,CACN,qBACA,6BACA,SACA,CACA,uBACA,UACA,mBACA,CACA,yBACA,oDACA,gBACA,OACA,QACA,mBACA,uGACA,sBACA,OACA,QACA,yBACA,8DACA,KACA,cACA,YAEA,wCACA,CACA,oCACA,0BACA,uBAAyC,MAAS,KAClD,WACA,uBACA,8BAEA,CACA,CACA,eACA,mEACA,iBACA,OACA,gBACA,MACA,CACA,mBACA,mEACA,iBACA,OACA,gBACA,MACA,CAEA,2BACA,mDACA,YACA,QACA,KACA,QAEA,OACA,uBACA,SACA,CACA,0BACA,iIACA,gBACA,OACA,QACA,YACA,2BACA,YAGA,gBACA,qEACA,iBACA,OACA,gBACA,MACA,CACA,oBACA,sEACA,gBACA,OACA,gBACA,MACA,CAEA,0BACA,qEACA,OAWA,OAVA,aAOA,CANA,SACA,oBACA,oBACA,EACA,GACA,EACA,eACA,QAEA,CACA,CACA,+BACA,6FACA,iBACA,OACA,iBACA,MACA,CAIA,kBACA,6BACA,0CACA,oBACA,yBACA,OAQA,GAPA,aAEA,EADA,SACA,YAl2tBA,MAu2tBA,YACA,wBACA,+BACA,SAEA,oBACA,UACA,WACA,CACA,wBACA,yBAGA,OAFA,sBACA,+BACA,CACA,CAEA,oBACA,oHACA,YACA,uBAGA,CAEA,gBACA,2CACA,cAA+B,KAAQ,IACvC,YAEA,YAGA,UACA,kBACA,8FACA,YAAoB,MAAgB,IAEpC,CADA,IACA,iBAEA,6CACA,YAAoB,MAAiB,IACrC,cAEA,YAGA,WACA,YACA,YAAoB,uBAA0B,IAC9C,wBAEA,qBACA,CAEA,UACA,kBAGA,eACA,0DACA,eACA,qBACA,uBAAkD,MAAS,KAC3D,WACA,0BACA,mCACA,oBACA,yBACA,gBACA,OACA,QACA,wCACA,CACA,YAEA,CAEA,eACA,mCACA,gBACA,gCACA,QACA,0BACA,8BAEA,CACA,qCACA,cACA,gBACA,WACA,yBACA,8BACA,CAEA,CAEA,mBACA,8BACA,YACA,0BACA,8BAEA,CACA,CACA,oBACA,qBACA,WACA,qCACA,uBACA,CACA,QAGA,OAFA,cACA,yCACA,KAEA,SACA,qBAEA,OADA,yCACA,CACA,CACA,UACA,sBAGA,OAFA,kCACA,yCACA,CACA,CACA,CACA,aACA,UACA,2BACA,qBACA,YACA,WACA,iBACA,mBACA,aACA,OAAc,CACd,MAAc,YAAc,CAC5B,MAAa,CACb,QAAgB,YAAc,CAC9B,SACA,CACA,CACA,SACA,iBACA,CACA,mBACA,uBACA,qDACA,iFACA,eACM,wBACN,wEACA,iEACA,eAEA,kEAEA,CACA,uBAIA,OAHA,6CACA,qDACA,gDACA,KAEA,6BAGA,OAFA,eACA,WACA,CACA,CACA,8BACA,uBAAwC,IAAO,IAC/C,kBAGA,OADA,WACA,CACA,CACA,CACA,iBACA,6BAEA,qBACA,SAKA,GAJA,yBAEA,KADA,gBACA,OAEA,gBACA,iBACA,uBAAyC,IAAO,IAChD,eAEA,CACA,CACA,SACA,yBAIA,OAHA,cACA,WACA,aACA,KAEA,WAIA,OAHA,cACA,WACA,aACA,KAEA,QAIA,OAHA,qBACA,eACA,mBACA,KAGA,WAGA,OADA,kBADA,KACA,iBADA,KACA,WACA,KAEA,kBACA,+CACA,CACA,8BASA,OARA,mCACA,iBACA,aACA,aAEA,2BACA,4CAEA,KAEA,QACA,wCACA,CACA,CACA,cACA,SACA,UACA,+BACA,aACA,UACA,CACA,SAGA,OAFA,mBACA,iBACA,KAEA,QAGA,OAFA,yBACA,qBACA,KAEA,aACA,2DACA,CACA,SACA,wCACA,CACA,aACA,6CACA,CACA,WACA,sCACA,CACA,QACA,sDACA,CACA,kCACA,4BACA,mCACA,iBAEA,EADA,WACA,EAIA,OAHA,GACA,cAEA,CACA,CACA,2BACA,6CACA,sDACA,CACA,gBAGA,OAFA,2BACA,yBACA,KAEA,UACA,yDACA,CACA,QACA,wCACA,CACA,CACA,oBACA,2CACA,YACA,YACA,UACA,MACA,MACA,UACA,qBAA0C,KAAgB,UAC1D,qBACA,qBACA,gBACA,eACA,KACA,eACA,KACA,eACA,KACA,eACA,IACA,CACA,aACA,uCACA,oCAEA,QADA,QAA6C,8BAAuC,GAEpF,sBACA,CACA,UACA,wBACA,uBACA,CACA,CACA,oBACA,sBACA,QACA,cACA,kBACA,gBACA,cACA,aACA,mBAA0B,kCAC1B,cAAqB,kBACrB,CACA,UACA,CACA,aACA,CACA,UACA,CACA,SACA,CACA,CACA,wCACA,6DAAiE,QACjE,SAj1uBA,KAk1uBA,EAAK,GAEL,6BACA,iBACA,wEAEA,iBAx1uBA,OA21uBA,6BAEA,aADA,wBAAkF,kDAA6D,UAC/I,8BACA,UACA,mBACA,6BACA,8BACA,wBACA,oBACA,wBACA,uBACA,yBACA,+BACA,6BACA,0BACA,SACA,OACA,CAAK,EACL,sCACA,OACA,QACA,CAAK,EACL,mCACA,uCACA,kCACA,kCACA,gCACA,mCACA,CAAK,EACL,gBACA,oBACA,mBACA,8BACA,oCACA,uCACA,yBACA,yBAEA,+BACA,sCACA,uCACA,qCACA,wCACA,yBACA,yBAEA,aACA,yCAEA,OACA,CACA,UACA,CACA,eACA,gBACA,eACA,0CACA,uEACA,CAAO,CAEP,CACA,uBACA,8EACA,CACA,gBACA,MACA,wBACA,qBACA,qBACA,4DACA,2BACA,KAIA,IADA,mFACA,sBACA,MACA,MALA,4FAOA,mCACA,mCACA,iCACA,yBACA,4CACM,kCACN,yBACA,4CAEA,gBACA,uCACA,6BACA,wBAEA,iDACA,CACA,UACA,6CACA,6BACA,iDAEA,0CACA,CACA,iBACA,MACA,OACA,4CACA,iEACA,8DACA,sCACA,CACA,CACA,kBACA,QACA,4CACA,iDACA,iCACA,8BACA,4CACM,kCACN,8BACA,4CAEA,mCACA,CACA,kBAEA,uBADA,IAEA,CACA,qBACA,4CACA,gCACA,kDAGA,qCACA,qCACA,8BACA,kCACA,iDAEA,CACA,iBACA,QACA,0BACA,QAGA,GAFA,2CACA,4CACA,2CACA,yCACA,oDACM,CACN,8BACA,gCACA,oCACA,oCACA,gCACA,oCACA,0CACA,gDACA,CACA,iDACA,mCACA,CACA,QACA,oCACA,sBACA,sBACA,uBAEA,qCACA,sBACA,sBACA,uBAEA,8BACA,qBACA,qBACA,sBAEA,+BACA,qBACA,qBACA,sBAEA,gDACA,gDACA,CACA,CACA,QAAuB,eACvB,IAAsB,cACtB,IAAoB,YACpB,UACA,UACA,2BACA,UACA,aACA,IACA,QACA,SACA,QACA,MACA,eACA,YACA,kBACA,oBACA,CAEA,qBACA,sBACA,WACA,mBACA,gBACA,mBACA,mBACA,mBACA,qBACA,eACA,iBACA,uBACA,yBACA,qBACA,2BACA,0BACA,yBACA,sBACA,uBACA,mBACA,iBACA,qBACA,mBACA,kBACA,gBACA,2BACA,mBACA,qBACA,mBACA,uBACA,WAAkB,qEAClB,mBAA0B,6CAC1B,cAAqB,gCACrB,iCACA,4CACA,4BACA,+BACA,0BACA,4BACA,gCACA,2DACA,8CACA,uBACA,4BACA,cACA,uBACA,yBACA,uBACA,yBACA,sBACA,oBACA,sBACA,wBACA,sBACA,wBACA,4BACA,mBACA,2BACA,kBACA,0BACA,uBACA,kCACA,kCACA,gCACA,kCACA,iCACA,8BACA,iCACA,gCACA,gCACA,gCACA,yCACA,uCACA,wBACA,eAEA,aACA,CACA,UACA,oEACA,oEACA,oEACA,6DAAoE,WAAgB,EAEpF,IADA,0BACA,uDAAwE,sBAA8B,EACtG,wCACA,CACA,aACA,uEACA,uEACA,mEACA,uEACA,gEACA,uEACA,6BAEA,IADA,0BACA,0DAA2E,WAAe,EAC1F,wCACA,CACA,UACA,iBACA,CACA,gBACA,2BAEA,oBACA,6BAEA,cACA,mDACA,CACA,qBACA,8CACA,2BACA,CACA,wBACA,mCACA,yEACA,+BAEA,CACA,YACA,+BACA,0CACA,4BAEA,QACA,+BACA,0CACA,4BACA,qCACA,uBACA,cACA,mBAEA,eACA,2BACA,4BACA,+BACA,mCACA,uCACA,gDAEA,oBACA,qEACA,mEAEA,kDACA,+CAEA,2BACA,uBACA,2BACA,iBACA,mBACA,iBACA,mBACA,KACA,oEAEA,yHAGA,kGACA,2BACA,wBACA,gEAEA,iCAEA,6BACA,mEACA,6BACA,SACA,gFACA,uEACM,CACN,6BACA,+EACA,4BAcA,GAZA,qCACA,sCACA,4BACA,gCACA,yBACA,iDACA,+CACA,uDAEA,gCACA,4BAEA,4CACA,WACA,oCACA,kBACA,qCACA,UACA,6DACA,gCACA,KACA,EAAQ,yCACR,4CACA,yBACA,uBACA,4FACA,qCACA,uBACA,4CACA,yBACA,mCACA,gCACA,aACA,EAAQ,IACR,wGACA,oBAEA,YACA,wBACA,4GAEA,qCACA,gEACA,8CACA,iCAEA,6DACA,oCAIA,EAAM,yCACN,sBACA,6FACA,uBACA,qCACA,KAEA,QAGA,IAFA,UACA,6BACA,+DAnPA,MAmPA,uDAnPA,MAmPA,wDAnPA,IAmPA,IACA,uBACA,8CACA,kDACA,2CACA,GAGA,CACA,gCACA,SACA,6BAEA,8BAGA,iBACA,sBACA,qCACA,CACA,eACA,6BACA,CACA,aACA,2BACA,CACA,cACA,4BACA,sBACA,uBACA,CACA,YACA,6BACA,6BAEA,4BACA,oCAEA,qBACA,uBACA,CAEA,UACA,sBACA,oCACA,2BACA,4BACA,kBACA,2CACA,uDACA,oDACA,EAAM,sCACN,wGACA,yGAEA,6FACA,kBAEA,CACA,aACA,kEACA,gBAEA,oGACA,mBAEA,CACA,YACA,kEACA,gBAEA,oGACA,mBAEA,CACA,2BACA,sBACA,MAEA,4BACA,8CACA,WACA,UACA,UACA,WACA,sBACA,yBACA,oHACA,CACA,kBACA,8DACA,CAIA,0BACA,0CACA,CACA,yBACA,gDACA,yCACA,CACA,uBACA,uCACA,CACA,0BACA,yCACA,iGACA,sBACA,wDACA,sDACA,wCACA,aACA,CACA,yBACA,wCACA,6DACA,qBACA,uDACM,sBACN,sDAEA,sCACA,aACA,CACA,uBACA,sCACA,qFACA,6CACA,kCACA,aACA,CACA,qBACA,gDACA,WACA,4CACM,YACN,6CAEA,aACA,CACA,kBACA,SACA,eACA,kBACA,iCACA,iEAEA,8BAEA,KACA,KACA,uBACA,iCACA,kEAEA,+BAEA,KACA,KACA,qBACA,iCACA,mEAEA,8BAEA,KACA,KACA,sBACA,iCACA,oEAEA,+BAEA,IAEA,CACA,IACA,mBACA,cAEA,CACA,2BACA,6BACA,2CACM,CACN,wCACA,mBACA,mBACA,0BACA,CACA,CACA,wBACA,6BACA,wCACM,CACN,wCACA,mBACA,mBACA,uBACA,CACA,CACA,0BACA,wCACA,cACA,cACA,qBACA,yBACA,CACA,6BACA,gDACA,4CACA,CACA,gCACA,gDACA,kDACA,CACA,0BACA,4BACA,yCACM,CACN,wCACA,mBACA,mBACA,wBACA,CACA,iGACA,sBACA,wDACA,sDACA,uCACA,CACA,uBACA,6BACA,sCACM,CACN,wCACA,mBACA,mBACA,qBACA,CACA,qFACA,6CACA,iCACA,CACA,yBACA,wCACA,cACA,cACA,qBACA,wBACA,qFACA,mCACA,sCACA,uBACA,mBACA,+BACA,CACA,4BACA,+CACA,2CACA,CACA,+BACA,+CACA,iDACA,CAEA,eACA,gCACA,CACA,kBACA,2CACA,YAAoB,wBAA2B,IAC/C,8CACA,0BAIA,CACA,sBACA,YAAoB,wBAA2B,IAC/C,2CAEA,QACA,CACA,iBACA,+CACA,QACA,SACA,uCAEA,sBACA,CACA,6BACA,0EACA,iCAGA,qBACA,kBACA,GACA,kBACA,kBACA,iBAEA,UACA,OACA,aACA,KACA,QACA,aAEA,CAIA,OAHA,iCACA,eAEA,CACA,CACA,CACA,eACA,oBACA,4BACA,+CACA,oEACA,iEAEA,6BACA,oBACA,wBACA,sBAEA,sBAEA,CACA,eACA,oBACA,wBACA,qBAEA,qBAEA,CACA,eAEA,OADA,uBACA,uBACA,OACA,mDACA,uEACA,mEACA,uBACA,mBACA,KACA,QACA,wBACA,4BACA,8BAA2B,sBAAiD,CAE5E,CACA,CACA,eACA,MACA,iBACA,OACA,yBACA,KACA,QACA,2BACA,KACA,QACA,0BACA,KACA,SACA,IACA,CACA,UACA,cACA,+BACA,8BACA,oBACA,KACA,gBACA,qCACA,8BACA,4BACA,iBACA,EAAQ,IACR,iCACA,+BACA,qBAEA,KACA,aACA,qCACA,iCACA,+BACA,sBACQ,IACR,8BACA,4BACA,kBAEA,KACA,SACA,kBACA,CACA,sBACA,sBAEA,CACA,eACA,mBACA,eACA,iCACA,+BACA,KACA,eACA,+BACA,8BACA,KACA,aACA,8BACA,2BAEA,CACA,CACA,eACA,gEACA,mBACA,uBACA,kDACA,uBACA,CACA,eACA,wCACA,sBACA,CACA,eAEA,OADA,sBACA,uBACA,OACA,yBACA,eACA,iCACA,gCACA,2BACA,KACA,aACA,8BACA,6BACA,wBACA,KACA,SACA,mBAEA,KACA,QACA,yBACA,kBACA,oDACA,kCACA,8BACA,KACA,sBACA,uDACA,qCACA,iCACA,KACA,SACA,mBAEA,KACA,SACA,mBAEA,sBACA,sBAEA,CACA,eAEA,OADA,sBACA,YACA,qBACA,iCACA,+BACA,cACA,KACA,mBACA,8BACA,4BACA,cACA,KACA,yBACA,oDACA,iCACA,cACA,KACA,4BACA,uDACA,oCACA,cACA,KACA,SACA,mBAEA,CACA,eACA,mBACA,kBACA,CACA,eACA,oBACA,uBAEA,IADA,0BACA,mDAAoE,sBAA8B,EAElG,CACA,eACA,oBACA,uBACA,8BACA,sDAAuE,sBAA8B,EAErG,CACA,6BAEA,aADA,wBAAkF,kDAA6D,UAC/I,8BACA,UACA,qBACA,oBACA,wBACA,uBACA,kBACA,oBACA,mBACA,cACA,qCACA,8BACA,CACA,OACA,0CACA,kDACA,sCACA,oCACA,kDACA,iEACA,CAAO,CACP,CAAK,CACL,CACA,UACA,uBACA,CACA,eACA,CACA,SACA,sBACA,CACA,gBACA,4CACA,8BACA,eACA,uBACA,uBACA,mBACA,sBACA,CACA,QACA,gCACA,sBACA,CACA,CACA,mCAGA,GACA,cAHA,yBAAkF,kDAA6D,UAI/I,KAHA,YAGA,EAAyC,CACzC,CACA,sBACA,mBACA,uBAEA,yBACA,CACA,yBACA,mBACA,4CACA,SACA,CAEA,CACA,eACA,mBACA,kCAEA,CACA,CACA,6BAEA,YADA,yBAAkF,kDAA6D,UAC/I,8BACA,UACA,iBACA,qBACA,iBACA,wBACA,aACA,mBACA,CACA,OACA,kBACA,CACA,UACA,wBACA,oBACA,CAAK,EACL,eAEA,cACA,0BACA,kBACA,oBACA,0BACA,wBACA,kBACA,oBACA,0BACA,yBACA,kBACA,oBACA,0BACA,wBACA,kBACA,oBACA,0BACA,uBACA,kBACA,oBACA,0BACA,wBACA,kBACA,mBACA,CACA,qBACA,wBACA,gBACA,mBACA,iBACU,mBACV,iBACU,mBACV,iBAEA,iBAEQ,iBACR,kBAEA,CAAK,EACL,qDACA,CACA,QACA,CACA,CACA,+CACA,WACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EAEA,EACA,EAEA,EACA,EACA,WACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GAEA,EACA,EACA,EACA,4DACA,iBAEA,QADA,aACA,IAAkB,KAAQ,IAC1B,kBAGA,QADA,gBACA,IAAkB,KAAQ,IAC1B,eAAuB,SAAc,IACrC,iBAGA,SAAW,IACX,EACA,4BACA,sBAGA,QAFA,cACA,iBACA,KAAgB,SAAW,MAC3B,mCAEA,UADA,gCACA,kBACA,qCACA,CAsCA,QArCA,mBAIA,IAHA,IAWA,EAXA,WACA,IACA,YACS,IAAO,IAChB,MACA,YAEA,gBACA,QAAc,IAAQ,IACtB,sBAGA,MACA,eACA,WACA,QAAgB,IAAO,IACvB,QAIA,QAHA,YACA,SACA,iBACA,aAAyC,KAAQ,IACjD,aAIA,EAAI,IAEJ,QADA,YACgB,IAAO,IACvB,MACA,gCAIA,QACA,EACA,eACA,KAAgB,OAAS,KACzB,SACA,eAAkB,OAAS,KAC3B,SACA,eAAkB,OAAS,KAC3B,SACA,eAAkB,OAAS,KAC3B,SAEA,QADA,cACA,KAAgB,MAAQ,KACxB,SAvDA,IAwDA,cACA,cACA,eAEA,QADA,OACA,IAAkB,WAAc,IAChC,QACA,SAEA,QACA,EACA,mBACA,YACA,+BACA,EACA,iBACA,YACA,wCACA,EASA,IACA,iBACA,qBACA,yBACA,mBACA,kBACA,qBAEA,cACA,qBACA,uBACA,8BACA,oBACA,mBACA,mBAEA,CACA,mBACA,sBAIA,GAHA,SACA,yBACA,8BACA,GACA,QACA,QACA,EACA,qBACA,IAhCA,IAgCA,WACA,iBACA,oBACA,SACA,YACA,MACA,GACA,gBACA,kBACA,eACA,QACA,8BACA,SACA,GACA,CACA,EACA,mDACA,MACA,GACA,OACA,YACA,kBAEA,GADA,KACA,EAYQ,QACR,uBACA,SACA,uCACA,mBACA,MAGA,QAFA,YACA,aACA,IAAwB,IAAW,IACnC,uBAEA,OAGA,QAFA,mBACA,YACA,IAAwB,KAAQ,KAChC,eACA,QACA,WACA,QACA,aACY,CACZ,YAOA,IANA,MACA,8BACA,MACA,qBACA,OACA,wBACA,KACA,QACA,CACA,CAnBA,IAoBA,kCACA,QACA,QACA,YACA,WACA,EAAQ,IACR,UAlDA,CACA,MA1DA,EA0DA,EA1DA,QA0DA,2BACA,QACA,GACA,MACA,KACA,CACA,GACA,OACA,yBACA,yBACA,QACA,CAuCA,CAvCQ,EAuCR,KACA,GACA,MACA,KACA,CACA,CACA,GACA,YAGA,IAFA,0BACA,KACa,KACb,0BAEA,IADA,SACA,GACA,GACA,MACA,KACA,CAGA,GAFA,GACA,MACA,MACA,cACA,WACA,WACA,KACA,EAAQ,IACR,YACA,UACA,oBACA,yBACA,IACA,CACA,yBACA,IACA,MACA,QACA,YACA,QACA,WACA,yBACA,CACA,QACA,GACA,MACA,KACA,CACA,GACA,YACA,UACA,QACA,MA5HA,EA4HA,kBAGA,IAFA,OACA,MACiB,IAAW,IAC5B,WACA,CACA,KAAe,IAAU,IACzB,YAEA,CACA,wBACA,GACA,uBACA,EAAI,SACJ,uBA1KA,EA0KA,EAzKA,QADA,EA0KA,IAzKA,aACA,aACA,kBAuKA,EAvKA,KAuKA,eACA,EACA,aAWA,oDAEA,IACA,cAAkB,UAAc,CAEhC,CAAE,SACF,CACA,mBACA,mBACA,WACA,WAEA,WACA,SAEA,QACA,IACA,sBACA,wBACA,OACA,IAEA,IAEA,sBAEA,QACA,CA0KA,oBACA,uBACA,QACA,qBACA,cACA,eACA,aACA,sBACA,oBACA,kBACA,YAAoB,IAAkB,KACtC,WACA,6CACA,CACA,CACA,qBAEA,yFACA,WAvKA,SACA,gBACA,EAtBA,kBACA,SACA,KACA,KACA,OACA,YAAkB,KAAQ,KAC1B,gBACA,cACA,QACA,YAAoB,IAAO,KAC3B,aACA,SACA,YACA,YACA,KACA,CACA,MACA,CACA,QACA,EAGA,SACA,kBACA,YAAkB,KAAQ,KAC1B,eACA,OACA,OACA,YACA,WACA,WACA,UACA,CACA,QACA,EAyJA,6CAIA,OAHA,SACA,oBAJA,EAMA,gBACA,CACA,2BA5BA,MA8BA,sEACA,GA/BA,EA+BA,YA/BA,EA+BA,WA/BA,EA+BA,mBA7BA,SArBA,GACA,eACA,KACA,KACA,YAAkB,IAAQ,KAC1B,WACA,yBACA,SAEA,SACA,YAAkB,IAAQ,KAC1B,mBACA,YAAoB,KAAQ,IAC5B,6CA3BA,KACA,QACA,YAAkB,KAAQ,IAC1B,KAEA,QACA,YAAkB,KAAQ,IAC1B,KAEA,YAAkB,OAAY,IAC9B,KAEA,UACA,EAcA,WAEA,0BACA,CACA,QACA,EA1DA,oBACA,MAyFA,EAzFA,MACA,KACA,YACA,EA3EA,oBACA,SACA,YAAkB,KAAQ,IAC1B,OACA,SACA,YAAkB,KAAQ,IAC1B,gBACA,SACA,YAAkB,KAAQ,IAC1B,eACA,WACA,iBACA,aACA,YAAkB,KAAQ,KAC1B,gBACA,cACA,QACA,YAAqB,IAAQ,KAC7B,aACA,QACA,aACA,wBACA,cACA,KACA,CACA,SACA,CACA,YAAkB,KAAQ,IAC1B,gBAEA,YAAmB,KAAS,KAC5B,QACA,IACA,KACA,YAAoB,KAAQ,IAC5B,eAEA,WACA,YAAoB,KAAQ,KAC5B,QACA,MACA,MACA,OACA,0BACA,mBAEA,iBACA,iBACA,YAAwB,KAAU,IAClC,wCACA,qBAEA,OACA,6BACA,oBAEA,UACA,QACA,IACA,GACA,CACA,CACA,QACA,YAAkB,KAAQ,KAC1B,YAAoB,KAAQ,IAC5B,WAEA,MACA,CACA,QACA,EAKA,WACA,KACA,YAAkB,WAAc,KAChC,mBACA,KACA,QACA,OACA,OACA,MACA,CACA,YAAkB,KAAS,KAC3B,6CACA,YAAoB,KAAQ,IAC5B,+CAEA,OACA,CACA,cAAuB,OAAa,IACpC,mBAEA,QACA,EAmCA,MA8BA,OAEA,OAJA,EAGA,uBAHA,CAKA,CACA,SACA,qBAMA,OALA,qBACA,wBACA,uDACA,2BACA,uBACA,CACA,CACA,YAOA,OANA,kBACA,qBACA,wBACA,uEACA,2BACA,uBACA,KAEA,CAIA,oBACA,eACA,QACA,CACA,cACA,WACA,0CACA,uBACA,kBACA,iCACA,oCACA,wCACA,qBACA,IACA,eACA,CAAQ,SACR,EACA,KAEA,iBAEA,sBACA,CACA,CAAK,KACL,CACA,WACA,YA6pEA,GACA,+BACA,mDACA,EAhqEA,GACA,wBACM,CACN,YACA,IA6pEA,YACA,4FACA,IAOA,YAAkB,WAAoB,IAEtC,YARA,GACA,WAGA,OAFA,YAKA,GAJA,IACA,CACA,EAEA,KACA,KACA,SAGA,QACA,EA7qEA,GACA,gDAEA,aACA,+EAEA,mBACA,CAEA,cADA,oFACA,sBACA,CACA,CACA,SACA,iBACA,qBACA,cACA,CACA,QACA,0BACA,yBACA,wBACA,yBACA,wBACA,oBAEA,OADA,uBACA,CACA,CAGA,mBACA,cAyBA,MAxBA,mBACA,0BACA,oBACA,WACA,OACA,OACA,UACA,SACA,WACA,YACW,EAGX,sBADA,CAAqC,sBAErC,UACA,SACA,WACA,WACA,CAAW,EAGX,uBADA,CAAoC,qBAEpC,CAAO,EAEP,CACA,CAIA,cACA,SACA,KACA,wBACA,sBACA,gBACA,WAGA,GADA,EADA,YACA,gCACA,eACA,+DACA,6CACA,SACA,2BACA,oCACA,CACA,CACA,CACA,CACA,gBACA,gBACA,mBACA,2BACA,CACA,QACA,CAEA,cACA,IAGA,EAHA,YACA,iCACA,8CAEA,UACA,UACA,cACA,KACA,WACA,WACA,eACA,KACA,WACA,cACA,KACA,WACA,eACA,KACA,WACA,wCACA,6DAEA,cACA,KACA,SACA,gEACA,MACA,CACA,sBACA,kBAAgC,UAC1B,EACN,wBACA,qDAA4D,EAAM,EAClE,CACA,CAIA,iBACA,cACA,0BACA,wBACA,gBACA,gCACA,oBACA,CACA,CACA,QACA,CAEA,kBACA,2BACA,WACA,kBACA,kBACA,cACA,uBACA,uBAGA,GAFA,cAvnyBA,IACA,KAunyBA,cAxnyBA,IACA,KAwnyBA,eACA,sBACA,gBACA,eACA,CACA,sBACA,0BACA,gBACA,gBAEA,QACA,CAEA,iBACA,IAeA,EAfA,yDACA,4CACA,uCAAoF,EAAU,sBAC9F,MAKA,OAJA,aACA,cAAsB,iBAAyB,oDAC/C,oBAEA,OAEA,aACA,GACA,mCAEA,gCAEA,wCAEA,KADA,eACA,2CACA,kBAGA,gBAEA,OADA,aACA,CACA,CAEA,kBACA,cACA,2BACA,yBACA,gBACA,gCACA,+BACA,CACA,CACA,QACA,CAIA,mBACA,IAQA,EARA,OACA,aACA,iBAIA,GAHA,oBACA,YAEA,sBACA,kCAEA,wBACA,YACA,SACA,KACA,eACA,SACA,KACA,SACA,gGACA,QAEA,CAGA,OAFA,eACA,SACA,CACA,CAGA,uBACA,QACA,eACA,iCAEA,UACA,uEACM,mFACN,8EAEA,sBACA,iDAEA,WACA,2EACM,sFACN,kFAEA,kBACA,yDAEA,4EACA,iCACA,qDACA,kBACA,8EAGA,aACA,mBAEA,oBACA,0CAEA,aACA,gCAEA,WACA,2EACM,iDACN,kFAEA,WAyDA,OAxDA,sCACA,qBACA,UACA,WACA,+BACA,KACA,uBACA,6BACA,KACA,oBACA,yBACA,2BACA,gBACA,sBAEA,KACA,yBACA,uCACA,KACA,qBACA,mCACA,wBACA,8BAEA,KACA,iBACA,0BACA,iCACA,KACA,uBACA,8BACA,oBACA,iBA1xyBA,IA2xyBA,wBAEA,KACA,qBACA,mCACA,wBACA,8BAEA,KACA,wBACA,yBACA,gCACA,iBACA,KACA,SAKA,yFAEA,CACA,CAAK,EACL,CACA,CAEA,gBAKA,MAJA,8DACA,iHACA,2BAEA,QACA,CAIA,iBACA,SACA,KACA,2BACA,yBACA,gBACA,WACA,qBACA,wBACA,6BACA,QACA,mHACA,6BACA,MACA,EAAU,kCACV,OACA,IACA,CACA,0CACA,OACA,uHACA,MACA,CACA,CACA,CACA,OACA,YACA,cACA,CACA,CAIA,mBACA,SAkBA,OAjBA,+BACA,cACA,iCACA,OACA,QACA,WACA,WACA,mDAGA,CACA,iBACA,sBACA,uBAEA,SACA,CAAK,EACL,CACA,WACA,SAEA,CAEA,uBACA,SACA,YAAoB,oBAAmC,KACvD,oBACA,UACA,GACA,gBACA,8BACA,QACA,6BAEA,0CACA,2DACA,+BACO,QACP,SACA,CACA,QACA,CAEA,kBACA,SACA,wCACA,kBACA,OACA,sBACA,cACA,2BACA,oBACA,oBACA,iBACA,qBACA,CAAO,EACP,iBACA,QAEA,CAAK,EACL,mCACA,8BACA,uBACA,6BACA,WACA,sDACA,iEAEA,mCACA,kBACA,qBACA,CACA,CAAK,EACL,sBACA,gDACA,2BACA,iBAEA,cACA,CAEA,mBACA,cACA,kBACA,gBACA,kBACA,OACA,WACA,uCACA,OACA,mBACA,aACA,uBACA,KACA,aACA,sBACA,KACA,YACA,yBACA,KACA,kBACA,wBACA,KACA,gBACA,WACA,SACA,KACA,SAEA,QAEA,CACA,qDACA,mCACA,MACA,CACA,2BACA,UACA,CACA,QACA,CACA,uBACA,WAoBA,OAnBA,8BACA,gBACA,WACA,iCACA,gBACA,QAEA,CADA,UACA,kCACA,mCACA,0BACA,OACA,aACA,UACA,QAEA,CACA,CAAS,CACT,CACA,CAAK,EACL,CACA,CAEA,gBACA,MACA,EAOA,GANA,+BACA,mCACA,aACA,KAEA,CAAK,EACL,WACA,aACM,CACN,OACA,oEACA,MAEA,OACA,uBACA,0BAEA,SACA,sBACA,yBAEA,wBACA,oBACA,mDACA,sBACA,wBAEA,UACA,IACA,yBACA,wBAEA,6CACA,UACA,OACA,kBACA,8BACA,KACA,QACA,yEACA,SACA,KACA,SACA,4DACA,QAEA,CACA,CACA,QACA,CAEA,eACA,MACA,EAOA,GANA,+BACA,yCACA,OACA,KAEA,CAAK,EACL,WACA,aACM,KACN,EAEA,EADA,qBACA,EAEA,kBAEA,cACA,mBACA,iEAEA,kDACA,8DACA,MAEA,QASA,OARA,+BAEA,EADA,kEACA,EAEA,2BAIA,GACA,OACA,eAHA,GAIA,KACA,QACA,cACA,KACA,QACA,eACA,wBACA,oCAEA,OACA,wBAEA,YADA,kCACA,IAEA,mBAlBA,GAmBA,KACA,SACA,uGACA,aAEA,CACA,iDACA,iBAEA,CACA,QACA,CACA,kBAEA,IADA,EACA,OACA,OACA,KA+BA,OA9BA,+BACA,aACA,gBAEA,aACA,mBAEA,CAAK,EACL,WACA,IACM,WACN,QAEA,UACA,8BACA,cACA,CAAO,EACP,WAEA,wBACA,sBACA,iBACA,CAAO,EAEP,eACA,gBACA,uBAEA,cAEA,CACA,CACA,iBAUA,cATA,gCAEA,OADA,6BACA,CACA,CAAK,OACL,QACA,8BACA,cACA,WACA,CAAK,EAEL,CAEA,sBACA,QACA,kEACA,2DACA,mBACA,+DACA,uDACA,sDACA,0DACA,iDACA,6DACA,0DACA,gEACA,6DACA,0BACA,CACA,yBACA,sBACA,qBACA,oBACA,sCACA,4BACA,0BACA,6BACA,oBACA,+BACA,iBAEA,+BAEA,CACA,CACA,CAAO,CAEP,CACA,oBACA,4BACA,gBACA,WAEA,EADA,4BACA,oBACA,gBACA,WACA,SACA,4BACA,aACA,YACA,6BAEA,CAAW,CACX,CACA,CAAO,CACP,CACA,CACA,iBACA,SACA,uBACA,qBACA,eACA,mDACA,oBACA,iBACA,sBACA,wCACA,CAAa,EAEb,wCAEA,CAEA,CACA,QACA,CACA,yBACA,yBACA,sCACA,0CACA,OACA,OACA,OACA,wBACA,gCACA,kBACA,CACA,CACA,sCACA,mEAEA,CACA,CACA,CACA,SACA,cACA,+BACA,CAEA,SACA,cACA,2BACA,yBACA,gBACA,yBACA,+BACA,oBACA,CACA,CAIA,MAHA,mCACA,oIAEA,CACA,CAEA,qBACA,mBACA,WACA,oCACA,kBACA,iCACA,CACA,CAEA,yBACA,kBACA,KACA,4BACA,6BACK,EACL,uBACA,sCAEA,OADA,8BACA,CACA,CAAK,OACL,+BACA,+BACA,4BAEA,CAAK,EACL,WACA,IACA,+DACA,iEACA,yEACA,gEACA,2DACA,YACA,gCACA,CAEA,qBACA,YACA,iCACA,6BACA,qBACA,qBAWA,GAVA,kBACA,6BACA,mBACA,2CAEA,IACA,uDACA,uDACA,kBAEA,mBACA,kCACA,qBACA,uBACA,0BACA,CAKA,GAJA,4BACA,sBAAyC,EAAE,EAC3C,oCACA,CAAK,EACL,gDACA,yBACA,IAQA,GAPA,sCACA,QACA,oBACA,IACA,IAEA,CAAO,EACP,mBACA,kCACA,kBACA,4BACA,wCAEA,CACA,qBACA,uDAEA,CAEA,OADA,8BACA,CACA,CACA,kBACA,SAYA,GAXA,sDACA,wEACA,qBACA,yDAEA,wBACA,kEAEA,sBACA,sDAEA,kBACA,QACA,QACA,0BACA,wBACA,8CAEA,GAEA,CAcA,OAbA,iBACA,WACA,aACA,iCACA,gCACA,iDACA,uBACA,KACA,oBACW,CACX,CAAS,CACT,CAAO,GAEP,CACA,CACA,cACA,OACA,UACA,UACA,UACA,OACA,iBACA,iBACA,iBACA,EACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,OAwFA,OAvFA,sCAEA,IADA,EACA,KACA,MACA,MACA,MAEA,SACA,KAEA,GADA,wBACA,SACA,wBACA,sBACA,CACA,eAOA,GANA,2BACA,qCACA,iBACA,YACA,CAAW,EAEX,YACA,IACA,0HACA,MAEA,gBACA,YACA,wBACA,QACA,OACA,0BACA,QACA,OACA,IACA,WACA,OACA,GACA,CACA,CAAa,CACb,CAAW,EACX,IACA,GACA,CACA,iBACA,UACA,UAEA,YAAwB,IAAO,IAC/B,aACA,YAEA,CACA,aACA,yBACA,sBACA,CACA,gDACA,4BACA,IACA,6BACA,KAGA,MACA,2BACA,iBACA,gBACA,UAEA,gBACA,eACA,CAAS,EAET,IACA,IACA,+BACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,KAEA,CAAK,EACL,CACA,CAEA,mBACA,oBACA,YAAoB,WAAqB,KACzC,WACA,oBACA,yBACA,yBACA,wBACA,CAEA,OADA,cACA,CACA,CACA,gCACA,8BAEA,GADA,8CACA,qBACA,iCACA,OACA,SACA,UACA,WACA,CACA,CACA,qBACA,cACA,SACA,SAEA,CAEA,6BACA,MACA,QACA,SACA,2CACA,YAAsB,WAAgC,KACtD,OACA,OACA,QACA,UACA,YAIA,YAAc,eAAqB,qCACnC,KACA,eACA,kCAEA,2BACA,EAAM,IACN,YAEA,mBACA,yCACA,2CACA,2CACA,yCACA,2CACA,2CACA,yCACA,2CACA,2CACA,aACA,6BACA,+BACA,+BACA,+BACA,6BACA,+BACA,+BACA,+BACA,6BACA,+BACA,+BACA,+BACA,8BACA,gCACA,gCACA,gCACA,8BACA,gCACA,gCACA,gCACA,8BACA,gCACA,gCACA,iCAEA,UACA,sBACA,wBACA,wBACA,sBACA,wBACA,wBACA,sBACA,wBACA,yBAEA,iDACA,wBACA,wBACA,yBAEA,WACA,sBACA,wBACA,wBACA,sBACA,wBACA,wBACA,sBACA,wBACA,yBAEA,MACA,2BACA,iCACA,yBACA,2BACA,yBACA,2BACA,yBACA,0BACA,CAAS,CAGT,CACA,yBACA,sBACA,2BACA,8BACA,WACA,sBACA,iCACA,uCACA,OACA,kCAEA,CAAO,CACP,CAAK,CACL,CAKA,4BACA,0CACA,0DACA,sCACA,oCAEA,mBADA,+BAEA,YAAoB,WAAyB,KAC7C,aACA,YACA,gBACA,gBAQA,aADA,gBALA,CACA,gBACA,kBACA,qBACA,GAEA,SACA,sBACA,kBACA,kCACA,CAEA,gBACA,+BACA,6BACA,cACA,KAQA,MAPA,sBACA,kBACA,kBACQ,oBACR,sBAGA,CACA,WACA,SACA,UACA,cACA,eACA,CACA,CAEA,YACA,+BACA,6BACA,SACA,KAIA,MAHA,qBACA,gBAEA,CACA,WACA,SACA,UACA,cACA,eACA,CACA,CAEA,qBACA,+BACA,6BACA,aACA,KACA,qBACA,mBAEA,qBAAqC,WAAmB,KACxD,iBACA,6BACA,eAEA,OACA,WACA,SACA,UACA,cACA,eACA,CACA,CAEA,wBACA,+BACA,6BACA,8BACA,OACA,WACA,WACA,YACA,sBACA,eACA,EAEA,oBACA,KACA,YAAoB,WAAgC,IACpD,UAEA,OACA,WACA,SACA,UACA,cACA,eACA,CACA,CAEA,sBACA,IAYA,IAZA,oBACA,YAEA,OADA,0FACA,OAEA,UACA,iBACA,KACA,aACA,uBAA6C,IAAO,KACpD,gCAGA,qBACA,kBACM,wBACN,IACA,eACA,YAAsB,IAAY,IAClC,YAEA,CAEA,UADA,cACA,uBACA,gCACA,CACA,CACA,SAEA,QACA,SACA,oBACA,cACA,gBACA,WACA,kBACA,SACA,CAEA,QACA,CACA,aACA,4CACA,sCACA,6BACA,mCAEA,OADA,uBAEA,CAIA,2BACA,mCACA,UACA,gBACA,WACA,mDACA,OACA,QACA,gBACA,SACA,EACA,aACA,CACA,CACA,QACA,CAIA,wBACA,+BACA,gBACA,OACA,WACA,6BACA,6BAEA,cACA,eACA,sBACA,4BACA,aACA,oBACU,aACV,oBACU,aACV,oBACU,oCACV,yBAEA,CACA,CACA,CAIA,wBACA,+BACA,UACA,gBACA,SACA,oBACA,cACA,WACA,sBACA,gBACA,kBACA,kEACA,kBACA,6CACA,+BACiB,QACjB,eACA,oCACA,0BACA,+DAGA,OACA,wDACA,QACA,wBACA,wBACA,sBAEA,uBACA,cACA,qBACA,6EAEA,CAAmB,EACnB,kCACA,uDACA,0DACA,MACA,CACA,CACA,sBACA,EAAc,gCACd,kBACA,6CACA,+BACiB,QACjB,yBACA,yBACA,yBACA,qBACA,GACA,wDACA,yCAEA,OACA,CACA,cACA,CACA,CACA,CAAS,EACT,qBAEA,CACA,QACA,CAGA,mBACA,+BACA,KACA,gBACA,iCACA,aACA,mJAEA,oBACA,OACA,mBACA,OACA,CACA,CACA,QACA,CACA,WACA,SACA,OAIA,OAHA,4BACA,+BACA,CAAK,EACL,mBACA,CACA,kBACA,SACA,SACA,SAIA,GAHA,+CACA,cACA,cACA,gDACA,mEACA,sBACA,CACA,mDACA,kGACA,sBACA,CACA,mDACA,gEACA,sBACA,CACA,6BACA,gCACA,sBACA,CACA,QACA,CACA,6BACA,iCACA,qCACA,0BACA,CACA,qCACA,EACA,EACA,6CACA,+CACA,OACA,OAEA,WACA,cACA,uBACA,QACA,wBACA,4BAEA,aACA,uBACA,QACA,wBACA,qCAEA,aACA,SACA,KACA,iDACA,YAAoB,WAAmB,KACvC,4BACA,kBACA,6BACA,0BACA,KAKA,EAJA,mBACA,EACA,WAEA,QACA,2BAGA,mBAEA,kCACA,CACA,sBACA,mCACA,2BACA,YACA,CAAK,EACL,oEACA,oEACA,CAGA,sBACA,SAOA,GANA,sCACA,sCACA,sCAIA,CAHA,uBACA,UACA,EAAK,EACL,UACA,QACA,OACA,YAAsB,WAAkB,KACxC,WACA,QACA,OACA,IACA,IAEA,CACA,cACA,CACA,QACA,CACA,8BAEA,SACA,KACA,KACA,KA2BA,OA1BA,sBAIA,GAHA,8BACA,8BACA,8BACA,QACA,oBACA,UACA,MACA,EAAQ,IACR,OAdA,CAcA,KAEA,WACA,oBACA,UAlBA,CAmBA,KACA,EAAQ,IACR,aAEA,WACA,oBACA,UACA,MACA,EAAQ,IACR,OA5BA,CA4BA,IAEA,CAAK,EACL,CACA,CAIA,8BACA,SACA,KACA,mBACA,iCACA,iCACA,iCACA,YAAoB,kBAA0B,KAC9C,OACA,cACA,cACA,cACA,CACA,yCACA,SAEA,yBACA,GACA,YACA,YACA,YACA,CACA,yCACA,SAEA,yBACA,GACA,UACA,UACA,UACA,CACA,GACA,eACA,eACA,eACA,CACA,oCAEA,MADA,eACA,IACA,iBACA,iBACA,2BACA,0BACA,WACA,2BAEA,mBACA,eACA,SACA,SACA,YAAyB,IAAQ,OACjC,qCACA,cACA,yBACA,YACA,YACA,WAEA,EAAQ,IACR,mBACA,iCACA,iCACA,gCAEA,CACA,YAEA,CACA,SACA,cACA,4CAEA,iBACA,4CAEA,iBACA,wBAEA,aACA,uBACA,qBACA,CACA,WACA,qBACA,qBACA,CACA,oBACA,mBACA,sBACA,CACA,SACA,qBACA,qBACA,kBACA,oBACA,wBACA,WACA,qBAkBA,OAjBA,wBACA,wBAAgD,GAChD,uBACA,eACA,oBAA8C,oBAA4B,YAAY,MACtF,gBAA6C,oBAA4B,4BACzE,gBAAwC,yBAAmC,GAC3E,EACA,sBACQ,EACR,gCACQ,EACR,aACQ,iBAA6B,KACrC,+BAEA,CAAK,EACL,cAEA,oBACA,oDACA,kCACA,iDACA,CAAK,EACL,GAAmB,QACnB,wBACA,uBACA,wBACA,uBAEA,QACA,eACA,mBACU,mBACV,QACA,oBAEA,2BACQ,uBACR,QACA,cACQ,qBACR,wBACA,QAGA,mCACA,iCACA,iCACA,iBACA,CACA,iBACA,WACA,WAEA,MADA,mBAEA,SAGA,cAKA,OAJA,aACA,8BACA,QAEA,CAAa,mBACb,CACA,yBACA,oDACA,+CACA,yBACA,+CAEA,4BAEA,oBADA,OACA,YACA,qCAGA,YACA,4BACA,iBACA,iBACA,wBACA,oBACA,gCACA,CAAO,EACP,gBAEA,SAoiBA,KACA,kCAA8C,IAAO,QACrD,WAviBA,QACA,GACA,eACA,SAEA,CACA,qBACA,4BACA,aAEA,eACA,MAEA,yBACA,4BACA,WAEA,CACA,8BACA,2BACA,QACA,mBACA,aAEA,CAEA,gCACA,oCACA,mDACA,CAAK,EACL,OACA,OACA,OACA,OACA,OACA,UACA,UACA,WACA,WACA,gBACA,aACA,aACA,kBACA,gBACA,KACA,aACA,eACA,eACA,sBACA,mBACA,kBACA,OAEA,CACA,uBACA,OACA,QACA,OACA,OACA,EACA,yCACA,CACA,CACA,SACA,SACA,gBACA,WACA,oBACA,UACA,2EAEA,aACA,6BACA,yBACA,0BACA,CACA,QACA,CAEA,uBACA,eACA,qCAEA,8BAEA,CAEA,eACA,SACA,sCACA,qCACA,qCACA,mBACA,iBACA,qBACA,SACA,YAAoB,IAAmB,IACvC,8BAEA,yBACA,qBACA,qBAEA,IADA,0CACA,kBACA,yBACA,mCACA,CAMA,OALA,iBACA,6BACA,uBACA,uBACA,mBACA,CACA,CACA,oBACA,0BACA,wBACA,kBACA,YACA,OAEA,WAEA,EAAM,wCACN,SACA,qCACA,gBACA,CAAO,EACP,wBACA,mBAEA,qBACA,EAAM,+BACN,eACA,oBACA,UACO,OACD,qCACN,IAIA,EAJA,oBACA,oBACA,oBACA,oBAEA,oDACA,oDAEA,EADA,iFACA,CACA,kBACA,kBACA,kBACA,CAEA,kBAEA,MACA,OACA,QACA,OACA,OACA,CACA,EAAM,uBACN,uBACA,aACA,mBAEA,YAGA,qBACA,0BACA,wBAEA,mBACQ,0BACR,mBAGA,CACA,iBACA,IACA,EADA,iBAEA,UACA,QACA,qBACA,SACA,qBACA,SACA,qBACA,SACA,mBACA,SACA,mBACA,SAEA,OADA,gBACA,mBACA,SAEA,OADA,gBACA,cACA,SACA,mBACA,SACA,QACA,QACA,QACA,QACA,YA/vEA,IAPA,EAuwEA,oBACA,gBACA,gBACA,SACA,UACA,QACA,QACA,2BACA,SACA,2BACA,SACA,2BACA,SACA,yBACA,SACA,yBACA,CAGA,gBAlxEA,CADA,EAkxEA,qCAjxEA,UARA,EAOA,OANA,eAOA,CAPA,WAOA,CAPA,OAOA,CAPA,UACA,0BACA,CAKA,CALA,gBACA,wEACA,CAGA,CAHA,aAGA,KAAqD,IAAM,MAkxE3D,QACA,UACA,QACA,QACA,2BACA,SACA,2BACA,SACA,2BACA,SACA,yBACA,SACA,yBACA,CACA,KACA,SACA,wDACA,CACA,CACA,CACA,SACA,iBACA,wBACA,cACA,gCACA,iCACA,CACA,YACA,mBAEA,OACA,gCACA,CACA,QACA,cACA,CAIA,aACA,4BACA,CACA,mBACA,SACA,YAAoB,IAAU,IAC9B,0BAEA,QACA,CACA,WACA,oCAEA,OADA,eACA,CACA,CACA,WACA,sDAEA,OADA,eACA,CACA,CACA,WACA,sDAEA,OADA,eACA,CACA,CACA,iBACA,SACA,YAAoB,IAAU,IAC9B,wBAEA,QACA,CACA,YACA,uDAEA,OADA,eACA,CACA,CAMA,WACA,cAQA,CAPA,mBACA,mBACA,qBAEA,mBACA,oBAEA,eACA,KAEA,YADA,QACA,UAEA,gBADA,SACA,GAEA,eACA,CACA,iBACA,SACA,YAAoB,IAAU,IAC9B,wBAEA,QACA,CAEA,YACA,QAQA,OAPA,mBACA,mBACA,qBAEA,mBACA,oBAEA,eACA,CACA,aACA,wDAEA,OADA,eACA,CACA,CACA,mBACA,SACA,YAAoB,IAAU,IAC9B,0BAEA,QACA,CACA,aACA,wDAEA,OADA,eACA,CACA,CACA,mBACA,SACA,YAAoB,IAAU,IAC9B,0BAEA,QACA,CACA,kBACA,sDAEA,OADA,eACA,CACA,CACA,aACA,kBACA,qCACA,aACA,mBAEA,OADA,6CACA,2BACA,CACA,CACA,SACA,SACA,SACA,CACA,CAsBA,eAEA,cADA,qBAEA,KAEA,OADA,cAGA,mFACA,CACA,eACA,mBACA,CACA,UACA,yBACA,EACA,sBACA,sBACA,IACA,KACA,iBACA,IACA,KACA,iBACA,IACA,KACA,eACA,eACA,KACA,SACA,8EACA,CACA,oDACA,mBACA,mBAkHA,EAjHA,GAiHA,EAjHA,SAiHA,EAjHA,EAiHA,EAjHA,EAkHA,gBAA4B,IAAQ,QACpC,UAEA,QApHA,CACA,cACA,UACA,eACA,aACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,+BACA,2DACA,YACA,kBACA,qCACA,UACA,wCACA,CACA,eACA,kCACA,wBACA,wCACA,CACA,mBACA,sCACA,UACA,yCACA,UACA,CACA,wCACA,8DACA,4DACA,gEACA,8DACA,sBACA,uBACA,6BAEA,wCACA,SACA,qBACA,aACA,kBACA,qCACA,iCAEA,SACA,SACA,2CAHA,QAII,SACJ,2CALA,OAMI,CAEJ,UADA,2CACA,iBACA,wBACA,2CAVA,EAWA,CACA,yBACA,qBACA,oIACA,2BACA,wBAIA,OAHA,kBACA,0BACA,wBACA,CACA,CACA,eAEA,OACA,MAEA,MAEA,MAEA,MAEA,MAEA,MAGA,QACA,IAhBA,UAiBA,oHACA,MAEA,KAEA,eAIA,OAHA,6BACA,oBACA,CAAG,CAEH,CACA,mBAGA,OAFA,kBACA,6BACA,+CACA,CAwGA,iBACA,GA7z2BA,IA6z2BA,EAEA,OADA,wGACA,EAEA,gBA8CA,OADA,uFACA,CA9CA,EACA,mBACA,aACA,SACA,6BACA,cAQA,OADA,yHACA,EAPA,YAAwB,UAAoB,IAC5C,UAEA,cACA,cAKA,CACA,gBACA,KACA,SACA,YAAsB,KAAwB,IAC9C,kBACA,kBACA,yBAGA,YAAsB,IAAuB,IAC7C,QACA,kBACA,oBACA,sBAEA,oBACA,oBACA,kBAIA,iBACA,kHAEA,gBAGA,OAFA,cACA,gBACA,CACA,CAIA,CACA,oBACA,eACA,SACA,sBACA,qBACA,yBACA,wBACA,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,CACL,CACA,cACA,IACA,EADA,OAEA,0BACA,yBACM,mBACN,2BACA,4BACA,EAAM,IACN,uBAEA,0BACA,kBACA,EACA,KAEA,iBAEA,uBACA,oBACA,EACA,uBACA,qBACA,iCACA,uCACA,2CACA,qBACA,IACA,wBACA,KACA,oBACA,CAAS,GACT,CAAQ,SACR,IACA,CACA,CAAK,KACL,CACA,kBAEA,OADA,mBACA,IACA,CACA,iBAEA,OADA,kBACA,KAEA,qBAEA,OADA,sBACA,KAEA,YAIA,OAHA,sCACA,6BAEA,KAEA,cAIA,OAHA,sCACA,+DAEA,KAEA,eAEA,IADA,EACA,KACA,KACA,kBACA,sBACA,qBACM,4BAEN,GADA,kCACA,IACA,IACA,+BACA,CAAU,SACV,QACA,MACA,CACA,2CACA,EAAQ,IACR,+BAGA,IAEA,2CACA,uFACA,MACA,CACA,gBACA,8BACA,6BACA,iCACA,qBACA,2BACA,mCACK,EACL,kDACA,YAAoB,8BAAiC,KACrD,gCACA,+EACA,YACA,YACA,CACA,oBACA,YAAsB,0BAAgC,KACtD,0BACA,2BACA,UACA,4BACA,YACA,KACA,oCACA,gCACA,KACA,+BACA,YACA,KACA,+BACA,YACA,KACA,SACA,gCACA,4DAEA,CACA,CAEA,mBACA,gBACA,YACA,CACA,gBACA,WACA,iCACA,gBACA,CAAK,CACL,CACA,CACA,cACA,SACA,OACA,gBACA,YACK,CACL,kBACA,MACA,CAAK,CACL,mBACA,YACK,CACL,qBACA,IACA,CACA,CACA,CACA,QACA,kCACA,wDACA,0CACA,kDACA,oDACA,sCACA,0CACA,gDACA,wDACA,sDACA,oDACA,0CACA,4CACA,wCACA,8CACA,8CACA,kEACA,wCACA,oCACA,oCACA,kDACA,iDACA,CACA,UACA,eACA,cACA,iCACA,YAAmB,OAAQ,SAC3B,CACA,YACA,kBACA,6BACA,uBAA0D,IAAwB,KAClF,WACA,+EACA,uDAEA,CACA,CACA,cACA,IAQA,EARA,cACA,aACA,iBACA,cACA,aAGA,EADA,CADA,4CACA,WACA,IAEA,kBACA,iEACA,iCACA,eACA,kBACA,cACA,4BACA,gBACA,KACA,aACA,cACA,WACA,KACA,YACA,cACA,WACA,kBACA,6EACA,qFACA,8BACA,yDACA,8BACA,gBACA,KACA,SACA,+DACA,CAQA,OAPA,sBACA,UACA,QACA,gDACA,8CACA,qBACA,iBACA,CACA,CACA,mBACA,eACA,yBACA,CACA,wBACA,WACA,cAEA,IADA,KACA,SAEA,EADA,4CACA,aACA,gBACA,oCACA,iCACA,CAAK,CACL,CACA,CACA,aACA,cACA,iCAEA,kBACA,SACA,CACA,oBACA,SACA,sBACA,YACA,6BACA,MACA,qCACA,wBACA,kCACA,eAEA,6BACA,sDAEA,CACA,qBACA,CACA,EACA,SACA,eACA,cACA,6CAEA,0BAEA,MADA,YACA,kBACA,2CACA,yBAEA,+CAIA,OAHA,YACA,wBAEA,iBACA,CACA,EACA,SACA,eACA,cACA,qCAEA,mBAEA,UADA,QACA,yBACA,sCACA,GADA,IAEA,CACA,0BACA,kBACA,sBACA,2CACA,yBAEA,SACA,0BAaA,GAZA,4BACA,gCAEA,6BACA,6DAEA,qCACA,kDAEA,sCACA,+EAEA,oCACA,yEACA,0CACA,oCACA,mCACA,CAEA,qBACA,CACA,EACA,SACA,eACA,cACA,sCAEA,mBAEA,MADA,YACA,yBACA,sCACA,GADA,IAEA,CACA,0BAEA,MADA,YACA,kBACA,2CACA,yBAEA,8BAEA,OADA,kDACA,iBACA,CACA,EACA,SACA,eACA,cACA,uCAEA,mBAEA,MADA,YACA,yBACA,sCACA,GADA,IAEA,CACA,0BACA,kBACA,sBACA,2CACA,yBAEA,SACA,0BAsBA,OArBA,8BACA,oCAEA,+BACA,iEAEA,2BACA,oCAEA,sCACA,wCAEA,wCACA,+DAEA,wCACA,+DAEA,wCACA,mFAEA,cACA,CACA,EACA,SACA,eACA,cACA,iCAEA,mBAEA,UADA,QACA,yBACA,sCACA,GADA,IAEA,CACA,0BACA,kBACA,sBACA,2CACA,yBAEA,SACA,2BACA,mBACA,UACA,8BACA,gCACA,yBACA,sCACA,CAUA,OATA,iCACA,0CAEA,8BACA,kEAEA,kCACA,uEAEA,cACA,CACA,EACA,SACA,eACA,cACA,wCAEA,mBAEA,MADA,YACA,yBACA,sCACA,GADA,IAEA,CACA,0BACA,kBACA,sBACA,2CACA,yBAEA,SACA,0BAOA,OANA,+BACA,sCAEA,gCACA,mEAEA,cACA,CACA,EACA,SACA,eACA,cACA,kCAEA,mBAEA,MADA,YACA,yBACA,sCACA,GADA,IAEA,CACA,0BACA,kBACA,sBACA,2CACA,yBAEA,SACA,0BACA,2DACA,6BACA,6DAEA,iDACA,kCAEA,OADA,sDACA,cACA,CACA,EACA,SACA,eACA,cACA,8BACA,CACA,mBAEA,MADA,YACA,yBACA,sCACA,GADA,IAEA,CACA,0BAEA,MADA,YACA,kBACA,2CACA,yBAEA,8BAEA,OADA,+BACA,iBACA,CACA,EACA,SACA,eACA,cACA,oCAEA,mBAEA,MADA,YACA,yBACA,sCACA,GADA,IAEA,CACA,0BACA,kBACA,sBACA,2CACA,yBAEA,SACA,0BACA,iEACA,4BACA,oEAEA,qCAKA,OAJA,mDACA,iCACA,wEAEA,cACA,CACA,EACA,SACA,eACA,cACA,gCAEA,mBAEA,MADA,YACA,yBACA,sCACA,GADA,IAEA,CACA,0BACA,kBACA,sBACA,2CACA,yBAEA,SACA,0BAKA,OAJA,iDACA,wBACA,mDAEA,cACA,CACA,EACA,SACA,eACA,cACA,sCAEA,mBAEA,MADA,YACA,yBACA,sCACA,GADA,IAEA,CACA,0BACA,kBACA,sBACA,2CACA,yBAEA,SACA,0BAUA,OATA,+BACA,oCAEA,+BACA,4CAEA,8BACA,+DAEA,cACA,CACA,CACA,UACA,eACA,cACA,gCAEA,eACA,kBACA,SACA,gBACA,2CACA,YAEA,8BACA,uBACA,MACA,uEAGA,iBAFA,2FAKA,uCACA,CACA,CACA,SACA,eACA,cACA,8BACA,qBACA,CACA,eACA,gBACA,cACA,SACA,gBACA,mCACA,YAEA,sBACA,qBACA,kBACA,UACA,yCACA,gBACA,CACA,6CACA,6CACA,4DACA,yEAEA,uBACA,CAAK,CACL,CACA,gBAUA,OATA,kBACA,0CACA,eACA,wBAAqC,iEACrC,8BACA,eACA,CACA,EAAO,EAEP,iBAEA,CACA,SACA,eACA,cACA,8BACA,qBACA,CACA,eACA,gBACA,cACA,SACA,gBACA,mCACA,YAEA,sBACA,qBACA,kBACA,UACA,yCACA,gBACA,CACA,6CACA,6CACA,4DACA,yEAEA,uBACA,CAAK,CACL,CACA,gBAUA,OATA,kBACA,0CACA,eACA,wBAAqC,iaACrC,8BACA,eACA,CACA,EAAO,EAEP,iBAEA,CACA,SACA,eACA,qCACA,aACA,CACA,kBACA,uBACA,mBACA,2CA8BA,WA9BA,EACA,8BACA,+CACA,qCACA,oBACA,uEAGA,iBAFA,kGAKA,0BACA,sBACA,kBACA,UACA,eACA,+BACA,wBACA,gEACA,gBACW,EAEX,wBACA,2BAEA,OADA,4DACA,CACA,CAAW,CAEX,CAAO,CACP,CAGA,CAHM,CAKN,aACA,eACA,qCACA,aACA,CACA,kBACA,uBACA,aACA,4DACA,YAGA,eADA,eACA,WACA,gGACA,YAIA,MADA,wBACA,WACA,KACA,KACA,eACA,2DACA,OACA,eAGA,WACA,MAEA,sCACA,wBACA,cACA,2BACA,aACA,KACA,gBACA,aACA,SACA,SACA,gBACA,kCACA,YAAwB,IAAW,IACnC,eACA,uCAEA,YACA,oCAEA,SACA,iCAEA,kCAEA,eACA,mBACA,UACA,wDACA,EAAY,mDACZ,gCAGA,4BACA,mCACA,SACA,QACA,WACA,UACA,YACA,GAEA,KACK,EACL,CACA,EACA,UAEA,IAAuC,4BACvC,UACA,eACA,6BACA,kBACA,eACA,uBAPA,IAQA,kBAMA,GALA,aACA,6CACA,0BACA,wBACA,EACA,uBACA,iEACM,yBACN,8DAEA,yBAnBA,GAoBA,iBApBA,IAqBA,IACA,WACA,wBACA,KACA,wBAEA,GADA,KACA,aACA,8BACA,yBACA,EAAQ,mBACR,UACA,yBACA,CACA,IACA,CACA,uBACA,wDAEA,CACA,CACA,SACA,iBACA,MACA,kEAEA,yCACA,YACA,mBACA,0BACA,CACA,qBACA,gBACA,mBACA,qCACA,qCACA,KACA,KACA,KACA,eAEA,EADA,uBACA,MAEA,2BACA,6BACA,kBACA,mCACA,sBACA,YACA,uBAEA,CACA,wDACA,iCACA,gCACA,2BACA,sBACA,YACA,uBACA,CACA,IACA,CAAS,UACT,CAAO,CACP,CAAK,CACL,CACA,CACA,SACA,cACA,mCAEA,yBACA,0GAGA,YACA,qBACA,uBAEA,mBACA,6BAEA,qBACA,wBAEA,kBACA,4BAEA,kBAfA,CAiBA,CACA,CACA,SACA,cACA,mCAEA,CACA,oBACA,qBACA,cACA,CACA,oBACA,uEACA,YAAoB,MAAiB,IACrC,YAEA,QACA,CACA,sBACA,wBACA,oBACA,iBACA,MACA,MACA,MACA,UACA,MACA,MACA,MACA,MACA,WACA,MACA,MACA,QACA,YAAoB,MAAc,KAClC,eACA,aACA,WACA,UACA,qBACA,CACA,QACA,CACA,CACA,aACA,qBACA,sBACA,kCAEA,OADA,uCACA,CACA,CACA,CACA,QAWA,SACA,QACA,YACA,aACA,YACA,iBACA,cAGA,EACA,IACA,eACA,gBACA,gBACA,iBACA,iBACA,iBACA,EACA,IACA,KA3/4BA,KA4/4BA,KAz/4BA,KA0/4BA,KA5/4BA,KA6/4BA,KA1/4BA,KA2/4BA,KA7/4BA,KA8/4BA,KA3/4BA,IA4/4BA,EACA,IACA,MArg5BA,KAsg5BA,MArg5BA,KAsg5BA,MAxg5BA,GAyg5BA,EACA,IACA,SACA,OACA,OACA,OACA,OACA,OACA,OACA,EACA,IACA,oBACA,gBACA,kBACA,gBACA,iBACA,iBACA,iBACA,gBACA,uBACA,oBACA,EACA,IACA,cACA,uBACA,sBACA,+BACA,EACA,IACA,mBAGA,OAp+4BA,KAq+4BA,KAt+4BA,IAu+4BA,EACA,IACA,gBACA,YACA,aACA,EAeA,mBACA,0BACA,gBACA,wDACA,6CAGA,CACA,iBACA,oBACA,0BACA,mCAEA,6EAGA,CAgFA,eACA,SACA,wBACA,uBAAoC,IAAQ,IAC5C,sBAA6D,EAE7D,QACA,CACA,eACA,UACA,eACA,YACA,iBACA,YACA,iBACA,cACA,kBACA,cACA,SACA,gFACA,CACA,CAOA,aACA,UACA,gBAAuB,KAAc,EACrC,YACA,mBACA,gBACA,eACA,kBACA,0BACA,uBACA,kBACA,gBAAuB,OAAQ,UAC/B,kBAAyB,OAAQ,UACjC,iBAAwB,OAAQ,UAChC,oBACA,qBACA,sBACA,SACA,KACA,KACA,KACA,kCACA,0BACA,gDACA,gCACA,4BAEA,EADA,4BACA,oCACA,CACA,wDACA,gDAEA,gDAEA,4DACA,gEACA,6CACA,+CACA,8CACA,sCAEA,CACA,iBACA,iBACA,CACA,cACA,cACA,CACA,WACA,WACA,YACA,kBACA,uBACA,kBACA,4BACA,iCACA,CAAK,EACL,wCACA,mCACA,CAAK,mBACL,oBACA,2BACA,+BACA,4BACA,CACA,CAAK,mBACL,OACA,uBACA,YACA,gBACA,aACA,cACA,SACA,WACA,EAGA,OAFA,UACA,QACA,qCACA,kCACA,CAAO,mBACP,sBACA,sBAEA,IACA,CAAO,CACP,CAAK,UACL,CAIA,YACA,0BACA,sBACA,uBACA,uBAA0D,IAAwB,KAClF,kBACA,uBAA0C,IAAQ,IAClD,iBAEA,CACA,uBAA0D,IAAwB,KAClF,gBACA,aACA,wCACA,iBACA,8BAGA,mBACA,2CAEA,CACA,CAUA,iBACA,aACA,oBACA,wBAEA,YACA,CAEA,mBACA,yBACA,gBACA,UACA,+BAIA,eAHA,SACA,2BAEA,sBACA,kBAEA,EAGA,OAFA,OACA,iCACA,CACA,CACA,cACA,kCACA,aACA,YAAoB,WAAuB,KAC3C,cACA,aACA,CACA,WACA,CACA,cACA,kCACA,gBACA,SACA,YAAoB,WAAuB,KAC3C,aACA,aACA,CACA,QACA,CAOA,mBACA,cACA,oBACA,OACA,UACA,YACA,oBACA,KACA,YACA,8BACA,gCACA,CAAW,EACX,KACA,YACA,8BACA,gCACA,CAAW,EACX,KACA,gBACA,uBACA,KACA,kBACA,8BACA,4CACA,CAAW,EACX,KACA,cACA,qBACA,KACA,gBACA,8BACA,wCACA,CAAW,EACX,KACA,eACA,8BACA,sCACA,CAAW,EACX,KACA,YACA,mBACA,KACA,iBACA,8BACA,0CACA,CAAW,EACX,KACA,cACA,qBACA,KACA,SAIA,IAHA,+BACA,qDACA,EAAW,EAEX,+BAGA,CACA,mBACA,CACA,QACA,CAMA,mBACA,wBACA,OACA,WAEA,cADA,yCACA,kBACA,2BACA,CAAO,GACP,mBACA,CACA,QACA,CAMA,cACA,2BACA,kBACA,kCACA,0EAEA,yBACA,iEAEA,mBACA,iCACA,uDACA,gEACA,CAAO,CACP,CAAK,CACL,CAMA,kBACA,+BACA,8DACA,sBACA,kBACA,qBACA,CAAK,CACL,CAMA,gBACA,WACA,YACA,yBACA,6CACA,iBACA,sBACA,oBAEA,8BADA,iBACA,KACA,CACA,SAUA,OATA,sBACA,sDAEA,aAEA,oBACA,qEACA,qEAEA,gCACA,IAQA,EARA,OACA,aACA,sBACA,sBACA,MACA,kBACA,sEACA,oBAEA,aACA,sBACA,0EACA,iBACA,IAEA,SADA,yBACA,KACA,kBAEA,qBACA,EAAQ,IAMR,SALA,SACA,iBAEA,qBAEA,KAEA,sBACA,gBACA,qCACA,iCACA,gCACA,iCACA,gCACA,WACA,oDAEA,gBACA,uBAAmD,IAAQ,KAC3D,WAKA,GAJA,iBACA,yBACA,yBACA,yBACA,qFACA,CACA,cACA,CACA,QACA,CAAK,CACL,CAMA,eACA,gBACA,eAEA,EADA,cACA,OACA,cACA,qBACA,UACA,iCACA,gBACA,CACA,mCACA,CACA,wBACA,WACA,YACA,gBACA,cACA,sCACA,wBACA,4BAEA,iDACA,WACA,0BACA,2EACA,eAGA,MADA,gBACA,gBAOA,OANA,6BAnk6BA,KAok6BA,6BAlk6BA,KAmk6BA,qBA3k6BA,IA4k6BA,qBA5k6BA,IA6k6BA,iFACA,sBAAyC,WAAwB,EACjE,CACA,CAAK,mBACL,WACA,CAAK,EAEL,OADA,uBACA,CACA,CACA,qBAEA,gBACA,eACA,gCACA,8CAEA,kBACA,2BACA,YACA,KACA,yBACA,EAXA,KAWA,0DACA,KACA,oBAA+C,gBAA0B,EAEzE,OADA,sBAEA,CAAO,OACD,kBACN,2EAEA,0CACA,iCACA,OACA,6BACA,eACA,eACA,kBACA,IACA,GAEA,0CACA,CAAO,CACP,CAAK,uBAlcL,EAwcA,MALA,QACA,qBAEA,QACA,gCAtcA,EADA,EAucA,OAtcA,4EACA,6EACA,6EACA,WAHA,EAucA,CACA,CAAK,oBAEL,MADA,2DACA,CACA,CAAK,EAEL,OADA,sBACA,CACA,CAQA,uBACA,WACA,8DACA,kBAKA,GAJA,mCAEA,CADA,cACA,oBAEA,wCACA,0EACA,MACA,4BACA,4DACA,uBACA,CACA,CAKA,OAJA,YACA,iBAEA,OACA,CACA,CAAK,CACL,CASA,uBACA,iBACA,aACA,gCACA,8BACA,+BACA,eACA,+BACA,oBACA,IACA,SACA,4BACA,sBACA,YACA,qBACA,qBAEA,GACA,EAAM,iBACN,kCACA,oBACA,IACA,SACA,4BACA,sBACA,YACA,qBAEA,GACA,CACA,YACA,kCACA,gCACA,yBACA,wBACA,wBACA,IACA,YACA,uBACA,sBACA,IACA,qCACA,wDAEA,oBACA,mDAEA,GACA,CACA,YACA,CACA,kBACA,SACA,CAMA,gBACA,IAIA,EAJA,OACA,YACA,kBACA,iBAEA,KACA,mBACA,KACA,8BACA,gCACA,sBACA,6BACA,EAAM,IACN,iCAGA,GAFA,sBACA,YACA,kCACA,wBACA,kCACA,eAEA,6BACA,uDAEA,yDACA,2DACA,sCACA,qEACA,sEAEA,8BACA,8CACA,CAAO,EACP,+CACA,0DACA,CAAO,GACP,CACA,oBACA,QAn06BA,CAm06BA,EAEA,6BAUA,GATA,cACA,iBACA,kBAEA,iBACA,aACA,uDAGA,mCACA,uDACA,0BACA,iCACA,4BACA,sBACA,CAQA,GANA,sCACA,sDACA,sCACA,gDAGA,mCACA,uBACA,6CACA,CAIA,OAHA,oCACA,8DAEA,+BACA,eAKA,OAJA,wBACA,QACA,sBAA0C,YAA0B,EACpE,wBACA,CACA,CAAK,CACL,CAEA,oBACA,wCACA,wBACA,gCAEA,wBACA,EAEA,CASA,kBACA,WACA,kBACA,sBAMA,KACA,uBAA4C,IAAQ,KACpD,WACA,EArsBA,YAEA,IADA,EACA,4DAMA,GAJA,EADA,EACA,yDAEA,0CAEA,mBACA,+BAAsD,IAAQ,IAC9D,wBAGA,QACA,EAurBA,GACA,OACA,KACA,sBACQ,CACR,MAEA,EADA,0DAdA,YACA,8EACA,gBACA,CAAO,CACP,EAWA,GAEA,eAEA,MAA6B,uBAC7B,SACA,CACA,CACA,qBACA,CAMA,YACA,WACA,YACA,kBACA,cACA,eACA,KACA,uBAA4C,IAAQ,SAj0BpD,EAk0BA,8BAj0BA,UADA,EAk0BA,YAj0BA,iBACA,2BACA,eACA,WACA,YACA,YACA,eACA,aACA,KAln5BA,CAmn5BA,EAAK,EAEL,mBAszBA,6CACA,SACA,CAEA,OADA,4BACA,gCACA,4BACA,gBACA,KACA,uBAA8C,IAAQ,KACtD,IAEA,EAFA,OACA,OAEA,OACA,gGAEA,KADA,iDACA,eACA,yBAEA,2BACA,yBAzz6BA,GA0z6BY,0BACZ,0BA1z6BA,EA0z6BA,OAEU,qBACV,mBACU,0BACV,mBACU,yBACV,mBACU,sBACV,mBAEA,oEAEA,mDACA,SAzxBA,KAEA,GADA,uBACA,mBACA,+BAAiD,IAAQ,IACzD,wCAGA,kDACA,2BACA,8CACA,2BACA,uBAA+C,IAAQ,IACvD,+BAEA,EAAM,IACN,oFAEA,CACA,EAuwBA,KAEA,6CACA,QACA,wBACA,yBACA,SACA,CACA,uBAA0C,IAAQ,IAClD,yBACA,SACA,YACA,CAAS,EAET,gBAEA,OADA,2BACA,KAEA,YACA,yBACA,sBAAuC,SAAmB,EAC1D,uBAA0C,IAAQ,IAClD,YAEA,QACA,CAAK,CACL,CAMA,cAEA,IADA,EACA,uBACA,mBACA,GAIA,uBACA,sEACM,yBACN,yDAEA,+CACA,QACA,yBAVA,4DAWA,CAMA,YACA,yBACA,KACA,8BAAgD,IAAQ,IACxD,2CAOA,OALA,+BACA,6DAEA,aAEA,gCACA,cAEA,KACA,KACA,uBAA8C,IAAQ,KACtD,WACA,MACA,UACA,YACA,WACA,0BAEA,SACA,EAAU,IACV,4EAEA,CACA,kBACA,CAAK,CACL,CAMA,iBACA,gBACA,OACA,kBACA,+BACA,KACA,KACA,KACA,KACA,KACA,gCAAuD,IAAQ,KAC/D,oBACA,wBACA,WACA,SACA,sDACA,6DACA,aACA,qCACA,yCACA,yCACA,UACA,UACA,CACA,oBACA,eACA,eACA,eACA,eACA,eACA,mBACA,WACA,OACA,OACA,OACA,OACA,KACA,uBAAyC,IAAQ,KACjD,WACA,OACA,OACA,OACA,OACA,sBACA,iBACA,iBAEA,0CACA,KACA,YAA0B,WAA0B,IACpD,YAGA,CACA,yBACA,CAAK,CACL,CACA,kBACA,gBACA,OACA,oBACA,qBACA,gDACA,0CASA,OARA,oBACA,uBACA,YACA,+BAAuD,IAAQ,IAC/D,wCAES,EAET,CACA,CAAK,CACL,CAMA,YACA,IAEA,MAFA,MAEA,SACA,EAFA,KAEA,oBACA,KACA,iBACA,uBAA6C,IAAQ,IACrD,OANA,KAMA,4BAEA,4CARA,KAQA,6BACA,oBACA,EACA,eACA,EACA,mBACA,WACA,OACA,cACA,GACA,uBACA,iBACA,YACA,CAAS,EAET,uBAA4C,IAAQ,IACpD,YAEA,QACA,CAAK,CACL,CAGA,oBACA,gBACA,kBACA,OACA,8BACA,yBAEA,iBACA,uCACA,KACA,2BACA,4CACA,CAAK,EAyDL,OAxDA,GACA,UAEA,mBACA,2DACA,8CACA,CAAO,GAEP,yBACA,wDACA,CAAK,sBACL,SACA,CAAK,EACL,kDACA,MAUA,IARA,EADA,cACA,OACQ,WACR,OACQ,aACR,KAEA,UAEA,KACA,uBAA6C,IAAQ,IACrD,YASA,GANA,SACA,uBACA,UAEA,QACA,wBACA,mBACA,aACA,sBACA,iBACA,EAAQ,IACR,wBACA,oCAEA,qBACA,mCAEA,kBACA,2BAOA,OAJA,uBACA,uBAAwC,EAExC,8BACA,CACA,CAAK,EACL,kBAOA,aACA,sBACA,sBACA,OACA,QACA,6CACA,QACA,wBACA,kBACA,KACA,uBAAyC,IAAQ,IACjD,qCAEA,uCACA,uBAAyC,IAAQ,IACjD,YAkBA,OADA,eAfA,KACA,cACA,8BACA,oCACA,WASA,OANA,eACA,2BACA,UACA,UAEA,CAAS,EACT,CACA,GACA,GACA,CACA,CAAK,CACL,CACA,kCACA,IAYA,EAZA,KACA,uBACA,KAWA,OAVA,wBACA,uBACA,yBACA,4BAEA,CAAO,EAEP,UAGA,YACA,gBACA,KACA,KACA,kBACA,KACA,KACA,kBACA,cACA,KACA,KACA,SAGA,EADA,IADA,WAEA,GAKA,EAIA,CACA,mDAnr7BA,KAor7BA,gCACA,uBAA6C,IAAQ,KACrD,YACA,oBACA,QACA,EACA,EAEA,kCACA,2CAEA,SACA,CACA,QACA,CACA,yBACA,cACA,iBACA,wBACA,6BACA,uBAA+C,IAAQ,IACvD,YAEA,GACA,CACA,QACA,CACA,sCACA,gCAEA,UADA,2BACA,+CACA,EACA,gEACA,CACA,CAyDA,mBACA,mBACA,KAMA,gBACA,6BACA,mBACA,OARA,cACA,sDACA,mBACA,CAAK,CACL,EAIA,QACA,CACA,iCACA,6DACA,aACA,CAAK,EACL,SACA,CAMA,OALA,0CACA,kFAAsF,qBAAkC,mBAExH,SACA,SA/EA,OACA,mBACA,SACA,uBAmBA,MAnBA,EACA,mCACA,QACA,QACA,0BAUM,OACN,oFANA,GAJA,MACA,uBACA,wBAEA,cACA,8BACA,wBACA,uBACA,CAKA,CAGA,CAHI,GAGJ,YACA,eACA,aACA,SACA,uBAAyC,IAAQ,KACjD,WACA,wBACA,mCACA,QACA,QACA,2BAIA,GAHA,gDACA,gDACA,gDACA,cACA,8BACA,mBACA,CACA,QACA,EAAU,IACV,mFAEA,CACA,CACA,mBACA,CACA,gBACA,aACA,sBACA,mCACA,kBACA,EAwBA,OACA,+BACA,mCA7xCA,OACA,SACA,KACA,KACA,uBAAuC,IAAQ,KAC/C,WAIA,GAHA,4BACA,0BACA,2BACA,aACA,CACA,wCACA,SACA,KACA,KACA,uBAAuC,IAAQ,KAC/C,WACA,MACA,uFACA,SACA,CACA,MACA,iFACA,SACA,CACA,MACA,kFACA,SACA,CACA,CACA,oBACA,eACA,eACA,eACA,mBACA,WACA,OACA,OAKA,OAJA,kCACA,gCACA,+BACA,0BACA,CACA,CAAG,CACH,EAivCA,gBACA,CAAG,CACH,CACA,oBACA,eACA,QACA,CAcA,cACA,WACA,gDACA,uBACA,qBACA,uCACA,2CACA,qBACA,IACA,eACA,CAAQ,SACR,EACA,KAEA,iBAEA,sBACA,CACA,CAAK,KACL,CACA,sBAEA,OADA,uBACA,KAaA,WACA,oBACA,KACA,QACA,KACA,YAAoB,WAAkB,KACtC,WAEA,OADA,aACA,0BACA,SAEA,qBACA,0BACA,kBACA,+BAEA,GADA,WACA,aACA,GAAiB,QACjB,YAEA,2CACA,kBACA,4DACU,IACV,MAGA,CACA,wDAIA,OAHA,mCACA,2BACA,kBACA,CACA,CACA,CACA,SACA,qBAAwC,EACxC,eACA,eACA,sBACA,kBACA,uBACA,mBACA,6BACA,uDAxg8BA,EAyg8BA,uDAj97BA,GAk97BA,CACA,kBAEA,OADA,mBACA,KAEA,cACA,cACA,CACA,gBACA,mCACA,kBACA,uBACA,kBACA,CACA,WACA,0BACA,SACA,gBACA,WACA,KAEA,aADA,OACA,GACA,SACA,OACA,kBACA,UACA,SACA,SACA,SACA,yCACA,iCAEA,2CACA,8BACA,MAIA,CACA,GACA,QAEA,CACA,CACA,QACA,CACA,UACA,gCACA,cAEA,CACA,YACA,0BAEA,aACA,QACA,gCACA,sCACA,qBACA,IAEA,2BAEA,UAIA,OAHA,4BACA,wBAEA,kBAEA,mBACA,WACA,wBACA,GACA,OACA,gBAQA,oBANA,IAOA,eACA,8BACA,iBATA,EASA,UARA,iBADA,EASA,QARA,OACA,GACA,0BACA,MAMA,uBACA,wBACA,eACA,eACA,gCACA,kBAEA,MACA,CACA,gBACA,IACA,EADA,OAEA,UACA,wBACA,SACA,yDACA,KACA,UACA,4DACA,KACA,UACA,4DACA,KACA,cACA,WACA,KACA,cACA,mBACA,KACA,cACA,mBACA,KACA,YACA,iBACA,KACA,gBACA,WACA,eACA,KACA,aACA,gBACA,iBACA,KACA,UACA,0BACA,KACA,SACA,kBACA,IACA,YACA,kBAEA,KACA,UACA,gBACA,qDACA,MACA,cACA,iBAGA,CACA,CAEA,OADA,4BACA,kBAEA,sBACA,IAKA,EALA,GACA,kBACA,kBACA,EACA,iBAkBA,MAhBA,sBACA,IACA,+BACA,eAEA,qBACA,IACA,mDACA,eAEA,qBACA,IACA,oDACA,eAEA,yBACA,CACA,CACA,uBACA,4CACA,iBACA,WACA,cAEA,qDACA,sBAEA,OADA,0BACA,CACA,CACA,CACA,uBACA,cACA,cACA,cACA,SACA,UACA,UACA,UACA,UACA,UACA,UACA,cACA,OACA,WACA,SAAc,CACd,YACA,WACA,UACA,OACA,YAAiB,CACjB,qBACA,0BACA,kDACA,mBACA,mCACA,MACA,CACA,uGA6EA,GA5EA,uDACA,0BAEA,aACA,WACA,uBACA,UACA,YACA,WACA,UACA,OACA,eACA,CAAS,CACT,aACA,UACA,4BACA,wBACA,oCACA,iCAEA,OACA,4BACA,WACA,qDACA,uCACA,mCACA,YACA,cACA,aACA,kBACA,OACA,sCACA,eACA,mBACA,mBACA,aACA,YACA,cACA,YACA,EAEA,OADA,2BACA,CACA,CACA,EAEA,OADA,uBACA,CACA,CAAS,CACT,2BACA,2BACA,8CAGA,CAAS,CACT,sBACA,6BAMA,GALA,qBACA,2CACA,qCACA,gBAEA,2BACA,kCAAqD,KAAS,IAC9D,iCACA,2BAUA,OANA,8BACA,qBACA,QACA,mBACa,EAEb,CACA,CACA,EACA,uCACA,gBACA,gBACA,6BACA,CACA,8BACA,CAAK,CACL,oBACA,uDACA,yBAEA,CAAK,CACL,+BACA,qBACA,wBACA,CAAK,CACL,+BACA,qBACA,wBACA,CAAK,CACL,2BACA,qBACA,wBACA,CAAK,CACL,0BACA,oBACA,gCACA,6BACA,6BACA,4BACA,CAAK,CACL,2BACA,oBACA,8BACA,0BACA,CAAK,CACL,0BACA,oBAEA,IADA,0BACA,0BACA,CAAK,CACL,0BACA,mBACA,+BACA,6BACA,6BACA,4BACA,CAAK,CACL,8BACA,oBACA,+BACA,kBACA,kBACA,kBACA,qBACA,qBACA,aACA,eACA,uBACA,uBACA,sBACA,CAAK,CACL,yBACA,kBACA,mCACA,uCACA,4CACA,2CACA,CAAK,CACL,sBACA,eACA,2BACA,sBACA,sBACA,qBACA,CAAK,CACL,wBACA,+BACA,YACA,YACA,WACA,CAAK,CACL,sBACA,eACA,yBACA,mBACA,CAAK,CACL,oCACA,2BACA,6BACA,6BACA,6BAGA,GAFA,sBACA,qBACA,oBACA,0BACA,6BACA,6BACA,6BACA,qBACA,EAAQ,IACR,0BAEA,uBACA,sBACA,yBACA,yBACA,yBACA,kBACA,oCACA,EAAQ,IACR,mBAEA,CAAK,CACL,6BACA,mCACA,2BACA,uBAA4C,IAAQ,KACpD,oCACA,uBACA,gBACA,CACA,CAAK,CACL,8BACA,iCACA,2BACA,kBACA,uBAA4C,IAAQ,IACpD,kDAEA,uBAAwC,IAAS,IACjD,yCAEA,CACA,EAEA,OADA,qBACA,CACA,CACA,oBACA,eACA,SACA,mBACA,CACA,cACA,WACA,uBACA,qBACA,uCACA,2CACA,qBACA,IACA,aACA,CAAQ,SACR,EACA,KAEA,iBAEA,sBACA,CACA,CAAK,KACL,CACA,gBAEA,OADA,iBACA,KAEA,SACA,YACA,yBACA,4BAEA,wBACA,0BAEA,oBACA,KACA,uBAAsC,IAAO,KAC7C,uBACA,yBACA,kBACA,WACA,YACA,kBACA,aACA,QACA,gBACA,iBACA,iBACA,kBAEA,aACA,UACA,iBACA,iBACA,iBACA,IAEA,+BAEA,oCAEA,KACA,UACA,eACA,iBACA,iBACA,kBAEA,KACA,UACA,WACA,iBACA,iBAGA,CACA,EAAQ,gBAER,MADA,kBACA,UACA,KACA,uBAAgD,IAAQ,KACxD,WACA,eACA,mBACA,SACA,CACA,CACA,WACA,yBAAsD,IAAQ,KAC9D,WACA,SACA,UACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KAEA,CACA,EAAQ,gBACR,uCACA,KACA,KACA,uBACA,SAEA,uBAAoD,IAAW,KAC/D,qBACA,yBACA,uBACA,CAEA,sBACA,EAAQ,gBAER,QADA,gBACA,WACA,qBACA,EAAQ,8BACR,0CACA,gBACA,EAAQ,kBACR,uEACQ,cACR,qDACQ,cACR,0HACQ,YAER,GADA,iBACA,UACA,+BACA,mCACA,EAAU,IACV,mBAEA,gCACA,8BACA,EAAQ,IACR,qBACA,yDACA,CACA,CACA,aACA,aAGA,GAFA,mDAEA,IADA,kEAEA,+BAAgD,IAAO,KACvD,IAsDA,EAtDA,eACA,aACA,cACA,kBACA,oBACA,KACA,kCACA,aACA,gDACA,oBACA,6CAEA,oBACA,KACA,4CAEA,qBACA,qCAEA,SACA,uBAAmD,IAAY,KAC/D,WACA,4BACA,iBACA,yBAEA,GADA,gCACA,wBAKc,8BACd,cAA0D,2BAAkC,EAC5F,4BACA,sBACA,YACA,GACA,MAXA,CACA,aACA,4BACA,sBACA,GACA,CAQA,CARc,IAQd,QAQA,CANA,EADA,EACA,OACc,EACd,QAA8C,0BAAiC,EAE/E,QAEA,YACA,wBACA,iBACA,kBAEA,SACA,CAEA,eACA,uBAAqD,IAAY,KACjE,WACA,uCACA,CAEA,EADA,EACA,YACY,EACZ,YAEA,WAEA,EAAU,IAEV,EADA,EACA,eACY,EACZ,eAEA,cAGA,eACA,QACA,MAEA,wBACA,cAA8C,0BAAiC,EAC/E,SACA,gDACA,0CACA,2CACA,mBAEA,kBACA,QACA,CAEA,QACA,CACA,CACA,oBACA,eACA,QACA,CACA,cACA,WACA,uBACA,qBACA,iCACA,uCACA,2CACA,qBACA,IACA,aACA,CAAQ,SACR,EACA,KAEA,iBAEA,sBACA,CACA,CAAK,KACL,CACA,SA8JA,MAXA,YACA,sBAOA,QAPA,EACA,+BACA,YAAwB,WAAmB,IAC3C,yBAEA,kBACA,CAGA,CAHQ,CAIR,GACA,gBA9JA,GACA,sBAIA,GADA,GAFA,GACA,qBAEA,aACA,SAEA,4BACA,YAAwB,IAAS,IACjC,GAIA,gBACA,uBAAyC,IAAQ,IACjD,mCAEA,QACA,EATA,gBAEA,QACA,EAiJA,GA1EA,YACA,IAYA,EAZA,SACA,6BACA,6BACA,gBACA,IACA,0DACA,6BACA,6BACA,KACA,KACA,KACA,SAEA,IACA,IACA,IACA,4BACA,IACA,WACA,+BAEA,IADA,UACA,uBACA,QACA,IACA,OACA,2BACA,qBACA,qBACA,qBACA,IAEA,2BACA,2DACA,oBACA,IACA,GAEA,QACA,0FAEA,OACA,4FAEA,GACA,CACA,QACA,KACA,yBACA,kBACA,GACA,CAGA,OAFA,uCACA,qCACA,CACA,EAEA,iBAiBA,EAhBA,yBAgBA,MA1IA,YACA,IAGA,QAHA,kBACA,qBACA,aAEA,YAA0B,KAAiB,IAC3C,0EACA,KACA,0BACA,sBACA,sBACA,sBACA,uBAKA,aACA,0BACA,0BACA,SACA,YAAyB,IAAc,KACvC,MAPA,GACA,GAMA,EACA,qBACA,uBACA,uBACA,MACA,0BACA,eACA,YACA,eACA,kBAEA,IACA,IACA,IAEA,CACA,YAAwB,KAAQ,KAChC,aACA,eACA,yBACA,4BACA,4BACA,OACA,SACA,SACA,IACA,mBACA,SACA,WACA,WAEA,CACA,CAQA,OAPA,uCACA,qCACA,IACA,oCACA,eACA,WAEA,CACA,EA2EA,EACA,CACA,CACA,6BAEA,YADA,yBAAkF,kDAA6D,UAC/I,8BACA,UACA,iBACA,sBACA,qBACA,qBACA,qBACA,qBACA,wBACA,wBACA,oBACA,oBACA,uBACA,sBACA,sBACA,sBACA,qBACA,CACA,OACA,CACA,UACA,CACA,qBACA,UACA,QAIA,EACA,GAJA,sDACA,+BACA,gCAEA,EACA,sDACA,sGACQ,CACR,2DACA,qEACA,EACA,4DAEA,0CAEA,CACA,iBACQ,OAAa,YAAY,OAAC,6CAGlC,uCACA,IACA,sCAEA,mDACA,CAAM,SACN,oDACA,wCACM,OAAa,YAAY,OAAC,oCAChC,CACA,CACA,6BACA,WACA,uCACA,oBACA,MAEA,OADA,4CACA,KAEA,IAEA,mBAFA,4CAEA,iCADA,wBACA,aACA,UACA,UACA,0BACA,wCACA,sCACA,yBACA,aACA,EACA,oCAEA,SACA,SACA,IACA,KACA,WACA,0BACA,wCACA,sCACA,IACA,eACA,iBACA,qDAEA,CAAS,EACT,KACA,WACA,+CACA,IACA,0BACA,iCACA,oCACA,YACA,8BACA,CAAY,SACZ,YACA,sEAEA,CAEA,0BACA,sCACA,aACA,iBACA,qDAEA,CAAS,EACT,KACA,YACA,UACA,2BACA,yCACA,sCACA,UACA,qBACA,kBACA,kCACA,sDAEA,CAAS,CAET,CACA,QACA,CACA,CACA,QACA,UACA,OACA,kBACA,gBACA,2BACA,QACA,mBACA,iBACA,4BACA,CACA,QACA,kBACA,mBACA,CACA,SACA,kBACA,mBACA,CACA,UACA,OACA,kBACA,gBACA,QACA,mBACA,iBACA,CAEA,UACA,cACA,uBACA,wBACA,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,EACL,0BACA,gBACA,CAAK,CACL,CACA,YAIA,OAHA,sCACA,6BAEA,KAEA,cAIA,OAHA,sCACA,+DAEA,KAEA,mBAEA,OADA,oBACA,KASA,eACA,aACA,KACA,0CAAsD,IAAQ,IAC9D,mCAEA,gBACA,qCACA,4BACA,CACA,gBACA,WACA,iCACA,gBACA,CAAK,CACL,CACA,CACA,QACA,SACA,QACA,YACA,aACA,YAGA,UACA,mBACA,WACA,oBACA,SACA,kBACA,WACA,mBACA,2BACA,aACA,YACA,4BACA,2BACA,2BACA,0BACA,oBACA,sBACA,YACA,EACA,2BACA,MACA,GArk+BA,KAqk+BA,YACA,GArk+BA,KAqk+BA,2BACA,GArk+BA,KAqk+BA,0BACA,GArk+BA,KAqk+BA,WACA,GArk+BA,KAqk+BA,0BACA,GArk+BA,KAqk+BA,yBACA,GA7k+BA,KA6k+BA,kBACA,GA/k+BA,IA+k+BA,WACA,GA9k+BA,KA8k+BA,oBACA,QACA,cACA,uBACA,sBACA,+BACA,EACA,UAOA,iBACA,kDACA,gBACG,CACH,CAgCA,eACA,uBACA,CACA,mBACA,uBACA,qBACA,wBAEA,GADA,yBACA,MACA,uBAA2C,IAAkB,IAC7D,OAGA,gBAEA,QACA,CACA,oBACA,kEACA,yBAEA,gCACA,CACA,qBAIA,SAHA,kBACA,+BAGA,iBACA,MACI,kBACJ,OAEA,iBACA,OACA,SACA,CAAG,EACH,CACA,SACA,cACA,gBACA,gBACA,gBACA,gBACA,kBACA,gBACA,qBACA,cACA,uBACA,2BACA,kBACA,WACA,WACA,OACA,cACA,mCACA,CACA,EACA,YACA,eACA,mBACA,6BACA,kBACA,iBACA,cACA,EACA,sBACA,CACA,cACA,cACA,CACA,mBACA,mBACA,CAOA,yBAA8C,EAC9C,4BAEA,UACA,OACA,eACA,mBACA,cACA,0BACA,CAAK,IACL,kCACA,sBAEA,gCACA,gCAEA,MADA,KACA,QACA,EAFA,KAEA,KACA,EAHA,KAGA,QACA,MAJA,KAIA,eACA,EALA,KAKA,mBACA,cAAsC,gCAAkC,EACxE,iBACA,iBAIA,GAHA,iCACA,qCACA,gEACA,eACA,qBACA,uBACA,2BA7IA,EA8IA,mBACA,+BAvJA,IAwJA,+BACA,cAvJA,QAuJA,IACA,UAlJA,EAkJA,kBAjJA,oCAiJA,IACA,+BA3JA,IA4JA,+BACA,cA5JA,WA4JA,IACA,sBAjKA,IAkKA,kBACA,cAlKA,WAkKA,IACA,cAlKA,EAkKA,IACA,MArKA,GAqKA,oDACA,oBACA,gBACA,EACA,EACA,EACA,EACA,EACA,EAAa,gCAAkC,EAC/C,iBACA,uBACA,uBACA,WACA,CACA,CACA,EAAM,IACN,kCACA,qBACA,mBACA,uBACA,cACA,oBACA,IACA,CACA,EAAQ,IACR,IAGA,CAOA,uBACA,6CACA,mBACA,sBACA,IACA,6CACA,gDAEA,aADA,yCACA,iBACA,oCACA,OAEA,yBAEA,qCACA,CAAM,SACN,6HACA,CACA,CAMA,eACA,0BACA,cACA,qBACA,qBACA,kBACA,CAEA,WADA,aACA,MACA,CAOA,+BAEA,OADA,OACA,qCACA,aACA,sBAAuC,IAAQ,IAC/C,iEAEA,QACA,CAQA,mCACA,iBACA,sEACA,gBACA,SACA,sBAA0C,IAAQ,IAClD,2BACA,0BACA,UAEA,cAEA,wBAGA,OADA,gCACA,CACA,CAQA,2BACA,SACA,KACA,mCACA,4BACA,MAEA,iBACA,sBACA,MAEA,mCACA,2BACA,MAEA,IACA,8BACA,qCACA,6CAEA,CACA,uCACA,kBACA,qBACA,kBACA,YACA,qEACA,EAEA,YACA,QACA,CACA,CACA,iBACA,yCAEA,iBACA,yCAEA,qBACA,iBACA,oCACA,sCACA,MACA,WACA,WACA,yBACA,qBACA,CAAK,CACL,uBACA,oBACA,8BACA,MACA,uBACA,WACA,+BACA,YAAsB,WAAiB,KACvC,yBAEA,CACA,MACA,uBACA,WACA,+BACA,YAAsB,WAAiB,KACvC,yBAEA,CACA,sBAEA,MADA,OACA,QAQA,OAPA,mBACA,aAr2+BA,GAs2+BA,yBACA,6BACA,uGAEA,mFACA,CACA,CACA,sCACA,4BACA,oGAEA,8CACA,CAMA,iBACA,gBACA,eAGA,OAFA,wBAAyC,cAAe,EACxD,UACA,CACA,CAUA,6BACA,IAEA,EAFA,YAGA,OAFA,mCAEA,GACA,aACA,sBACA,IACA,KACA,eACA,uBACA,IACA,KACA,SACA,GACA,CACA,kBACA,sBACA,qBAEA,cACA,mCACA,IACA,YAAwB,MAAmB,KAC3C,YAAsB,aAAwB,KAC9C,KACA,cACA,2BAEA,kBACA,kBACA,kBACA,qBACA,mBACA,6BAGA,aACA,qBACU,WACV,mBACU,oBACV,oBACU,aACV,mBACU,sBACV,oBACU,YACV,eACU,sBACV,gBAEA,IACA,CACA,QACA,UAEA,CACA,OACA,oCACA,2BACA,YACA,EAWA,OAVA,yBACA,qBACA,iBAEA,mBACA,sBACA,CACA,0BACA,YACA,CAEA,CAMA,0BACA,WACA,SAEA,OADA,kCACA,wBACA,qBACA,uBACA,uBACA,mBACA,GACA,0BACA,wBACA,wBAEA,4BACA,0BACA,CACA,CAAK,CACL,CASA,yBACA,IASA,EAsBA,EA/BA,YAUA,sCACA,gBACM,oCACN,cACM,qCACN,uBACM,oCACN,gBACM,qCACN,yBACM,mCACN,eACM,oCACN,wBAEA,yGAIA,GAFA,kBACA,mCACA,kBACA,eA5fA,OACA,OACA,gCACA,gCACA,EACA,YAAsB,MAAmB,IACzC,YAAoB,aAAwB,KAC5C,KACA,cACA,2BAEA,kBACA,kBACA,kBACA,qBACA,mBACA,6BAGA,8BACA,6BACA,CAEA,QACA,EAoeA,MAEA,aACA,wDAEA,wCACA,GACA,gBACA,wBACA,gBACA,QACA,UACA,UACA,KA1CA,CACA,WACA,SACA,SACA,SACA,SACA,SACA,CAmCA,cAIA,MAFA,qCACA,8BACA,qBACA,CASA,kCACA,aACA,WACA,UACA,SACA,YACA,WACA,mCAAgE,EAChE,sBACA,2BACA,4BACA,yBACA,gBAAyB,GACzB,MACA,4CACA,6CACA,yBACA,qBACA,CAAO,EAKP,GAJA,SACA,wBACA,eAEA,iBACA,UACA,+DAEA,uDACA,yEAEA,gDACA,YAAwB,WAAiB,KACzC,mBACA,mBACA,mBACA,mBAEA,qDACA,EAAQ,IACR,4QACA,yCAEA,+HAGA,eACA,OACA,sDACA,cACA,CAAW,GAGX,qBACA,qBAEA,OACA,4DACA,OACA,CAAa,GAIb,yBAEA,OADA,OACA,CACA,CACA,CADM,KACN,kFAEA,CAMA,kBACA,gBACA,4BACA,OACA,0BACA,0BACA,kBACA,mBAEA,2BACA,CAMA,6BAEA,MADA,KACA,QACA,aACA,YACA,6CACA,6BACA,iBACA,0DAEA,yBACA,mCACA,OACA,+BACA,oDACA,CACA,yBACA,6CACA,yCACA,CAAK,EACL,2BAEA,OADA,oBACA,CACA,CAMA,8BACA,iBACA,YACA,gDACA,sBAEA,OADA,kEACA,IAEA,+BACA,OAA0B,wBAC1B,4DACA,8FAEA,4CAWA,GAVA,iBACA,2CAEA,0BACA,kDACA,qDAEA,wCACA,0CAEA,gCACA,4EACA,GACA,wCACA,oBAEA,gCACA,iDACA,CACA,UACA,OACA,4CACA,sBACA,EACA,oCACA,yCACA,CACA,eACA,iBAKA,GAHA,KADA,iBACA,GACA,wCAEA,eACA,OACA,oDACA,gCAEA,4CACA,mBACA,CACA,CACA,gBACA,OACA,kDACA,6BAEA,qCACA,0BAEA,0CACA,iBACA,CACA,YACA,OACA,8CACA,yBAEA,uBACA,8BAEA,sCACA,oBACA,CACA,cACA,oBAEA,gBACA,mBACA,2BAGA,+BACA,6BACA,4BACA,6CACA,qDACA,CAAK,EACL,4BAEA,OADA,qBACA,CACA,CAMA,0BACA,IAaA,EAbA,aACA,YACA,oBACA,6BACA,gCAAgD,IAAO,IACvD,gCAGA,wBAEA,kBACA,0CACA,iBAGA,EADA,iBACA,SACM,aACN,aACM,SACN,cACM,WACN,UAEA,2CAEA,SACA,KACA,KACA,KACA,GACA,gBACA,iBACA,iBACA,iBACA,gBACA,uBACA,oBACA,EACA,0BACA,mDACA,sGACA,kEAEA,WACA,2BACA,mCACA,sBAIA,GAHA,wBACA,4EACA,mBACA,kCACA,sCACA,QACA,CACA,OACA,cACA,kEAGQ,0EACR,yCAAiD,EAAc,6BAC/D,yCAJA,sFACA,sDAKA,kCACA,YACA,mBACA,iCAEA,OACA,mCAEA,CAEA,GADA,uCACA,sCACA,uEACA,SACA,KACA,KACA,oCACA,qCACA,gCAGA,YAAsB,iCAAuC,KAC7D,SACA,KACA,gCACA,iCACA,IACA,4EACA,MAEA,QACA,CACA,8BACA,kBACA,kBACA,wCACA,yCACA,QACA,CACA,gBACA,2BACA,sBAAkD,IAAQ,IAC1D,YAA8B,aAAwB,IACtD,qCACA,qCACA,qCACA,oCAIA,gCACA,wCACA,CACA,UACA,mCACA,8CACA,CACA,YACA,aACA,YACA,uBAEA,CACA,gCACA,sCACA,SACA,sBACA,SACA,0CAA+D,IAAQ,IACvE,OAEA,cACA,IACA,CACA,gCACA,eAA0D,0CAAgD,EAC1G,uBAAwC,IAAQ,KAChD,OACA,OACA,YACA,EAGA,GAFA,4BACA,0BACA,gBACA,0BACA,6CACA,mCAEA,oBACA,+BAEA,gEACA,+BAEA,mCAEA,4DACA,0BACA,SACA,CACA,QACA,iBAEA,eACA,wBACA,uCACA,6BACA,CAAK,EACL,yBAEA,OADA,kBACA,CACA,CAYA,gCAEA,EADA,kCAEA,4BACA,eACA,SACA,KACA,iBACA,kBACA,KACA,iBACA,UACA,KACA,kBACA,mBACA,KACA,SACA,MACA,CACA,iCACA,wBACA,2BACA,2BACA,+BAEA,CAMA,iBACA,gBACA,0BACA,6BACA,GACA,mCACA,EAiBA,OAhBA,EACA,gBACA,eACA,aACA,yBACA,yBAGA,eACA,qBACA,wBACA,yBACA,yBAGA,6BACA,mBACA,CAWA,sBACA,gBACA,eACA,gCAEA,MADA,iDACA,OACA,KACA,KACA,YAAoB,WAAmB,KACvC,IAoBA,EApBA,OACA,4BACA,4BACA,qBAQA,GAPA,yBAEA,EADA,qBACA,wCAEA,QAGA,QACA,kFACA,QACA,CAEA,qCACA,8BACA,oCAGA,oEACA,gBACA,MAEA,EADQ,4BACR,OAEA,SAEA,QACA,0CAfA,IAgBA,gDACA,eACA,CAAO,EACP,QACA,mBACA,QACA,cACA,MACA,CACA,CAAO,CACP,CAMA,OALA,mBACA,yCACA,WACA,UACA,CAAK,EACL,qBACA,CAKA,eACA,gBACA,eACA,oBACA,aACA,0BACA,0BACA,0BACA,SACA,sCACA,SACA,YAAoB,iBAA2B,IAC/C,0BACA,0BACA,yCASA,OAPA,+BACA,cACA,uDACA,SACA,iBACA,CAAK,EACL,uBAEA,CAMA,0BACA,gBACA,eACA,eACA,sBACA,SACA,UACA,6BACA,uBACA,mBACA,kBACA,eAEA,eACA,kBAEA,eACA,WAEA,EAAM,IACN,oBACA,iBAEA,KApmCA,KAomCA,OApmCA,6CAqmCA,6BAKA,GAFA,qCACA,4BACA,gCACA,oCACA,qBACA,EAAM,gBACN,iCAGA,GADA,oCACA,qBACA,SACA,gCAAkD,IAAO,KACzD,oBACA,kCACA,oCACA,oBACA,CACA,CACA,0BACA,CACA,uCACA,6BACA,CAAK,EACL,wBAEA,OADA,WACA,CACA,CAKA,2BACA,gBACA,cACA,YACA,YACA,WAEA,QACA,8BACA,iBACA,SACA,gCAA+C,IAAO,KACtD,oBACA,kCACA,oCACA,oBACA,CACA,CACA,wBACA,2BACA,CAKA,6BACA,YACA,mBACA,YAAoB,WAAoB,IACxC,qBAEA,gCACA,CAIA,2BACA,mBACA,2BACA,uCACA,+BACA,CAAK,EACL,SACA,YAAoB,WAAkB,IACtC,kBACA,mCAEA,YAGA,aACA,kCAEA,YAAoB,oBAAuB,IAC3C,gCAEA,YAAoB,sBAA+B,IACnD,2CAEA,wCACA,6BACA,CAAK,CACL,CACA,yBACA,kCAA8C,IAAQ,IACtD,wBAEA,CACA,CACA,SACA,eACA,cACA,+BACA,CACA,eACA,qBACA,sEACA,8FAGA,kBACA,SACA,mBACA,IACA,yBACA,0BACA,wBACA,qBACA,qBACM,gBACN,eACA,oCACM,gBACN,cACA,mCACA,UACA,6CACA,+BAEA,+BACA,kHAEA,6GACA,gJAEA,eACA,8BACA,yBAAqC,WACrC,iBAEA,qCACA,UACA,8BACA,yBAAsC,iBACtC,CACA,CACA,SACA,eACA,cACA,+BACA,CACA,8BACA,iCAEA,MADA,YACA,cACA,+BACA,2BACA,gBACA,wCACA,yCACA,CACA,CACA,SACA,eACA,cACA,mCACA,CACA,8BACA,qDACA,kBACA,mBACA,KAEA,GADA,8BACA,gBACA,OACA,kDACA,+BACA,EACA,0CACA,oBACA,CAEA,GADA,gDACA,yBACA,OACA,2DACA,0CAEA,mDACA,6BACA,CACA,yBACA,OACA,wDACA,sCAEA,kEACA,gDACA,0BACA,CACA,8BACA,0BACA,eACA,CACA,CACA,SACA,eACA,cACA,oCACA,CACA,8BACA,sDAEA,MADA,YACA,eACA,IACA,2BACA,8BACA,0BACA,eACA,CACA,CACA,SACA,eACA,cACA,qCACA,CACA,8BACA,uDACA,kBACA,mBACA,KAEA,GADA,kCACA,kBACA,OACA,oDACA,mCAEA,4CACA,sBACA,CAIA,GAHA,kCACA,6DACA,6DACA,2BACA,OACA,6DACA,4CAEA,qDACA,+BACA,CACA,8BACA,0BACA,eACA,CACA,CACA,SACA,eACA,cACA,sCACA,CACA,8BACA,wDACA,kBACA,mBACA,KAEA,GADA,oCACA,mBACA,OACA,qDACA,oCAEA,6CACA,uBACA,CACA,8BACA,0BACA,eACA,CACA,CACA,SACA,eACA,cACA,gCACA,CACA,8BACA,wDACA,kBACA,mBACA,KAEA,GADA,8BACA,gBACA,OACA,kDACA,iCAEA,0CACA,oBACA,CACA,6BACA,8CAEA,gDACA,8BACA,0BACA,eACA,CACA,CACA,SACA,eACA,cACA,6BACA,CACA,8BACA,iDAEA,MADA,YACA,eACA,IACA,aACA,8BACA,0BACA,eACA,CACA,CACA,SACA,eACA,cACA,kCACA,CACA,8BACA,uIACA,kBACA,mBACA,KACA,2BACA,OACA,0DACA,yCAEA,kDACA,mBACA,CACA,uBACA,OACA,sDACA,mCACA,EACA,8CACA,wBACA,CACA,qCACA,gDACA,8BACA,0BACA,eACA,CACA,CACA,SACA,eACA,cACA,+BACA,CACA,8BACA,gDACA,kBACA,mBACA,KACA,wBACA,OACA,uDACA,sCAEA,+CACA,yBACA,CACA,oBACA,OACA,mDACA,kCAEA,2CACA,qBACA,CACA,wCACA,0CACA,8BACA,0BACA,eACA,CACA,CACA,SACA,eACA,cACA,oCACA,CACA,8BACA,qDACA,kBACA,mBACA,KACA,oBACA,OAAiC,oDACjC,2CACA,qBACA,CACA,kCACA,0CACA,8BACA,0BACA,eACA,CACA,CACA,SACA,eACA,cACA,2CACA,CACA,8BACA,6DAEA,MADA,YACA,eACA,IACA,wCACA,8BACA,0BACA,eACA,CACA,CACA,SACA,eACA,cACA,8BACA,CACA,8BACA,iEACA,kBACA,mBACA,KACA,cACA,OACA,6CACA,4BAEA,qCACA,eACA,CACA,yBACA,8BACA,0BACA,eACA,CACA,CACA,SACA,eACA,cACA,mCACA,CACA,eACA,6BACA,kBAEA,qBADA,EACA,OACA,qBAFA,EAEA,OACA,8BACA,SACA,SACA,SACA,SACA,YAAoB,EARpB,EAQoB,MAAgB,IACpC,mBACA,mBACA,iBACA,iBACA,iBAEA,OACA,2CACA,wCACA,oCACA,CACA,CApBA,EAoBA,eACA,gDACA,8BACA,oCAAsC,GACtC,+BACA,kCACA,CACA,CACA,UACA,6BAEA,IAIA,EAJA,mBACA,yCACA,2CACA,gDAEA,uBACA,OACA,YAAsB,IAAe,IACrC,OAEA,GACA,EAAM,qBACN,uCACA,QACA,iBACA,uBACA,kBACA,GACA,EAAM,oCACN,8CACA,uBAEA,iBACA,iBACA,kBACA,qCACA,YACA,EAAM,IACN,YAAsB,iBAAwB,KAC9C,GA9BA,KA8BA,gCACA,iCACA,8BACA,SACA,8BACA,mCACA,6BACA,uCACA,MACA,KACA,CACA,CAIA,OAFA,UACA,WACA,CACA,CAAG,CACH,qCACA,SACA,KACA,WACA,YAAoB,WAAyB,KAC7C,IAoBA,EApBA,OACA,4BACA,4BACA,uEACA,UACA,QACA,CACA,qHACA,iEACA,4FAEA,6GAEA,CADA,aACA,iBArrhCA,KAsrhCA,CACA,qCACA,2CACA,cACA,iFAGA,uBAEA,UADA,aACA,kCACA,YAAwB,iBAA8B,IACtD,qBAEA,iDACA,WACA,YACA,UACA,QACA,CACA,oDACA,YACA,YAAsB,iBAA8B,IACpD,uCAEA,YAAsB,iBAA8B,KACpD,uCACA,6BAEA,CAEA,OADA,WACA,CACA,CAAG,CACH,qCACA,iEACA,kDAEA,OADA,qBACA,EAEA,sBAA6C,IAAQ,IACrD,YAAsB,aAA2B,IACjD,wCAGA,QACA,CACA,CACA,UACA,SACA,SACA,IACA,IACA,IACA,SACA,SACA,SACA,SACA,KAyHA,OAXA,uBACA,eACA,SA/GA,GACA,QACA,IACA,IACA,aACA,SACA,6BACA,2BACA,uBACA,eAKA,GAJA,oBACA,6BACA,oCAEA,WACA,sBAA4C,IAAO,QACnD,2BACA,8BACA,iCAGA,cACA,sBAAuC,IAAO,QAC9C,2BACA,0BAGA,eACA,iCACA,sBAA2C,IAAO,QAClD,2BACA,8BACA,iCAEA,CACA,YACA,sBAA2C,IAAO,MAClD,YAA0B,IAAO,KACjC,mBACA,mDACA,CACA,wBACA,MAEA,sBAA4C,IAAO,MACnD,YAA0B,IAAO,KACjC,WACA,mDACA,CACA,wBACA,CAEA,KACA,KACA,IACA,EAwDA,GAEA,eAzDA,YACA,QACA,aACA,SACA,6BAEA,GADA,oBACA,WACA,sBAA4C,IAAO,QACnD,2BACA,8BACA,iCAGA,eACA,QACA,sBAA4C,KAAQ,IACpD,WAEA,OACA,CACA,sBACA,4BAAuD,IAAO,WAC9D,6BAGA,IACA,EAgCA,GAEA,iBACA,SAlCA,GACA,QACA,aACA,6BACA,0BAEA,GADA,oBACA,YACA,sBAA4C,IAAO,QACnD,2BACA,8BACA,4BACA,aACA,2BACA,+BACA,4BAEA,QAEA,QACA,sBAA4C,KAAQ,IACpD,WAEA,OACA,CACA,IACA,EASA,EAEA,CAAK,EACL,CACA,CACA,CACA,SACA,YAA2B,EAI3B,IAeA,EAfA,EAHA,kBACA,SACA,CAAK,KACL,OACA,KACA,IACA,uBACA,aACA,iBACA,UACA,6BACA,gCACA,QACA,WACA,UACA,CAAS,CACT,CACA,CAAK,EAEL,QACA,SAGA,gBADA,gBADA,iBAEA,EACA,kBACA,MAGA,qBAEA,aACA,SACA,SACA,SACA,SACA,SACA,uBAAyC,IAAQ,KACjD,oBACA,gBACA,UACA,6BACA,YACA,YAAwB,UAAiB,MACzC,kBAGA,IAFA,YACA,YACA,IACA,MAEA,YAAwB,UAA6B,KAIrD,EAHA,IACA,IACA,IACA,IAGA,CAIA,MAHA,QACA,2BAEA,EACA,0BAwBA,MAvBA,2BACA,2BACA,2BACA,uBACA,0BACA,0BACA,2BAEA,8BACA,8BACA,8BAaA,EAZA,EAYA,EAZA,EAYA,EAZA,EAaA,kBACA,kBACA,uBACA,sBACA,QACA,uBACA,KACA,uBACA,KACA,uBACA,OAEA,6CACA,qBAzBA,KACA,KACA,KACA,QACA,oBACA,OAEA,iBACA,iBAEA,CAkBA,cACA,QACA,uBACA,KACA,uBACA,KACA,uBACA,MAEA,wCAEA,CACA,CACA,CACA,SACA,8BACA,MACA,IACA,+CACA,YAEA,KAEA,MADA,uDACA,IAEA,CAAM,SACN,qCACA,CACA,WACA,CACA,4BACA,eACA,sCACA,KACA,iCACA,CACA,kCACA,IACA,qBACA,iBACA,6BACA,+BACA,aACA,UACA,2BACA,CAAM,SAGN,MAFA,+CACM,OAAa,YAAY,OAAC,wCAChC,CACA,CACA,CACA,0CACA,kCAEA,OADA,iDACA,wBAEA,aACA,IACA,uCACA,gCACA,QACA,EACA,IACA,IACA,CAAW,CACX,IACA,IACA,CAAW,CACX,CAAY,WAEZ,CAAO,CACP,wCACA,uBACA,CAAM,SAKN,MAJA,wCACM,OAAa,YACX,OAAC,sCAAwC,aAAe,GAEhE,CACA,CACA,CACA,0CACA,kCAEA,OADA,iDACA,wBAEA,aACA,IACA,uCACA,gBACA,wCACA,kBACA,CAAM,SAKN,MAJA,wCACM,OAAa,YACX,OAAC,sCAAwC,aAAe,GAEhE,CACA,CACA,CACA,0CACA,kCAEA,OADA,iDACA,wBAEA,aACA,IACA,uCACA,gBACA,wCACA,kBACA,CAAM,SAKN,MAJA,wCACM,OAAa,YACX,OAAC,sCAAwC,aAAe,GAEhE,CACA,CACA,CACA,4BACA,oBAAuC,gCAAkC,EACzE,6BACA,+BACA,aACA,UACA,2BACA,CACA,uBACA,oBAAqC,kBAAoB,EACzD,6BACA,+BACA,aACA,UACA,2BACA,CACA,CACA,mCAGA,GACA,gBAAuB,EAHvB,yBAAkF,kDAA6D,UAI/I,KAHA,eAIA,WACA,CACA,uBACA,iCACA,2BAEA,CACA,6BACA,2DAGA,wBAFA,CAGA,CACA,WACA,WACA,CACA,CACA,6BAEA,aADA,wBAAkF,kDAA6D,UAC/I,8BACA,UACA,2BACA,yBACA,iCACA,0BACA,4BACA,4BACA,6BACA,iBACA,2BACA,uBACA,wBACA,uBACA,kCACA,mCACA,sCACA,yCACA,+CACA,kDACA,aACA,uBACA,mBACA,mBACA,oBACA,kDACA,sCACA,uCACA,iCACA,CACA,6BACA,iBACA,6CACA,0CACA,eACA,cACA,aACA,KAnxiCA,CAoxiCA,CAAK,EACL,kCACA,EACA,qCAEA,+CACA,2DACA,CACA,OACA,CACA,UACA,+BACA,wCAEA,qCACA,8CAEA,6BACA,8CACA,mDACA,8CAGA,CACA,wBACA,oDACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAGA,mDACA,mBACA,oBACA,eACA,oBACA,IACA,2BARA,IAQA,sBAEA,2BATA,IASA,sBAEA,iDAXA,MAWA,oBACA,0BAEA,wBACA,CAAK,EACL,oEACA,qCACA,wBACA,CACA,qBACA,yCACA,wCACA,wEACA,yEACA,gBACA,qCACA,uCACA,CAAK,KACL,CACA,oBACA,iCACA,2DACA,qCAA2C,kBAAkB,IAC7D,sCAA4C,EAAc,IAE1D,qBACA,6CACA,YAGA,MADA,mBACA,WACA,gDACA,4BACA,kEACA,YAEA,oDACA,iDAGA,OAAa,KAFb,4CAEa,OADb,EACa,iBACb,CACA,gBACA,gCACA,aACA,yBACA,0BACA,mBACA,4KACA,oDAEA,kEACA,kEACA,yCACA,wCACA,6BACA,qBACA,0BACA,KACA,WACA,YACA,YACA,cACA,SACA,0BACA,EAAM,IACN,6BACA,qBACA,YACA,cACA,WACA,0BACA,CACA,qDACA,cACA,OACA,SACA,QACA,UAEA,aACA,OACA,SACA,QACA,UAEA,qBACA,UACA,gCACA,wCACA,oBACA,CACA,2BACA,+BACA,oBACA,uBACA,eA53iCA,EA63iCA,mEACA,gBACA,uBACA,CACA,CACA,6BACA,mCACA,iEACA,kCAEA,4EACA,4BACA,0EAEA,gCACA,wCACA,mCAEA,CACA,iBACA,mBACA,uBACA,sEAEA,kDACA,CACA,mBACA,yCAaA,GAZA,mBACA,oBACA,yBAEA,WADA,KACA,MACA,0BACA,8BACA,2BACA,EACA,GAGA,mBACA,qCACA,8BACA,iDACQ,qCAER,SACA,iCACA,gCACA,2CACA,EAEA,CACA,eACA,wBACA,CACA,2BACA,KAKA,IAJA,+BACA,wCAEA,gCACA,4BACA,cACA,MACA,eACA,cACA,aACA,KAv+iCA,CAw+iCA,CAAS,CACT,+HACA,8CAEA,sCACA,+CACA,0BACA,8BACA,2BACA,iBACA,kBAEA,OAEA,2DAEA,CACA,8BACA,iBACA,iBACA,iBACA,mCACA,KACA,KACA,qBAEA,qBAEA,gBACA,CACA,QACA,CACA,CACA,6BAEA,YADA,yBAAkF,kDAA6D,UAC/I,8BACA,UACA,mBACA,8BACA,6BACA,0BACA,gCACA,mCACA,iBACA,oBACA,wBACA,gCACA,+BACA,gCACA,aACA,gBACA,oBACA,8BACA,CACA,0BAOA,cACA,IAPA,cACA,oBAA0B;AAC1B;AACA;AACA,gBAIA,eACA,aACA,aACA,CAAK,CACL,mCACA,4CACA,+CACA,mCACA,uCACA,CACA,uBACA,qBAGA,IAGA,GAFA,8CACA,4DACA,sBACA,mDAEA,4DACA,qBAA8B,YAC9B,sBACA,CAAO,EACP,uBACA,uCACA,eACA,gCAEA,EACA,+BACA,mCACA,oBACA,0BACA,gDACA,gCACA,yCACA,CAAS,CACT,EACA,yBACA,qCAEA,8BACA,oBACA,mCACA,oDACA,CAAM,SACN,6CACA,+CACA,CACA,CACA,gBACA,uCAGA,gEACA,0BACA,sBACA,sDAEA,CACA,iBACA,wBAEA,eACA,mCACA,CACA,uBACA,8BAEA,mBACA,mCACA,oCAAoD,kBAAoB,EACxE,6BACA,CACA,WACA,CACA,yCACA,8CACA,4BACA,iBACA,2CAIA,uDACA,IACA,oCAAoD,kBAAoB,EACxE,yBACA,8BACA,6BACA,uBACA,SACA,aACA,UACA,8BACA,6BACA,qDACA,CAAM,SACN,8CACA,+CACA,CACA,CACA,iBACA,uBACA,yBACA,oDACA,CACA,UACA,MACA,qBACA,sBACA,0BACA,2CACA,4DACA,2CAEA,CACA,CACA,SACA,0CACA,IAEA,YAFA,iCAEA,CADA,GAAoB,EAAO,GAAG,WAAW,GAAG,EAAS,EACrD,CACA,sCACA,CAAK,EACL,eACA,oBACA,+BACA,wBACA,YAAuB,GAAG,2BAC1B,cACA,MACA,CAAK,EACL,mBACA,oCAAiD,UAAa,IAAI,aAAgB,OAC5E,OAAa,eACnB,QACA,CACA,qBACA,CACA,6BACA,MACA,IACA,mBACA,oBACA,wBACA,YAAyB,GAAG,2BAC5B,cACA,MACA,CAAO,EACP,mBACA,qBACA,SACA,aACA,sBAEA,GACA,EAAQ,GACA,OAAa,wCAErB,CAAM,SACN,iCACM,OAAa,YACnB,6BAAiD,OAAC,mCAElD,CACA,QACA,CACA,wBACA,gCACA,OACA,OAEA,CACA,iBACA,iBACA,CAEA,qCACA,OACA,kCACA,UACA,eACM,GAAG,6BACT,WACA,eAAoB,EAAO,EAE3B,2CACA,wBACA,wBAEA,qBACA,CACA,CACA,6BAEA,YADA,yBAAkF,kDAA6D,UAC/I,8BACA,UACA,qBACA,iBACA,sBACA,2BACA,4BACA,+BACA,kCACA,wCACA,yCACA,4CACA,wBACA,oBACA,2BACA,uBACA,gBACA,oBACA,kBACA,uBACA,mBACA,8BACA,oCACA,gCACA,4BACA,6CACA,0BACA,CACA,sBACA,iBACA,sCACA,0CACA,eACA,cACA,aACA,KA/wjCA,CAgxjCA,CAAK,EACL,2BACA,EACA,8BAEA,wCACA,8CACA,gCACA,CACA,OACA,CACA,UACA,wBACA,iCAEA,8BACA,uCAEA,sBACA,uCACA,4CACA,wCAGA,kBACA,CACA,cACA,iBACA,4BAEA,+CACA,CACA,sBACA,8BACA,mCACA,mDACA,2BAEA,0CACA,sCACA,4CACA,4CACA,qBACA,4DAEA,yBACA,iCACA,6BAEA,sDACA,CACA,4BACA,sBACA,qDAGA,gEACA,2BACA,oBAEA,uBACA,aAEA,IACA,aACA,4BACA,oBACA,CAAO,CACP,yBACA,iCAEA,gBACA,yBACA,mCACA,qBACA,2BAEA,cACA,MACA,eACA,cACA,aACA,KAl2jCA,CAm2jCA,CAAO,CACP,uBACA,yGACA,uCAEA,+BACA,yCAEA,0BACA,uBACA,oBACA,+BACA,iCAEA,uDACA,6DACA,CAAM,SACN,8DACA,mDACA,oDACA,CACA,CACA,wBACA,qDACA,6DACA,CACA,8BACA,iBACA,iBACA,iBACA,mCACA,KACA,KACA,qBAEA,qBAEA,gBACA,CACA,kBACA,mFACA,0BACA,uBACA,oBACA,EACA,EAGA,CACA,mBACA,wBACA,gCACA,oCACA,0BAl3jCA,EAm3jCA,iEACA,4BACA,mCACA,CACA,CACA,2BACA,OACA,gCACA,yEACA,CACA,CACA,kBACA,gCACA,IACA,qCACA,kCACA,8BACA,QAEA,gCACA,iCAEA,GADA,2BACA,qCACA,4BACA,cACA,0BACA,EAAU,IACV,6BAEA,KACA,gBACA,eACA,QACA,YACA,0BACA,CACA,mFACA,0BACA,uBACA,oBACA,EACA,GAGA,cACA,sBACA,wBACA,wDACA,sDACA,iCACA,sBACA,wDACA,sDACA,wBACA,kBACA,oBACA,mBACA,eACA,KAn9jCA,EAo9jCA,uBACA,CAAa,EAEb,CAAS,EACT,8BACA,2BACA,iCACA,sBACA,wDACA,sDACA,wBACA,oBACA,cACA,IACA,cAEA,CACA,CAAS,EACT,WACA,UAaA,GAZA,wBACA,KACA,2CACA,MAEA,uEACA,mBACA,aAEA,CAAS,EACT,wCACA,sBACA,UAEA,cACA,eACA,kBACA,mBACA,aAEA,CAAW,EACX,gBACA,aACA,wDACA,YACA,kBACA,WACA,CAAW,CACX,CACA,sDACA,kBACA,WACA,CAAS,EACT,0BACA,iCACA,2BACA,iCACA,uBACA,GACA,QACA,OACA,SACA,SACA,CAAS,CACT,CAAQ,SACR,IACA,CACA,CAAK,CACL,CACA,QACA,CACA,CACA,SACA,YAAgB,QAAU,CAC1B,WAAe,QAAU,CACzB,YAAgB,kBAA0B,CAC1C,YAAgB,QAAU,CAC1B,WAAe,QAAU,CACzB,UAAc,QAAU,CACxB,SAAa,QAEb,EACA,SACA,mBACA,UACA,OACA,QACA,EACA,aAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,yCAAyC;AACzC,yCAAyC;AACzC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,+DAA+D;;AAE/D;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,yDAAyD;;AAEzD;AACA;AACA;;AAEA;AACA,IAEA,eAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,iDAAiD;;AAEjD,qFAAqF;;AAErF;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAGA,qBACA,kBACA,oBACA,CACA,eACA,OACA,oCACA,kCACA,sCACA,WAEA,CAAK,EACL,uBACA,iBACA,CACA,YACA,mCAEA,aACA,6BACA,CACA,iBACA,mCAEA,kBACA,OACA,4BAEA,gCAGA,gBACA,qCAEA,iBACA,yBACA,iCACA,CACA,aACA,+BACA,CACA,cACA,sBACA,sBAEA,OACA,yBAEA,6BAGA,gBACA,qCAEA,iBACA,+BACA,CACA,eACA,mCACA,CACA,gBACA,8BACA,CACA,iBACA,qCACA,CACA,kBACA,gCACA,CACA,cACA,mCAEA,eACA,6BACA,CACA,cACA,mCAEA,eACA,eACA,+BACA,CACA,iBACA,sCAEA,kBACA,sCACA,CACA,sBACA,4CACA,CACA,uBACA,eACA,+BACA,sBAEA,OACA,sCAEA,0CAEA,CACA,CACA,cACA,SACA,qBACA,cACA,QACA,+BACA,iCAIA,cADA,uCAEA,oCAJA,wDAIA,IACA,8BAJA,0CAIA,GACA,CACA,gBACA,oCACA,8BAYA,OAXA,aACA,kBACA,kBACA,kBAEA,yBACA,0BAEA,4BACA,6BAEA,IACA,CACA,oBACA,CACA,2BACA,IACM,kBACN,wBAEA,oBAMA,OALA,iDACA,+CACA,uDACA,0BACA,6BACA,KAEA,iBACA,CACA,2BACA,IACM,kBACN,wBAEA,oBAGA,OAFA,sDACA,oDACA,KAEA,yBAEA,OADA,+CACA,KAEA,qBAEA,OADA,+CACA,KAEA,YAEA,OADA,+CACA,KAEA,oBACA,iBAEA,OADA,+CACA,IACA,CACA,qBACA,yBACA,0BAEA,oCACA,mCACA,oBACA,2CACA,6BACA,2BAEA,CACA,wBACA,4BACA,6BAEA,yBACA,0BAEA,oCACA,8BACA,2BACA,iCACA,8BACA,QACA,sBAAwC,IAAQ,IAChD,4BACA,sCACA,4BACA,qCAEA,yCACA,mCACA,2JAEA,CACA,CACA,SACA,CACA,eAEA,OADA,8FACA,oBACA,CACA,CACA,cACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UAEA,mBAOA,OANA,kDACA,0BACA,eACA,gBACA,2CACA,0BACA,6BACA,CA2GA,oBACA,+BAAmF,6BAAiC,GACpH,WACA,wBACA,yBACA,CAEA,uBACA,oBACA,6BACA,2BACA,8BACA,0BAAoD,IAAO,SAC3D,4BACA,4BACA,oBACA,8BAEA,oBAGA,OAFA,sDACA,oDACA,KAEA,aACA,IAeA,EAeA,EA9BA,2BACA,UACA,cACA,+IAEA,2DACA,QACA,uBACA,gBACA,gBAOA,GANA,gBACA,yBACA,0BAEA,0CAEA,EACA,WACM,CACN,oDACA,sBACA,CAEA,GADA,aACA,6BAQA,GALA,sBACA,uBAEA,uCAEA,EACA,WACM,CACN,oDACA,sBACA,CACA,qBACA,2BAGA,EA3KA,cACA,oBACA,aACA,6BACA,2BACA,oCACA,YAAoC,EAApC,EAA2C,KAC3C,kCACA,gCACA,mBACA,aACA,SACA,2CACA,sBAEA,QACA,QACA,cACA,gCACA,SACA,UACA,YACA,QACA,QACA,CAAO,CAEP,CACA,EAiJA,QAEA,SAlJA,OACA,yBAEA,EADA,WACA,WACA,gBACA,aACA,6BACA,2BACA,oCACA,UACA,WACA,OACA,sCACA,mBACA,0BACA,YACA,YACA,OACA,YACA,4CACA,YAAoC,EAApC,EAA2C,KAQ3C,GAPA,4BACA,4BACA,OACA,OACA,oBACA,oBACA,eAEA,SAEA,WACA,gBACA,aACA,aACA,EAAM,eACN,gBACA,aACA,aACA,CACA,mBACA,mBACA,0BACA,0BACA,YACA,YACA,YACA,YACA,kBACA,aACA,gBACA,WACA,6CACA,YACA,2BACA,cACA,yBACA,SACA,kCACA,gCACA,yBACA,uBACA,aACA,SACA,2CACA,QACA,QACA,cACA,gCACA,SACA,UACA,YACA,QACA,QACA,CAAO,CACP,CACA,CACA,EAqEA,WAEA,CACA,kBACA,6BACA,kBACA,kBACA,uDAEA,CACA,CACA,oBACA,YACA,mCAEA,kBACA,uCAEA,iBACA,+BACA,CACA,gBACA,qCAEA,eACA,OACA,mBACA,kBACA,CACA,aACA,sBACA,CACA,EACA,EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KACK,EACL,8BACA,SACA,OACA,6BACA,CAAS,CACT,MACA,mCAEA,CACA,CAAK,EACL,kBACA,cACA,CACA,CACA,cACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,SACA,qBACA,mBAIA,EAHA,QACA,SACA,wBAGA,EADA,QACA,QAGA,uBADA,uCACA,MAEA,sBAAqC,IAAO,MAC5C,4CACA,YAAsB,IAAO,KAC7B,WACA,aACA,KAAwB,EAAO,GAAG,EAAO,EACzC,KAA+B,EAAO,GAAG,EAAO,EAChD,QACA,8BACA,eAEA,MACA,SACA,SACA,yBACA,mBACA,SACA,SACA,CAEA,CACA,CACA,SACA,KACA,KACA,KACA,gBACA,WAAc,0DAA2D,YACzE,IAGA,0CACA,0CACA,0CACA,0CACA,0CACA,0CACA,6BACA,6BACA,iBAGA,4BACA,4BACA,qBACA,4BACA,4BACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,wBACA,CACA,kBACA,WACA,kCAEA,kBACA,YACA,kCAEA,kBACA,WACA,kCAEA,kBACA,WACA,iCAEA,CACA,CACA,QACA,UACA,SACA,YACA,CAAK,CACL,SACA,OACA,CACA,CAAG,CACH,aAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAEA,eAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,qCAAqC;AACrC;;AAEA;AACA;AACA;;AAEA;AACA,IAGA,IACA,WAAe,QAAU,CACzB,YAAgB,kBAA0B,CAC1C,WAAe,QAAU,CACzB,UAAc,QAAU,CACxB,SAAa,QAAU,CAEvB,SAAa,QACb,EACA,IACA,mBACA,UACA,OACA,GACA,EACA,aAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,yCAAyC;AACzC,yCAAyC;AACzC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+DAA+D;;AAE/D;;AAEA;;AAEA;;AAEA,MAAM;;AAEN;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,yDAAyD;;AAEzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAEA,eAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,iDAAiD;;AAEjD,wEAAwE;;AAExE;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,IAGA,qBACA,eACA,OACA,+BACA,+BACA,6BACA,iCACA,WAEA,CAAK,EACL,eACA,8BACA,OACA,cACA,eACA,mCACS,CACT,gBACA,6BACA,CACA,CAAO,CACP,WACA,cACA,eACA,oCACA,CAAS,CACT,gBACA,+BACA,CACA,CAAO,CACP,WACA,cACA,eACA,qCACS,CACT,gBACA,+BACA,CACA,CAAO,CACP,UACA,cACA,eACA,oCACS,CACT,gBACA,8BACA,CACA,CAAO,CACP,SACA,cACA,eACA,mCACS,CACT,gBACA,6BACA,CACA,CAAO,CACP,SACA,cACA,eACA,mCACS,CACT,gBACA,6BACA,CACA,CAAO,CACP,YACA,cACA,eACA,sCACS,CACT,gBACA,sCACA,CACA,CACA,CAAK,EACL,iBACA,CACA,CACA,yCACA,qBACA,gCACA,2BACA,cAAY,yBAAgC,aAyB5C,OAxBA,kBACA,YACA,OACA,oBACA,EACA,IAGA,kBACA,WACA,OACA,oBACA,EACA,IAGA,kBACA,WACA,OACA,oBACA,EACA,IAGA,IACA,CACA,CACA,6BAEA,YADA,yBAAkF,kDAA6D,UAC/I,8BACA,UACA,yBACA,QACA,6BACA,8BACA,iCACA,yCACA,mCACA,yCACA,0BACA,4BACA,6BACA,yBACA,iCACA,4BACA,+BACA,yBACA,iBACA,oBACA,wBACA,wBACA,uBACA,wBACA,iCACA,gCACA,+BACA,iCACA,2BACA,gCACA,4BACA,2BACA,aACA,gBACA,oBACA,sBACA,mBACA,0BACA,8FACA,6BAEA,4BACA,eACA,KAlknCA,EAmknCA,wBACA,eACA,SACA,CAAK,EACL,+BACA,eACA,aACA,eACA,SACA,CAAK,EACL,2BACA,aAz8mCA,KA08mCA,KA/knCA,CAglnCA,CAAK,EACL,+CACA,yBACA,qCACA,CACA,OACA,CACA,UACA,kBACA,8BACA,gCACA,iCACA,6BACA,sBACA,8BACA,0BAEA,0BACA,CACA,oBACA,eACA,cACA,aACA,aACA,eACA,KAzmnCA,CA0mnCA,CAAK,CACL,CACA,sBACA,yBACA,0BACA,8BACA,yBACA,8BACA,CACA,oBACA,kBACA,wBACA,+CAEA,6BACA,kBACA,0BACA,mCAEA,qBAGA,CAAO,EAEP,CACA,iBAEA,GADA,yBACA,mBACA,MAEA,2CACA,uCACA,SAMA,aALA,6BACA,iBACA,SAEA,CAAK,EACL,GACA,WACA,WACA,wBACA,SACA,EACA,QAAgC,uBAAyB,GAEzD,4BACA,sBACA,4BAIA,aAHA,2BACA,GAIA,QAA2B,oCAAwC,GAEnE,4BACA,sBACA,4BACA,qBACA,kBACA,iBACA,CACA,6BACA,qDACA,6CACA,8DACA,uBAEA,CAAK,CACL,CACA,oBACA,wCACA,OAEA,SAMA,aALA,6BACA,oCACA,SAEA,CAAK,EACL,GACA,UACA,mBAGA,SAMA,aALA,+BACA,iBACA,SAEA,CAAK,EACL,IAEA,aADA,UACA,YACA,SACA,EACA,QAAgC,uBAAyB,GAEzD,4BACA,sBACA,4BAIA,aAHA,2BACA,GAIA,QAA2B,oCAAwC,GAEnE,4BACA,sBACA,4BACA,uBACA,sBACA,CACA,6BACA,qDACA,6CACA,8DACA,uBAEA,CAAK,EACL,oDACA,CACA,yBACA,uBACA,6BACA,yDAEA,kCACA,iBACA,oBAEA,CAAO,EAEP,CACA,qBACA,mBACA,yBACA,iDAEA,8BACA,iBACA,oBAEA,CAAO,EAEP,CACA,oBACA,kBACA,wBACA,+CAEA,6BACA,iBACA,oBAEA,CAAO,EAEP,CACA,0BACA,wBACA,8BACA,2DAEA,mCACA,iBACA,oBAEA,CAAO,EAEP,CACA,sBACA,8BACA,0BACA,yBACA,oBAGA,+CACA,gCACA,kCACA,kBACA,mBACA,uBACS,EACT,4BACA,iCACA,gCACA,gBACA,0BACA,uBAEA,CAAK,EACL,4CACA,2CACA,4BACA,8BACA,kBACA,mBACA,uBACA,WACA,CAAS,EACT,4BACA,iCACA,gCACA,mBACA,gBAEA,CAAK,EACL,wCACA,0CACA,2BACA,6BACA,kBACA,mBACA,uBACS,EACT,4BACA,iCACA,gCACA,yBACA,gBAEA,CAAK,EACL,uCACA,CACA,uBAEA,GADA,+BACA,mBACA,MAEA,iDACA,6CACA,iCACA,SAMA,aALA,mCACA,iBACA,SAEA,CAAK,EACL,GACA,WACA,WACA,qBACA,0BACA,gBACA,qBAGA,sBAlgRA,UACA,6BACA,SACA,eACA,6BACA,oBACA,IACA,4BACA,KACA,KACA,KACA,gCACA,gCACA,uBAA6C,IAAO,KACpD,WACA,kBACA,uBACA,4CACA,WACA,cAEA,2BACA,IACA,gBACA,kBACA,iDACA,qDACA,CAAO,EAEP,CACA,WAEA,cADA,iBAEA,MACA,YAAkB,IAAiB,KACnC,oBACA,KACA,uBAA+C,IAAO,KACtD,WACA,oBACA,aACA,YAAsB,IAAc,IACpC,MAAmB,mBAAiE,GAGpF,UACA,iBACM,CACN,uBAAiD,IAAO,KACxD,WACA,oBACA,uBACA,aACA,OACA,OACA,YAAwB,IAAc,KACtC,WACA,OAEA,GADA,gBACA,EACA,uBAAyD,IAAQ,IACjE,qBAGA,CACA,CACA,OACA,UACA,GACA,CACA,CACA,gBACA,2BACA,WAMA,GALA,mCACA,8BACA,WACA,eAEA,OACA,YAAoB,cAAqC,KACzD,cACA,0CACA,8BACA,WACA,aAEA,CACA,CAEA,OADA,cACA,CACA,EAu6QA,IACA,aACA,+CACA,kBACA,4BACA,sBACA,4BACA,IAOA,SAPA,sCACA,GAEA,QACA,uBACA,WACA,CAAO,GAKP,4BACA,sBACA,4BACA,qBACA,kBACA,iBACA,CACA,mCACA,qDACA,6CACA,8DACA,uBAEA,CAAK,CACL,CACA,mBACA,2CAGA,oBACA,YACA,kCAEA,kCAEA,mBACA,0CAEA,mBACA,0CAEA,+BACA,mBACA,UACA,YACA,+BACA,yCAEA,cACA,aAxxnCA,KAyxnCA,KA95nCA,CA+5nCA,CAAa,CACb,uBACA,uBACA,wCACA,EACA;AACA;AACA,kBAAkB;AAClB,gBACA,0CACA,sFAAsG,EACtG;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,kBAEA,EACA,4BACA,gDAEA,aACA,KACA,cACA,+BACA,yCAEA,mBACA,eACA,KAh8nCA,EAi8nCA,wBACA,eACA,SACA,CAAa,EACb,KACA,iBACA,+BACA,yCAEA,mBACA,eACA,aACA,eACA,SACA,CAAa,EACb,KACA,gBACA,oCACA,EACA,aAEA,oBACA,mBACA,wBACA,aACA,aACA,KA39nCA,CA49nCA,CAAiB,EAEjB,iCAMA,CAAK,EACL,oDACA,CACA,uBACA,eACA,iBACA,wCAEA,CAAK,EACL,gCACA,CACA,aACA,SACA,wBACA,mDAEA,SAEA,CAAK,EACL,cACA,OACA,iCACA,mBAEA,qBAEA,kBACA,kCACA,0BACA,mCAEA,kCAGA,CAAK,EACL,YACA,CACA,QACA,uBACA,2BACA,mCACA,iCACA,2BACA,sBACA,sBACA,8BACA,0BAEA,kCACA,CACA,mBACA,oBACA,iCACA,CACA,oBACA,oBACA,gCACA,oBACA,sBACA,wBAGA,uBAFA,EACA,GAEA,mBACA,eACA,aACA,mCACA,kBACA,gCACA,wCAEA,sCACA,6CAEA,4BACA,oBACA,yBACA,wBAEA,CACA,oBACA,kCACA,sBACA,2BACA,4BACA,4BACA,CACA,oBACA,oBACA,CACA,kBACA,sBASA,OARA,oDACA,2DAEA,0BACA,wBACA,uDACA,wDAEA,GACA,eAWA,SAVA,KACA,UACA,uCACA,KACA,UACA,wCACA,KACA,UACA,qCACA,KAGA,UACA,uCACA,KACA,UACA,uCAEA,CACA,4DACA,mDACA,CACA,CACA,oBACA,iBACA,QACA,qBACA,kBACA,mBACA,wBACA,oBACA,oBACA,oBACA,KACA,KACA,SACA,SACA,SACA,wBACA,sBACA,iEACA,iBACA,iBACA,gBACA,wBACA,wBACA,YACA,YACA,YACA,WACA,OACA,OACA,OACA,YACA,YACA,YACA,YACA,YACA,WACA,gBACA,eACA,eACA,gBACA,gBACA,gBACA,sBACA,sBACA,sBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,YACA,YACA,YACA,YACA,YACA,YACA,UACA,UACA,UACA,UACA,UACA,UACA,aAEA,WACA,yBACA,4CACA,yBACA,aACA,gCACA,oBAPA,IAQA,eACA,iBACA,kBAVA,SAWA,iBACA,8BACA,EACA,aACA,SACA,SACA,SACA,SACA,IAgGA,cACA,qBAAqC,gBAA0B,CAC/D,CACA,gBACA,SAAc,8CAA2E,EACzF,kCACA,YACA,YACA,yBACA,cACA,2BACA,cACA,yBACA,SACA,IACA,SACA,qBACA,cACA,qBAEA,gBAEA,OADA,gBACA,QAAkC,oBAAiC,CACnE,CACA,aACA,yBACA,yBACA,yBACA,qBACA,qBACA,qBACA,yBACA,yBACA,wBACA,CAjIA,6BACA,gCACA,gCACA,wBAvBA,GAuBA,EACA,wBAxBA,GAwBA,CACA,mCACA,wCACA,qBACA,mCACA,aAiDA,cACA,wBACA,WACA,aACA,uCACA,KACA,YACA,aACA,0CACA,KACA,YACA,aACA,uBACA,KACA,YACA,cACA,0CACA,KACA,YACA,cACA,uCACA,KACA,YACA,cACA,oCACA,KACA,SACA,0CACA,CACA,2BACA,2BACA,mBACA,qBACA,qBACA,YACA,oBACA,EApFA,KACA,OACA,aACA,kBACA,GAIA,EACA,+BACA,WACA,WACA,WACA,GACA,EACA,mCACA,SACA,UACA,WACA,GACA,EACA,wBACA,UACA,qBACA,4EACA,gCACA,kBACA,mBAEA,EACA,wBACA,YACA,qBACA,qBACA,qBACA,yBACA,yBACA,yBACA,yBACA,yBACA,yBACA,qBACA,qBACA,qBACA,qBACA,qBACA,oBACA,CAyEA,CACA,CACA,6BAEA,aADA,wBAAkF,kDAA6D,UAC/I,8BACA,UACA,qBACA,uBAA0C,EAC1C,gCAAmD,EACnD,2BACA,uBACA,uBACA,oBACA,gBACA,uBACA,mBACA,kBACA,CACA,OACA,CACA,UACA,iBACA,0BAEA,+DACA,yEAEA,CACA,oBACA,uDACA,mDACA,0CACA,wCACA,6CACA,8CACA,0DACA,oBACA,8BACA,CAAK,EACL,4DACA,mBACA,CAAK,EACL,wCACA,uBACA,uBACA,0BAEA,iDAEA,UACA,4BACA,0BACA,2BACA,kDACA,iDACA,yCACA,uEACA,2EACA,CAAS,EAGT,CACA,eACA,CACA,qBACA,GACA,2BACA,iDAEA,2BACA,8CAEA,CACA,qBACA,iBACA,0BAEA,uBACA,uBACA,0BAEA,gDACA,CACA,QACA,CACA,CACA,6BAEA,aADA,wBAAkF,kDAA6D,UAC/I,8BACA,UACA,iBACA,OAAY,CACZ,YACA,CAAG,EACH,UACA,oBACA,iBACA,iCACA,gBACA,wBACA,uBACA,wBACA,yBACA,2BACA,2BACA,6BACA,0BACA,yBACA,wBACA,4BACA,gCACA,iCACA,kCACA,kCACA,2BACA,4BACA,+BACA,2BACA,qBACA,kBACA,qCACA,qEACA,kEACA,OACA,yBACA,0BACA,2DAEA,sBAAwC,sBAA8B,EACtE,+BACA,qCACA,2BACA,kCACA,wCACA,yBACA,mCACA,yBACA,cACA,gCACA,4BACA,mBAEA,0BACA,cACA,kBACA,kBAEA,4BACA,cACA,gCACA,kBACA,kBAEA,8DACA,4BACA,wBACA,mBAEA,8BACA,cACA,gCACA,4BACA,kBAEA,2BACA,wBACA,gCACA,4BACA,kBACA,kBACA,kCACA,oCAEA,kBACA,sCAEA,yBACA,wBACA,cACA,kBACA,gCACA,4BACA,GAEA,+DACA,6BACA,wBACA,cACA,mBAEA,yBACA,0BACA,4BACA,4BACA,0BACA,0BACA,2CACA,+BACA,gDACA,4CACA,4BAEA,6BACA,8BACA,+BACA,oBACA,sBACA,gBACA,kBACA,CAAK,KACL,CACA,kBACA,yBAEA,iBACA,uBACA,CACA,kBACA,yBAEA,mBACA,0BAEA,qBACA,2BACA,CACA,qBACA,4BAEA,uBACA,8BAEA,oBACA,2BAEA,mBACA,0BAEA,kBACA,yBAEA,sBACA,6BAEA,cACA,4BACA,iCACA,8BACA,uBACA,iCACA,oCAEA,qBACA,0CACA,wDAEA,2BACA,CACA,kBACA,2CACA,wCACA,sBAIA,IAFA,EACA,EACA,IACA,GACA,CALA,IAKA,uBAGA,KADA,IADA,KACA,uBACA,IAIA,KADA,IADA,KACA,uBACA,IAEA,mCACA,kCACA,iCACA,oCACA,sBACA,mCACA,kCACA,UACA,uCACA,EAAM,IACN,mCACA,kCACA,iCAEA,qCACA,qBACA,wBACA,gCAEA,CACA,gBACA,2CACA,wCACA,mCACA,kCACA,gCACA,CACA,kBACA,uCAEA,cACA,qCAEA,eACA,mCACA,CACA,iBACA,WAEA,GADA,+CACA,iBACA,OAEA,4BACA,iCACA,8BACA,uBACA,iCACA,oCAEA,qBACA,0CACA,uDAEA,EACA,GACA,CACA,2BACA,2BACA,CACA,4BACA,4BACA,CACA,6BACA,6BACA,CACA,WACA,wIACA,CACA,qBACA,mCACA,kCAEA,sBAA0C,gBAAqB,KAC/D,oDACA,IACA,6CACA,8CACA,KAA0B,EAAiB,GAAG,EAAO,EACrD,gCAEA,OADA,uCACA,GACA,UACA,0BACA,KACA,WACA,0BACA,KACA,WACA,wBACA,KACA,SACA,0CAAwD,EAAO,EAC/D,CACA,sCACA,CAAM,SAEN,MADA,0CAAgD,EAAO,MACvD,CACA,EAAM,OACN,oDACA,CACA,CACA,sBACA,wCACA,iDACA,kBACA,CACA,4BAKA,GAJA,8CACA,4CACA,qCAEA,0FACA,IAGA,EACA,EAJA,uCACA,wCACA,IAGA,uBAEA,EADA,MACA,uBAGA,EADA,MACA,uBAEA,uCACA,oCACA,iCACA,EACA,EAEA,CACA,kBACA,CACA,wBACA,0CACA,8CACA,0CAEA,kBACA,CACA,cACA,gCACA,kBACA,CACA,gBACA,mCACA,mEACA,4CACA,oBACA,kBACA,CACA,uBACA,gDACA,CACA,kBACA,sCAEA,kBACA,qCACA,kBACA,CACA,iBACA,0CACA,CACA,UACA,6BACA,kBACA,CACA,oBACA,sCACA,kBACA,CACA,mBACA,qCACA,kBACA,CACA,qBACA,2BACA,6BACA,0BACA,wCACA,oBACA,kBACA,CACA,aACA,+BACA,kBACA,CACA,kBACA,oCACA,kBACA,CACA,qBACA,0CACA,kBACA,CACA,iBACA,qCACA,kBACA,CACA,mBACA,mBACA,oBACA,2BACA,uCACA,kBACA,CACA,sBACA,uCACA,CACA,yBACA,0CACA,CACA,kBACA,oBACA,kBACA,CACA,eACA,QACA,mFACA,kBACA,yCAGA,oBACA,iBACA,0BAEA,EACA,CACA,CAHA,IAGA,uBAEA,GADA,KACA,uBAGA,EADA,MACA,uBAEA,qCACA,mCACA,EAAM,IACN,qCACA,oCAEA,2BACA,mCACA,kBACA,CACA,kBACA,0CACA,CACA,sBACA,6CACA,CACA,uBAEA,OADA,6CACA,sCACA,CACA,gBACA,6CACA,sCACA,uDACA,CACA,cACA,6CACA,CACA,uBACA,mDACA,CACA,mBACA,+CACA,CACA,mBACA,wCACA,CACA,iBACA,sCACA,CACA,SACA,iCACA,+BACA,gCACA,WACA,aACA,CAAK,EACL,mBACA,8BACA,4CAEA,4BACA,6BACA,+BACA,+BACA,iCACA,8BACA,6BACA,4BACA,gCACA,wBACA,iCACA,CACA,CAoSA,6BAEA,YADA,yBAAkF,kDAA6D,UAC/I,8BACA,UACA,iBACA,iCACA,+BACA,6BACA,oCACA,iCACA,4BACA,wBACA,2BACA,oBACA,sBACA,CACA,OACA,CACA,UACA,wBACA,kCACA,QACA,CAAO,EACP,4BAEA,yBACA,uBACA,8BACA,2BACA,sBACA,qDACA,CACA,0BACA,KACA,yBACA,sCACA,0BAEA,SACA,2CACA,eACM,qBACN,iBAEA,aACA,sBACA,iBACA,gCAEA,6BACA,wBAGA,8BACA,iCAGA,0BACA,CACA,sBACA,SACA,8BACA,oCACA,0BAAwC,IAAU,EAClD,OACA,EAAO,GAEP,oDACA,CACA,qBACA,sBACA,kCACA,0BACA,CAAK,CACL,CACA,2BACA,2FACA,iDAGA,kCACA,QACA,CAAK,EACL,sCACA,yBACA,8BACA,6BACA,sCACA,6CACA,UACA,uBACA,OA9nqCA,KA+nqCA,wBACA,UAEA,SACA,aAEA,0BAEA,mBACA,wEACA,sCAGA,qDACA,kCACA,yBACA,YACA,6CACA,WAGA,WAEA,CAAK,CACL,CACA,UACA,gDACA,+BAEA,CACA,QACA,CACA,CACA,mCAGA,cACA,iBACA,OACA,CAAG,MAJH,EAKA,WANA,yBAAkF,kDAA6D,UAO/I,KANA,sBAOA,6BACA,kBACA,iCAEA,6BACA,4BACA,CACA,wBACA,8BACA,4CAEA,WAEA,GADA,+CACA,iBACA,OAEA,4BACA,gCACA,iCACA,8BACA,uBACA,iCACA,oCAEA,qBACA,0CACA,uDAEA,EACA,GACA,CACA,qBACA,2BACA,gCACA,2CACA,+BACA,gCAGA,CACA,aACA,gCACA,kBACA,CACA,sBACA,2CACA,CACA,qBACA,0CACA,CACA,2BACA,gDACA,CACA,mBACA,wCACA,CACA,yBACA,gDAEA,qBACA,4CAEA,6BACA,oDAEA,qBACA,4CAEA,uBACA,8CAEA,uBACA,8CAEA,SACA,gCACA,cACA,CACA,CACA,6BAEA,YADA,yBAAkF,kDAA6D,UAC/I,+BACA,eACA,WACA,cACA,mCACA,mCACA,CACA,qBAIA,OAHA,YACA,mBAEA,WAEA,sBACA,MAAoB,QAAK,GACzB,8BACA,qBAGA,IAEA,KADA,GAFA,KACA,sBACA,OACA,GACA,OACA,WACA,CAAK,CACL,2BACA,oBACA,6BACA,EACA,0BACA,6BACA,EACA,sBACA,gBACA,EACA,8BACA,qDACA,EACA,8BACA,mCAKA,OAJA,IACA,mBACA,iCAEA,CACA,CACA,aACA,MAAoB,QAAK,IACzB,wCACA,CACA,mBACA,MAAoB,QAAK,IACzB,8BACA,iBACA,IAGA,+BACA,gCAEA,oCACA,CACA,mBACA,oCACA,SACA,SAGA,WACA,CACA,gBACA,MAAoB,QAAK,IACzB,8BACA,IACA,WACA,gCAEA,+BACA,CACA,QACA,kCACA,qBAEA,6BACA,CACA,qBAIA,OAHA,cACA,aAjlBA,IACA,MAA0B,QAAG,KAC7B,EAAmB,QAAG,KACtB,EAAqB,QAAG,gBACxB,EAAe,QAAG,KAClB,EAAyB,QAAG,IAC5B,EAA0B,QAAG,KAC7B,EAA6B,QAAG,KAChC,EAAsB,QAAG,aACzB,EAAuB,QAAG,aAC1B,EAAwB,QAAG,KAC3B,EAA2B,QAAG,KAC9B,OACA,OACA,EAAuB,QAAG,EAC1B,0BACA,YACA,yBACA,OACA,iBACA,iBACA,mBACA,uBACA,wBACA,gBACA,CAAG,EACD,QAAK,OACP,KACA,IACA,uBACA,CAAM,SACN,oDACM,OAAa,YACX,OAAC,gDAAkD,QAAiB,EAE5E,CACA,CAAG,EACD,QAAK,OACP,KACA,IACA,eACA,CAAM,SACN,wCACM,OAAa,YACX,OAAC,qCAAuC,kBAA+B,EAE/E,CACA,CAAG,EACD,QAAK,OACP,KACA,IACA,iBACA,CAAM,SACN,0CACM,OAAa,YACX,OAAC,uCAAyC,SAAuB,EAEzE,CACA,CAAG,EACD,QAAK,OACP,KACA,IACA,mBACA,CAAM,SACN,uCACM,OAAa,YACX,OAAC,oCAAsC,MAAa,EAE5D,CACA,CAAG,EACD,QAAK,OACP,KACA,IACA,8BACA,CAAM,SACN,mDACM,OAAa,YACX,OAAC,+CAAiD,YAAqB,EAE/E,CACA,CAAG,EACD,QAAK,aACP,KACA,IACA,8BACA,WACA,CAAM,SACN,oDACM,OAAa,YAAY,OAAC,gDAChC,CACA,CAAG,EACD,QAAK,OACP,KACA,IACA,mBACA,CAAM,SACN,gDACM,OAAa,YACX,OAAC,4CAA8C,YAAqB,EAE5E,CACA,CAAG,EACD,QAAK,OACP,KACA,IACA,oBACA,CAAM,SACN,iDACM,OAAa,YACX,OAAC,6CAA+C,OAAgB,EAExE,CACA,CAAG,EACD,QAAK,OACP,KACA,IACA,6BACA,CAAM,SACN,kDACM,OAAa,YACX,OAAC,8CAAgD,YAAqB,EAE9E,CACA,CAAG,EACH,mBACA,QACA,MACA,IACA,IACA,YACA,OACA,kBACA,eACA,CAAO,EACP,gCACA,+BACA,oBACA,WACA,8CACA,0CACA,2CACA,+CACA,qDACA,yCACA,aAEA,WACA,YAEA,mBACA,gDAEA,0CACA,oCACA,2CACA,SACA,wBACA,iBACA,mBACA,YACA,uBACA,cACA,wBACA,oBACA,qBACA,uBAEA,6DACA,yDACA,OACA,gBACU,QAAK,UACL,QAAK,UAGf,CAAM,SACN,qDACM,OAAa,YACX,OAAC,iDAET,EACA,EAkCA,YACA,mBACA,yBAmBA,OAlBA,EACA,aACA,yCAFA,EAGA,gCAHA,EAIA,kCAJA,EAKA,uBACA,wCANA,EAOA,4BACA,0CAEA,gCACA,SACA,oCAEA,gBAdA,EAeA,OACA,8BAEA,EACA,EAIA,YACA,OACA,WACA,WACA,MACA,CACA,IACA,0CACA,iBAAsD,SAAsB,OAC5E,2BACA,IACA,UACA,WAEA,CAAM,SACN,qDACM,OAAa,YAAY,OAAC,gDAChC,CACA,EAMA,OAEA,kBACA,WACA,aACA,MACA,iBACA,kBACA,qBACA,cACA,eACA,gBACA,mBAEA,mBACA,YAlGA,UACA,KACA,IACA,sBACA,CAAM,SACN,0CACM,OAAa,YACX,OAAC,sCAAwC,uBAA8B,EAE/E,CACA,EAyFA,aAxFA,KACA,yBACA,EAuFA,iBAtFA,KACA,wCACA,EAqFA,iBApFA,KACA,wCACA,EAmFA,oBAlFA,KAEA,WADA,EAEA,aAFA,EAGA,uDAHA,EAIA,yCAJA,EAKA,6CALA,EAMA,2BACA,uDAPA,EAQA,8CACA,yDAEA,EAuEA,eACA,gBAhDA,KACA,6BACA,EA+CA,8BACA,QA5BA,KACA,oBACA,OACA,MACA,CAyBA,EACA,EA+SA,IAEA,YACA,CACA,gBACA,kBACA,IACA,YAEA,eACA,CACA,2BACA,UACA,kCACA,MACA,eACA,oCACA,iCACA,kEACA,8EACA,oDACA,yDACA,oCACA,uEAEA,CACA,+BACA,qBAMA,GALA,kBACA,oBACA,iEACA,qDAEA,YADA,6CACA,MACA,8BACA,qEACA,GACA,6BAEA,CACA,oBACA,oEAEA,mBACA,qDAEA,6BACA,qEACA,kDAEA,CACA,yBACA,aACA,iBACA,+BACA,eACA,gDAEA,kBACA,wCACA,CACA,2BACA,+BACA,2BACA,uBAEA,oBACA,CACA,EACA,kBAEA,WADA,GAEA,cAEA,GAAoC,QAAe,EACnD,qBACA,OACA,OAAY,CACZ,YAAiB,CACjB,kBAAuB,CACvB,UAAgB,aAAe,CAC/B,iBAAsB,CACtB,MAAW,CACX,aAAkB,CAClB,aAAmB,aAAe,CAClC,kBAAuB,CACvB,cAAmB,CACnB,eAAoB,CACpB,gBAAqB,CACrB,iBACA,CAAG,CACH,0OACA,SAAmB,gBAAgC,EAEnD,MAAsB,QAAG,OACzB,EAAiB,QAAG,SACpB,EAAmB,QAAG,OACtB,EAA8B,QAAG,OACjC,GACA,gDACA,sDACA,oDACA,8BACA,4CACA,wCACA,8CACA,sDACA,iCACA,MACA,+CAAmF,OAAC,kCACpF,CAAO,CACP,+BACA,MACA,8CACA,CAAO,CACP,8CACA,kDACA,uBACA,MACA,+CAAmF,OAAC,wBACpF,CAAO,CACP,qBACA,MACA,8CACA,CAAO,CACP,0BACA,MACA,+CAAmF,OAAC,iCACpF,CAAO,CACP,wBACA,MACA,8CACA,CAAO,CACP,uBACA,KACA,sCAAuF,OAAC,0BACxF,CAAO,CACP,sBACA,KACA,kCACA,CAAO,CACP,qDACA,EACI,QAAK,CACT,kBACA,IACA,SAC4B,QAAK,UACjC,gBAEA,GAEI,QAAK,CACT,iBACA,IACA,SAC4B,QAAK,UACjC,eAEA,GAEI,QAAK,CACT,UACA,IACA,SAC4B,QAAK,UACjC,SAEA,GAEI,QAAK,CACT,qBACA,IACA,SAC4B,QAAK,UACjC,oBAEA,GAEI,QAAK,CACT,eACA,IACA,SAC4B,QAAK,UACjC,aAEA,GAEI,QAAK,CACT,sBACA,IACA,SAC4B,QAAK,UACjC,qBAEA,GAEI,QAAK,CACT,sBACA,UACA,YACA,MAA4B,QAAK,SACjC,8BACA,CACA,GAEI,QAAK,CACT,kBACA,IACA,SAC4B,QAAK,UACjC,iBAEA,GAEI,QAAK,CACT,mBACA,IACA,SAC4B,QAAK,UACjC,kBAEA,GAEI,QAAK,CACT,oBACA,IACA,YAC4B,QAAK,UACjC,mBAEA,GAEA,QACA,MACA,UACA,oCACA,MACA,SAA0B,EAAO,qBACjC,sBACA,CAAO,EAnJP,EAoJA,gBACA,mDACA,MACA,SAA4B,EAAO,qBACnC,sBACA,CAAS,EAET,EAkBA,MAjBI,QAAS,MACb,SACA,6BACA,QACA,QAhKA,EAiKA,UACA,EAEA,QACA,CAAK,EACD,QAAW,MACf,YACA,0BACA,CAAK,EACL,GACA,QACA,CAAK,EACL,OACa,SAAS,GAAI,QAAkB,QAC5C,oBACA,MACA,4CACA,CAAO,EACC,QAAW,KACnB,4BACA,KACA,CAAS,WACT,MAEA,CACA,CAAC,EACD,IAAuB,uDACvB,IAAuB,6BACvB,IAAuB,kDACvB,IAAuB,2CACvB,IAAuB,wCACvB,IACA,MACA,2CACA,EACA,GAAoC,QAAe,EACnD,2BACA,OACA,cAAoB,aAAe,CACnC,aAAmB,aAAe,CAClC,OAAY,CACZ,oBACA,CAAG,CACH,4EACA,SAAmB,OAAc,EACjC,MAAqB,GAAO,CAE5B,OACA,YACA,kEACA,+DACA,2BACA,qBACA,8DACA,kCACA,MACA,WACA,kCAEA,qBADA,IACA,KACA,gDACA,4BACA,IACA,mBAEA,CACA,CACA,EACA,OACA,cACA,mBAEA,mBAEA,EACA,OACA,oBACA,EACA,OACA,mBACA,EAMA,cACa,QAAS,GAAI,QAAkB,WACpC,QAAkB,WAChB,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CACA,MAA2B,QAAK,CAAC,GAAC,kCAClC,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,CAAW,EACD,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,MAAmB,QAAc,oCACjC,gCACA,uCACa,GACb,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,MAC/C,MAAuB,QAAc,EACrC,KACA,0CACA,qBACA,CACA,CAAe,UACf,CACkB,QAAK,IACvB,CACA,oBAA8C,QAAK,CAAC,GAAC,0BAA4B,QAAK,CAAC,GAAC,2BACxF,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,CAAW,cACX,gCAAoD,QAAS,GAAI,QAAW,CAAC,QAAK,CAAC,GAAM,GACzF,MACA,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CACA,MAA2B,QAAK,CAAC,GAAC,4BAClC,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,EAAW,EAAK,QAAkB,QAClC,gCAAoD,QAAS,GAAI,QAAW,CAAC,QAAK,CAAC,GAAM,GACzF,MACA,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CACA,MAA2B,QAAK,CAAC,GAAC,2BAClC,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,EAAW,EAAK,QAAkB,QAClC,uCAA6D,QAAS,GAAI,QAAkB,UAAsB,QAAe,EA/FjI,IACA,uBACA,mBACA,SAAgB,6BAAoC,GAAG,6BAA6C,CACpG,GA2FiI,0BAAgD,QAAkB,QACnM,EACA,EAEA,CACA,CAAC,EACD,GAA0C,OAAW,uCACrD,IAAuB,mBACvB,IACA,MACA,iBACA,EACA,GAAoC,QAAe,EACnD,wBACA,OACA,aAAoB,CACpB,sBAA6B,CAC7B,MAAa,CACb,eACA,CAAG,CACH,yCACA,SACA,OACA,CAAQ,MAAO,OAAC,sDAAyD,CACzE,CAAQ,MAAO,OAAC,yDAChB,CACA,EAAuB,QAAQ,iBAC/B,EAAiB,QAAQ,UACzB,EAA0B,QAAQ,8BAClC,cACa,QAAS,GAAI,QAAkB,CAAC,IAAQ,OAC7C,QAAkB,WAChB,QAAkB,cAAgB,QAAe,CAAC,QAAK,CAAC,GAAC,kCACzD,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,mBACA,gDACA,UACA,uBACA,sBACA,CAAW,wBACX,EACA,SAA+B,QAAS,GAAI,QAAkB,WACpD,QAAkB,cAAgB,QAAe,CAAC,QAAK,CAAC,GAAC,oBACzD,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,mBACA,gDACA,OACA,QACA,OACA,kBACA,CAAW,wBACX,GAAc,QAAkB,QAChC,KAEA,CACA,CAAC,EACD,GAAoC,QAAe,EACnD,wBACA,sBACA,SAAmB,OAAc,EAEjC,OACA,CAAQ,wBAA4B,CACpC,CAAQ,wBAA4B,CACpC,CAAQ,yBACR,CACA,EAAyB,QAAG,QAI5B,aACa,SAAS,GAAI,QAAkB,CAAC,IAAQ,OAC7C,QAAW,CAAC,QAAK,CAAC,GAAM,GAChC,mBACA,gDACA,UACA,uBACA,sBACA,CAAS,wBACD,QAAW,CAAC,QAAK,CAAC,GAAM,GAChC,qBACA,QACA,WACA,wBAvBA,EAQA,cAeA,UACA,CAAS,EACT,QAAmB,QAAO,MACd,QAAe,CAAC,QAAe,CAAC,QAAK,CAAC,GAAC,uBACnD,EACA,GACA,CAAS,EACT,KAEA,CACA,CAAC,EACD,GAAoC,QAAe,EACnD,uBACA,OACA,iBAAwB,CACxB,0BACA,CAAG,CACH,gCACA,SACA,MAA2B,QAAQ,qBACnC,EAAkC,OAAe,OACjD,sCAEA,EAAkC,OAAe,OACjD,sCAEA,EAAqC,OAAe,OACpD,yCAEA,cACa,QAAS,GAAI,QAAkB,CAAC,IAAQ,OAC7C,QAAkB,cAAgB,QAAe,CAAC,QAAK,CAAC,GAAC,+BACzD,QAAW,CAAC,QAAK,CAAC,GAAM,GAChC,mBACA,gDACA,eACA,IAAe,QAAK,IACpB,IAAe,QAAK,IACpB,KAAgB,QAAK,GACrB,CAAS,2CACT,KAEA,CACA,CAAC,EACD,IAAuB,mBACvB,GAAoC,QAAe,EACnD,uBACA,OACA,cAAqB,CACrB,uBAA8B,CAC9B,eAAsB,CACtB,wBACA,CAAG,CACH,mDACA,SACA,MAAwB,QAAQ,kBAChC,EAAyB,QAAQ,mBACjC,GACA,CAAQ,MAAO,OAAC,kDAAqD,CACrE,CAAQ,sBAA0B,CAClC,CAAQ,sBAA0B,CAClC,CAAQ,sBAA0B,CAClC,CAAQ,sBAA0B,CAClC,CAAQ,sBAA0B,CAClC,CAAQ,uBACR,CACA,EAAgC,QAAQ,KACxC,CACA,CAAU,MAAO,OAAC,mDAAsD,CACxE,CAAU,MAAO,OAAC,+CAAkD,CACpE,CAAU,MAAO,OAAC,sDAClB,EAEA,cACa,QAAS,GAAI,QAAkB,WACpC,QAAkB,aAChB,QAAkB,cAAgB,QAAe,CAAC,QAAK,CAAC,GAAC,4BACzD,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,mBACA,gDACA,UACA,uBACA,sBACA,CAAW,wBACX,EACQ,QAAkB,aAChB,QAAkB,cAAgB,QAAe,CAAC,QAAK,CAAC,GAAC,6BACzD,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,mBACA,gDACA,gBACA,uBACA,sBACA,CAAW,kCACX,EACA,EAEA,CACA,CAAC,EACD,IAAuB,mBACvB,IAAuB,OACvB,IACA,eACA,YACA,EACA,IAAuB,OACvB,IACA,MACA,iBACA,EACA,GAAoC,QAAe,EACnD,uBACA,MAAyB,QAAW,EACpC,oBAA0B,aAC1B,CAAG,EACH,kBAAyB,CACzB,2BAAkC,CAClC,UAAkB,aAAe,CACjC,oBACA,CAAG,EACH,MAAyB,QAAW,yEACpC,SAAmB,OAAc,EACjC,MAA4B,QAAQ,sBACpC,EAAqB,QAAQ,eAE7B,EAA2B,QAAG,OAC9B,OACA,KACA,6BACA,EACA,MACA,eACA,qBACA,sCAEA,UACA,EACA,OACA,+BACA,EACA,cACa,QAAS,GAAI,QAAkB,WAC5C,qBASc,QAAkB,QATI,SAAS,GAAI,QAAkB,WACzD,QAAkB,cAAgB,QAAe,CAAC,QAAK,CAAC,GAAC,gCACzD,QAAc,CAAC,QAAkB,UAC3C,gDACA,aACA,cACA,CAAW,YACX,CAAa,IAAU,UACvB,EACA,GACQ,QAAkB,aAChB,QAAW,CAAC,QAAK,CAAC,GAAQ,GACpC,mBACA,gDACA,sBACA,UACA,eACA,CAAW,wBACD,QAAkB,YAAwB,QAAe,CAAC,QAAK,CAAC,GAAC,yBAC3E,EACA,qBAgBc,QAAkB,SAhBI,QAAS,GAAI,QAAkB,WACzD,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,qBACA,MAAmB,QAAK,CAAC,GAAC,kCAC1B,mBACA,eACA,SACA,CAAW,mBACD,QAAkB,UAC5B,yBACA,MACA,YACA,iBACA,eACA,UACA,CAAW,WACX,GACA,sBAAmC,QAAS,GAAI,QAAkB,WACxD,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,qBACA,MAAmB,QAAK,CAAC,GAAC,kCAC1B,mBACA,eACA,SACA,CAAW,mBACX,GAAc,QAAkB,QAChC,EAEA,CACA,CAAC,EACD,IAAuB,4BACvB,IAAuB,oCACvB,IAAuB,mBACvB,IAAqB,uBACrB,IAAqB,uBACrB,IAAqB,uBACrB,IAAqB,uBACrB,IAAqB,uBACrB,IAAqB,aACrB,IAAsB,oBACtB,GAAoC,QAAe,EACnD,6BACA,OACA,OACA,CAAG,CACH,SAEA,MAA6B,QAAG,GAChC,EAAyB,QAAG,GAC5B,EAA2B,QAAG,GAC9B,EAAsB,QAAG,KACzB,EAA6B,QAAG,OAChC,yBAAwD,QAAK,UACzD,QAAS,WACb,4BACA,aACA,oCAEA,UACA,iCACA,cACA,uDACA,oDACA,gBACA,mBACA,CAAe,IAEf,CAAW,CACX,CAAS,EACT,yBACA,cACA,8BACS,GAET,gDACA,CAAK,EACL,WACA,wBACM,OAAc,gBACpB,EAQA,MAPI,QAAe,MACnB,oDACA,UACA,qBACA,aAEA,CAAK,EACL,QACa,QAAS,GAAI,QAAkB,QAC5C,2BACA,MACA,MAAe,QAAc,gDAC7B,yBACA,QAAqB,QAAK,sBAA6B,QAAK,4BAC5D,yBACA,QAAqB,QAAK,sBAA6B,QAAK,2BAC5D,CAAO,EACC,QAAkB,QAC1B,yBACA,MACA,uBACA,CAAS,EACC,QAAkB,QAC5B,uBACA,MACA,oDACA,qBACA,QAAyB,QAAK,kBAAyB,QAAK,uBAC5D,CAAW,WACX,MACQ,QAAkB,WAChB,QAAkB,WAChB,QAAkB,WAChB,QAAkB,WAChB,QAAW,KAC3B,mBAAsC,QAAK,0BAC3C,0CAAsF,QAAK,6BAC3F,YAA+B,QAAK,mBACpC,mCAA+E,QAAK,sBACpF,uBAA0C,QAAK,6BAC/C,wBAA2C,QAAK,gCAC/B,2FACjB,EACc,QAAkB,WAChB,QAAW,KAC3B,eAAkC,QAAK,sBACvC,sCAAkF,QAAK,yBACvF,gBAAmC,QAAK,uBACxC,uCAAmF,QAAK,yBACxF,CAAiB,0CACjB,EACc,QAAkB,WAChB,QAAW,KAC3B,cAAiC,QAAK,qBACtC,qCAAiF,QAAK,wBACtF,IAAuB,QAAK,cAC5B,8BAA0E,QAAK,gBAC/E,CAAiB,+BACjB,EACc,QAAkB,WAChB,QAAW,KAC3B,kBAAqC,QAAK,yBAC1C,yCAAqF,QAAK,2BAC1F,CAAiB,6BACjB,EACc,QAAkB,WAChB,QAAW,KAC3B,cAAiC,QAAK,gBACrB,2BACjB,EACA,EACA,EACU,QAAkB,WAChB,QAAkB,WAChB,QAAW,CAAC,QAAK,CAAC,GAAM,GACtC,mBACA,qBACA,MAAuB,QAAK,CAAC,GAAC,cAC9B,SACA,CAAe,mBACf,EACA,EACA,EACA,KAEA,CACA,CAAC,EACD,GAA4C,OAAW,uCACvD,IAAuB,uDACvB,IAAuB,6BACvB,IAAqB,yCACrB,GAAoC,QAAe,EACnD,wBACA,OACA,OACA,CAAG,CACH,SACA,MAAqB,GAAO,CAC5B,OACA,OAAsB,aAChB,OAAc,eACpB,2BACA,MAAe,OAAC,wBAChB,aACA,QACA,sBACA,oBAA+B,aAAa,EAC5C,eACA,kBACA,oCACA,CACA,CACA,CAAO,CACP,EACA,cACa,QAAS,GAAI,QAAkB,WACpC,QAAkB,WAChB,QAAW,CAAC,QAAK,CAAC,GAAM,GAClC,uCACA,SACA,CAAW,EACX,QAAqB,QAAO,MACd,QAAc,CAAC,QAAkB,mBAC/C,CACkB,QAAK,IACvB,CACA,MAA2B,QAAK,CAAC,GAAC,2BAClC,aACA,CAAmB,CACnB,OACA,CAAoB,UACpB,CACA,EACA,EACA,GACA,CAAW,EACX,EACA,EAEA,CACA,CAAC,EACD,IACA,MACA,wDACA,EACA,GAAoC,QAAe,EACnD,gBACA,OACA,SACA,CAAG,CACH,SACA,IAAY,KAAQ,CAAE,OAAO,GAC7B,qBACA,gBACA,SACA,EAA4B,QAAG,YAC/B,EAAqB,QAAG,KACxB,EAAwB,QAAG,KAC3B,EAA2B,QAAG,IAC9B,EAAqC,QAAG,KACxC,EAAiB,QAAG,KACpB,EAA0B,QAAG,KAC7B,EAAuB,QAAG,gBAC1B,EAA+B,QAAG,KAClC,EAA4B,QAAG,KAC/B,EAAwB,QAAG,aAC3B,EAAyB,QAAG,aAC5B,EAA0B,QAAG,KAC7B,EAA2B,QAAG,OAC9B,EAAwB,QAAG,KAC3B,EAAyB,QAAG,KAC5B,EAA8B,QAAG,IACjC,EAAkC,QAAG,eACrC,EAA2B,QAAQ,CACnC,IAAY,OAAe,uCAE3B,EAA8B,QAAQ,KACtC,wBAEA,OACA,KACA,sCACA,2CAEA,EACA,OACA,KACA,sCACA,2CAEA,EACA,YACA,MACA,sCACA,sCACA,WAEA,EACA,OACA,MACA,sCACA,+BACA,WACA,8CACA,kBAEA,EACA,OACA,MACA,sCACA,oDACA,KAA4B,EAAU,sBACtC,iCACA,CACA,EACA,OACA,MACA,sCACA,gCACA,WACA,UAEA,EACA,OACA,6DACA,gCACA,qCAEA,MACA,UACA,sCAEA,MACA,UACA,mCAEA,MACA,UACA,yCAEA,YACA,OACA,WACA,WACA,oCACA,MACA,CACA,0CACA,iBAAsD,SAAsB,MAC5E,kCACA,wCACA,EACA,MACA,UACA,0BAEA,MACA,UACA,wCAEA,MACA,UACA,kCACA,EACA,MACA,UACA,8BACA,EACA,MACA,UACA,+BACA,EACA,YACA,MACA,mDACQ,OAAa,kDAGrB,IACA,mCACA,CAAQ,SACR,0CACQ,OAAa,YACrB,uCACA,sBACA,CAAW,EAEX,CACA,EACA,MACA,UACA,sBACA,EACA,MACA,SACA,EACA,MACA,SACA,EACA,MACA,KACA,WACA,0CACA,8CACA,kBAEA,EACA,MACA,SACA,EACA,MACA,SACA,EACA,OACA,SACA,EACA,OACA,UACA,iCAEA,OACA,SACA,EACA,OACA,SACA,EACA,OACA,UACA,uBACA,YAEA,EACA,cACa,QAAS,GAAI,QAAkB,QAC5C,+BACA,eACA,cACA,CAAO,EACC,QAAW,KACnB,yBACA,MACA,KAAgB,QAAK,IACrB,aAAwB,QAAK,IAC7B,2BACA,oBACA,0BACA,YACA,sBACA,uBACA,2BACA,uBACA,wBACA,yBACA,uBACA,0BACA,yBACA,eACA,sBACA,oBACA,uBACA,2BACA,sBACA,wBACA,yBACA,CAAS,sLACD,QAAW,KACnB,aAAwB,QAAK,IAC7B,2BACA,oBACA,uBACA,0BACA,sCACA,YACA,4BACA,8BACA,sBACA,+BACA,uBACA,wBACA,yBACA,0BACA,iBACA,eACA,0BACA,yBACA,kBACA,cACA,sBACA,uBACA,wBACA,eACA,CAAS,2PACT,SAAgC,QAAS,GAAI,QAAkB,WACrD,QAAW,KAAgB,KAAM,QAAK,IAAQ,kBACxD,GAAc,QAAkB,QAChC,SAAuC,QAAS,GAAI,QAAkB,QACtE,MACA,MAAiB,QAAc,+CAC/B,kBACA,gBACA,CAAW,EACX,CAAS,EACC,QAAW,KACrB,KAAkB,QAAK,IACvB,uBACA,wBACA,6BACA,mBACA,kBACA,oBACA,kBACA,CAAW,sEACX,KAAiB,QAAkB,QACnC,KAEA,CACA,CAAC,EACD,IACA,MACA,yGACA,EACA,GAAoC,QAAe,EACnD,iCACA,OACA,aAAkB,CAClB,SAAe,aACf,CAAG,CACH,qDACA,SAAmB,OAAc,EAGjC,MAAuB,QAAG,eAC1B,EAAoB,QAAG,CAHvB,EAGuB,SACvB,EAA0B,QAAG,IAC7B,EAA8B,QAAG,IACjC,GACA,CAAQ,qBAA0B,CAClC,CAAQ,qBAA0B,CAClC,CAAQ,kBAAsB,CAC9B,CAAQ,sBAA0B,CAClC,CAAQ,mBACR,CACI,QAAK,CACT,iBACA,IACA,SACA,GAEA,WACA,iBACA,uBACA,EACA,OAtBA,EAuBA,sBACA,EACA,OACA,4BACA,EACA,aACA,2BAAgE,QAAS,GAAI,QAAkB,WACvF,QAAW,CAAC,QAAK,CAAC,GAAM,GAChC,uCACA,SACA,CAAS,EACT,QAAmB,QAAO,MACd,QAAkB,MAC9B,MAAqB,QAAc,0DACnC,CAAa,SACb,EACA,GACA,CAAS,EACD,QAAW,CAAC,QAAK,CAAC,GAAM,GAChC,mBACA,gDACA,UACA,sBACA,uBACA,aACA,UACA,CAAS,wBACD,QAAW,CAAC,QAAK,CAAC,GAAM,GAChC,mBACA,gDACA,gBACA,sBACA,uBACA,aACA,UACA,CAAS,kCACT,GAAY,QAAkB,OAE9B,CACA,CAAC,EACD,GAAoC,QAAe,EACnD,8BACA,OACA,OAAY,CACZ,YAAiB,CACjB,kBAAuB,CACvB,UAAgB,aAAe,CAC/B,iBAAsB,CACtB,MAAW,CACX,aAAkB,CAClB,aAAmB,aAAe,CAClC,eAAoB,CACpB,cAAmB,CACnB,eAAqB,aAAe,CACpC,0BAAgC,aAAe,CAC/C,SAAe,aAAe,CAC9B,gBAAqB,CACrB,oBAAyB,CACzB,kBACA,CAAG,CACH,oNACA,SAAmB,gBAAgC,EAEnD,MAAiB,QAAG,SACpB,EAA4B,QAAG,CAF/B,EAE+B,iBAC/B,EAAwB,QAAG,CAH3B,EAG2B,aAC3B,EAAiB,QAAG,QACpB,EAA2B,QAAG,mBAC9B,EAAuB,QAAG,eAC1B,EAAqB,QAAG,aACxB,EAAwB,QAAG,CAR3B,EAQ2B,aAC3B,EAAyB,QAAG,iBAC5B,EAA0B,QAAG,kBAC7B,EAAqC,QAAG,6BACxC,EAA2B,QAAG,OAC1B,QAAK,CACT,iBACA,IACA,SACA,GAEI,QAAK,CACT,IApBA,EAoBA,SACA,IACA,SACA,GAEI,QAAK,CACT,sBACA,IACA,SACA,GAEI,QAAK,CACT,qBACA,IACA,SACA,GAEI,QAAK,CACT,UACA,IACA,SACA,GAEI,QAAK,CACT,kBACA,IACA,SACA,GAEI,QAAK,CACT,mBACA,IACA,SACA,GAEI,QAAK,CACT,kBACA,IACA,SACA,GAEI,QAAK,CACT,cACA,IACA,MACA,8CACA,uBACA,GAEI,QAAK,CACT,oBACA,IACA,MACA,8CACA,yBACA,GAEI,QAAK,CACT,wBACA,IACA,MACA,8CACA,+BACA,GAGA,UACA,UACA,sBACA,EACA,MACA,SACA,EACA,MACA,SACA,EACA,MACA,SACA,EACA,MACA,UACA,iCAEA,MACA,SACA,EACA,MACA,SACA,EACA,MACA,8BACA,EACA,GACA,wBA5BA,EA6BA,wBACA,CACA,EAIA,OAHA,GACA,gBACA,CAAK,EACL,OACa,SAAS,GAAI,QAAW,KACrC,yBACA,MACA,aACA,yBACA,2BACA,oBACA,0BACA,YACA,sBACA,uBACA,oBACA,qCACA,uBACA,wBACA,uBACA,0BACA,yBACA,cACA,qBACA,mBACA,sBACA,yBACA,CAAO,qKAEP,CACA,CAAC,EACD,IAAqB,iEACrB,IACA,MACA,wDACA,EACA,GAAkC,QAAe,EACjD,yBACA,OACA,SACA,CAAG,CACH,SACA,yBACA,gBACA,SACA,EAA4B,QAAG,YAC/B,EAAqB,QAAG,KACxB,EAAwB,QAAG,KAC3B,EAA2B,QAAG,IAC9B,EAAqC,QAAG,KACxC,EAAiB,QAAG,KACpB,EAA0B,QAAG,KAC7B,EAAuB,QAAG,gBAC1B,EAA+B,QAAG,KAClC,EAAuB,QAAG,KAC1B,EAAoB,QAAG,KACvB,EAA0B,QAAG,IAC7B,EAA8B,QAAG,IACjC,EAA4B,QAAG,KAC/B,EAAwB,QAAG,KAC3B,EAAyB,QAAG,KAC5B,EAA8B,QAAG,IACjC,EAAkC,QAAG,eACrC,EAA8B,QAAQ,KACtC,wBAEA,EAAoC,QAAG,OACvC,OACA,MACA,gDACA,2BACA,qCAEA,EACA,OACA,MACA,gDACA,2BACA,qCAEA,EACA,YACA,MACA,gDACA,4BACA,gCACA,WAEA,EACA,OACA,MACA,gDACA,4BACA,yBACA,WACA,wCACA,kBAEA,EACA,OACA,MACA,gDACA,4BACA,oDACA,KAA4B,EAAU,0BACtC,2BACA,CACA,EACA,OACA,MACA,gDACA,4BACA,0BACA,WACA,UAEA,EACA,MACA,MAEA,GADA,UACA,IACA,gDACA,4BACA,wCACA,kBAEA,CACA,EACA,OACA,6DACA,gCACA,mCACA,EACA,MACA,UACA,sCAEA,MACA,UACA,mCAEA,MACA,UACA,uCACA,EACA,YACA,OACA,WACA,WACA,oCACA,MACA,CACA,0CACA,iBAAsD,SAAsB,MAC5E,kCACA,0CAEA,MACA,UACA,0BAEA,EAAyB,QAAG,aAC5B,EAAwB,QAAG,aAC3B,MACA,UACA,8BACA,EACA,MACA,UACA,+BACA,EACA,MACA,UACA,kCACA,EACA,MACA,SACA,EACA,MACA,SACA,EACA,MACA,SACA,EACA,MACA,SACA,EACA,MACA,UACA,sBACA,EACA,MACA,SACA,EACA,MACA,SACA,EACA,MACA,SACA,EACA,MACA,SACA,EACA,OACA,UACA,+BACA,EACA,OACA,SACA,EACA,OACA,SACA,EACA,OACA,UACA,uBACA,YAEA,EACA,cACa,QAAS,GAAI,QAAkB,QAC5C,+BACA,eACA,cACA,CAAO,EACC,QAAW,KACnB,kCACA,MACA,KAAgB,QAAK,IACrB,aAAwB,QAAK,IAC7B,2BACA,oBACA,0BACA,YACA,sBACA,uBACA,4BACA,sCACA,gBACA,yBACA,6BACA,2BACA,uBACA,wBACA,uBACA,0BACA,yBACA,cACA,sBACA,oBACA,uBACA,2BACA,wBACA,sBACA,yBACA,CAAS,uQACD,QAAkB,WAChB,QAAW,KACrB,aAA0B,QAAK,IAC/B,2BACA,oBACA,uBACA,0BACA,sCACA,YACA,4BACA,8BACA,sBACA,+BACA,uBACA,wBACA,0BACA,iBACA,eACA,0BACA,yBACA,kBACA,cACA,sBACA,sBACA,CAAW,0OACD,QAAW,KACrB,mBACA,gBACA,eACA,gBACA,mBACA,CAAW,kCACX,EACA,QAAuC,SAAS,GAAI,QAAkB,WAC5D,QAAW,KACrB,KAAkB,QAAK,IACvB,uBACA,wBACA,6BACA,mBACA,kBACA,oBACA,kBACA,CAAW,sEACX,GAAc,QAAkB,QAChC,KAEA,CACA,CAAC,CACD,UACA,eACA,aACA,CACA,0BACA,wCACA,6BACA,CACA,+BACA,+BACA,0BACA,6BACA,CACA,qBACA,OACA,2CACA,eACA,oCACA,EACA,eACA,oCACA,EAEA,CACA,mCACA,sCACA,IACA,IAEA,CACA,0BACA,oCACA,EACA,EAEA,UACA,WAEA,eACA,2CACA,IACA,CACA,CACA,yBACA,mCACA,cACM,OAAe,mCAErB,4BACA,mCACA,YACM,OAAe,iCAErB,0BACA,mCACA,eACM,OAAe,oCAErB,6BACA,mCACA,mBACA,IAAY,OAAe,wCAE3B,kCACA,aACA,6BACA,kBACQ,OAAe,wCAGvB,iCACA,qDACA,sBACA,0DACA,iCACA,CACA,8BACA,SACA,iBACA,aAEA,uBADA,GAEA,MAAuB,GAAG,QAC1B,qBACA,iBAJA,GAKA,GAGA,+BARA,GASA,mCACA,eACA,YAEA,8BACA,mCACA,gBACA,YAEA,+BACA,aACA,mDAGA,GADA,gCACA,0BACA,IACA,6BACA,CAAU,SACV,iDACA,CACA,IACA,CACA,CACA,CACA,qBACA,uCACA,eACA,OAGA,QADA,YACA,SACA,IACA,kDAEA,CACA,CACA,uBACA,gBACA,qCACA,wCACA,0BAEA,IACA,0CACA,iBAAoD,SAAsB,OAC1E,8BACA,iBACM,OAAa,YAAY,OAAC,oCAGhC,MAAqB,GAAG,QACxB,qBACA,oBACA,SAGA,2DACA,OACA,sEACA,yDAEA,UAEA,CAAI,SACJ,wCACI,OAAa,YAAY,OAAC,mCAC9B,CACA,CACA,uBACA,2BACA,IACA,0CACA,iBAAoD,SAAsB,MAC1E,kCACA,CAAI,SACJ,kDACI,OAAa,YAAY,OAAC,6CAC9B,CACA,CACA,oBACA,sCAKA,OAJA,cACA,WACA,aACA,uBACA,CACA,CACA,OAAmB,sBACnB,oBACA,UACA,CACA,2BACA,kDACA,+BACA,0KACA,eACA,gBACA,eACA,CAAK,CACL,CACA,8BACA,qDACA,kCACA,oLACA,eACA,gBACA,eACA,CAAK,CACL,CACA,kCACA,mDACA,gCACA,qNACA,aACA,sBACA,eACA,CAAK,CACL,CACA,6BACA,+CACA,2BACA,gMACA,aACA,uCACA,2BACA,eACA,CAAK,CACL,CACA,iCACA,kDACA,+BACA,yOACA,cACA,eACA,eACA,CAAK,CACL,CACA,wCACA,kDACA,+BACA,4KACA,cACA,gBACA,eACA,CAAK,CACL,CACA,wCACA,kDACA,+BACA,4KACA,cACA,eACA,eACA,CAAK,CACL,CACA,2CACA,qDACA,kCACA,oOACA,cACA,OACA,OACA,MACA,OACA,CAAO,CACP,gBACA,eACA,CAAK,CACL,CACA,iCACA,oCACA,+BACA,qKACA,eACA,gBACA,eACA,EACA,CACA,UACA,CACA,iCACA,oBACA,gDACA,cACA,MAA8B,GAAG,uBACjC,wCACA,2BACA,IAAa,OAAY,WACjB,GAAQ,oBACR,GAAQ,yBAChB,OAAwB,QAChB,OAAc,eACtB,2BACA,MAAiB,OAAC,wBAClB,aACA,QACA,sBACA,oBAAiC,aAAa,EAC9C,eACA,kBACA,oCACA,CACA,CACA,CAAS,CACT,CACA,EACA,CACA,qBACA,EACA,WACA,wCACA,oCACA,qBACA,mBACA,EACA,4DACA,SACA,CAAS,EACT,gBACA,sBACA,oBACA,UACA,EACA,YACA,SACA,yBACA,uBACA,KACA,SACA,GAEA,0CACA,OACA,6CACA,iEACA,IACA,YAEA,CAAS,EACT,OACA,aACA,cACA,eACA,YACA,EACA,MAA2B,GAAmB,EAC9C,OACA,YACA,aACA,YACA,UACA,CAAS,EAET,MADQ,OAAS,MACjB,QAAiB,EACjB,CACA,GAEA,qBACA,8CACA,gBACA,6CACA,MAAU,QAAQ,GAClB,yBACA,YACA,kCACA,YACA,8DACA,yDACA,0DACA,yDACA,aACA,6BACA,2BACA,+CACA,kBACA,IACA,QACA,OACA,SACA,UACA,CAAY,qBACZ,QACA,SAEA,6BACA,8BACA,mCACA,qCACA,sCACA,EACA,iBACA,OACA,gBAA6B,QAAW,QACxC,eAA4B,QAAe,QAC3C,iBAA8B,QAAiB,QAC/C,kBAA+B,QAAkB,QACjD,wCACA,YACA,EACA,uBACA,MACA,0BACA,wCACA,CACA,uBAA+C,QAAgB,QAE/D,QACA,EAEA,CAAK,CACL,CACA,CAAC,EACD,OAAmB,sBACnB,6BACA,qBACA,EACA,qBACA,8BACA,oCACA,qBACA,mBACA,EACA,4DACA,SACA,CAAS,EACT,gBACA,sBACA,oBACA,UACA,EACA,YACA,SACA,yBACA,uBACA,KACA,SACA,GAEA,0CACA,OACA,6CACA,iEACA,IACA,YAEA,CAAS,EACT,OACA,aACA,uBACA,eACA,YACA,EACA,MAA2B,GAAmB,EAC9C,OACA,YACA,aACA,YACA,UACA,CAAS,EAET,MADQ,OAAS,MACjB,QAAiB,EACjB,CACA,GAEA,qBACA,uDACA,gBACA,6CACA,MAAU,QAAQ,GAClB,yBACA,YACA,6DACA,8DACA,8BACA,yDACA,0DACA,gBACA,UACA,2BACA,2BACA,+CACA,EACA,oBADA,EAEA,eACA,kBAEA,IACA,QACA,OACA,SACA,CAAY,MATZ,EASY,aACZ,QACA,SAEA,2BACA,8BACA,mCACA,qCACA,EAjBA,EAkBA,eACA,OACA,gBAA6B,QAAW,QACxC,eAA4B,QAAe,QAC3C,iBAA8B,QAAiB,QAC/C,wCACA,YACA,EACA,uBACA,MACA,0BACA,wCACA,CACA,uBAA+C,QAAgB,OAC/D,CACA,QACA,EAEA,CAAK,CACL,CACA,CAAC,EACD,OAAmB,sBACnB,uBACA,iCACA,sBACA,uCAEA,CAAG,CACH,qBACA,EACA,cACA,OACA,aACA,iBACA,eACA,YACA,EACA,MAA2B,GAAmB,EAC9C,OACA,YACA,aACA,YACA,UACA,CAAS,EAET,MADQ,OAAS,MACjB,QAAiB,EACjB,CACA,GAEA,qBACA,iDACA,gBACA,6CACA,MAAU,QAAQ,GAClB,mBACA,yBACA,MACA,gBACA,8DACA,MACA,2CACA,MACA,UACA,kCACA,yBACA,CACA,yBACA,iCACA,kBACA,OACA,MAAwB,OAAC,2CACzB,iBACY,OAAa,cACzB,CACA,kBACA,+BACA,6CACA,yBACA,CACA,CACA,CAAK,CACL,CACA,CAAC,EACD,OAAmB,sBACnB,gCACA,iCACA,+BACA,iDAEA,CAAG,CACH,qBACA,EACA,wBACA,OACA,aACA,0BACA,eACA,YACA,EACA,MAA2B,GAAmB,EAC9C,OACA,YACA,aACA,YACA,UACA,CAAS,EAET,MADQ,OAAS,MACjB,QAAiB,EACjB,CACA,GAEA,qBACA,0DACA,gBACA,6CACA,MAAU,QAAQ,GAClB,mBACA,yBACA,MACA,gBACA,8DACA,MACA,2CACA,MACA,UACA,kCACA,yBACA,CACA,yBACA,iCACA,kBACA,OACA,MAAwB,OAAC,2CACzB,iBACY,OAAa,cACzB,CACA,kBACA,+BACA,6CACA,yBACA,CACA,CACA,CAAK,CACL,CACA,CAAC,EACD,mCACA,QACA,8BAAiC,EAAU,MAC3C,yBAA4B,EAAU,MACtC,kCAAqC,EAAU,MAC/C,sBAAyB,GAAyB,EAAE,EAAU,MAC7D,EAUD,6BAEA,YADA,yBAAkF,kDAA6D,UAC/I,+BAqBA,uBACA,MAAQ,GAAG,0BACX,cACA,MACA,CAAG,YACH,yBACA,CAAG,EACD,GAAQ,gBAAgB,GAAQ,oCAChC,GAAQ,gBAAgB,GAAQ,8BAAmC,GAAG,QACxE,2CAA0D,GAAG,yBAA2B,GAAG,iBAErF,GAAQ,mBACV,IAAQ,kBAAkB,GAAQ,6BACtC,qBACA,CAmBA,uBAAiE,GAAW,CAC5E,cACA,QACA,iBACA,mBACA,sBACA,6BACA,gCACA,uBACA,sBACA,sBACA,iBACA,iBACA,qBACA,8BACA,sBACA,iBACA,8BACA,8BACA,mBACA,mBACA,2BACA,2BACA,yBACA,wBACA,qCACA,gCACA,4BACA,yBACA,oCACA,2BACA,oBACA,oBACA,sBACA,aAAmB,OAAG,oBAAsB,qBAAuB,EAC7D,OAAG,sDACT,CACA,CACA,qBAIA,OAHA,YACA,mBAEA,UACA,CACA,gBACA,SAGA,kBACA,uCAIA,OAHA,6BACA,cACA,8BACA,CACA,CAEA,sBACA,6BAGA,OAFA,wBACA,0BACA,CACA,CAEA,uBACA,6BAGA,OAFA,yBACA,yBACA,CACA,CAEA,wBACA,mCACA,0BACA,wBACA,gCACA,0BACA,kCACA,gDACA,2BACA,0CACA,4BACA,wBACA,sBACA,0BACA,uBACA,4BACA,kBACA,6BACA,qDACA,kDACA,6CACA,+CACA,gDACA,sCAKA,OAJA,gBACA,iBACA,oCACA,kDACA,CACA,CAEA,2BACA,mCACA,kCACA,wBACA,gCACA,0BACA,kCACA,gDACA,2BACA,0CACA,4BACA,wBACA,sBACA,0BACA,uBACA,4BACA,kBACA,6BACA,uDACA,oDACA,iDACA,iDACA,mDACA,mDACA,sCAKA,OAJA,gBACA,iBACA,sCACA,mDACA,CACA,CACA,2BACA,mCACA,gCACA,wBACA,gCACA,0BACA,kCACA,gDACA,2BACA,0CACA,4BACA,wBACA,sBACA,0BACA,uBACA,4BACA,kBACA,6BACA,qCACA,+BACA,sCACA,0BACA,kCACA,4BACA,yBACA,sCACA,eACA,gBACA,cACA,uCAYA,OAXA,eACA,gBACA,iBACA,iBACA,gCAEA,eADA,SACA,MACA,4BACA,CAAK,EACL,iBACA,iBACA,CACA,CACA,wBACA,yBACA,mCACA,sCACA,2CAEA,oCACA,uCACA,0CAEA,CACA,eACA,WACA,qBACA,mCACA,6BACA,qBACA,oBACA,qBACA,sBACA,6BACA,mCACA,cACA,sCACA,mCACA,oCACA,4BACA,sBACA,6BACA,aACA,6BACA,4BACA,4BACA,4BACA,6BACA,yCACA,oBACA,EACA,EACA,mBACA,oBAEA,CAAK,CACL,8CACA,EACA,YAEA,IACA,4BACA,uBACA,GAEA,mDACA,EACA,UAEA,IACA,+BACA,iCACA,uDAEA,GAEA,+DACA,sEACA,6BACA,2BACQ,6BACR,8BAEA,2BAEA,mCACA,CAAK,EACL,2CACA,wDACA,SACA,CAAK,CACL,oDACA,wDACA,QACA,CAAK,EACL,4BACA,4BACA,4BACA,iBACA,+BACA,iBACA,sCACA,yCACA,8CACA,gCACA,4BACA,4BACA,kBACA,iBACA,wBACA,0BACA,+BACA,qCACA,oCACA,CACA,aAIA,GAHA,kBACA,aACA,aACA,yBACA,uCACA,kCACA,oBACA,kBACA,oBACA,iBACA,kBACA,gCAAmD,sBAA0B,EAC7E,wBACA,0BACA,WACA,iCACA,sBACA,mDACA,sFACA,6BACc,GAAQ,4BAEtB,6CAEA,CAAS,CACT,CAAO,EAEP,qBADA,CAAuB,eAEvB,CACA,qDACQ,GAAQ,uBAChB,yCAEA,iCAEA,4BACA,mCACA,+BACA,mCACA,kCACA,6BACA,8BACA,iCACA,qCACA,kBACA,CACA,WACA,0CAGA,sBACA,6BACA,+BACA,8BACA,gCACA,sCAAmD,sBAA0B,EAC7E,mCACA,qBACA,CAAK,EACL,oCAnWA,kBACA,oCACA,qBACA,EACA,EACA,QACA,UAEA,YAAkB,gBAA0B,KAC5C,+BACA,gBACA,cACA,gBACA,gBAEA,yCACA,qBACA,EAmVA,wCACA,CAEA,mBACA,WACA,qBAAgD,sBAA0B,EAC1E,eACA,kBACA,4DACA,8DACA,cAEM,GAAQ,gBAAgB,GAAQ,+BAEtC,iCACA,iCACA,kCACA,YA5YA,gBACA,eACA,qBACA,IACA,EACA,MAuYA,CAtYA,CAAG,EAuYH,UAEM,GAAQ,gBAAgB,GAAQ,+BAEtC,iCACA,oCACA,qBACA,6BACA,sBACA,wBACA,8BACA,2BACA,EACA,2BACA,CACA,0BACA,uBACA,oBACA,2BACA,4BACA,oBAEA,IADA,KACA,oCAEA,KAEA,GADA,MACA,oCAEA,mCACA,cACA,SACA,cACA,aACA,wBACA,CACA,oBACA,uCACA,oCACA,iBACA,kBAEA,iBACA,kBAEA,SAAmB,EAAU,IAC7B,KAAoB,EAAW,IAC/B,KAAkB,WAAW,IAC7B,KAAiB,WAAW,GAC5B,+BACA,+BACA,6BACA,4BACA,6BACA,8BACA,4BACA,0BACA,CAEA,mBACA,WACA,0BACA,qCACA,kBACA,CAAO,EACP,8BACA,QACA,+BAEA,8BACA,cACA,6BAEA,8BACA,YACA,6BAEA,8CACA,WACA,kBAEA,CAAO,EACP,mBACA,cACA,gCAEA,mBACA,cACA,wBAEA,mBACA,YACA,wBAEA,sCACA,gCACA,CAAO,EACP,uCACA,+BACA,CAAO,EACP,0BACA,YACA,mBAEA,2BAEA,CACA,2BACA,mCACA,CACA,0BACA,WACA,EAEA,CACA,uBACA,2BAGA,CACA,qBACA,gCACA,CAAe,aAEf,iCAGA,mCAFA,CAAe,mBAKf,CAAa,YACb,CACA,mBACA,0BACA,oCACA,CACA,qBACA,gBAQA,MAPA,gCACA,UACM,gCACN,UACM,oCACN,eAEA,WACA,CACA,kCACA,qDACA,+BACA,mDACA,mDACA,0BACA,4BACA,EACA,EACA,sBACA,wBAEA,YAAoB,gBAA0B,KAC9C,cACA,gBACA,gBAEA,gCACA,CAEA,wBACA,iBACA,aACA,0CACA,yCACM,aACN,wCACA,yCACM,iBACN,SAEA,uBACA,CAEA,0BACA,mBACA,sBACA,sBACA,0BACA,CAEA,sBACA,cACA,gBACA,YACA,kDACA,mDACA,iDACA,+CACA,CAEA,sBACA,mBACA,WACA,WACA,gDAEA,gDAEA,2BAEA,2DACA,8CACA,yDACA,8BAEA,CAEA,oBACA,qBACA,qBACA,wBACA,YACA,mBACA,iBAEA,+DACA,kBACA,kBACA,gBACA,uBACA,uBACA,iCACA,IAEA,yBACA,MACA,CACA,CAEA,cACA,iBACA,eACA,8BACA,0BACA,+BACA,+BACA,qBACA,CAEA,CAEA,eACA,yBACA,OAEA,mBACA,qBACA,qBACA,wBACA,+DACA,+BACA,iBACA,mCACA,2CACA,gBACA,kBACA,WACA,sCAEA,iBACA,qCAEA,gBACA,gBACA,sBACA,iDACA,cACA,+BACQ,iDACR,sBAEA,kBAEA,yBACA,2BACA,aACA,EACA,eAGA,sBACA,UACA,SACA,CAAS,EAET,2BACA,aACA,EACA,eAQA,QALA,YACA,YACA,qBACA,MACA,MACA,IAA0B,IAAc,MACxC,kBACA,cACA,qBACA,CACA,UACA,SACA,CAAS,EACT,4BACA,EAAM,uBACN,2CACA,8DACA,6DACA,sBACA,iDACA,cACA,+BACQ,4CACR,KACA,sBAEA,kBAEA,yBACA,2BACA,aACA,EACA,mBAGA,sBACA,UACA,SACA,CAAS,EAET,2BACA,aACA,EACA,mBAQA,QALA,YACA,YACA,qBACA,MACA,MACA,IAA0B,IAAc,MACxC,kBACA,cACA,qBACA,CACA,UACA,SACA,CAAS,EACT,4BACA,CACA,CAEA,uBACA,cACA,eACA,wBACA,wBACA,gCACA,iCAEA,MACA,CACA,sBAKA,GAJA,kDACA,cACA,+BAEA,4BAGA,GAFA,kBACA,mBACA,YACA,uBACA,+BACA,MACA,CACA,2CACA,8DACA,6DACA,sBAOA,aACA,EACA,mBARA,aACA,EACA,eAUA,sBACA,UACA,UACA,4BACA,CACA,CAEA,gBACA,sBACA,kBACA,4CACA,kDACM,sBACN,sDAEA,CAEA,oBACA,wBACA,eACA,IACA,IACA,IACA,KAGA,oCAEA,gBACA,CACA,aACA,uCACA,qBACA,qBACA,CAAK,CACL,0BACA,2BACA,kCACA,YACA,gBACA,EACA,EACA,sBACA,uBACA,EACA,EACA,QACA,UAEA,qBACA,EACA,EACA,QACA,UAEA,YAAoB,gBAA4B,KAChD,+BACA,gBACA,YACA,cACA,aAEA,0CACA,sBACA,mBACA,6CACA,GACA,WACA,sBACA,YACA,EAEA,GADQ,GAAQ,oBAAmB,GAAQ,wBACnC,GAAQ,oBAChB,MAAoB,GAAQ,6BAC5B,oBAEA,QAAsB,GAAQ,8BAC9B,CAEA,eAx3BA,GACA,gBAAgC,UAChC,qBACA,aACA,4BACA,oBACA,YAAkB,WAAuB,IACzC,qBAEA,qBAAmC,OAAmB,CACtD,EA62BA,eAEA,0BACA,GAEA,uCACA,EACA,iCACA,oBACA,gCACA,eACA,sBACA,2CACA,yBACA,kCACA,sCACA,4BACA,cACI,GAAQ,yBACZ,YACA,CACA,EACA,uBACA,0BACA,0BAEA,6BAEA,aADA,wBAAkF,kDAA6D,UAC/I,+BACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EACA,mCACA,mBACA,gBACA,8BACA,QACA,MACA,WACA,SACA,cACA,cAEA,CACA,kBACA,YACA,kBACA,YACA,YACA,EACA,CAAC,OAA6B,EAC9B,OAAyB,OAAQ,eACjC,IACA,wBACI,OAAe,KACnB,CAAI,SACJ,iDACA,CACA,CAAC,MAiBD,mBAA2D,GAAW,CACtE,cACA,QACA,qBACA,uBACA,6BACA,qBACA,2BACA,2BACA,yBACA,yBACA,2BACA,uBACA,oBACA,8BACA,qBACA,mCACA,iBAAuB,OAAG,CAC1B,wBACA,CAAQ,qBAAuB,CAC/B,IAEA,8BAEA,qBACA,IAAS,GAAQ,aAAe,GAAQ,gBACxC,yCAEA,MAAuB,GAAQ,gBAAgB,GAAQ,8BAMvD,OALA,sCACA,iCACA,iBACA,uBAEA,WAEA,aAEA,GADA,eACA,uBACA,0BACA,mCACA,kCACA,4BACA,oCACA,8BACA,kCACA,6CACA,kCACA,WAYA,IAXA,6BACA,sBACA,mDACA,qFACc,GAAQ,2BAEtB,6CAEA,CAAS,CACT,CAAO,EAEP,yBADA,CAAuB,gBAEvB,wBACA,gCACA,CACA,iCACA,sCACA,kCACA,8BACA,2CACA,2CACA,4CACA,eACQ,GAAQ,YAAc,GAAQ,iBACtC,iCAEA,mCACA,CACA,UACA,gDACA,uBACA,+CACA,sBACA,CACA,UACA,wBACA,eACA,iCACA,uCACA,eACA,aACA,eACA,CACA,WACA,mBAEA,aACA,oCACA,iCACA,QACA,gCACA,4BACA,IACA,uBACA,CAAM,SACN,6CACA,MACA,CACA,qBACA,EACA,EACA,QACA,UAEA,gBACA,WACA,QACA,UAEA,WACA,0CACA,sBAEA,SADA,+BAEA,GACA,8BACA,kBACA,gCACA,2CACA,EACA,QACA,gBACA,OACA,CAAK,EACL,mCACA,qBACA,kCACA,qCACA,MACA,YACA,2FAEA,OACA,WACA,kDACA,uCACA,EAYA,gBAXA,EAYA,kCAXA,mBAQA,OAPA,mBAWA,GAVA,SACA,eACA,sBAEA,yBACA,kCACA,CAKA,EACA,GAEA,+BACA,mBACA,eACA,EACA,gBAEA,qBACA,EACA,qBACA,eAEA,EACA,iCAAqC,OAAC,cACtC,wCACA,uCACA,IACA,sBACA,cACA,cACA,iBAEA,wCACA,yDACA,sBACA,qBACA,qBACA,iBAEM,GAAQ,yBACd,cACA,CAAM,SACN,wCACA,iCAAuC,OAAC,YACxC,wCACA,mCACA,CACA,CACA,mBACA,yBACA,CAEA,iBACA,gBAAkC,UAClC,qBACA,aACA,4BACA,oBACA,YAAoB,WAAuB,IAC3C,qBAEA,qBAAqC,OAAmB,CACxD,CACA,4BACA,QACA,eACA,IAAY,GAAG,2BACf,cACA,MACA,CAAO,GAEP,MACA,8BAEA,MAEA,OADA,sBACA,EAEA,IACA,MAA0C,MAA1C,GAAkC,GAAQ,kCAC1C,aAAkB,GAAQ,wCAC1B,eACA,WAAmC,iBAA8B,EACzD,GAAQ,qBACJ,GAAQ,oBACV,GAAQ,uBAElB,CACA,CAAM,SACN,mDACA,CACA,qBACA,CACA,wBACA,QAOA,IANA,SACA,IAAY,GAAG,0BACf,cACA,MACA,CAAO,GAGP,8BAEA,IACA,OACA,8BACA,6BACA,CAAO,IACP,aACA,MAA2C,MAA3C,GAAmC,GAAQ,wBAC3C,cAAmB,GAAQ,8CAC3B,eACA,WAAiC,iBAA8B,EACzD,GAAQ,qBACJ,GAAQ,oBACV,GAAQ,uBAEhB,CAAM,SACN,mDACA,CAvw7CA,EAww7CA,mBACA,CACA,EACA,sBAEA,UACA,oBACA,sBACA,yBACA,kBACA,eACA,qBACA,kBACA,qBACA,gCACA,wBACA,0BACA,kBACA,wCACA,iBACA,sBACA,CACA,mBACA,wDACA,kDACA,0DACA,mDACA,CACA,kBACA,+DACA,qDACA,oDACA,CACA,cACA,eACA,0BACA,mBACA,CACA,yBAEA,GADA,wBACA,mGACA,mDAGA,mBACA,4BACA,EACA,EACA,kBACA,oBAEA,2BACA,EACA,EACA,qBACA,uBAEA,kBAAuB,aAAgC,EACvD,yBACA,mBACA,CACA,YACA,8DACA,uBAGA,2DACA,4BACA,EACA,EACA,kBACA,oBAEA,2BACA,EACA,EACA,qBACA,uBAEA,kBAAuB,aAAgC,EACvD,yBACA,oCACA,oBACA,yBAEA,CACA,OACA,gDACA,yBACA,wDAEA,sCAEA,CACA,OACA,mEACA,yBACA,wDAEA,sCAEA,CACA,gBACA,sBACA,kCACA,oCAEA,CACA,CACA,SAEA,eACA,sBACA,yBACA,kBACA,eACA,sBACA,uBACA,0BACA,qBACA,uBACA,2BACA,kBACA,wCACA,uBACA,oBACA,CACA,sBACA,iBACA,CACA,mBACA,wDACA,iDACA,CACA,kBACA,6BACA,0BACA,yBAEA,6BACA,kBACA,sBAEA,6DACA,6BACA,iBACA,0BAEA,CACA,gBACA,mCACA,eACA,yBAEA,mCACA,iBACA,kCAEA,CAEA,kBACA,sCACA,CACA,cACA,uCAEA,kBACA,wBACA,kBACA,mBACA,mBACA,gBACA,CACA,mCACA,SACA,EACA,0BAEA,0BAEA,CACA,mBACA,sBACA,kBAGA,GAFA,6BACA,+BACA,wCACA,MAEA,kEACA,8BACA,yBACA,UACA,iBACA,oDACA,KACA,yCASA,IARA,wBACA,EACA,EACA,eACA,IAEA,cAEA,aACA,iBACA,iBACA,iBACA,yBACA,4BACA,EACA,EACA,eACA,GAEA,QAEA,QACA,0CACA,cACA,wDACA,oBACA,wBACA,yBACA,EACA,EACA,eACA,IAEA,aAEA,CACA,EACA,SACA,SACA,SACA,QACA,CACA,0CACA,oBACA,cACA,CACA,gBACA,gBACA,CACA,eACA,sBAGA,aACA,4BACA,EACA,EACA,kBACA,oBAEA,SACA,YACA,YAAoB,WAAiB,KACrC,aACA,OACA,SACA,SACA,KACA,CAEA,YAAoB,WAAiB,MACrC,aACA,aACA,QACA,OACA,SACA,SAEA,CACA,6BACA,uCACA,CACA,CACA,SAEA,eACA,sBACA,yBACA,sBACA,uBACA,kBACA,mBACA,oBACA,yBACA,0BACA,wBACA,0BACA,0BACA,GACA,KACA,wBACA,UAGA,8BACA,0BACA,2BACA,6BACA,kBACA,wCACA,uBACA,oBACA,CACA,4BACA,uBACA,CACA,mBACA,uDACA,sDACA,uDACA,CACA,kBACA,6BACA,kBACA,+BAEA,6BACA,0BACA,yBAEA,6BACA,iBACA,2BAEA,6BACA,2BACA,gCAEA,yEACA,6BACA,gBACA,+BAEA,6BACA,kBACA,4BAEA,6BACA,mBACA,6BAEA,6BACA,sBACA,4BAEA,CACA,sBACA,mCACA,iBACA,0BAEA,CACA,cACA,yBACA,OACA,oBACA,sBACA,sBAEA,CACA,kBACA,2CAEA,oBACA,mCACA,aAMA,QALA,qCACA,WACA,kCACA,WACA,kCAGA,CACA,CACA,0BAIA,YAHA,KACA,8DAEA,eAEA,uBACA,iCACA,6BACA,oBAMA,OAHA,UACA,+BAHA,kBAGA,yBAFA,aAEA,aAEA,eAEA,gBACA,OACA,OACA,OACA,sBACA,kBACA,kBACA,UACA,UAEA,OADA,yBACA,GACA,OACA,kBACA,KACA,QACA,YACA,KACA,QACA,WAEA,CACA,IACA,CACA,OACA,QACA,QACA,OACA,CACA,CACA,uBACA,uBACA,mBAKA,OAJA,UACA,6DAEA,SACA,eAEA,YACA,cACA,UACA,UAOA,QAHA,GAHA,gDAGA,KAGA,MAFA,GAHA,gDAGA,KAEA,MADA,GAHA,gDAGA,KAOA,KAHA,OAFA,0BAGA,IAFA,0BAGA,QACA,CACA,YAAoB,WAAgB,IACpC,uDAEA,OACA,cACA,kBACA,iBACA,CACA,CACA,kBACA,wBACA,sBACA,uBACA,uBACA,oBACA,CACA,4BACA,6BACA,+BACA,iBACA,4DAQA,GAPA,qBACA,0CACA,EACA,EACA,WACA,aACA,KACA,sBACA,oBACA,gBACA,iBAEA,gDACA,aACA,cAEA,YAAsB,MAAoB,GAD1C,IAC0C,CAC1C,iBAFA,IAEA,KACA,YAAiC,IAAuB,KACxD,UACA,iBACA,4CACA,uCAEA,CACA,qCACA,CACA,EAAM,IACN,sBACA,kBACA,2CACA,OAEA,yBACA,KACA,yCACA,cACA,oDACA,kBACA,iBACA,kBACA,kDAGA,OACA,wCACA,0EACA,sEACA,gBAGA,qFACA,sEACA,gBAGA,0EACA,sEACA,gBAGA,sFACA,sEACA,gBAGA,CACA,CACA,iCACA,wCACA,mBACA,mBACA,CACA,gBACA,iBACA,mCACA,mCACA,wCAEA,CACA,kBACA,kBACA,CACA,uBACA,6BACA,mCACA,mCACA,wCAEA,CACA,iBACA,mBACA,CACA,sBACA,sBACA,CACA,mBACA,kBACA,CACA,oBACA,oBACA,CAEA,oBACA,yCACA,mCACA,mCACA,wCAEA,CACA,CACA,SACA,eACA,yBACA,yBACA,wBACA,4BACA,+BACA,iCACA,kCACA,iCACA,wBACA,uBACA,0BACA,kCACA,+BACA,+BACA,qCACA,6BACA,8BACA,kCACA,sBACA,yBACA,8BACA,8BACA,kBACA,wCACA,uBACA,qBACA,qBAA2B,GAAG,8BAC9B,oCAEA,0BAAgC,GAAG,8BACnC,yCAEA,eA74BA,GACA,IACA,MAAwB,OAAe,IACvC,MAMA,OADA,wCACA,IANA,EACA,oBAEA,OADA,0CACA,CACA,CAIA,CAJM,MAIF,GAEJ,OADA,oDACA,IACA,CACA,EA83BA,6BACA,EACA,qBAEA,oBACA,WACA,QACA,WACA,WACA,qBACA,EAEA,0BACA,CACA,kBACA,6BACA,eACA,yBAEA,6BACA,kBACA,4BAEA,6BACA,mBACA,6BAEA,6BACA,gBACA,yBAEA,6BACA,iBACA,uBAEA,6BACA,6BACA,uCAEA,+CACA,eACA,CAAK,EACL,6BACA,uBACA,iCAEA,6BACA,kBACA,kCAEA,6BACA,YACA,yBAEA,6BACA,OACA,0BAEA,6BACA,UACA,mBAEA,CACA,gBACA,mCACA,YACA,kCAEA,mCACA,eACA,qCAEA,mCACA,gBACA,sCAEA,mCACA,YACA,kCAEA,mCACA,0BACA,gDAEA,mCACA,gBACA,6BAEA,mCACA,gBACA,4BAEA,CACA,gCACA,iCACA,OAEA,kDACA,kCACA,iBACA,kBACA,yBACA,sCACA,CACA,0BAEA,CADA,mBAEA,mDACA,GAAmB,yBACnB,mDACA,sCAEA,EADA,2BACA,kBAEA,cAEA,iCACA,sBACA,yCAEA,sBACA,mBACA,oBAEA,sBACA,6BACA,mCACA,CACA,uBACA,6DACA,OAAmB,yBACnB,oDACA,8CACA,uBACA,2BACA,gBACA,eAGA,mBACA,gCACA,CAAO,EAEP,2BACA,2BACA,gBACA,mBAIA,gBACA,eAIA,+BACA,CAAO,EACP,mCACA,CACA,iBACA,OAAqB,yBACrB,gCACA,iBACA,EAEA,kBACA,kBACA,wCACA,sBACA,oBAEA,CACA,+BAcA,GAbA,2BACA,8BAEA,wBACA,uDAGA,GAFA,iCAEA,gCADA,EAEA,OAEA,QACA,2BACA,aAEA,YAAoB,IAAS,IAG7B,cAFA,mBAEA,EADA,oBACA,GAEA,sEAEA,IAQA,GAPA,KAFA,UAEA,GACA,kCACA,yBACA,EAEA,EAEA,mBACA,kBACA,4EAEA,SACA,gBAEA,CACA,eACA,oBAEA,kBAGA,oBAFA,0DAIA,CACA,sBACA,iDAEA,YACA,KAFA,gCAEA,6CAEA,uEACA,mBACA,YAAoB,KAAY,KAChC,UAGA,GAAsB,EAFtB,gBAEsB,EADtB,eACsB,EACtB,oBACA,CACA,CAEA,8BACA,mBACA,OAAqB,yBACrB,oDACA,mEACA,oBACA,wBAEA,CACA,+BACA,OAAqB,yBAErB,oDACA,0BACA,0BACA,EAJA,EAIA,gBACA,oBACA,IACA,IAEA,GADA,kCACA,sBACA,6BAEA,GADA,EAEA,IACQ,MACR,KAEA,CACA,qCACA,iCACA,WACA,EACA,SACA,IACA,yDAGA,WACA,EACA,SACA,EACA,6DAGA,2BACA,8BACA,gDACA,CAEA,sBACA,yBACA,yDACA,uDACA,6CACA,gDACA,SACA,YACA,gBACA,aACA,MACA,MACA,UACA,iDACA,+CACA,6DACA,uCACA,qCACA,QACA,oBACA,eACA,EACA,oCAGA,oBACA,oBACA,oDAEA,cACA,cACA,WACA,OACA,IACA,IACA,IACA,KAGA,4BAEA,SACA,MACA,CACA,0CACA,SACA,eACA,EACA,yBAA2C,EAAQ,WAAa,IAAY,IAAI,IAAY,IAAI,IAAY,IAAI,EAAQ,IAExH,eACA,EACA,yBAA2C,EAAQ,WAAa,IAAY,IAAI,IAAY,IAAI,IAAY,IAAI,EAAQ,QAElH,CACN,UACA,kBACA,MACA,GACA,wCAAwD,EAAQ,IAChE,wCAAgE,EAAQ,IACxE,wCAAgE,IAAY,IAC5E,6CAEA,eACA,EACA,QAAkB,IAAY,IAAI,IAAY,IAAI,IAAY,IAAI,EAAQ,IAE1E,eACA,EACA,QAAkB,IAAY,IAAI,IAAY,IAAI,IAAY,IAAI,EAAQ,IAE1E,eACA,EACA,QAAkB,IAAY,IAAI,IAAY,IAAI,IAAY,IAAI,IAAY,IAE9E,eACA,EACA,QAAkB,IAAY,IAAI,IAAY,IAAI,IAAY,OAG9D,CACA,cACA,cACA,WACA,OACA,IACA,IACA,IACA,KAGA,4BAEA,QACA,CACA,gBACA,MAAY,WAAU,CAAE,MAAQ,IAChC,cAAmB,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAM,GAE3C,oBACA,qDACA,yDACA,uDACA,cACA,cACA,kBACA,cACA,yCACA,0CACM,uBACN,6CACA,6CAEA,CACA,+BACA,SACA,MACA,YAAoB,WAAmB,KACvC,IAEA,aAFA,gBACA,gBAEA,cACA,CAEA,kBADA,aACA,GACA,YAAoB,KAAgB,KACpC,UACA,IACA,6BACA,IAEA,kBACA,sBACA,QACA,CACA,WAEA,SADA,OACA,GACA,6BACA,6BACA,QAAoB,QAAM,CAC1B,CACA,QACA,CACA,gBACA,0BACA,kDACA,CACA,mBACA,6BACA,kDACA,CACA,oBACA,8BACA,kDACA,CACA,gBACA,0BACA,kDACA,CACA,8BACA,wCACA,kDACA,CACA,CACA,SACA,iBACA,uBACA,iBACA,gCACA,mBACA,kBACA,oBACA,sBACA,qBACA,qBACA,6BACA,mCACA,mCACA,6BACA,+BACA,2BACA,8BACA,wBACA,sBACA,qBACA,qBACA,uBACA,4BACA,2BACA,iBACA,uBACA,oBACA,uBACA,mCACA,oCACA,sBACA,yBACA,2BACA,GACA,KACA,gBACA,SAGA,wBACA,8BACA,8BACA,wBACA,WACA,uCAEA,OADA,wBACA,CACA,EAAO,GACP,UACA,uCAEA,OADA,wBACA,CACA,EAAO,EACP,CAAK,EACL,2BACA,wBAEA,IAEA,CACA,wCACA,0BACA,CAAO,CAEP,OAEA,CACA,uCACA,CAAO,CAEP,SAEA,CACA,wCACA,yBACA,CAAO,CAEP,YAEA,CACA,wCACA,oDACA,0BACA,CAAO,CAEP,YAEA,CACA,wCACA,oDACA,0BACA,CACA,CAAK,EACL,mBACA,kBACA,wCACA,oBACA,oBACA,CACA,oBACA,sCAQA,OAPA,eACA,8BACA,kBACA,+BACA,qBACA,2CACA,CAAK,EACL,CACA,CACA,eACA,6BACA,qBACA,oCAEA,6BACA,oBACA,oCAEA,6BACA,YACA,4BAEA,6BACA,qBACA,+BAEA,6BACA,oCACA,8CAEA,qEACA,6BACA,cACA,uBAEA,CACA,gBACA,mCACA,aACA,0BAEA,oEACA,sEACA,wEACA,kEACA,wEACA,mCACA,iBACA,iCAEA,mCACA,qBACA,+BAEA,mCACA,eACA,6BAEA,CACA,kBACA,uBACA,4BACA,4BACA,0BACA,mCACA,wBACA,gCACA,gCACA,4BACA,CACA,iBACA,mCACA,+BACA,gCACA,+BACA,yCACA,mCACA,2BACA,yBAMA,OALA,iBACA,iBACA,iBACA,iBACA,iBACA,CACA,CACA,qBACA,mCACA,kCACA,sCACA,oBACA,sCACA,mBACA,sCACA,kBACA,mCACA,yBACA,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,kBACA,uBACA,wBACA,yBAAgD,sBAA0B,CAC1E,IACA,iBAEA,yBAA8C,sBAA0B,CACxE,IACA,gBAEA,yBAA8C,sBAA0B,CACxE,IACA,kBAEA,uBACA,yCACA,yCACA,0CACA,+BACA,8BACA,kDACA,oDACA,mDACA,qDACA,gCAGA,OAFA,kDACA,mDACA,CACA,CACA,6BAEA,SADA,iDACA,MACA,mCACA,sCACA,2CAEA,oCACA,uCACA,0CAEA,CACA,eACA,0BAAgC,OAAC,WACjC,4BACA,oCACA,CACA,wBACA,+BACA,+BACA,6BACA,mCACA,sCACA,iCACA,yBACA,4CACA,uCACA,+BACA,4CACA,uCACA,+BACA,4CACA,yBAOA,OANA,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,CACA,CACA,4BACA,+EACA,2BACA,sBACM,OAAC,+BAEP,2BACA,4BACM,OAAC,4BAEP,2BACA,yEACA,mBACA,uCACA,mCACA,6CACA,mBACA,gCACA,2BACA,gBACA,OAGA,4BACA,wDACA,qBACA,CAAK,EACL,mCACA,6CACA,mBACA,gCACA,2BACA,gBACA,QAGA,4BACA,wDACA,qBACA,CAAK,EACL,+DACA,wDACA,wBAEA,sBACA,yDAEA,iBACA,iBACA,iBACA,iBACA,wBACM,OAAC,yBACP,EACA,IACA,EACA,sDACA,QACA,uDACA,yBACA,EAEA,+BACA,wBACM,OAAC,uBACP,EACA,EACA,IACA,yDACA,QACA,4DACA,yBACA,EAEA,kCACA,wBACM,OAAC,wBACP,EACA,EACA,IACA,0DACA,QACA,6DACA,yBACA,EAEA,mCACA,wBACM,OAAC,mCACP,EACA,IACA,EACA,oEACA,QACA,2BACA,6BACA,YAEA,GAEA,kCACA,iCACA,YAAyC,OAAC,gCAC1C,gCACA,2BACA,gBACA,OAGA,8CACA,gDACA,iDACA,4DACA,wDACA,sBACA,oBACA,mBACA,mBACA,oBACA,4BACA,yBACA,CAAK,EACL,iBACA,iBACA,iBACA,+BACA,gCACA,8BACA,gDACA,iBACA,+BASA,OARA,iBACA,iBACA,2BACA,2BACA,2BACA,cACA,aAEA,CACA,CACA,kCACA,+BACA,sBACM,OAAC,sCAEP,gDACA,oBACM,OAAC,yBACP,EACA,IACA,EACA,EACA,QACA,iEACA,GAEA,uDACA,oBACM,OAAC,4BACP,EACA,IACA,EACA,EACA,QACA,wDACA,GAOA,OALA,iBACA,cACA,aAEA,2BACA,CACA,CACA,kCACA,+BACA,sBACM,OAAC,sCAEP,oDACA,wBACM,OAAC,yBACP,EACA,IACA,EACA,EACA,QACA,iEACA,GAEA,oBACM,OAAC,iCACP,EACA,IACA,EACA,IAEA,QACA,6DACA,GAEA,oBACM,OAAC,4BACP,QACA,8CACA,GAEA,oBACM,OAAC,oCACP,QACA,6CACA,GAEA,oBACA,sBACM,OAAC,sBACP,EACA,QACA,wDACA,GAEA,oBACM,OAAC,4BACP,QACA,+CACA,GAEA,oBACM,OAAC,8BACP,EACA,IACA,EACA,EACA,QACA,0DACA,GAgBA,OAdA,iBACA,cACA,aAEA,cACA,aAEA,iBACA,iBACA,iBACA,iBACA,cACA,aAEA,CACA,CACA,0BACA,eACA,2BACA,sBACA,sBACA,gBAEA,oBACA,cAEA,CAAK,CACL,CACA,kCAEA,iBADA,6CAEA,6CACA,EACA,wBAEA,sBAEA,CAAK,CACL,CACA,wBACA,+CACA,mBACA,+BACA,kDAOA,EALA,MACA,cACA,cAEA,CACA,wBACA,eACA,YAIA,4BACA,eACA,OAIA,iCACA,CACA,6BACA,yBACA,8CAEA,0BACA,+CAEA,mDACA,yDACM,oDACN,2DAEA,CACA,iCAEA,6EACA,2BACA,sBACM,OAAC,uBAEP,2BACA,mBACA,uCACA,kDACA,0DACA,2BACA,CAAK,EACL,iDACA,yDACA,0BACA,CAAK,EACL,4CACA,2CACA,4BACA,8CACA,2BACA,mBACA,uCACA,sCACA,kCACA,aACA,gBACA,qCAEA,gCACA,iBAGA,wDAFA,iCAIA,CAAK,EACL,IArCA,QAqCA,gCACA,gBACA,6CAEA,mTACA,iBACA,iBACA,sCACA,0BACA,gCACA,yBAEA,2BACA,uCACA,yBACA,4BAEA,6FACA,uCACA,mBAHA,6BAIA,YACA,sCACA,WACA,cACA,iBACA,uBACA,eAEA,CAAK,EACL,gCACA,qBACA,qBACA,sBACA,CAAK,EACL,iBACA,wBACM,OAAC,4BACP,EACA,EACA,IACA,kBACA,QACA,gCACA,wDACA,qBACA,aAEA,YAEA,EAEA,iCACA,+CACA,2BACA,mBACA,uCACA,sCACA,kCACA,qDACA,aACA,gCACA,iBAGA,iCAFA,gCAIA,CAAK,EACL,oCACA,gBACA,6CAEA;AACA;AACA;AACA;AACA;AACA,MACA,iBACA,iBACA,qCACA,2BACA,oDACA,2BACA,mBACA,uCACA,sCACA,kCACA,gBACA,qCAEA,aACA,gCACA,iBAGA,iCAFA,gCAIA,CAAK,EACL,oCACA,gBACA,6CAEA,oCAqBA,OApBA,2CACA,OAA4I,MAA5I,GAA6D,MAA7D,GAA6D,MAA7D,GAAqD,GAAQ,8CAAuE,GAAQ,2DAC5I,oBACA,iBACA,iBACA,iBACA,iBACA,cACA,aAEA,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,kCACA,iCACA,CACA,CAEA,qBACA,sCACA,CACA,kBACA,mCAGA,OAFA,6CACA,cACA,CACA,CACA,mBACA,oCAMA,OALA,EACA,uDAEA,oDAEA,CACA,CACA,wBACA,qCAGA,OAFA,gDACA,cACA,CACA,CACA,0BACA,+BACA,+BACA,kCAYA,OAXA,kDACA,+BACA,gCACA,gCACA,iCACA,kCACA,+BACA,mBACA,CAAK,EACL,iBACA,iBACA,CAAa,qBACb,CACA,kBACA,+BACA,+BACA,kCACA,uDACA,sCACA,kCACA,sDACA,gCACA,qBACA,CAAK,EACL,6EACA,gCAOA,OANA,oDACA,mBACA,iBACA,iBACA,iBACA,iBACA,CACA,CACA,sBACA,6FACA,+BACA,+BACA,mCAcA,OAbA,mBACA,gDACA,cACA,sCACA,WACA,cACA,gBACA,CAAK,EACL,gCACA,mBACA,CAAK,EACL,iBACA,iBACA,CACA,CACA,kBACA,oCAEA,OADA,iDACA,CACA,CAEA,qBACA,uFACA,2FACA,mCACA,0BACA,mCACA,wCACA,kCACA,+BACA,sBACA,iBACA,mCACA,4CACA,mCACA,oCACA,mBACA,sXACA,gCACA,kCACA,CAAK,EACL,mCACA,oCACA,mBACA,2YACA,gCACA,kCACA,CAAK,EACL,sCACA,sCACA,mBACA,YAAsC,OAAC,sBACvC,gCACA,oCACA,CAAK,EACL,sCACA,qCACA,mBACA,YAAqC,OAAC,qBACtC,gCACA,uBACA,EACA,EACA,sBACA,wBAEA,sEACA,uCACA,CAAK,EACL,sCACA,oCACA,mBACA,YAAoC,OAAC,WACrC,kBACA,gCACA,sBACA,CAAK,EACL,uCAeA,OAdA,qCACA,mBACA,YAAsC,OAAC,aACvC,gCACA,yBACA,CAAK,EACL,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,CACA,CACA,aAEA,aADA,wCACA,mBACA,kCACA,6DAEA,yDACA,4CACA,kDACA,mDAGA,wCACA,oBACA,+CACA,GACA,uBAEA,iCACA,yCACA,GACA,8BAEA,CACA,kBACA,IA2BA,EAGA,EAIA,EAlCA,+BACA,6BACA,iBACA,4FACA,sBACA,UACA,6DACA,6CACA,iCAEA,UACA,6CACA,yCAEA,gDACA,+CACA,uDACA,6DACA,iBACA,CAAO,EACP,oCACA,iDACA,8CACA,6CACA,EAsBA,OArBA,cAGA,CADA,iCACA,mDACA,mBAEA,CADA,kCACA,kCACA,mBACA,oBAEA,CADA,kCACA,wCACA,gBACA,0BACA,iBACA,iBACA,gCACA,uCACA,CAAO,EACP,iBAGA,CACA,CACA,oBACA,oCAgCA,OA/BA,8BACA,mBACA,qCACA,2CACA,CAAK,EACL,qCACA,2CACA,CAAK,EACL,mCACA,yCACA,CAAK,EACL,uCACA,6BACA,gCACA,CAAK,EACL,oCACA,gDACA,CAAK,EACL,mCACA,+CACA,CAAK,EACL,kCACA,8CACA,CAAK,EACL,mBACA,QACA,0CAEA,4CACA,mBACA,CAAK,EACL,CACA,CACA,wBACA,iDACA,0CACA,yCAGA,EADA,aADA,6CAEA,IACA,wCAIA,OAAa,EAFb,IAEa,EAHb,eAEA,CACa,CACb,CACA,kBACA,mDACA,kBACA,CAAK,EACL,kDACA,kBACA,CAAK,EACL,oDACA,kBACA,CAAK,EACL,kDACA,WACA,kBAEA,CAAK,CACL,CACA,oBACA,mCACA,gDACA,wBACA,oCAKA,OAJA,uCACA,iBACA,aACA,4BACA,CACA,CACA,uBACA,kBAcA,EAbA,qBAAgD,sBAA0B,EAC1E,eACA,kBACA,iBACA,4DACA,8DACA,iCAA4C,GAAQ,8CAAuE,GAAQ,sDACnI,MACA,YACA,8DAGA,sDAGA,EADA,UAAe,GAAQ,wDAAsE,GAAQ,4BAA2C,GAAQ,yBAA2B,GAAQ,kCAAiC,GAAQ,gBAAgB,GAAQ,yCAC5P,QACQ,GAAQ,gBAAgB,GAAQ,+BACxC,6BAEA,OAEA,kBAviIA,IAIA,GAHA,aACA,IAKA,UADA,WADA,iBACA,mBAEA,EAgiIA,MACA,OACA,GACA,qDAAgH,sBAA6C,IAC7J,wCAAmG,gBAAuC,QAC1I,EACA,+BACA,iCACA,iCACA,kCACA,8BACA,+BAWA,GAVA,gBACA,iCACA,oCACA,qBACA,qCACA,eACA,mBACA,YACA,kBACA,CAAK,EACL,cACA,2BACA,4BACA,mCACA,QACA,eACA,mBACA,YACA,kBACA,EAEA,CACA,yBACA,2BACA,yBACA,2BACA,qCAA2C,iBAAiB,GAAG,kBAAkB,EACjF,2DACA,uEACA,CACA,8BACA,6BACA,+BACA,8BACA,gCACA,6BACA,+BACA,sCAAmD,sBAA0B,EAC7E,mCACA,qBACA,CAAK,EACL,kCACA,qBACA,CAAK,EACL,oCACA,GACA,YACA,EACA,EACA,EACA,QACA,UAGA,wBACA,EACA,gBACA,EACA,0BAEA,CACA,4BACA,oCACA,qBACA,EACA,EACA,QACA,UAEA,YAAoB,gBAA0B,MAC9C,iBACA,eACA,gBACA,gBACA,iBACA,CACA,yCACA,qBACA,CACA,wBACA,+BACA,mDACA,mDACA,+BACA,+BAAoC,IAAY,IAAI,IAAY,IAAI,IAAY,GAChF,2BACA,gCACA,EACA,EACA,sBACA,wBAEA,YAAoB,gBAA0B,KAC9C,cACA,gBACA,gBAEA,gCACA,CACA,2BACA,gCACA,CACA,0BACA,WACA,EAEA,CACA,uBACA,0BAGA,CACA,kBACA,4DACA,CACA,aACA,2BACA,eACA,qBACA,IACA,EACA,sBACA,IACA,EACA,aACK,CACL,CACA,2BACA,mDACA,6CACA,iDACA,6CACA,UACA,UACA,aACA,aACA,mBAOA,GANA,0CACA,yCACA,qBACA,sBACA,wBACA,uBACA,OACA,kEACA,MACA,CAEA;AACA;AACA;AACA;AACA,8BAA8B,EAL9B,MAK0C,IAAI,MAAe;AAC7D;AACA;AACA,MAEA,mBACA,0BAEA,kBACA,wCACA,CACA,2BACA,6BACA,CAAe,aAEf,8BAGA,gCAFA,CAAe,mBAKf,CAAa,YACb,CACA,yBACA,gCACA,oCACA,CACA,4BACA,6BACA,+CAEA,8CAEA,CACA,gBACA,uBAEA,eACA,sBAEA,eACA,sBAEA,WACA,kBAEA,mBACA,kCACA,CACA,wBACA,2BACA,CACA,qBACA,2BACA,CACA,2BACA,EACA,2EAEA,oCAEA,CACA,mBACA,EACA,yCAEA,oCAEA,CACA,sBACA,kCACA,CACA,qCACA,wDACA,CACA,qBACA,kDACA,oBACA,2EACA,yBACM,mBACN,2EACA,0BAEA,qCACA,yBAEA,0BACA,0CACA,CACA,eACA,6BACA,CACA,qBACA,mCACA,CACA,CACA,SAEA,eACA,sBACA,yBACA,+BACA,GACA,KACA,cACA,OAGA,+BACA,kBACA,wCACA,oBACA,oBACA,CACA,eACA,iDACA,eACA,CAAK,EACL,qDACA,yBACA,CAAK,EACL,qDACA,yBACA,CAAK,EACL,mDACA,uBACA,CAAK,EACL,+CACA,wBACA,CAAK,CACL,CACA,sBACA,mCACA,cACA,+BAEA,CAEA,WACA,mBACA,kBACA,4CAEA,CACA,iBACA,uBACA,CACA,2BAEA,GADA,mBACA,wBACA,wDACA,oCACA,yCACA,oDACA,MACA,CACA,gDACA,0CACA,wCACA,MACA,CACA,4DACA,qCAGA,mDACA,OAAuB,yBACvB,gCACA,iBACA,GAEA,gDACA,wCACA,MACA,CACA,mDACA,OAAuB,yBACvB,gCACA,iBACA,GAEA,gDACA,MACA,CACA,2BACA,yBACA,qDACA,MACA,CACA,OACA,MACA,SACA,WAEA,UACA,kBAEA,2CACA,0CAGA,CACA,2BAEA,GADA,mBACA,8BACA,OAA6B,yBAC7B,4CACA,wDAEA,GADA,iDACA,4CACA,wCAWA,GARA,CACA,MACA,SACA,WAEA,UACA,mBAGA,uHACA,gDAGA,0CACA,qCAGA,CACA,mBACA,2CACA,0BACA,2CACA,yBACA,wCACA,yBACA,CACA,oBACA,qCACA,OAA6B,yBAC7B,2CACA,CACA,CACA,SACA,eACA,sBACA,yBACA,gCACA,8BACA,6BACA,mCACA,6BAAiD,QAAY,EAC7D,0BAA8C,QAAY,EAC1D,wBACA,mCACA,sBAA0C,QAAY,EACtD,+BACA,sBAA0C,QAAY,EACtD,gCACA,2BACA,0BACA,4BACA,sBACA,4BACA,6BACA,uBAA2C,QAAY,EACvD,+BACA,kBACA,wCACA,oBACA,oBACA,CACA,eACA,6BACA,cACA,UACA,6CACA,GAEA,kDACA,sBACA,CAAK,EACL,iDACA,qBACA,CAAK,EACL,8CACA,YACA,CAAK,EACL,qDACA,4BACA,CAAK,EACL,qDACA,uBACA,uCACA,CAAK,EACL,mDACA,0BACA,gDACA,wCACA,CACA,CAAK,EACL,6BACA,mBACA,UACA,wBACA,GAEA,6BACA,kBACA,UACA,uBACA,GAEA,6BACA,iBACA,UACA,sBACA,GAEA,mDACA,gCACA,4BACA,CAAK,CACL,CACA,gBACA,mCACA,cACA,2BAEA,yEACA,wEACA,CACA,oBAEA,GADA,oBACA,iCAEA,GADA,oDACA,sBACA,2BAEA,KADA,sBACA,sBACA,uBACA,4BACQ,CACR,wBACA,uBACA,4DACA,sCACA,yBACA,CACA,EAAM,0BACN,sBACA,uBACA,uBACA,CAEA,CACA,yBAEA,GADA,oBACA,iCAEA,GADA,wBACA,2CACA,uCACA,+BACA,kBACA,yBACA,GACA,gCAEA,sBACA,mCACA,2BACA,mCACA,+BACA,qBACA,oBACA,CACA,wBACA,8DAEA,8CACA,aACA,YACA,KACA,0BACA,yBACA,yBACA,6BACA,wBACA,EAAM,0BACN,uCAEA,CACA,kBACA,mBACA,mBACA,EACA,qBACA,YACA,cAGA,uBACA,wBAAiC,SAEjC,CACA,oBACA,gCACA,4BACA,yBACA,CACA,oBACA,OACA,gCACA,+BACA,CACA,CACA,8BACA,+BACA,qBAA8B,yBAC9B,MACA,CACA,sCACA,iCACA,sBACA,qBACA,+BACA,qBAA4B,wBAC5B,CACA,wBACA,4BACA,wBACA,kBAAyB,QACzB,CAEA,kBACA,kCACA,CACA,cACA,OAA0B,yBAC1B,kBACA,mBACA,0BACA,GACA,gCAEA,sBACA,8CACA,4BACA,aACA,YACA,iBACA,SACA,0BACA,yBACA,+BAEA,QADA,YACA,oBACA,6BACA,4CAAiD,kBAA4B,IAC7E,6BACA,2BACA,gDACA,CAAK,CACL,CACA,6BACA,sBACA,GAAuB,oBAIvB,+BAHA,IACA,GAGA,gCAFA,GAGA,qBACA,sBACA,gBACA,qCAGA,GAAwB,EAVxB,GAUwB,EATxB,EASwB,CACxB,KAGA,OAFA,EACA,CACA,IAbA,GAiBA,OAFA,EACA,CACA,IAlBA,GAoBA,wBACA,MAEA,eADA,MACA,KACA,mBAEA,iBADA,UAEA,kCACA,kCACA,yBAEA,2BACA,cACA,GAAW,eAHX,aAGmD,IAEnD,KACA,wBAEA,EACA,yBACA,4BACA,CACA,mCAIA,mBACA,oBAJA,IACA,GAIA,iBAHA,GAIA,YACA,aACA,mBACA,IACA,IACA,GAAuB,EAVvB,GAUuB,EATvB,EASuB,CACvB,KAGA,OADA,GADA,MACA,EACA,IAbA,GAiBA,OADA,GADA,MACA,EACA,IAlBA,GAoBA,mBACA,eAEA,sBACA,uBACA,8BACA,kBACA,yBACA,8BACA,CACA,0BACA,UACA,mIACA,yDAGA,uCACA,oCACA,sHACA,uBACA,0CACA,SAAgB,EAAU,IAC1B,UAAiB,EAAW,IAC5B,QAAe,kBAAkB,IACjC,OAAc,kBAAkB,IAC3B,EACL,0DACA,iBACA,uFACA,sCACA,yCAEA,8BAAsC,EAAU,IAChD,+BAAuC,EAAW,KAElD,CACA,kBACA,0CACA,YACA,YACK,EACL,qBAA4B,yBAC5B,2CACA,gCAGA,iBACA,oEACA,sCACA,kCACA,sBACA,qBACA,kBAAwB,SACxB,wBACA,CACA,CACA,SACA,cACA,uBAA0C,EAC1C,uBAA0C,EAC1C,wBACA,CAEA,oBACA,iCACA,wCACA,kCACA,6CACA,kCACA,gCACA,2CACA,wCACA,6BACA,0CACA,kCACA,gCACA,6BACA,6BACA,6BACA,oCACA,kCACA,kCACA,sCACA,2CACA,uCACA,qCACA,6CACA,gDACA,qCACA,yCACA,wCACA,sCACA,oCACA,gCACA,uCACA,oCACA,oCACA,kCACA,8BACA,4CACA,2CACA,0DACA,yCACA,wCACA,uCACA,wCACA,gDACA,uCACA,qCACA,iDACA,uCACA,sCACA,wCACA,yCACA,mDACA,oCACA,kCACA,+BACA,oCACA,mCACA,4CACA,sCACA,CAOA,mBACA,uCACA,mCAEA,uBASA,eACA,wCACA,sBAAgC,EAAU,oBAE1C,0BACA,CAQA,iBACA,wCACA,oCAEA,mCACA,OACA,8BAEA,CAOA,gBACA,wCACA,sBAAgC,EAAU,oBAE1C,+BACA,OACA,CAAK,CACL,CASA,qBACA,uCACA,mCAEA,qBACA,CAOA,gBACA,wCACA,oCAEA,yBACA,IAEA,OADA,UAEA,CAAM,SAEN,MADA,gDAAsD,EAAU,OAChE,CACA,CACA,CAQA,iBACA,0BACA,CACA,CACA,SACA,eACA,uBACA,sBACA,yBACA,4DACA,wDACA,oDACA,kBACA,wCACA,oBACA,CACA,gBACA,mCACA,eACA,sCAEA,CACA,eACA,6DACA,yDACA,mDACA,CACA,kBACA,gEACA,4DACA,sDACA,CACA,YACA,iBAEA,iBAIA,GAHA,+BACA,0BAEA,mCACA,yBACA,0CACA,mCACQ,qBACR,kCAEA,CACA,CACA,eACA,gDACA,CACA,aACA,gCACA,CACA,CACA,cAIA,GAHuB,GAAG,8BAC1B,iCAEA,CACA,sBACA,6CACA,QAEA,EAAI,IACJ,sBACA,6CACA,QAEA,CACA,CACA,cACA,mBACuB,GAAG,8BAC1B,iCAGA,yEAEA,wEAEA,CACA,WACA,GAAY,GAAQ,YAAc,GAAQ,iBAAmB,GAAQ,0BAErE,GAAG,oBACH,wBACA,UACA,CACA,mCACA,qCACA,2BACA,kDACA,eACA,gBACA,eACA,CAAK,CACL,CACA,2CACA,yDACA,yCACA,qHACA,gBACA,cACA,OACA,OACA,MACA,OACA,CAAO,CACP,eACA,oBACA,CAAK,CACL,CACA,sCACA,6DACA,8CACA,mHACA,eACA,gBACA,eACA,EACA,CACA,UACA,CACA,qCACA,oBACA,2CACA,cACA,MACA,MAA8B,GAAG,uBACjC,wCACA,2BACA,qEAEQ,GAAQ,oBACR,GAAQ,yBAChB,KACA,CACA,CAAK,CACL,CACA,yCACA,yBACA,0CACA,mBAA+C,GAAO,kBACtD,CAAK,CACL,CACA,yCACA,0BACA,0CACA,mBAA+C,GAAO,kBACtD,EACA,CACA,OACI,GAAQ,oBACR,GAAQ,0BACZ,iBACA,aACA,GACA,GAEA,CACA,CAAC,EACD,iBACA,gBACA,uBACA,aACA,2BAEA,IADA,sCAEA,4BACA,+BACA,EACA,kBACA,QACA,KACA,cACA,IACA,eACA,MACA,KAEA,uCAEA,CAAM,SACN,gCAAsC,KAAa,YAEnD,MACA,kCAEA,kDAEA,CAEA,eAAW,EACX,EAEA,qBADA,KACA,SACA,WACA,UACA,IACA,gCAA8B,KAAQ,8DACtC,MAAkC,GAAQ,6BAC1C,sCAGA,IAD6B,GAAQ,sBACrC,OACI,GAAQ,8BACZ,2BAEM,GAAQ,mBADd,MACc,QACd,CAAK,CACL,CAAI,SACJ,6CACA,CACA,EACA,0BACA,eACA,SACA,iBACA,WACA,CAAC,EACD,OACA,uCACA,QAeA,OAdA,gBACA,kBACA,kCACA,YACA,EACA,EACA,EACA,QACA,SACA,EACA,EACA,QACA,UAEA,OAEA,OACA,yBAAwC,sBAA0B,EAClE,0DACA,QACA,EACA,OACA,kBAAU,WAAuB,EACjC,YAEA,OADA,mBACA,KACA,EACA,IAEA,IAEA;AACA;AACA;AACA;AACA,IAEA,OAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAEA,YAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAEA,YAEA;AACA;AACA;AACA;AACA,IAEA,SAEA;AACA;AACA;AACA;AACA;AACA,KAEA,QACA,WACA,sBACA,aACA,CAAC,CACD,OACA,MAA8B,GAAG,QACjC,+CAA2D,GAAG,yBAA2B,GAAG,iBAE5F,YAGA,OAFA,QACA,OAGA,6BAEA,YADA,yBAAkF,kDAA6D,UAC/I,+BAEA,6BACA,kBAA8B,GAAW,CACzC,cACA,QACA,qBACA,qBACA,yBACA,oBACA,uBACA,qBACA,gBACA,CAAK,EACL,qDACA,oBACA,wBACA,wBACA,kCAAwC,yDACxC,iBAAuB,OAAG,UAC1B,YACA,eACA,YACA,OAAe,eAAiB,CAChC,qBACA,6BACA,CAAK,CACL,CACA,gBACA,4BAsBA,OArBA,yBACA,kBACA,iCACA,YACA,EACA,UACM,OAAG,WACT,cACA,qBACA,4BACA,CAAO,GAEP,UACM,OAAG,WACT,cACA,qBACA,aACA,wBACA,CACA,CAAO,GAEP,CACA,CACA,aACA,SACA,QAAsB,GAAG,iBACzB,kBACA,IACA,gBACA,CAAQ,SACR,MACM,gBACN,yCAEA,aAEA,cACA,8CACA,IACA,MAAY,GAAG,qBAAkC,aAAkB,CACnE,CAAM,SACN,iBACM,OAAa,sBACnB,CACA,CACA,kBACA,oCACA,0DACA,oBACA,oBACA,2BACA,+BACA,yBACA,kDACA,sBAGA,mBACA,CACA,EACA,qBACA,CAEA,4BACA,YACA,CACA,YACA,uCACM,OAAa,YAAY,OAAC,uCAIhC,gBADA,gBAAkC,yBAA2B,SAC7D,EAAqC,wBAA0B,EAC/D,yBACA,EAAc,OAAG,MACjB,OACA,+BACA,OAAe,eAAiB,CAChC,qBACK,EACL,UACA,sBACA,WACA,6BACA,CAAK,GACL,CACA,OACA,WACM,OAAG,CACT,MACA,EAAU,CACV,+BACA,MACA,OACY,OAAG,CACf,MACA,CACA,SAA2B,gBAAkB,CAC7C,+BACA,OACA,eACA,+BACA,gCACA,UACA,sCACA,CAAiB,CAEjB,gBACA,+BACA,oCACA,iDACA,oCACA,8CACA,CAAiB,CAEjB,cACA,2BACA,sDACA,6CACA,qEACA,mCACA,0BACA,sBACA,EACA,EACA,+BAGA,yBACA,CAAmB,EACnB,YACA,CAAiB,CAEjB,eAEA,GADA,mBACA,uCACA,6CACA,4BACA,wCACA,eACA,6BAGA,wCACA,eACA,gBAGA,CACA,CAAe,CACf,CACgB,OAAG,CACnB,QACA,CACA,qBACA,OACA,aACA,CAAqB,CAErB,gBACA,6BACA,6CACA,CACA,CAAmB,CACnB,CACoB,OAAG,UACvB,aACA,SAAiC,YAAe,CAChD,OACA,sCACA,uBACA,CAAuB,CAEvB,aACA,iCACA,eACA,0BACA,6DACA,aACA,0CACA,gCACA,yCACA,iCACA,+CACA,CAAyB,IACzB,CAAuB,CAEvB,eACA,eACA,iCACA,gCACA,+CACA,CAAuB,CACvB,QACA,CAAqB,EACrB,EAEgB,OAAG,SAAU,EACX,OAAG,WACrB,qBACA,OACA,gBACA,mBACA,CAAqB,CACrB,aAEA,gBADA,gBAAoD,cAAiB,SACrE,EACA,uBACA,CAAuB,EACvB,yBACA,EAAgC,OAAG,MACnC,OAEA,mCACA,OAAiC,eAAiB,CAClD,qBACuB,EACvB,UACA,sBACA,WACA,6BACA,CAAuB,GACvB,CACA,CAAmB,EACD,OAAG,WACrB,qBACA,OACA,gBACA,YACA,mBACA,CAAqB,CAErB,YACA,qCACA,4BACA,uCACA,aACA,WACA,sBACA,kEACA,yBACA,CAAyB,CACzB,CAAuB,GACvB,CACA,CAAmB,EACnB,EACA,EAEA,CACS,GAGT,CACA,CACA,GAAG,oBACH,KA5RA,sBA6RA,QACA,aACA,YACA,uDACA,WACA,mDACA,EACA,EAAiB,GAAY,gCACzB,GAAY,2CAChB,8BACA,aACA,QACA,oCACA,sBAA+B,GAAG,0BAA4B,SAE9D,mBACA,YAA6B,OAAgB,WAC7C,MAAmB,OAAC,iCACpB,QAAqB,OAAC,4BACtB,eACA,CAAW,EACX,2BACA,OACY,GAAG,0BACf,wDACA,gBACA,kBAAwC,GAAG,wBAC3C,YAA4B,WAAoB,KAChD,MAA2B,GAAG,yBAC9B,wCACA,qBACA,MAKA,GAJA,aACA,cACA,kBAEA,8CACA,wBACA,sBACA,CACA,CACA,kBACA,OACA,sBACA,CAAa,EACb,SACA,CAAW,CACX,CACA,CAAO,EACP,yBACA,EACA,eACA,cACA,YACA,wBACA,8CAA4E,EAC5E,YAGA,yDACgB,GAAG,8BAHH,OAAoB,QAAU,GAAG,QAKjD,CAAa,CACb,CACA,IAYA,OAVA,aACA,iBACA,qBACA,CAAO,EACP,QACA,yBACA,SACA,SACA,CACA,CAAO,EACP,CACA,CACA,CACA,CAAC,EACD,6BAEA,aADA,wBAAkF,kDAA6D,UAC/I,+BACA,GAAG,oBACH,sBACA,sBACA,gBAA2B,GAAU,CACrC,eACA,SACA,gBAAuC,GAAY,2BACnD,kBAAyC,GAAY,6BACrD,qBAA4C,GAAY,gCACxD,yBACA,iBACA,kBAA8B,UAEtB,GAAY,QACpB,KACA,OACA,WAAuB,0CAAgD,EAC7D,GAAG,EAEb,0BACA,qBACA,CACA,CACA,iBACA,oBACA,mBACI,GAAS,kBACb,OACA,iBACA,WAAoB,GAAS,cAC7B,aACA,cACA,CAAO,GAEP,kBACA,iBAAmC,GAAU,CAC7C,eACA,SACA,gBAAuC,GAAY,2BACnD,kBAAyC,GAAY,6BACrD,qBAA4C,GAAY,gCACxD,iBACA,kBAA8B,UAEtB,GAAY,UACpB,KACA,OACA,WAAuB,6BAA+B,EAC5C,GAAG,EAEb,0BACA,qBACA,CACA,CACA,8BACI,GAAS,oCACb,kBACA,CACA,CAAC,EACD,OAAmB,sBACnB,wBACA,iCACA,0BACA,gCACA,qCACA,oBACA,MAAgC,GAAY,QAC5C,KACA,UACA,WAAuB,aAAiB,EAC9B,GAAG,EACb,OACA,sBACA,cACA,EACA,6BACA,mCACA,KACA,4BACA,iEACA,IACA,mBAEA,CACA,CACA,CACA,CAAC,EACD,6BAEA,aADA,wBAA8E,kDAA6D,UAC3I,+BACA,GAAG,oBACH,yBACA,uBACA,sBAAqD,GAAU,CAC/D,eACA,SACA,iBACA,qBAEA,mDACA,8BACA,sBACA,0DACA,uCACA,2BACA,yBAAqC,GAAS,oBAC9C,CAAW,CACX,EACA,uCACA,QAwFA,EACA,EAxFA,6BACA,UAAoC,GAAS,SAC7C,QAEA,wEAEA,QACA,SACA,YAA8B,iCAAsC,KACpE,+BACA,mBACA,SACA,CACA,eAEA,EADA,+BACA,8BAEA,CAEA,WACA,KACA,OACA,OACA,SACA,aACA,uBACA,aACA,uBACA,aACA,uCAEA,eADA,mBAEA,UACA,iCACA,QAEA,QAEgB,CAChB,IACA,2DACA,KACA,CACA,EAAc,IACd,OACA,KACA,CACA,CACA,aACA,OACA,gBAEA,MAEA,CAHA,YAGA,mCAEA,YACA,gBACA,uBACA,eACA,uCAEA,eADA,mBAEA,UACA,cACkB,CAClB,MAEA,UACA,wCACA,6BAEA,6BACA,IAEA,IACA,CAAmB,GAAS,wBAC5B,iCAEA,GAEA,CACA,CAEA,CACA,gBACA,EAAwB,GAAY,qBAGpC,eAKA,aAJA,yBACA,iBACA,mDACA,2BACA,yBACA,uBACA,MAEA,GADA,UACA,4BAEA,eADA,iCACA,gCACA,4BACA,YACA,IACA,WACA,QAEA,YACA,KACA,EACA,CACA,iBACA,kBAEA,CACA,CACA,CAEA,eACA,MACA,oBAAwC,cACxC,gBAEA,KACA,EACA,GAEA,qBAGA,MACA,qCACA,IACA,WAEA,CACA,EACA,sBACA,oCAIA,OAHA,kBACA,uDACA,2BACA,CACA,EACA,qBACA,CAEA,yBAwBA,OAvBA,UACA,CACA,+DACA,cACA,+DACA,+BACA,6DAEA,wBAEA,iCACA,6BACA,CACA,CAAW,CACX,CACA,+DACA,cACA,2BACA,qBAEA,CACA,GAEA,GAEA,cACA,OACA,2EACA,GACY,GAAS,mDACrB,GACA,GACA,CAGA,mCACA,sBACA,EACA,2DAEA,2DAGA,EACA,iBACA,6BACA,EACA,yBACA,uDAEI,GAAS,kBACb,UACA,cANA,EAMA,CACA,WAAoB,GAAS,UAC7B,gBACA,cACA,CAAO,GAEP,kBACA,CACA,CAAC,EACD,gBACA,YACA,mBACA,WACA,YACA,UACA,kBACA,WACA,UACA,YACA,WACA,aACA,EACA,GAAG,oBACH,kCACA,mCACA,mBACA,gCACA,qCACA,QAEA,wBACA,OACA,mDAIA,OAHA,qBACiB,OAAqB,kBAEtC,CACA,CACA,EAAM,IACN,gCACA,qCACA,QAEA,wBACA,OAIA,OAHA,wDACA,qEAEA,CACA,CACA,CACA,CACA,CAAC,EACD,OAAmB,sBACnB,qBACA,iCACA,oBACA,uCAEA,CAAG,CACH,qBACA,EACA,cACA,OACA,aACA,iBACA,eACA,YACA,EACA,MAA2B,GAAmB,EAC9C,OACA,YACA,aACA,YACA,UACA,CAAS,EAET,MADQ,OAAS,MACjB,QAAiB,EACjB,CACA,GAEA,qBACA,+CACA,gBACA,6CACA,MAAU,QAAQ,GAClB,mBACA,yBACA,KACA,kCACA,iBACA,oBACA,yDACA,SACA,gCACA,WACA,UACA,8BACA,CACA,CACA,CACA,CAAC,EACD,UACA,KACA,GAAG,oBACH,gCACA,QACA,UACA,WACA,OACA,OACA,OACA,cACA,kBACA,0CACA,0CAEA,CACA,cACA,OACA,sDACA,qDACA,CACA,CACc,MAAd,GAAW,GAAG,6CACd,aACA,IACA,QACA,4BACA,OACA,OACA,2CACA,WACA,iBAEA,OACA,4CACA,EAAwB,GAAG,iBAC3B,OACA,OACY,GAAG,2BAGf,CAAO,CACP,IAEc,MAAd,GAAW,GAAG,6CACd,WACA,IACA,QAGA,GAFA,4BACA,mDACA,2CACA,yCACA,WAA6B,GAAG,WAChC,OACA,SAEA,oCACA,oCACA,YAEA,YAEA,EACc,GAAG,2DACjB,gBACgB,GAAG,wDACnB,CAAe,EACf,kBACA,CAEA,MACA,CACA,GAEA,SAAU,GAAG,6CACb,YACA,IACA,UACA,oDACA,mBACA,sBACA,qBACA,aACA,QAEA,CACA,0EACA,mBACU,GAAG,0BACb,MACU,GAAS,8BACnB,SAAiB,GAAG,+BACpB,WACA,OACA,6BACA,YACA,0BACA,yBACA,GAAsB,GAAG,qBACzB,EAAoB,GAAG,qBACX,EAAiB,GAAG,sBAChC,GAAoB,GAAG,sBAEvB,MAA2B,GAAG,mBACpB,CAAG,mBACb,aAAuB,GAAG,sBACd,GAAG,oBAEf,MAA2B,GAAG,iBAC9B,MACA,YAAsC,GAAG,qBACzC,YAAsC,GAAG,qBACzC,CACA,WACA,MACU,IAAG,kCACH,GAAG,kCACb,oBACA,oBACU,GAAG,uBACb,CACA,CAAO,CACP,GAEA,CACA,CAAC,EACD,OAAyB,GAAY,4BACrC,GAAY,wCACZ,YAIA,OADE,GAAG,0BACL,kBACA,EACA,OAAyB,GAAY,4BACrC,GAAY,wCACZ,gBAGA,yBACA,EACA,GAAG,oBACH,0BACA,uBACA,OACI,GAAS,0BACT,GAAS,uCACb,uBAA6B,GAAG,yBAChC,kCACA,uDACA,mCACA,oDACA,cACA,OACA,MACA,QACA,MACA,CAAO,CACP,eACA,aACA,mBACA,CACA,CAAK,CACL,CAAG,CACH,yBAA4B,CAC5B,wBAA2B,CAC3B,iCAEA,IADA,EACA,SACA,0CACA,gBACA,WACA,kCACA,WACA,QAAkB,GAAY,EAC9B,WACA,0CACA,CAIA,GAHA,kCACA,6CAEA,oDACA,uCACA,2BACA,MAAyB,GAAS,4BAC1B,GAAS,8BAAyC,WAEpD,GAAS,wCAEf,aAEA,CAEA,aADA,aAEA,KACA,4BACA,4BAFA,EAEA,eAEA,2BAJA,EAIA,eACA,2BALA,EAKA,SACA,KAAqB,GAAS,6BACtB,GAAS,2BAPjB,EAOiB,EAAsC,WAEjD,GAAS,2BATf,EASe,0BACf,EAAW,CAAS,yBAVpB,IAWQ,GAAS,qBAXjB,IAcA,mCACA,mBACA,CAAG,CACH,eAGA,aAFI,GAAS,2BACT,GAAS,0BACb,4BACM,GAAS,qEAEf,wCACM,GAAS,kEAEf,CACA,CAAC,EAcD,iFAyBA,eAEA,IAxBA,OACA,IACA,eACA,sBAJA,WAIA,MACA,aACA,cAEA,UATA,WASA,CACA,eACA,uCAEA,aACA,CACA,aACA,8GAEA,eACA,+BAEA,aACA,CACA,EA7BA,QA+BA,GA9BA,SACA,GA8BA,IACA,GAxCA,IACA,YAEA,OADA,SACA,CACA,EAwCA,eAwBA,eASA,OACA,MAjCA,CACA,GAgCA,EA/BA,eAAc,EAAM,GACpB,UACA,UAAc,WAAe,mBAC7B,qBAA6C,OAAa,MAE1D,OADA,YACA,CACA,EAEA,kBAAiB,EAAM,GACvB,UACA,gBACA,cACA,+CAEA,8BAAiC,EAAQ,CACzC,EAEA,cAAkB,OAAM,GACxB,oBAEA,CAAC,CAYD,WACA,OAXA,IACA,aACA,iBAEA,cAEA,OADA,YACA,EACA,EAIA,GACA,+BAA0C,OAAe,IACzD,IAAc,MAAU,EACxB,uBACA,WAAgB,aAAkB,SAClC,YACA,iBACA,YAEA,yBAEA,CACA,CAAK,EAlDL,4BAoDA,UAEA,uBACA,oBACA,YACA,gBAAmC,YAAiB,EACpD,SACA,eAA+B,cAAiB,IAEhD,eAA+B,uBAAyB,GAExD,CAAO,EAEP,eACA,eAA2B,0BAA0B,GACrD,EACA,KACA,iCACA,GAAoB,iBAAgC,WAAc,GAElE,OAAa,KACb,CACA,EACA,WACA,WACA,eACA,OACA,kBAAiB,EAAM,GACvB,UACA,gBACA,cACA,mEAEA,sCAAgD,EAAW,EAG3D,OAFA,aACA,aACA,CACA,EAEA,cAAa,EAAM,GACnB,aACA,0CAAkD,cAA8B,EAEhF,OADA,aACA,CACA,EAEA,mBAAkB,EAAM,GACxB,aACA,aACA,2CAA+C,0BAAyC,EACxF,yBAAe,SACf,EAEA,gBAAe,EAAM,GACrB,UACA,aACA,gBAEA,aACA,YACA,IACA,2BAAwC,mBAAiB,KACzD,CAAQ,SAGR,MAFA,aACA,aACA,CACA,CACA,CAEA,CAAC,EAMD,aADA,OAAwB,OAAO,kBAAkB,aAAa,aAAa,kBAAkB,mBAAmB,WAAW,mBAAmB,eAAe,qBAAqB,qBAAqB,+GAA+G,mBAAmB,6CAA6C,2BAA2B,aAAa,KAAK,SAAS,+BAA+B,cAAc,8HAA8H,KAAK,SAAS,+BAA+B,eAAe,sCAAsC,6CAA6C,KAAK,MAAM,cAAc,WAAW,+BAA+B,YAAY,YAAY,oDAAoD,MAAM,aAAa,aAAa,yCAAyC,cAAc,eAAe,OAAO,aAAa,MAAM,gBAAgB,yCAAyC,OAAO,MAAM,oBAAoB,cAAc,OAAO,aAAa,iBAAiB,kEAAkE,sBAAsB,SAAS,EAAE,eAAe,OAAO,wBAAwB,EAAE,MAAM,WAAW,aAAa,4BAA4B,gBAAgB,oBAAoB,KAAK,gCAAgC,OAAO,IAAI,MAAM,KAAK,GAAG,uBAAuB,MAAM,mBAAmB,UAAU,wEAAwE,iDAAiD,8CAA8C,sCAAsC,SAAS,mBAAmB,0BAA0B,cAAc,mBAAmB,uBAAuB,IAAI,kBAAkB,eAAe,0BAA0B,KAAK,SAAS,sCAAsC,YAAY,gBAAgB,GAAG,OAAO,OAAO,GAAG,eAAe,OAAO,kCAAkC,OAAO,sBAAsB,0BAA0B,WAAW,OAAO,kBAAkB,kBAAkB,yCAAyC,UAAU,SAAS,SAAS,kEAAkE,SAAS,8GAA8G,MAAM,wBAAwB,IAAI,aAAa,IAAI,gGAAgG,4BAA4B,gHAAgH,uCAAuC,aAAa,gCAAgC,KAAK,gCAAgC,MAAM,4BAA4B,GAAG,eAAe,cAAc,KAAK,SAAS,MAAM,0BAA0B,GAAG,eAAe,OAAO,iBAAiB,MAAM,GAAG,wBAAwB,eAAe,OAAO,IAAI,UAAU,+CAA+C,qBAAqB,0BAA0B,IAAI,UAAU,cAAc,SAAS,IAAI,iBAAiB,kKAAkK,YAAY,aAAa,uBAAuB,0BAA0B,4BAA4B,gBAAgB,oBAAoB,cAAc,OAAO,oCAAoC,IAAI,YAAY,OAAO,uCAAuC,OAAO,YAAY,qBAAqB,0BAA0B,8EAA8E,OAAO,2BAA2B,mCAAmC,iBAAiB,gFAAgF,wBAAwB,2BAA2B,iBAAiB,+FAA+F,SAAS,mBAAmB,aAAa,qBAAqB,qBAAqB,oBAAoB,0BAA0B,cAAc,OAAO,IAAI,yDAAyD,oBAAoB,iBAAiB,8DAA8D,yFAAyF,2BAA2B,kHAAkH,cAAc,gBAAgB,iCAAiC,gCAAgC,OAAO,IAAI,+FAA+F,GAAG,kCAAkC,qDAAqD,6GAA6G,yGAAyG,mCAAmC,uBAAuB,cAAc,qBAAqB,KAAK,QAAQ,kBAAkB,YAAY,UAAU,YAAY,gBAAgB,gCAAgC,IAAI,yCAAyC,OAAO,0BAA0B,eAAe,4CAA4C,IAAI,iBAAiB,OAAO,4BAA4B,iBAAiB,mBAAmB,KAAK,oBAAoB,EAAE,EAAE,IAAI,IAAI,0BACp+K,EAAsC,8BAA+B,eAAgB,EACrF,2BACA,GALA,GADA,WAMA,KACA,aACA,kBACA,eACA,wBAiWA,YACA,IACA,+CACA,CAAI,SAGJ,OAFA,SACA,2BACA,CACA,CACA,EA8DA,qCAaA,QACA,EACA,OACA,OACA,EA4CA,IA1BA,EAyBA,CAlBA,QACA,WACA,EAEA,WACA,eACA,oBAHA,OAGA,CAHA,IAGA,GAA8E,UAAe,kBAC7F,WACA,EAEA,CACA,EAIA,OAHA,2BACA,oBAAiC,qBAAiC,CAClE,CAAK,CACL,IACA,CACA,GA1DA,YAUA,OATA,oBACA,mEACA,+CACA,wCAEA,2BACA,8BAGA,CACA,EAMA,mBACA,EACA,4BACA,EAEA,CACA,kCACA,4BACA,yBACA,EAEA,CACA,YACA,SACA,OACA,CACA,GAEA,eACA,mBAEA,OADA,0BACA,gCACA,CAAG,GAyIH,GAnHA,UACA,UACA,iBAAoD,8BAA+B,eAAgB,EACnG,uBACA,IACA,UACA,EAAM,OACN,oBACA,CACA,CACA,EAyGA,SADA,OAAuB,aAAa,sCAAsC,cAAc,qGAAqG,OAAO,IAAI,iuBAAiuB,OAAO,6DAA6D,SAAS,GAAG,aAAa,6DAA6D,2BAA2B,kFAAkF,yBAAyB,wBAAwB,wDAAwD,kFAAkF,8DAA8D,8BAA8B,uDAAuD,SAAS,4CAA4C,SAAS,wBAAwB,uBAAuB,iBAAiB,EAAE,6BAA6B,uBAAuB,OAAO,sFAAsF,MAAM,EAAE,SAAS,0EAA0E,kFAAkF,IAAI,GAEh8D,GA7EA,YACA,SAA6D,IAC7D,kDACA,KACA,4BACA,iBACA,iBACA,CAAK,EACL,UACA,cACA,4BACA,eACA,iBAuDA,OAtDA,2BACA,OACA,QACA,UACA,mBACA,WACA,GACA,cACA,CAAa,EAGb,CAAO,CACP,MACA,MACA,wEACA,CACA,CAAO,CACP,QACA,QACA,UACA,kBACA,cACA,GACA,gBACA,oBAAwB,EACxB,CAAa,MAGb,CAAO,CACP,QACA,QACA,UACA,gBACA,cACA,GACA,eACA,CAAa,EAGb,CAAO,CACP,MACA,QACA,UACA,4BACA,YACA,IACA,SAAkC,cAAgB,CAClD,EAAc,OACd,GACA,CACA,CAEA,CACA,CAAK,EACL,CACA,CACA,EAjGA,GACA,EAAY,OAAe,IAC3B,IAAY,MAAU,EACtB,aACA,eACA,eACA,WAAgB,aAAkB,EAClC,YACA,iBACA,YAEA,yBAEA,CACA,CACA,EAGA,OACA,UACA,oBACA,YACA,gBAAmC,YAAiB,EACpD,eAA2B,UAAqB,GAChD,CAAO,EAiFP,GAPA,QACA,kBACA,wCAAgD,aAA0C,EAAc,kBAAkB,cAAc,EAAa,IAErJ,GAIA,YACA,UAAW,uDAEX,YACA,UAAW,kDAEX,UACA,EAAW,sCAEX,YACA,WAAW,8CAEX,mBAAwD,0BAAiC,GACzF,0BAQA,MACA,6BANA,MAGA,sBAGA,EAHA,KAWA,eACA,WACA,2BAPA,aAOA,EAPA,KAOA,4BAJA,KAIA,2DACA,EACA,gBACA,sDAVA,oBAUA,sBAPA,kBAOA,EAPA,KAOA,CACA,uBACA,4BACA,EACA,YACA,wBACA,CAQA,MALA,0BAGA,iCAIA,aAEA,2BArCA,QAGA,6BAmCA,UAEA,YAEA,mBAA4E,UAAgB,GAC5F,MACA,EAEA,mBACA,uBAEA,EAEA,mBAAuE,UAAgB,GACvF,mBAiBA,UACA,eACA,0BACA,mBACA,oBACA,CACA,oBACA,gDACA,CACA,OACA,YACA,GApDA,0BAGA,iCAiDA,CACA,0CAlDA,kCAnBA,yBAuEA,0BAEA,UAEA,4BAIA,GAHA,QACA,2DA7DA,yBA+DA,CACA,8DACA,sBACA,eA3BA,qBA4BA,+CAEA,8BArFA,yBAqFA,6BACA,gCAtFA,yBAsFA,oCACA,EAnGA,kCAmGA,wBACA,EApGA,2BAoGA,EApGA,KAoGA,kDACA,8BACA,CAIA,GAHA,YApCA,sBAqCA,oDAEA,YA9FA,kBA8FA,EA9FA,MA8FA,0BACA,oBACA,iCACA,+BACA,YACA,sBACA,OACA,YAA4B,IAAY,MACxC,WACA,uCACA,CAEA,2EACA,CACA,CACA,EAAM,IACN,mDACA,6FACA,eAhHA,kBAgHA,EAhHA,MAgHA,mBACA,SAEA,iCA/HA,OA+HA,uCA5HA,6BA4HA,iCACA,UACA,mCACQ,CACR,uBAvHA,MAuHA,2CACA,SAEA,oCACA,CACA,CACA,QACA,CACA,SACA,mDACA,QACA,wCACA,OA5EA,sBA8EA,yFAEA,wBACA,CACA,CACA,YACA,qCACA,0BAEA,mDACA,4BACA,6CACA,4BACA,eA3FA,cA2FA,EA3FA,MA2FA,qCACA,6EAEA,eAxJA,qBAwJA,qBACA,eAEA,eAxJA,0BAwJA,sDACA,yBAvGA,cAA0C,uBAA6B,IACvE,+BATA,EAUA,EAVA,EAUA,EATA,oBACA,sBACA,MACA,KAEA,gCA0GA,KAEA,4BAEA,2CACA,eAEA,eA7KA,kCA6KA,CACA,6DACA,kBACA,CACA,eA9KA,sBA8KA,EA9KA,KA8KA,CACA,6DACA,kBACA,CACA,0BAEA,CAyCA,mBACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,eACA,IACA,cACA,EAEA,EAUA,wDAAoF,iFAAiF,8GAA8G,GACnR,WACA,SACA,yBACA,cACA,gBACA,uBACA,yBAAuE,2CACvE,UAEA,EADA,8CACA,SACA,CACA,gBAAkC,OAElC,OACA,iCACA,sGAEA,EACA,OACA,KA7BA,IACA,IAEA,IADA,eAEA,CAAI,MACJ,QACA,CACA,QACA,GAqBA,GACA,8EAEA,oDACA,6EAEA,EAiGA,WACA,eACA,cACA,8DAEA,QACA,EACA,WACA,8BACA,cACA,gDAEA,gBACA,qCAEA,SAEA,OADA,YACA,CACA,EACA,eACA,cACA,8BAIA,OAHA,YACA,YAEA,CACA,EACA,MACA,SAEA,OACA,aACA,gDAEA,UACA,uBACA,EAIA,OACA,cACA,4CAEA,aACA,uBACA,EACA,WACA,CAVA,UAUA,CAVA,GAUA,wBACA,KAEA,EA0FA,OACA,IACA,yCACA,CAAI,MACJ,QACA,CACA,QACA,EACA,6CAeA,IACA,kBACA,EAgCA,gBACA,IACA,YACA,eACA,uBACA,iCAEA,QACA,UACA,YACA,cACA,EA8JA,MACA,SAEA,MACA,SAEA,WACA,iBAAU,GAAe,MAUzB,aATA,+BACA,eACA,cAEA,CAAG,GACH,oBAEA,eACA,CAzVA,SAyVA,qCA/BA,GACA,2BACA,EA6BA,qCA3BA,WA2BA,cAzBA,GACA,8BACA,EAuBA,aAtBA,GACA,4CACA,EAoBA,gDACA,CACA,WACA,aACA,sCAEA,CACA,OACA,KAEA,EAyRA,MAFA,YAGA,KAEA,eACA,eACA,SACA,KACA,QAEA,8DACA,CAGA,OADA,SACA,EACA,EACA,mBACA,qCACA,EACA,mBACA,cACA,YACA,0BAEA,yBAEA,EAIA,eACA,GAHA,WAGA,GACA,kBAEA,OADA,iBACA,QAGA,OADA,iBACA,SAEA,aACA,eACA,sBAEA,OADA,YACA,EAGA,WACA,EAIA,WAEA,IADA,MACA,UACA,mDAEA,EACA,aACA,cACA,oBAIA,OAHA,YACA,YAEA,CACA,EACA,eArCA,WAsCA,EACA,8BAEA,mBAEA,EACA,MACA,SAEA,MACA,SAEA,MACA,UAEA,MACA,WAEA,UACA,gBACA,YACA,UACM,CACN,uCACA,iBACA,4BACA,qBACA,QACA,OACA,4BACA,YACA,UACA,oCACA,aACA,gBACA,qBACA,sCACA,sCACA,MAEA,MAEA,SACA,sBACA,gBACA,2BACA,EACA,SACA,CACA,CAAG,EAEH,WACA,cACA,eACA,gBACA,eACA,yBACA,CAEA,wBACA,EACA,MACA,cA6GA,iBACA,SAnBA,aACA,iBAAU,mBAA8B,MACxC,sBACA,SAEA,CADA,WACA,QAEA,UACA,EAWA,SAOA,GANA,WACA,QACA,cACA,qBAGA,OACA,iBAAY,GAAe,MAC3B,OACA,CACA,EACA,eACA,SAvBA,WACA,iBAAU,mBAA8B,MACxC,mBACA,SAEA,CADA,SACA,QAEA,UACA,EAeA,MACA,YACA,QACA,cACA,0BAGA,CA4VA,UACA,eACA,oBACA,CACA,WACA,sBAEA,UACA,0BACA,CACA,kBACA,mDACA,CACA,OACA,uBACA,CACA,OACA,uBACA,CACA,OACA,uBACA,CACA,SACA,yBACA,CACA,CACA,QACA,eAEA,4BACA,iCACA,iBACA,kBACA,gBAAmB,CACnB,mBACA,EAiDA,uBACA,wCACA,qBACA,6BAEA,gCACI,CACJ,0BACA,uBACA,0BACM,CACN,sEACA,WACA,CACA,CACA,CACA,qBACA,mCACA,qBACA,0BAGA,qBACA,+BAGA,EACA,WACA,SACA,YAAkB,IAAO,MACzB,SACA,4BACA,YAAoB,IAAY,KAChC,8BAEA,SACA,CACA,QACA,EAMA,0BACA,4DACA,kCACA,yBACA,8CACA,cACA,kDAEA,YACA,QAdA,SACA,eAEA,YADA,MAEA,GAUA,KACA,sCACA,0BACA,kDAAqF,gCAA0C,GAAK,EACpI,YAAkB,IAAY,QAC9B,gCACA,YAAsB,mBAA4B,KAClD,YAAwB,iBAA0B,KAClD,gBAIA,4CACA,sCAA2D,EAAM,MACjE,eACA,CAAO,EAEP,YAAoB,mBAA4B,KAChD,YAAsB,OAA2B,KACjD,wBACA,gCAIA,IACA,mBACA,2BACA,GAEA,GAEA,sDACA,YACA,gBAA6D,oBAA6B,MAC1F,YAA0B,OAA2B,KACrD,mBAEA,QAGA,MACA,KAEA,CAAM,SACN,iDACA,cACA,oBACA,gBACA,iBACA,CAAO,GACP,KACA,CACA,CACA,QACA,EAmRA,aACA,WACA,cACA,UAEA,QACA,EAmKA,gDAuPA,OACA,2GACA,IACA,sCACA,CAAK,EACL,cACA,SAIA,OAFA,aACA,CAAK,EACL,EACA,CAAI,MACJ,CACA,QACA,EAyDA,aACA,gBACA,iBACA,QAEA,EACA,WACA,uBACA,2BACA,+BACA,EAUA,aACA,gBACA,uBACA,cAEA,EAaA,WACA,IAOG,QAPH,QACA,cACA,qCACA,sDAEA,eACA,CAEA,EACA,WACA,IAOG,OAPH,OACA,QACA,OACA,qDAEA,WACA,CAEA,EAsOA,eAEA,MADA,MAhBA,oBACA,UAAY,WAAe,kBAC3B,oBAAyB,EAAM,IAC/B,UACA,UACA,IACA,EACA,wBAA8B,EAAM,IACpC,UACA,UACA,IACA,EACA,cAIA,EAHA,CAAG,GAiaH,WACA,iDAGA,OAFA,QA7BA,KACA,wBACA,wCACA,UACA,QACA,SACA,UAEA,CACA,CAAG,EACH,4CACA,mBACA,QACA,kBACA,UAEA,CACA,CAAG,EACH,iDACA,mBACA,QACA,kBACA,UAEA,CACA,CAAG,EACH,EAIA,GACA,CACA,EAmBA,WACA,4BACA,kCACA,GAsFA,WACA,qBAGA,OAFA,QACA,eACA,CACA,EAkBA,cACA,+BAEA,gDA8OA,eACA,QACA,2BACA,2BAEA,QAAU,SAAW,qCACrB,2BAA4C,kBAAgD,CAC5F,EAcA,aACA,IACA,qBACA,CAAI,SACJ,cACA,QAEA,cACA,CACA,EAgCA,OACA,2BACA,IACA,WACA,CAAI,SACJ,8BACA,CACA,QACA,EAcA,OACA,2BACA,IACA,UACA,CAAI,SACJ,8BACA,CACA,QACA,EAkDA,UACA,IACA,OAAyB,eAKzB,CAJA,2BACA,gBACA,QACA,CAAK,EACL,sBACA,YAEA,uBACA,EAEA,GApjHA,kBACA,wCACA,EAmjHA,GAhyGA,kBACA,cACA,YACA,4BA6xGA,GA3xGA,kCAEA,EA0xGA,GAvtDA,WACA,+BAwtDA,IAxiDA,EAuiDA,YAtiDA,IACA,MACA,6BACA,GAqiDA,IA1yDA,OACA,QACA,eACA,cACA,SAEA,eACA,cACA,SAEA,IACA,UACA,wBAEA,OADA,WACA,yBACA,YACA,WACA,IAIA,OADA,WACA,CACA,CAAM,MAEN,OADA,YACA,EACA,CACA,CACA,EA+wDA,qBACA,GAtQA,uCAuQA,GAnjDA,IACA,YACA,qBACA,+EAEA,mBA+iDA,GAzYA,UACA,eACA,UACA,8EACA,WACA,sBACA,uBACA,oBACA,gBAEA,CAAK,iCACL,CACA,EA6XA,UACA,GAvhDA,IACA,MAshDA,GAthDA,OACA,cACA,WAEA,QACA,EAkhDA,GA/ZA,IACA,SACA,KAEA,wCACA,sBAEA,8EACA,EAuZA,IACA,IAj9CA,GACA,GACA,wBAEA,EA68CA,IACA,eACA,GA7nDA,MACA,eACA,0BACA,2BACA,CACA,wBACA,aACA,4BACA,cACA,EAonDA,GApnDA,QACA,sBACA,0BAGA,+CACA,CACA,CACA,iBACA,+CACA,CACA,2BACA,6CACA,kEACA,CACA,EAsmDA,IAvoCA,GACA,SACA,KAEA,iCACA,eAEA,gEACA,EA+nCA,IACA,GAp+CA,IACA,GACA,wBAEA,EAg+CA,IACA,IAh+CA,GACA,GACA,oEA89CA,IACA,GA59CA,IACA,GACA,sEA09CA,IACA,GAllCA,IACA,SACA,KAEA,4DACA,EA6kCA,IACA,GA/8EA,oCACA,gBACA,qBACA,SACA,gBACA,wBACA,UACA,qBACA,UAEA,CArLA,IACA,IAeA,EAfA,SACA,eACA,cACA,4BACA,WAQA,OAPA,WACA,gBAAyC,WAAe,GAExD,uCACA,cAA0C,WAAe,EAGzD,CACA,CACA,CAAG,oBACH,EAuCG,aAvCH,aACA,UAEA,GADA,WACA,WACA,eACQ,sBACR,kBACA,+BACA,cACA,YAEA,UAEA,MACQ,YACR,cACA,gBACU,CACV,eACA,eACA,0DACA,cACA,YAEA,UAEA,CACA,CAEA,iBACA,cACA,MACA,8BAEA,qBAEA,CAAS,CAET,EAEA,EA6HA,GAEA,eACA,qBACA,uBACA,SAEA,WACA,CACA,mBACA,0CAEA,oBACA,oCACA,CACA,uBACA,8CAEA,wBACA,wCACA,CACA,4BACA,mDAEA,6BACA,6CACA,CACA,cACA,qBAEA,qBACA,2CACA,CACA,sBACA,6CAGA,mBACA,iDACA,UAGA,QADA,kBAEA,cACA,UAEA,GAtWA,YAsWA,GACA,YACA,IACA,sCACA,UACA,SACA,uCAEA,0CACA,KAEA,CAAU,SACV,eACA,SAEA,QACA,CAMA,OALA,iBAGA,GADA,YACA,MAEA,CACA,CACA,YACA,8CACA,UAEA,IACA,mCACA,eACA,qCAEA,CAAQ,SACR,eACA,SAEA,QACA,CACA,CAjNA,YACA,iBAAU,mBAA8B,MACxC,SAAU,GAAU,MACpB,QACA,MACA,YACA,QACA,MACA,gBACA,aACA,UACA,cAEA,EAAM,IAEN,KAzJA,GAwJA,EAxJA,UAwJA,GAxJA,OAwJA,GACA,IACA,UACA,iBAGA,QACA,yCACA,SACA,MACA,iBAEA,iBAEA,IAGA,EAkLA,aAGA,GADA,YACA,KAEA,CACA,kBAGA,IAFA,EAEA,IADA,kBAEA,cACA,GApJA,QACA,YACA,KACA,uBACA,MACA,aAEA,aAEA,aAGA,OADA,kBACA,EACA,EAuIA,aACQ,uBACR,gCACA,UAEA,GA3IA,UACA,YACA,KACA,uBACA,WACA,MACA,aAEA,aAEA,aACA,qBAGA,SACA,EA4HA,SACA,EAAQ,IACR,+CA/ZA,YAkaA,0CAFA,UAMA,QADA,EAnIA,eACA,YACA,yGACA,MACA,aAEA,aAEA,oBACA,OAEA,EAwHA,eACA,OACA,SAEA,CACA,eAEA,GADA,YACA,EAEA,CACA,CACA,EArvCA,UACA,SACA,YAAoB,mBAAoC,KACxD,gBAEA,UACA,eACA,gBACA,0BACA,UACA,CAAK,CACL,EAujHA,CAz2GA,8BACA,kBACA,oBACA,iBAAY,mBAA8B,KAC1C,SAAY,GAAU,KACtB,OACA,MACA,WACA,OACA,MACA,kBACA,YACA,SACA,WAEA,MACA,KAEA,EAAQ,IACR,iBACA,YACA,SACA,WAEA,WACA,SACA,MACA,YAEU,CACV,cACA,aACA,gBAEA,wBACA,MACA,OAEA,CAAW,QACX,CACA,CACA,QACA,oDACA,SACA,KACA,kBAEA,kBAEA,GAGA,EACA,EAozGA,2CAjgDA,gBACA,GACA,QACA,eACA,eACA,aACA,WACA,SAAkB,GAAU,KAC5B,eACA,SAEA,IADA,QACA,eACc,CACd,cACA,oBACA,CAEA,CACA,UACA,EAAQ,IACR,YAEA,CAEA,EAy+CA,sBAlgDA,8CAkgDA,GArwDA,oBACA,QACA,eACA,cACA,iDAGA,QADA,cAEA,SAEA,IADA,YACA,UACA,WACA,SAAgB,GAAU,KAC1B,eACA,SAEA,IADA,QACA,eACY,CACZ,cACA,iBACA,CAEA,OAEA,YAEA,CACA,EA0uDA,yBA3tDA,gBACA,sBA0tDA,MA1tDA,GACA,GALA,cAKA,EACA,SAEA,YACA,UAEA,iBACA,SAEA,YAAY,GAAU,MACtB,2EACA,EA8sDA,sBACA,eACA,GA5tCA,IACA,SACA,KAEA,gCACA,cAEA,IACA,EAotCA,IACA,GA9wDA,IACA,IACA,OACA,KAEA,EAywDA,oBACA,IAtRA,OACA,IACA,8BACA,WACA,OACA,yBACA,UAEA,eACA,sBACA,WACA,mBAAyD,WAA+D,KACxH,aAGA,4BACA,WACA,OACA,yBACA,UAEA,eACA,sBACA,WACA,mBAAyD,WAA0D,KACnH,YAGA,CACA,EAyPA,OACA,GAzPA,IACA,QACA,EASA,EATA,EAQK,kBARL,kBACA,YACA,WACA,OACA,cACA,sBAEA,EAEA,EAQK,gBARL,gBACA,YACA,WACA,OACA,cACA,sBAEA,CAEA,CACA,EAoOA,IACA,GA5vGA,qBACA,WACA,eACA,eACA,YACA,mEAEA,WAAc,mCAAuC,CAAI,WACzD,WACA,qBAEA,qCAA6M,kCAAsC,wBACnP,0BACA,UASA,MAPA,sCACA,KAjCA,SACA,IAWG,iBAXH,iBACA,IACA,IACA,kBACA,CAAQ,SACR,eACA,UAEA,QACA,CACA,EAEA,EAqBA,IACQ,iBACR,KAEA,SACA,CACA,CACA,8BACA,qFACA,CACA,EACA,EAguGA,gBA5VA,GACA,KACA,YACA,SAEA,IACA,OAA0C,0BAA8B,CACxE,CAAM,MACN,QACA,CACA,QACA,CACA,EAgVA,WACA,GA/yGA,QACA,YACA,eACA,4BACA,iCACA,MACA,CAAK,EACL,oCACA,WACA,iCACA,gBACA,cACA,EACA,6BACA,EAkyGA,GA9YA,eACA,WACA,iEACA,YACA,qBACA,QACA,cAEA,CAAK,EACL,EAsYA,GApyDA,SACA,UAoyDA,GArrCA,0BACA,QACA,6BA0BA,OAzBA,QACA,uBACA,iBACA,eACA,kBACA,oBACA,eACA,CA1CA,IACA,aACA,SACA,oBACA,KACA,WAEA,gBACA,IACA,CACA,EAAG,UACH,EA+BA,GAEA,eACA,KAEA,eACA,OAEA,eACA,MAEA,eACA,OAEA,eACA,MAEA,OACA,CACA,CACA,EAupCA,MAzJA,IACA,6BACA,UACA,IACA,SACA,CAAI,MACJ,QACA,CACA,QACA,EACA,IACA,4BAEA,UADA,0BAEA,IACA,YACA,CAAI,MACJ,QACA,CACA,QACA,EACA,IACA,6BACA,UACA,IACA,QACA,CAAI,MACJ,QACA,CACA,QACA,EA2HA,GAjHA,IACA,gCACA,wBACA,YACA,UACA,SACA,IAEA,OADA,SACA,EACA,CAAI,MACJ,QACA,CACA,EAqGA,GAlFA,IACA,YACA,cACA,eACA,mCACA,gDACA,gBAEA,eAEA,CACA,CAAG,SACH,EAjKA,QACA,+BACA,kBACA,aAEA,sBACA,gBACA,mBACA,CAAK,OACL,uBAEA,EAuJA,QACA,IAEA,EAFA,iBACA,aACA,SAKG,aAJH,KACA,YACA,gCACA,GAEA,8BACA,QACA,YACA,SACA,eACA,KACA,IACA,WACA,CAAU,MACV,0BACA,MAEA,YACA,IAEA,CACA,EAAG,QACH,GA4CA,IAtaA,EArpCA,IACA,YACA,qBACA,gFAEA,mBAipCA,UACA,KACA,UACA,YAmaA,GAjoGA,KACA,kBACA,OACA,OACA,eACA,MA4nGA,GA5nGA,GACA,EAnKA,YAmKA,EA4BA,OA3BA,IAYA,OAXA,CACA,gBACA,4BACA,oCACA,8CAEA,YACA,kBACA,sBACA,oCAGA,UACA,cAEA,UACA,WAGA,WACA,EAGA,0CAFA,MAomGA,GApmGA,iCAIA,gBACA,CACA,EACA,OACA,iBACA,OACA,CAAO,CACP,gBACA,OACA,CAAO,CACP,YACA,sBACA,WACA,mBAEA,MACA,CACA,CACA,EA+kGA,IAz1EA,6BACA,wBACA,cACA,YACA,cACA,GACA,mBACA,QACA,CAAO,CACP,eACA,4BACA,CAAO,CACP,eACA,4BACA,CAAO,CACP,YACA,eACO,CACP,iBACA,cACA,6CACA,CAAO,CACP,uBACA,4CACA,UACA,+BAEA,YACA,6BACU,CACV,yBACA,WACA,+BAEA,YACA,0BACA,2BACA,oBACA,kCACA,kDACc,6BACd,6CACc,oBACd,sCACc,0BACd,uDAGA,CACA,QACA,CAAO,CACP,0BACA,UACA,+BAEA,YACA,2BACA,GAEA,kCACA,UAGA,yBAFA,mBAKA,4BAUA,OATA,UACA,WAEA,2BACA,cACA,uBAEA,cACA,oCACA,CACA,CAAO,CACP,6BACA,4BAUA,OATA,UACA,WAEA,2BACA,cACA,uBAEA,cACA,+BACA,CACA,CAAO,CACP,0BACA,UACA,+BAEA,gBACA,yBACA,GAEA,uBACA,UACA,+BAEA,cACA,sBACA,GAEA,2BACA,sDACA,4CACA,UACA,uBACA,iBACA,kBACA,MACA,sBACA,YAA0B,IAAgC,MAC1D,iCACA,gBACA,cACA,+CAEA,UACA,+BAEA,gBACA,6BACA,SACA,MACA,qBAEA,oBACA,EAAU,IACV,UACA,+BAEA,gBACA,6BAEA,QACA,CACA,EAIA,OAHA,WACA,WACA,OACA,CACA,CACA,EA33CA,QAikHA,GAhkHA,OAAiD,0DAAqH,CACtK,EA+jHA,MArsEA,GACA,EACA,UACA,eACA,sCACA,YAAkB,WAAiB,EACnC,mCACA,EAAU,qCACV,IAAkB,mBAAiB,EACnC,8BACA,EAAU,6BACV,cAAkB,2BAAkC,EACpD,wBACA,EAAU,4BACV,cAAkB,WAAmB,EACrC,qBACA,EAAU,iCACV,aAAkB,wBAA8B,EAChD,4BACA,EAAU,IACV,iDAGA,CACA,GAx7CA,GACA,aAAW,yBAEX,GACA,aAAW,iCAEX,OACA,UAAW,0CAEX,OACA,UAAW,qCAEX,SACA,EAAW,uDAwlHX,aACA,IAztGA,mBACA,gBACA,iBACA,WACA,GAA8B,YAC9B,SACA,OACA,aACA,gBACA,sCACA,2BACA,kCACA,oCACA,mBACA,2CA3BA,qBADA,sBA6BA,CACA,oBACA,wBACA,KAEA,yCAEA,cAEA,GADA,2CACA,UACA,qBACA,SAEA,qBACA,CACA,CACA,WACA,8CAEA,YACA,wCACA,CACA,cACA,iDAEA,eACA,2CACA,CACA,gBACA,mDAEA,iBACA,6CACA,CACA,cACA,oBACA,CACA,eACA,yCACA,6CACA,gDACA,iCACA,CACA,mBACA,0BAEA,iBAKA,GAJA,+CACA,4CACA,qEAEA,+BACA,SACA,WACA,iEACA,UACA,QAEA,EACA,6DACA,CACA,CACA,UACA,0CACA,4CACA,4CAEA,CACA,CACA,EAqoGA,yBACA,GA5hGA,oBACA,gBACA,iBACA,WACA,OACA,WAEA,aADA,aAEA,0CACA,kCACA,CACA,mBACA,qDAEA,oBACA,2CACA,UAEA,sDACA,SAEA,gDACA,CACA,uBACA,yDAEA,wBACA,2CACA,SAEA,oDACA,CACA,sBACA,wDAEA,CACA,EAw/FA,GAv/FA,IACA,kBACA,eACA,oBAGA,OAFA,WACA,eACA,CACA,EACA,OACA,YACA,sBACA,WACA,mBAEA,MACA,CACA,CACA,EAs+FA,MAlpCA,QACA,UACA,oBACA,sBACA,IACA,gBACA,CAAQ,MACR,CAEA,oCACA,gCAEA,uBACA,2CACA,OACA,CAAO,EAEP,WACA,eACA,oCACA,8CACA,MACA,CAAK,EAuBL,OAtBA,2CACA,YACA,IACA,gBACA,CAAQ,SACR,uBACA,OAEA,CACA,CAAK,EACL,+CACA,YACA,oBACA,CAAK,EACL,oDACA,YACA,yBACA,CAAK,EACL,2CACA,yBACA,CAAK,EACL,aACA,CACA,CACA,EAmmCA,iBACA,GA7yCA,QACA,UACA,cAmDA,OAlDA,cACA,cACA,iBACA,QAMA,OALA,gBACA,gDACA,GACA,IAEA,EAEA,cACA,oCACA,GACA,GAGA,CACA,CAAK,YACL,iBACA,UACA,eACA,cACA,WACA,eACU,sBAEV,aADA,YACA,GACA,UACA,iBASA,aALA,KACA,gBAEA,cAEA,GACA,0DACA,YAIA,iBACA,MACA,GAEA,CACA,CAAK,eACL,CACA,CACA,EAsvCA,OAEA,GA9lBA,QACA,QACA,8CAKA,OAJA,yCACA,OAEA,QACA,CACA,CACA,EAqlBA,GADA,CAjOA,OACA,QACA,iBACA,8BACA,wCACA,UACA,SACA,SACA,CACA,CAAK,EACL,4CACA,mBACA,SACA,SACA,CACA,CAAK,EACL,6BAQA,IAPA,KACA,uBACA,YAAsB,IAAY,KAClC,gBAEA,EACA,oBAEA,CACA,EAuMA,QAEA,GA5hBA,WAA2B,OAA6B,IACxD,gCACA,QACA,YACA,eACA,uBACA,iCACA,QACA,UACA,YACA,cACA,CAAK,EACL,QAA4D,YAAmC,EAC/F,6BACA,OACA,OACA,WACA,UA2gBA,GA7cA,KA6cA,GA5cA,GA9DA,CACA,iBACA,MACA,CAAO,CACP,mBACA,sBACO,CACP,wBACA,oBACA,CAAO,CACP,uBACA,yBACA,CAAO,CACP,4BACA,wBACA,CAAO,CACP,4BACA,+BACO,CACP,iCACA,6BACA,CAAO,CACP,cACA,iBACO,CACP,aACA,SACO,CACP,qBACA,wBACO,CACP,sBACA,yBACO,CACP,aACA,cACO,CACP,cACA,iBACO,CACP,mBACA,eACA,CAAO,CACP,yBACA,mCAEA,sBACA,sBAEA,4BACA,sCAEA,WACA,iBACA,CAAO,CACP,UACA,gBACA,CACA,EAIA,GAHA,iBACA,oBAGA,EA4cA,GArjBA,cACA,QACA,mCACA,cAEA,+BAUA,OATA,QACA,iBACA,eACA,MAEA,eACA,MAEA,OACA,CACA,CACA,EAoiBA,gBACA,GAhZA,YACA,GACA,gBACA,iCACA,OACA,kBACA,mBACA,sBACA,cACA,EACA,mCACA,wBACA,CACA,yBACA,CAAO,EAEP,gBACA,WACA,eACA,4BACA,iCACA,MACA,CAAO,CACP,kBACA,eACA,mBACA,EACA,yBACA,kBACA,CAAK,CAEL,EAiXA,SA9TA,QACA,KACA,YACA,2BAEA,uBACA,OACA,eACA,4BACA,iCACA,MACA,CAAK,EACL,uBACA,kBACA,eACA,oBACA,EACA,kBACA,CAAK,CACL,CACA,EA0SA,QACA,GA5+FA,oBACA,QACA,iBAsLA,UAAY,+EAA+E,qBArL3F,KACA,0BACA,OACA,eACA,4BACA,iCACA,gBACA,CAAO,EACP,OACA,KACA,iBACA,UACA,OACA,KACA,OAEA,KACA,kBACA,gCAAgD,EAAa,IAC7D,OACA,SACA,SACA,SACA,SACA,SACA,SACA,CACA,0BACA,uBACA,KAEA,OACA,SACA,SACA,SACA,CACA,0BACA,oBACA,IAEA,EACA,YACA,EACA,SACA,WACA,OACA,uBAEA,EACA,SACA,WACA,OACA,oBAEA,EACA,gBA4BA,EAYA,EAYA,EAYA,EAYA,EAYA,EAYA,EAnGA,WACA,eACA,4BACA,iCACA,QACA,CAAS,EACT,iBACA,UACA,+CACA,QACA,CAEA,CAAS,EACT,iBAA+C,EAAS,YA1UxD,qBADA,uBA6aA,OAjGA,oCACA,IACA,WACA,CAAY,SACZ,cACA,OAEA,CACA,IACA,GACA,IAEA,CAAS,EACT,EAWS,sBAXT,sBACA,EACA,KACA,SACA,EAEA,SACA,mBAEA,OADA,IACA,CACA,EAEA,EAWS,wBAXT,wBACA,EACA,KACA,SACA,EAEA,SACA,mBAEA,OADA,IACA,CACA,EAEA,EAWS,+BAXT,+BACA,EACA,KACA,SACA,EAEA,SACA,mBAEA,OADA,IACA,CACA,EAEA,EAWS,0BAXT,0BACA,EACA,KACA,SACA,EAEA,SACA,mBAEA,OADA,IACA,CACA,EAEA,EAWS,kBAXT,kBACA,EACA,KACA,SACA,EAEA,SACA,mBAEA,OADA,IACA,CACA,EAEA,EAWS,iBAXT,iBACA,EACA,KACA,SACA,EAEA,SACA,mBAEA,OADA,IACA,CACA,EAEA,EAWS,sBAXT,sBACA,EACA,KACA,SACA,EAEA,SACA,mBAEA,OADA,IACA,CACA,EAEA,CACA,EACA,OACA,qBACA,qBACA,sBACA,sBACA,sBACA,sBACA,gBACA,gBACA,eACA,CACA,KAC2F,EAC3F,OACA,eACA,QACA,CAAO,CACP,eACA,QACA,CAAO,CACP,eACA,QACA,CAAO,CACP,gBACA,QACA,CAAO,CACP,gBACA,QACA,CAAO,CACP,gBACA,QACA,CAAO,CACP,UACA,QACA,CAAO,CACP,UACA,QACA,CAAO,CACP,UACA,QACA,CACA,CACA,CACA,EAqxFA,eA3MA,SACA,2BACA,wBAEA,uBACA,MAsMA,OACA,eACA,GA32CA,gBACA,gBACA,iBACA,SACA,sBACA,eACA,MACA,iBAEA,gCACA,yBACA,wBACA,CACA,kBACA,uCAEA,kBACA,wBACA,CACA,eACA,sBAEA,oBACA,2BAEA,qBACA,yCACA,qCACA,wCACA,uCACA,CACA,iBACA,sCAEA,YACA,iCAEA,CACA,EAq0CA,mBACA,IA7+CA,gCA6+CA,IACA,IAnoDA,GACA,UACA,2BACA,cACA,gBACA,QACA,eAEA,CAAO,CACP,aACA,gBACA,QACA,CAEA,CACA,CAAK,EACL,IACA,UACA,EAAM,OACN,WACA,sBACA,qBAEA,CACA,CACA,EA0mDA,IACA,eACA,GArjDA,QACA,IACA,eACA,cACA,SAEA,YACA,mEAIA,OAFA,mBACA,WACA,CACA,CACA,EAwiDA,OACA,OA1hHA,8BACA,QACA,cAA0C,mBAAqB,IAC/D,eACA,wBACA,yBAEA,eACA,eACA,eACA,cACA,QAEA,CACA,WACA,8CACA,iBAGA,SAFA,GAA+B,GAAkB,SAAS,+FAA+F,EAAE;AAC3J,CAAC,EAAE,mBAEH,CAAK,YACL,oBACA,cACA,oBAEA,yCACA,CAAO,gBACP,iBACA,UAEA,gBACA,eACA,YACA,UAEA,MACA,2BACA,UACA,EAAU,IACV,MACA,2BACA,0BAEA,CAAO,6BACP,CAAK,eACL,KACA,wBACA,qBACA,UACA,IACA,iBAMA,YAFA,GAA+B,GAAkB,6CAA6C,EAAE;AAChG,CAAC,IAAI,EAJL,8DAAqI,kBAAkB,cAAc,QAAQ,wGAAwG,EAInP,4CAA4C,EAH9E,wDAAiH,EAGhB,eAAe,EAFhH,0BAAqF,oBAAoB,2BAA2B,EAEC,kEAAkE,GAAG,0BAA0B,EAAa,sCAAsC,UAAU,WAAW,GAC5S,EAAgD,8BAA+B,eAAgB,EAC/F,yBACA,+CACA,QACA,SAEA,WACA,gDACA,CAAO,WACP,YACA,oBAEA,IACA,gBAAmG,EAAa,EAChH,CAAU,MACV,mBACA,CACA,CAAO,qCACP,CAAK,EAmBL,OAlBA,WACA,0BAEA,WAEA,YACA,cACA,YACA,sBAEA,QAEA,CAAK,eACL,cACA,aACA,WAEA,CAAK,EACL,CACA,EACA,EA47GA,GACA,GA7sDA,IACA,uBACA,wBACA,iBAGA,sBACA,YACA,qBACM,CACN,yCACA,gBAAyC,8BAAgC,EACzE,yBACA,YACA,OACA,YACA,sBACA,CACA,wBACA,0CACA,IACA,KACA,IAEA,SACA,oBAGA,eACA,IACA,gBACA,EACA,cACA,IACA,GACA,EACA,QACA,gBACA,gBACA,CACA,CAAG,CACH,EAqqDA,IACA,IAhnDA,EA1/DA,sCA2/DA,UACA,IACA,qBACA,QACA,6BAEM,MACN,CACA,SACA,GAwmDA,GACA,GACA,GACA,GACA,YACA,YACA,CAlXA,OACA,UACA,YACA,SAEA,YACA,SAEA,uDAAmE,WAAW,2CAA2C,4BACzH,8BAAqC,cACrC,CAAK,EACL,qBACA,yBACA,KACA,KACA,IACA,kCACA,mBAAkG,kBAAoB,EACtH,sBACA,2BACA,4BACA,aACA,WACA,yBACA,mCACA,CAAM,MACN,EAAM,OACN,sBACA,CACA,YACA,CACA,EAmVA,OAEA,IACA,OACA,GAhgDA,YACA,gBACA,iBACA,WACA,SACA,QACA,kBAEA,mBACA,wCACA,CACA,kBACA,0DAEA,CACA,EAi/CA,GA7dA,IAAsE,cAAa,IACnF,yBACA,yCACA,mBACA,gDAEA,OADA,uCAA2E,QAAoB,EAC/F,CACA,EAsdA,OACA,GAxjDA,IACA,gBACA,cACA,4DAEA,QACA,EAojDA,GAt0DA,gBACA,WACA,cACA,MAm0DA,YAj0DA,MACA,iBAEA,cACA,EA+zDA,GAvvDA,IACA,aACA,WACA,6BAEA,mBACA,uBAEA,MACA,WACA,8BAEA,WACA,0BAEA,4BAEA,WACA,8BAEA,yBAEA,EAiuDA,IACA,eAEA,IA7+BA,6BACA,gBA6KA,EAmBA,EA/LA,+CACA,UAEA,gGACA,kBACA,UAEA,gCACA,UAEA,mCACA,UAEA,sCACA,yBACA,kEACA,cACA,UAEA,yBACA,KACA,KACA,YAAoB,mBAA4B,KAChD,YACA,4BACA,oCACA,8CACA,MACA,CAAO,GACP,YACA,4BACA,4BACA,iCACA,+BACO,GAEP,SACA,mCACA,qBAAmB,gCAAyC,0BAC5D,WACA,eACA,4BACA,iCACA,oEACA,CAAS,EACT,kCACA,cACA,sBACA,CAAW,CACX,UACA,mBAp1EA,qBAo1EA,CACA,CAAW,CACX,UACA,mBAx1EA,sBAw1EA,CACA,CACA,CAAS,EACT,SACA,CAEA,WACA,eACA,4BACA,iCACA,8BACA,CAAK,EACL,EAvGA,QACA,SACA,IAEA,oEACA,EAkGA,gBACA,IACA,EACA,EACA,IAEA,eAEA,OACA,2BACA,4BACA,iCACA,6BACA,CAAK,EACL,KACA,YAAoB,oBAA6B,KACjD,YACA,eACA,4BACA,iCACA,oBACO,GAEP,YAAoB,mBAA4B,MAChD,mBACA,YAAsB,iBAA0B,KAChD,oCAEA,CACA,kFAAsJ,EAAM,MAC5J,WAGA,OAFA,mBACA,WACA,aACK,GACL,aACA,8BACA,OACA,8BACA,GACA,iBACA,QACA,CAAO,CACP,mBACA,sBACO,CACP,oBACA,SACA,CAAO,CACP,uBACA,0BACO,CACP,wBACA,SACA,CAAO,CACP,4BACA,QACA,CAAO,CACP,iCACA,eACA,8BAEA,OACA,CAAO,CACP,cACA,iBACO,CACP,aACA,QACA,CAAO,CACP,qBACA,uBACA,CAAO,CACP,sBACA,yBACO,CACP,uBACA,QACA,CAAO,CACP,4BACA,sBACA,0CAGA,kBADA,yCAEA,sCAEA,CAAO,CACP,iBACA,QACA,CAAO,CACP,WACA,eACO,CACP,yBACA,mCAEA,uBACA,0BACA,sBACA,sBAEA,4BACA,qCAEA,EACA,SACA,6BAkBK,yBAjBL,SACA,qBACA,iIACA,aACA,iBACA,YACA,QAEA,SACA,sCACA,EACA,cAEA,CACA,CACA,qCACA,GAEA,+BAWK,4BAVL,SACA,qBACA,iBACA,cACA,eACA,OAEA,CACA,qCACA,GAEA,WACA,2CACA,UACA,QACA,sBACA,yCAGA,kBADA,kCAEA,sCACA,gBAEA,CACA,CAAK,EACL,yBACA,WACA,CAvOA,YACA,eACA,cACA,cACA,aAEA,cAEA,OADA,WACA,CACA,GA8NA,SACA,aACA,0CACA,0BACA,4EAA+I,EAAM,KAAQ,gCAA0C,GAAK,EAC5M,KACA,OACA,qBACA,gBAEA,gBAA2D,oBAA6B,MACxF,WACA,YAAwB,OAA2B,KACnD,sBAEA,QAEA,EACA,SACA,gCAA4C,iBAA2B,IACvE,aACA,WACA,YAAwB,IAAgB,QACxC,YAA0B,mBAA4B,KACtD,YAA4B,iBAA0B,KACtD,gBAGA,kCACA,sCAAiE,EAAM,MACvE,eACA,CAAa,EAEb,YAA0B,mBAA4B,KACtD,YAA4B,OAA2B,KACvD,wBACA,gCAIA,IACA,oBAEA,GADA,KACA,OAEA,OADA,eACA,EAEA,sBACA,WACA,IAEA,gCACA,MACA,YAEA,cAGA,EACA,CAAa,EAEb,EADA,kEAEA,gBAAiE,oBAA6B,MAC9F,YAA8B,OAA2B,KACzD,mBAEA,QAEA,CAAY,SACZ,KACA,iDACA,cACA,oBACA,gBACA,kBACa,EACb,CACA,OACA,YAA4B,mBAA4B,MACxD,sBACA,YAA8B,iBAA0B,KACxD,uCAEA,CACA,oCACA,oCACA,YAA8B,IAAY,MAC1C,WACA,sBACA,QACA,CACA,CACA,gBACA,sBACA,EACA,IAEA,IAEA,KACA,CACA,CACA,CACA,EACA,SACA,OACA,eACA,4BACA,iCACA,MACA,CAAK,EACL,0CACA,OACA,gBACA,cACA,EAyBA,OADA,IACA,IAxBA,KACA,MACA,IACA,qBACA,aAEA,gBAA6D,oBAA6B,MAC1F,WACA,YAA0B,OAA2B,KACrD,mBAEA,QAEA,CACA,IACA,EACA,KACA,IACA,IACA,KAEA,IACA,EAGA,CACA,EAkoBA,iCAvnDA,MAsnDA,GAtnDA,GAunDA,IACA,GA3nCA,cACA,gBACA,YACA,IACA,mBACA,UACA,OAwEA,GAvEA,2BAKA,cACA,uBACA,SACA,SACA,CACA,CAAW,CACX,kBACA,mBACA,SACA,SACA,CACA,CAAW,CAEX,kBACA,UACA,QACA,sBACA,0CAEA,8BACA,sBACA,sCAEA,CACA,CACA,CAAS,EACT,uBACA,SACA,4BACA,iIACA,aACA,iBACA,YACA,QAEA,SACA,kBACA,2BACA,MAAgC,uBAChC,CAAuB,EACvB,MAEA,uBAAuE,KAAU,EAEjF,EACA,cAEA,CACA,CAEA,OADA,4BACA,cACA,CACA,CAAS,qBACT,0BACA,SACA,4BACA,iBACA,cACA,eACA,OAEA,CAEA,OADA,4BACA,wBACA,CACA,CAAS,wBACT,uBACA,WACA,eACA,4BACA,iCACA,MACA,CAAW,EAIX,OAHA,oCAGA,IAFA,mBACA,6BAEA,CACA,QACA,CAAQ,SACR,eACA,SAEA,QACA,CAEA,cACA,UAGA,MA9GA,KACA,UAAU,GAAQ,mBAClB,IACA,gBACA,EAAI,OACJ,SACA,EACA,EAsGA,GACA,UACA,CACA,EAmhCA,gBACA,IArhEA,mCACA,UACA,kBACA,OACA,eACA,WACA,OACA,IA3zCA,UA2zCA,EACA,4FACA,aACA,6BACA,OACA,2BACA,4BACA,iCACA,6BACA,CAAS,EACT,KACA,YAAwB,oBAA2B,KACnD,YACA,eACA,4BACA,iCACA,oBACW,GAEX,WACA,4BACA,oCACA,8CACA,MACA,CAAS,CACT,0BACA,4BACA,WACQ,OACR,eAGA,GADA,yBACA,UACA,aACA,cACA,kDAEA,YACA,mEAEA,sCACA,kEACA,MACA,YACA,YACA,EAGA,oCACA,cAEA,KACA,KACA,YAA4B,mBAA4B,KACxD,YACA,4BACA,oCACA,8CACA,MACA,CAAe,GACf,YACA,4BACA,4BACA,iCACA,+BACe,GAEf,wEACA,WACA,eACA,4BACA,iCACA,cACA,CAAe,EAEf,OADA,sBACA,CACA,CAAa,GACb,OACA,eACA,4BACA,iCACA,8BACA,CAAa,EACb,YAA4B,mBAA4B,MACxD,mBACA,YAA8B,iBAA0B,KACxD,oCAEA,CACA,2BACA,mBACA,WAIA,OAFA,yBACA,sCACA,IACA,EACA,sCACA,CACA,cACA,OACA,YACA,eACA,uBACA,iCACA,QACA,UACA,YACA,cACA,CAAS,EACT,SACA,YACA,WACA,YAEA,aACA,gBAA6D,oBAA2B,MACxF,WACA,YAA0B,OAA2B,KACrD,mBAEA,QAEA,QACA,CACA,KAUA,sCACA,QACA,EACA,EAEA,0BAdA,sCACA,QACA,EACA,EAEA,qBAcA,OADA,eACA,CACA,EACA,OACA,YACA,OACA,sBACA,WACA,mBAEA,MACA,CACA,CACA,CACA,EAg3DA,qBA1xDA,QACA,eACA,EAwxDA,yBACA,GA/lDA,GACA,UA+lDA,GAnZA,QACA,WACA,EAkZA,MAprEA,gCACA,gBACA,mBACA,MACA,WACA,OACA,KAA+D,WAAgC,EAC/F,KACA,gBACA,0BAEA,IADA,2CACA,8BAEA,aADA,iBAEA,SACA,6BACA,kBACA,aACA,CAAO,EACP,+BACA,4BACA,2BACA,GACA,UAEA,iBAAc,GAAe,QAC7B,MACA,CACA,uBACA,8BAEA,wBACA,yCACA,iDACA,oDACA,0CACA,CACA,wBACA,wBACA,wCAEA,iBAEA,WACA,yCAEA,CACA,EA5sCA,QACA,YACA,EA+0GA,2BAhOA,GACA,EACA,KACA,kHAMA,iBACA,YAAqB,yBAAiC,OACtD,GAqNA,GA3IA,IACA,UAAU,WAAe,mBACzB,IACA,gBACA,EAAI,OACJ,UACA,SACA,CACA,EAmIA,WACA,GA9/CA,cACA,gBACA,gBAA4B,MAI5B,EAHA,YACA,4DAGA,IACA,UACA,CAAQ,SACR,yDACA,SAEA,QACA,CACA,YACA,UAEA,IA/lDA,IACA,uGACA,EA6lDA,eACA,uCAAmD,cAAoB,mEAEvE,sDACA,UAEA,WACA,gBAAc,GAAc,EAC5B,YAAc,GAAa,EAoB3B,GAnBA,8IAKA,oDAEA,2BACA,+BACA,oCACA,gDACA,sCACA,gFACA,qCAEA,0BACA,iCAEA,iBACA,qBACA,wBACA,WACA,2BACA,mBAEA,sCACA,EACA,mCACA,CACA,CACA,kBACA,yBAEA,YACA,qEAEA,cACA,sBACA,2CACA,SACA,CAAS,GAET,2BACA,mBAEA,2CACA,iEACA,kCACA,kCACA,yCA3pDA,GA6pDA,KA7pDA,eA8pDA,CAAO,EACP,CACA,eACA,0BACA,oBACA,WACA,8DACA,2CACA,IAEA,uBAEA,EACA,0DACA,CAAS,EAET,4CACA,2BACA,SAEA,QACA,CAAO,CACP,CACA,UACA,oDACA,cACA,SAEA,QACA,CAAO,CACP,CACA,CACA,EA+4CA,MA/UA,wCA+UA,OACA,kFACA,sBACA,sBAAU,UAA0B,yBACpC,eACA,gBAEA,8BAAmH,SAAqB,EAGxI,6BAAW,iDAFX,sBAA+F,EAAa,EAEjG,gCADX,sBAA+G,EAAc,CAClH,CACX,CA8IA,UACA,qBACA,wBACA,mBAEA,wCACA,0BACA,mBAEA,SACA,mBACA,KACA,IACA,IACA,eACA,gBACA,mBAEA,MADA,mBACA,MACA,4BACA,SACA,EAAU,IACV,qBAEQ,QAER,OADA,iBACA,gCACA,4BACA,SACA,CAEA,gBACA,mBACA,mBACA,kBACA,qDACA,CACA,cACA,qBAEA,iBACA,wBAEA,iBACA,wBAEA,gBAKA,OAJA,oDACA,oDACA,oDACA,oDACA,oCACA,CACA,gBASA,OARA,oDACA,oDACA,oDACA,oDACA,oDACA,oDACA,oDACA,oDACA,oCACA,CACA,cAGA,OAFA,oDACA,oDACA,kCACA,CACA,cAKA,OAJA,oDACA,oDACA,oDACA,oDACA,kCACA,CACA,WACA,yCACA,qBACA,CACA,eAGA,OAFA,oDACA,oDACA,mCACA,CACA,eAKA,OAJA,oDACA,oDACA,oDACA,oDACA,mCACA,CACA,YACA,yCACA,sBACA,CACA,kBACA,uCACA,kDACA,oDACA,oDACA,mDACA,CACA,kBACA,uCACA,kDACA,oDACA,oDACA,oDACA,oDACA,oDACA,oDACA,mDACA,CACA,gBACA,qCACA,kDACA,mDACA,CACA,gBACA,qCACA,kDACA,oDACA,oDACA,mDACA,CACA,aACA,yCACA,gBACA,CACA,iBACA,sCACA,kDACA,mDACA,CACA,iBACA,sCACA,kDACA,oDACA,oDACA,mDACA,CACA,cACA,yCACA,iBACA,CACA,2BACA,QACA,8BACA,qBACA,aACA,YAEA,GACA,CACA,kBACA,CACA,CA2HA,eACA,mBACA,YAEA,oBACA,SACA,SAEA,QACA,SAEA,QACA,SAEA,QACA,SAEA,OACA,SAEA,OACA,SAEA,OACA,SAEA,OACA,SAEA,gBACA,wBACA,EAcA,MACA,GA/CA,uCAiDA,GAr5JA,IACA,QACA,YACA,wDAEA,iBACA,CACA,EAoOA,IACA,+BACA,YAEA,IACA,EAoqJA,KAEA,GAtdA,YACA,UACA,MAEA,cAA8D,kCAD9D,kEACmG,EACnG,qDAAkG,oCAAmD,OACrJ,KACA,SACA,eACA,gBAEA,cACA,CAAK,EACL,OACA,OACA,OACA,OACA,KACA,MACA,mCAAoE,iBAA+B,OAAgB,EAAG,EACtH,EACA,eACA,mBACA,UACA,cAEA,KACA,SAEA,EACA,OACA,KACA,YAEA,OACA,WAGA,WACA,oCACA,wCAEA,UACA,gBAEA,gCAA2D,0DAAyE,IACpI,WACA,aACA,CAAW,EACX,QAEA,eACA,gBACA,sBACA,WACA,UAEA,eACA,WACA,kCACA,CAAO,EACP,OACA,EACA,OACA,KACA,aAGA,OADA,IACA,CACA,eACA,QACA,CAAO,CACP,YACA,iDACA,CAAO,CACP,QACA,YACA,UAEA,IACA,IACA,oCAEA,CAAO,CACP,SACA,YACA,UAEA,IACA,IACA,qCAEA,CAAO,CACP,SACA,MACA,YACA,UAEA,+BACA,UAEA,oCACA,yBACA,+DACA,eACA,IACA,0BACA,sCAA4B,qFAAsG,KAClI,aACA,WACA,sBACA,YACA,aACA,SACA,CAAa,EACb,iBAEA,kBACA,YACA,WAEA,mBAAmB,6DAEnB,oBACA,OACA,IACA,wCAA8D,UAA0C,EACxG,EACA,iCACA,oCACA,mBACA,mBACA,2DACA,GAEA,CAAS,KACT,CAAO,CACP,MACA,CACA,CACA,EA0UA,GA70JA,SACA,IACA,qDACA,CAAI,SAIJ,OAHA,UACA,YACA,kCACA,CACA,CACA,EACA,KACA,IACA,+CACA,CAAI,SAGJ,OAFA,UACA,2BACA,CACA,CACA,EA2zJA,IACA,GAlgJA,QACA,MAigJA,GAjgJA,KACA,YACA,SAEA,4BACA,oBACA,YAGA,MADA,cACA,aACA,YAAoB,IAAY,KAChC,yBAEA,cAAa,UACb,EAo/IA,GA9iJA,cACA,cACA,YACA,SAEA,WAAY,WAAgB,EAC5B,gBACA,OAAe,uBAEf,sBACA,YAEA,iBACA,6CACA,cAAmC,SAAsB,0BACzD,YAAsB,IAAqB,MAC3C,YACA,YAAwB,IAAkB,KAC1C,iEAEA,CACA,eAAe,aACf,CACA,OAAa,wBACb,EAuhJA,GAphJA,QACA,cACA,YACA,SAEA,WAAY,WAAgB,SAC5B,OACA,QAAe,iBAEf,0FACA,QAAe,iBAEf,QAAa,iBACb,EAwgJA,GAj5JA,UACA,SACA,IACA,IACA,qBACA,aACA,cACA,YACA,MAEA,WAAgB,UAAe,EAC/B,IACA,IACA,EAAQ,IACR,kBACA,YACA,MAEA,YAAgB,YAAkB,EAClC,OACA,KACA,UACA,SAEA,CAEA,OAAa,yCACb,EAu3JA,GA/KA,YACA,SACA,WAAmF,sBAAuB,YAAa,EACvH,OACA,OACA,EACA,MACA,oCAAoE,iBAA+B,OAAgB,EAAG,EACtH,EACA,eACA,mBACA,sBACA,cAEA,KACA,SAEA,EACA,OACA,uBAGA,WACA,aACA,CAAS,EACT,QAEA,IACA,OACA,EACA,SACA,EAUA,OATA,+BACA,IACA,wCACA,cACO,EACP,CAAK,EACL,oEACA,sEACA,oEACA,CACA,eACA,QACA,CAAO,CACP,YACA,eACO,CACP,UACA,UAEA,WACA,WAEA,SACA,0BACA,qCACA,iBAAkB,gBAA2B,gBAC7C,cACA,gDAEA,cACA,8CAEA,SACA,KACA,IACA,UACA,OACA,IACA,EACA,mCAAkF,EAAM,IACxF,KACA,sBACA,yBAAoI,qDAA8D,IAClM,cACA,KACA,iEACA,kCACA,cACA,YACA,OAA2B,qDAE3B,UAAwB,GAAQ,EAChC,iBACA,gBAA2B,4CAE3B,IACA,CACA,uBAAsB,uBAAuC,UAC7D,uDAYA,OAXA,4CAAqF,EAAQ,QAC7F,mCACA,oBACA,eACA,WACA,kCACA,CAAiB,EACjB,kBACA,UACA,KAEA,CAAuB,oDACvB,CAAa,CACb,CAAW,CACX,aACA,2BAAwE,EAAmB,IAC3F,GAGA,UACA,CAAa,CAEb,CACA,YACA,CAAO,CACP,MACA,CACA,EA0DA,IA31JA,GACA,KACA,YACA,0DAEA,oCACA,CACA,EAo1JA,IACA,IA5qJA,GACA,UAGA,+CAwqJA,IACA,GAl0JA,kBACA,gBACA,kBAAoC,EACpC,aAAc,GAAW,EACzB,aACA,gEACA,eACA,SACA,6BACA,EAAQ,wCACR,QACA,qEAAmL,aACnL,0CAEA,6CAMA,MAHA,UACA,SAEA,GAEA,4BACA,mBACA,mBACA,oBACA,mBACA,iBACA,CACA,eACA,4CAEA,sBACA,mFAEA,uBAIA,GAHA,8BACA,mEAEA,sBACA,mBACA,yCACA,2BACA,EAAQ,IACR,0BAEA,CACA,cACA,2DAEA,eAIA,GAHA,sBACA,mDAEA,sBACA,mBACA,iCACA,qBACQ,IACR,kBAEA,CACA,cACA,2DAEA,eAIA,GAHA,sBACA,mDAEA,sBACA,mBACA,iCACA,qBACQ,IACR,kBAEA,CACA,eACA,8DAEA,gBAIA,GAHA,uBACA,qDAEA,sBACA,mBACA,kCACA,sBACQ,IACR,mBAEA,CACA,cACA,2DAEA,eAIA,GAHA,sBACA,mDAEA,sBACA,mBACA,iCACA,qBACQ,IACR,kBAEA,CACA,aACA,wDAEA,cAIA,GAHA,qBACA,iDAEA,sBACA,mBACA,gCACA,oBACQ,IACR,iBAEA,CACA,YACA,yCAEA,QACA,0CACA,CACA,SACA,2CACA,CACA,SACA,2CACA,CACA,OACA,yCACA,CACA,0BACA,iBACA,sEACA,CACA,CACA,EAaA,UACA,IAWA,EA+CA,EAoCA,EA9FA,UACA,cACA,cACA,KACA,aACA,cAiGA,OAhGA,sCAAkD,EAAW,IAC7D,GACA,yBAEA,CAAG,EACH,EA8CG,mBA9CH,mBACA,UACA,QACA,wBACA,wBACA,SACA,MACA,oBACA,OACA,UAEA,WAEA,EACA,WACA,UACA,EAAU,gBACV,MACA,wBACA,YAEA,iCAA2E,cAAoB,EAE/F,EACA,YACU,aACV,MACA,2BACA,eACA,QACA,aACA,gCACA,4BAA8D,EAAM,OAAc,iBAA2B,CAC7G,CAAmB,EAEnB,WACA,WACA,CAEA,WACA,EACA,YAGA,sBACA,EAEA,EAwBG,sBAxBH,sBACA,UACA,QACA,wBACA,yBACA,YACA,cACA,aACA,KAEA,EAAU,oBACV,cACA,aACA,KAEA,EAAU,mBACV,cACA,aACA,KAEA,EAEA,sBACA,EAEA,YACA,IACA,qFACA,WAKA,MAHA,sBACA,wBAEA,gCACA,CACA,CAAG,UACH,EAOG,OAPH,OACA,KACA,sBACA,aAEA,SACA,EAEA,CACA,EA+jJA,aAx3JA,EA+1JA,OACA,IACA,OAAyB,eAKzB,CAJA,2BACA,gBACA,QACA,CAAK,EACL,sBACA,YAEA,uBACA,EAz2JA,MACA,oBACA,4BACA,iCAo3JA,KAp3JA,CACA,CACA,wBACA,aACA,4BACA,cACA,YACA,sBACA,0BAGA,+CACA,CACA,CACA,iBACA,+CACA,CACA,2BACA,6CACA,kEACA,CACA,GA+1JA,IACA,eACA,aACA,kBACA,WACA,WACA,EACA,OACA,oBAAmB,EAAM,GACzB,sBAEA,SAAa,OAAM,GACnB,OACA,wBAA8B,cAAwB,EAGtD,cAAa,EAAM,GACnB,eACA,8BAA6B,6BAAsC,gBAAqB,EAAQ,MAChG,CAEA,CAAC,EAMD,aADA,OAAsB,OAAO,kBAAkB,aAAa,aAAa,kBAAkB,mBAAmB,WAAW,mBAAmB,eAAe,qBAAqB,qBAAqB,+GAA+G,mBAAmB,6CAA6C,2BAA2B,aAAa,KAAK,SAAS,+BAA+B,cAAc,8HAA8H,KAAK,SAAS,+BAA+B,eAAe,sCAAsC,6CAA6C,KAAK,MAAM,cAAc,WAAW,+BAA+B,YAAY,YAAY,oDAAoD,MAAM,aAAa,sEAAsE,SAAS,8GAA8G,MAAM,wBAAwB,IAAI,aAAa,IAAI,gGAAgG,4BAA4B,gHAAgH,uCAAuC,aAAa,gCAAgC,KAAK,gCAAgC,MAAM,4BAA4B,GAAG,eAAe,cAAc,KAAK,SAAS,MAAM,0BAA0B,GAAG,eAAe,OAAO,iBAAiB,MAAM,IAAI,aAAa,6BAA6B,eAAe,OAAO,IAAI,UAAU,+CAA+C,qBAAqB,0BAA0B,IAAI,UAAU,cAAc,SAAS,IAAI,iBAAiB,kKAAkK,YAAY,aAAa,uBAAuB,0BAA0B,4BAA4B,gBAAgB,oBAAoB,cAAc,OAAO,oCAAoC,IAAI,YAAY,OAAO,uCAAuC,OAAO,YAAY,qBAAqB,0BAA0B,8EAA8E,gDAAgD,WAAW,QAAQ,OAAO,IAAI,EAAE,iBAAiB,YAAY,IAAI,MAAM,aAAa,yBAAyB,kBAAkB,sBAAsB,mCAAmC,QAAQ,YAAY,mBAAmB,6BAA6B,oDAAoD,GAAG,SAAS,2BAA2B,iBAAiB,eAAe,SAAS,8DAA8D,oBAAoB,4DAA4D,2BAA2B,uGAAuG,gGAAgG,YAAY,eAAe,iBAAiB,YAAY,IAAI,MAAM,aAAa,sEAAsE,GAAG,OAAO,mBAAmB,0CAA0C,gTAAgT,aAAa,QAAQ,mBAAmB,uBAAuB,WAAW,0BAA0B,IAAI,iBAAiB,mGAAmG,iBAAiB,aAAa,0FAA0F,SAAS,+BAA+B,EAAE,GAAG,0HAA0H,wBAAwB,0BAA0B,eAAe,oFAAoF,oBAAoB,0BAA0B,OAAO,4BAA4B,UAAU,yCAAyC,IAAI,4BAA4B,+DAA+D,8GAA8G,uCAAuC,yBAAyB,EAAE,OAAO,cAAc,EAAE,IAAI,IAAI,kBACtwJ,EAAkC,8BAA+B,eAAgB,EACjF,2BAEA,GANA,GADA,WAMA,KACA,QACA,wBACA,UACA,OA8CA,EAEA,2BArBA,UAEA,mBADA,aAA8B,WAAW,MACzC,CAA4C,yBAAiC,EAC7E,eACA,oBACA,8BACA,wBACA,YAAuB,GAAG,2BAC1B,cACA,MACA,CAAK,EACL,mBACA,oCAAiD,UAAa,IAAI,aAAgB,OAC5E,OAAa,eACnB,QACA,CACA,qBACA,eAAoB,QAAgB,OACpC,EAIA,mBArCA,UACA,OAGA,IACA,qBACA,KACA,CAAM,SACN,oEACA,MAnBA,sCAA0C,KAAK,IAqB/C,mCAEA,CACA,EAwBA,cA9CA,IACA,IACA,0BACA,QACA,CAAO,EACP,OAEA,CAwCA,GAEA,eACA,gCACA,OACA,OAEA,CACA,iBACA,iBACA,CAEA,2BACA,OACA,kCACA,UACA,eACI,GAAG,6BACP,WACA,eAAkB,EAAO,EAEzB,gCACA,IACA,mBACA,oBACA,kCACA,YAAuB,GAAG,2BAC1B,cACA,MACA,CAAK,EACL,mBACA,qBACA,SACA,mCACA,8BACA,yBAEA,IACA,cAAoC,GAAG,QACvC,cAEA,UAEA,EAAM,GACA,OAAa,wCAEnB,CAAI,SACA,OAAa,cACjB,CACA,CACA,GAAG,oBACH,yBACA,iCACA,CACA,YACA,YACA,eACA,eACA,gBACA,UAEA,yBAEA,yCAAuD,CAEvD,CAAG,CACH,qBACA,EACA,cACA,qCACA,eACA,+BACA,+BACA,qBACA,EAEA,UACA,EAEA,gBACA,aAAgB,GAAW,cAC3B,+CAEA,GADA,cACA,CACA,8CACA,mBACA,yBACA,iCACA,cACA,aACA,WACA,cAAwC,GAAG,QAC3C,mCAEA,gDACA,CACA,CAUA,OATA,WAAiC,OAAgB,CACjD,WACA,KACA,YACA,kBACA,iBACA,mBACA,GAEA,CAAiB,SACjB,CACA,GAEA,wBACA,iCACA,gBACA,MAAqB,OAAkB,CAAC,GAAG,UAC3C,eACA,qBACA,uBAEA,aACA,cAAoC,GAAG,QACvC,mCAEA,gDACA,CAEA,CACA,CAAC,EACD,GAAG,oBACH,yBACA,iCACA,WACA,2IACA,2CAAyD,CAEzD,CAAG,CACH,qBACA,EACA,iBACA,qBACA,qBAEA,iBACA,uBAEA,OACA,cAAsC,GAAG,QACzC,mBAEA,CACA,UACA,IAEA,aACA,0BACA,+BACA,iCACA,SACA,GAEA,EACA,gBACA,2BACA,gBAEA,GAEA,iCACA,mBAAgB,GAAoB,CAAE,OAAgB,IACtD,iBACA,UACA,CAAS,EACT,cACA,SACA,EACA,GACA,EACA,CAAY,eAYZ,OAVA,QAA6B,OAAC,4BACtB,QAAkB,IAC1B,aACA,QACA,CAAS,EACD,QAAY,IACpB,aACA,SACA,CAAS,EACT,2BACA,CAAiB,SACjB,CACA,EAEA,CAAC,EACD,GAAG,oBACH,yBACA,qBACA,EACA,kBACA,qCACA,eACA,+BACA,+BACA,qBACA,EAEA,UACA,GAEA,OACA,KACA,KACA,OACA,OACA,OACA,MACA,4BACA,OACA,kBACA,GACA,CAAa,EACb,SACA,SAEA,oBACA,MAEA,MADY,OAAa,YAAY,OAAC,uBACtC,GAEA,uCACA,+CACA,EACA,eACA,SACA,EACA,GACA,UACA,KA+Dc,MACd,cA/DA,IACA,6CACA,QACA,CAAiB,EACjB,YACA,oBACA,CAAiB,EACjB,KACA,sBACA,cACA,EACA,mBACA,kBAA4D,iBAAmB,EAC/E,sBACA,kDACA,mCAEA,qCACA,KACA,GACA,SAAyC,OAAC,sBAE1C,IACA,IACA,OACA,OAEA,EACA,cACA,wCACA,sBACA,KACA,GACA,SAAyC,OAAC,sBAE1C,IACA,IACA,OACA,OAEA,EACA,UACA,KACA,GACA,SAAuC,OAAC,oBAExC,CAAgB,SAGhB,GAFA,+CACgB,OAAa,YAAY,OAAC,2BAC1C,EACA,IACA,QACA,CAAoB,MACpB,CAEA,sBACA,OACA,KACA,GACA,SAAuC,OAAC,qBAExC,CAIA,CAAW,CACX,CAAY,cACZ,EACA,MAA6B,OAAC,qBAC9B,kBAYA,OAXA,uBACA,KACA,OACA,SAEA,sBACA,wDACA,mCAEA,qBACA,EACA,CAAiB,SACjB,CACA,GAEA,qBACA,0CACA,+BACA,CACA,CAAC,EAcD,GAAG,oBACH,yBACA,2BACA,UAAY,GAAQ,MACpB,UAAY,GAAW,MACvB,aACA,6BACA,SApBA,KACA,iBACA,KACA,2EAC2B,QAAkB,kBAC7C,EAeA,IAEA,MACA,UACA,UAlBA,CACA,cACA,CACA,GAeA,CAfA,IACA,eAcA,CAbA,EAcA,CACA,CACA,CAAC,EACD,gBACA,GAAG,oBACH,2BACA,qBACA,EACA,gBACA,CACA,2BACA,mCACA,uCACA,2BACA,sCA8BA,OA7BA,oCACA,WACA,IACA,iDACA,SACA,QACA,CAAa,EACb,qBACA,yBACA,iDACA,cACA,QACA,CAAY,SACZ,mCACA,qBACA,wBACA,yBACA,8BACA,uBACA,0EACA,UAEA,uKACA,UAEA,oBACA,CACA,KAEA,CAAiB,oCACjB,CACA,GAEA,mBAEA,EADA,4DAEA,0CACA,sCACA,uCACA,iBACA,gCAEA,mCACA,OACA,gBACA,iBACA,mBACA,iCACA,+BACA,WACA,eACA,WACQ,GAAG,yBACX,EACA,OACA,EACA,cACA,SACA,wBACA,UACA,EAEA,eACA,4BACA,2BACA,MACA,WACA,SACQ,wCACR,gCAEA,MADQ,OAAa,eACrB,QACA,CACA,wCACA,KAAsB,UAA4B,MAClD,kBACA,eACA,oBACA,+BACA,wBACA,YAAyB,GAAG,2BAC5B,cACA,MACA,CAAO,EACP,mBACA,uCAAsD,UAAa,IAAI,aAAgB,OAC/E,OAAa,eACrB,QACA,CACA,gBAAuB,GAAM,OAC7B,EACA,eACA,IACA,UACA,0BACA,4BAEA,cACA,QAAkB,OAAC,aACnB,CAAK,CACL,CACA,CAAC","sources":["webpack://_N_E/../../node_modules/.bun/@comfyorg+comfyui-frontend@.+comfyorg-comfyui-frontend-1.26.2.tgz+e5b32ef95522b1e7/node_modules/@comfyorg/comfyui-frontend/lib/index-ZuOXyzLm.js"],"sourcesContent":["import { a as app, C as ComfyApp, b as ComfyDialog, $ as $el, L as LiteGraph, c as LGraphCanvas, i as isComboWidget, u as useExtensionService, p as processDynamicPrompt, d as isElectron, e as useWorkflowStore, f as useToastStore, g as checkMirrorReachable, t, h as useDialogService, l as log, j as electronAPI, E as ExecutableNodeDTO, k as ComfyDialog$1, D as DraggableList, m as getInputSpecType, n as isIntInputSpec, o as isFloatInputSpec, q as isComboInputSpec, r as getComboSpecComboOptions, s as toolkit, v as useChainCallback, G as GET_CONFIG, w as ComfyWidgets, x as LGraphNode, y as applyTextReplacements, z as CONFIG, A as addValueControlWidgets, B as isPrimitiveNode, F as GROUP, H as useExecutionStore, I as api, S as SubgraphNode, J as serialise, K as useNodeDefStore, M as useWidgetStore, N as deserialiseAndCreate, O as LGraphGroup, P as useSettingStore, _ as _export_sfc, Q as useDialogStore, R as isLoad3dNode, T as ComponentWidgetImpl, U as addWidget, V as debounce, W as setStorageValue, X as hexToRgb, Y as getStorageValue, Z as getNodeByLocatorId, a0 as useNodeFileInput, a1 as useNodeDragAndDrop, a2 as useNodePaste, a3 as isComboInputSpecV1 } from \"./lib-index-DdMUP0fe.js\";\nimport { defineComponent, ref, watch, computed, onMounted, onUnmounted, openBlock, createElementBlock, createVNode, unref, withCtx, withDirectives, createElementVNode, normalizeClass, vShow, createCommentVNode, Fragment, renderList, createTextVNode, toDisplayString, createBlock, Transition, nextTick, toRaw, useModel, mergeModels, vModelText, onBeforeUnmount } from \"vue\";\nimport { useI18n } from \"vue-i18n\";\nimport { Tooltip } from \"primevue\";\nimport Button from \"primevue/button\";\nimport Slider from \"primevue/slider\";\nimport Select from \"primevue/select\";\nimport Checkbox from \"primevue/checkbox\";\nvar __defProp$o = Object.defineProperty;\nvar __defNormalProp$o = (obj, key, value) => key in obj ? __defProp$o(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$o = (obj, key, value) => __defNormalProp$o(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nconst _ClipspaceDialog = class _ClipspaceDialog2 extends ComfyDialog {\n  static registerButton(name, contextPredicate, callback) {\n    const item = $el(\"button\", {\n      type: \"button\",\n      textContent: name,\n      contextPredicate,\n      onclick: callback\n    });\n    _ClipspaceDialog2.items.push(item);\n  }\n  static invalidatePreview() {\n    if (ComfyApp.clipspace && ComfyApp.clipspace.imgs && ComfyApp.clipspace.imgs.length > 0) {\n      const img_preview = document.getElementById(\n        \"clipspace_preview\"\n      );\n      if (img_preview) {\n        img_preview.src = ComfyApp.clipspace.imgs[ComfyApp.clipspace[\"selectedIndex\"]].src;\n        img_preview.style.maxHeight = \"100%\";\n        img_preview.style.maxWidth = \"100%\";\n      }\n    }\n  }\n  static invalidate() {\n    if (_ClipspaceDialog2.instance) {\n      const self2 = _ClipspaceDialog2.instance;\n      const children = $el(\"div.comfy-modal-content\", [\n        self2.createImgSettings(),\n        ...self2.createButtons()\n      ]);\n      if (self2.element) {\n        if (self2.element.firstChild) {\n          self2.element.removeChild(self2.element.firstChild);\n        }\n        self2.element.appendChild(children);\n      } else {\n        self2.element = $el(\"div.comfy-modal\", { parent: document.body }, [\n          children\n        ]);\n      }\n      if (self2.element.children[0].children.length <= 1) {\n        self2.element.children[0].appendChild(\n          $el(\"p\", {}, [\n            \"Unable to find the features to edit content of a format stored in the current Clipspace.\"\n          ])\n        );\n      }\n      _ClipspaceDialog2.invalidatePreview();\n    }\n  }\n  constructor() {\n    super();\n  }\n  createButtons() {\n    const buttons = [];\n    for (let idx in _ClipspaceDialog2.items) {\n      const item = _ClipspaceDialog2.items[idx];\n      if (!item.contextPredicate || item.contextPredicate())\n        buttons.push(_ClipspaceDialog2.items[idx]);\n    }\n    buttons.push(\n      $el(\"button\", {\n        type: \"button\",\n        textContent: \"Close\",\n        onclick: () => {\n          this.close();\n        }\n      })\n    );\n    return buttons;\n  }\n  createImgSettings() {\n    var _a2;\n    if ((_a2 = ComfyApp.clipspace) == null ? void 0 : _a2.imgs) {\n      const combo_items = [];\n      const imgs = ComfyApp.clipspace.imgs;\n      for (let i = 0; i < imgs.length; i++) {\n        combo_items.push($el(\"option\", { value: i }, [`${i}`]));\n      }\n      const combo1 = $el(\n        \"select\",\n        {\n          id: \"clipspace_img_selector\",\n          onchange: (event) => {\n            if (event.target && ComfyApp.clipspace) {\n              ComfyApp.clipspace[\"selectedIndex\"] = event.target.selectedIndex;\n              _ClipspaceDialog2.invalidatePreview();\n            }\n          }\n        },\n        combo_items\n      );\n      const row1 = $el(\"tr\", {}, [\n        $el(\"td\", {}, [$el(\"font\", { color: \"white\" }, [\"Select Image\"])]),\n        $el(\"td\", {}, [combo1])\n      ]);\n      const combo2 = $el(\n        \"select\",\n        {\n          id: \"clipspace_img_paste_mode\",\n          onchange: (event) => {\n            if (event.target && ComfyApp.clipspace) {\n              ComfyApp.clipspace[\"img_paste_mode\"] = event.target.value;\n            }\n          }\n        },\n        [\n          $el(\"option\", { value: \"selected\" }, \"selected\"),\n          $el(\"option\", { value: \"all\" }, \"all\")\n        ]\n      );\n      combo2.value = ComfyApp.clipspace[\"img_paste_mode\"];\n      const row2 = $el(\"tr\", {}, [\n        $el(\"td\", {}, [$el(\"font\", { color: \"white\" }, [\"Paste Mode\"])]),\n        $el(\"td\", {}, [combo2])\n      ]);\n      const td2 = $el(\n        \"td\",\n        { align: \"center\", width: \"100px\", height: \"100px\", colSpan: \"2\" },\n        [$el(\"img\", { id: \"clipspace_preview\", ondragstart: () => false }, [])]\n      );\n      const row3 = $el(\"tr\", {}, [td2]);\n      return $el(\"table\", {}, [row1, row2, row3]);\n    } else {\n      return [];\n    }\n  }\n  createImgPreview() {\n    var _a2;\n    if ((_a2 = ComfyApp.clipspace) == null ? void 0 : _a2.imgs) {\n      return $el(\"img\", { id: \"clipspace_preview\", ondragstart: () => false });\n    } else return [];\n  }\n  show() {\n    _ClipspaceDialog2.invalidate();\n    this.element.style.display = \"block\";\n  }\n};\n__publicField$o(_ClipspaceDialog, \"items\", []);\n__publicField$o(_ClipspaceDialog, \"instance\", null);\nlet ClipspaceDialog = _ClipspaceDialog;\napp.registerExtension({\n  name: \"Comfy.Clipspace\",\n  init(app2) {\n    app2.openClipspace = function() {\n      if (!ClipspaceDialog.instance) {\n        ClipspaceDialog.instance = new ClipspaceDialog();\n        ComfyApp.clipspace_invalidate_handler = ClipspaceDialog.invalidate;\n      }\n      if (ComfyApp.clipspace) {\n        ClipspaceDialog.instance.show();\n      } else app2.ui.dialog.show(\"Clipspace is Empty!\");\n    };\n  }\n});\nconst ext$1 = {\n  name: \"Comfy.ContextMenuFilter\",\n  init() {\n    const ctxMenu = LiteGraph.ContextMenu;\n    LiteGraph.ContextMenu = function(values, options) {\n      const ctx = new ctxMenu(values, options);\n      if ((options == null ? void 0 : options.className) === \"dark\" && (values == null ? void 0 : values.length) > 4) {\n        const filter = document.createElement(\"input\");\n        filter.classList.add(\"comfy-context-menu-filter\");\n        filter.placeholder = \"Filter list\";\n        ctx.root.prepend(filter);\n        const items = Array.from(\n          ctx.root.querySelectorAll(\".litemenu-entry\")\n        );\n        let displayedItems = [...items];\n        let itemCount = displayedItems.length;\n        requestAnimationFrame(() => {\n          var _a2, _b2;\n          const currentNode = LGraphCanvas.active_canvas.current_node;\n          const clickedComboValue = (_b2 = (_a2 = currentNode == null ? void 0 : currentNode.widgets) == null ? void 0 : _a2.filter(\n            (w) => {\n              var _a3;\n              return isComboWidget(w) && ((_a3 = w.options.values) == null ? void 0 : _a3.length) === values.length;\n            }\n          ).find(\n            (w) => {\n              var _a3;\n              return (\n                // @ts-expect-error Poorly typed; filter above \"should\" mitigate exceptions\n                (_a3 = w.options.values) == null ? void 0 : _a3.every((v, i) => v === values[i])\n              );\n            }\n          )) == null ? void 0 : _b2.value;\n          let selectedIndex = clickedComboValue ? values.findIndex((v) => v === clickedComboValue) : 0;\n          if (selectedIndex < 0) {\n            selectedIndex = 0;\n          }\n          let selectedItem = displayedItems[selectedIndex];\n          updateSelected();\n          function updateSelected() {\n            selectedItem == null ? void 0 : selectedItem.style.setProperty(\"background-color\", \"\");\n            selectedItem == null ? void 0 : selectedItem.style.setProperty(\"color\", \"\");\n            selectedItem = displayedItems[selectedIndex];\n            selectedItem == null ? void 0 : selectedItem.style.setProperty(\n              \"background-color\",\n              \"#ccc\",\n              \"important\"\n            );\n            selectedItem == null ? void 0 : selectedItem.style.setProperty(\"color\", \"#000\", \"important\");\n          }\n          const positionList = () => {\n            const rect = ctx.root.getBoundingClientRect();\n            if (rect.top < 0) {\n              const scale = 1 - ctx.root.getBoundingClientRect().height / ctx.root.clientHeight;\n              const shift = ctx.root.clientHeight * scale / 2;\n              ctx.root.style.top = -shift + \"px\";\n            }\n          };\n          filter.addEventListener(\"keydown\", (event) => {\n            switch (event.key) {\n              case \"ArrowUp\":\n                event.preventDefault();\n                if (selectedIndex === 0) {\n                  selectedIndex = itemCount - 1;\n                } else {\n                  selectedIndex--;\n                }\n                updateSelected();\n                break;\n              case \"ArrowRight\":\n                event.preventDefault();\n                selectedIndex = itemCount - 1;\n                updateSelected();\n                break;\n              case \"ArrowDown\":\n                event.preventDefault();\n                if (selectedIndex === itemCount - 1) {\n                  selectedIndex = 0;\n                } else {\n                  selectedIndex++;\n                }\n                updateSelected();\n                break;\n              case \"ArrowLeft\":\n                event.preventDefault();\n                selectedIndex = 0;\n                updateSelected();\n                break;\n              case \"Enter\":\n                selectedItem == null ? void 0 : selectedItem.click();\n                break;\n              case \"Escape\":\n                ctx.close();\n                break;\n            }\n          });\n          filter.addEventListener(\"input\", () => {\n            const term = filter.value.toLocaleLowerCase();\n            displayedItems = items.filter((item) => {\n              var _a3;\n              const isVisible = !term || ((_a3 = item.textContent) == null ? void 0 : _a3.toLocaleLowerCase().includes(term));\n              item.style.display = isVisible ? \"block\" : \"none\";\n              return isVisible;\n            });\n            selectedIndex = 0;\n            if (displayedItems.includes(selectedItem)) {\n              selectedIndex = displayedItems.findIndex(\n                (d) => d === selectedItem\n              );\n            }\n            itemCount = displayedItems.length;\n            updateSelected();\n            if (options.event) {\n              let top = options.event.clientY - 10;\n              const bodyRect = document.body.getBoundingClientRect();\n              const rootRect = ctx.root.getBoundingClientRect();\n              if (bodyRect.height && top > bodyRect.height - rootRect.height - 10) {\n                top = Math.max(0, bodyRect.height - rootRect.height - 10);\n              }\n              ctx.root.style.top = top + \"px\";\n              positionList();\n            }\n          });\n          requestAnimationFrame(() => {\n            filter.focus();\n            positionList();\n          });\n        });\n      }\n      return ctx;\n    };\n    LiteGraph.ContextMenu.prototype = ctxMenu.prototype;\n  }\n};\napp.registerExtension(ext$1);\nuseExtensionService().registerExtension({\n  name: \"Comfy.DynamicPrompts\",\n  nodeCreated(node) {\n    if (node.widgets) {\n      const widgets = node.widgets.filter((w) => w.dynamicPrompts);\n      for (const widget of widgets) {\n        widget.serializeValue = (workflowNode, widgetIndex) => {\n          if (typeof widget.value !== \"string\") return widget.value;\n          const prompt = processDynamicPrompt(widget.value);\n          if (workflowNode == null ? void 0 : workflowNode.widgets_values)\n            workflowNode.widgets_values[widgetIndex] = prompt;\n          return prompt;\n        };\n      }\n    }\n  }\n});\napp.registerExtension({\n  name: \"Comfy.EditAttention\",\n  init() {\n    const editAttentionDelta = app.ui.settings.addSetting({\n      id: \"Comfy.EditAttention.Delta\",\n      category: [\"Comfy\", \"EditTokenWeight\", \"Delta\"],\n      name: \"Ctrl+up/down precision\",\n      type: \"slider\",\n      attrs: {\n        min: 0.01,\n        max: 0.5,\n        step: 0.01\n      },\n      defaultValue: 0.05\n    });\n    function incrementWeight(weight, delta) {\n      const floatWeight = parseFloat(weight);\n      if (isNaN(floatWeight)) return weight;\n      const newWeight = floatWeight + delta;\n      return String(Number(newWeight.toFixed(10)));\n    }\n    function findNearestEnclosure(text, cursorPos) {\n      let start = cursorPos, end = cursorPos;\n      let openCount = 0, closeCount = 0;\n      while (start >= 0) {\n        start--;\n        if (text[start] === \"(\" && openCount === closeCount) break;\n        if (text[start] === \"(\") openCount++;\n        if (text[start] === \")\") closeCount++;\n      }\n      if (start < 0) return null;\n      openCount = 0;\n      closeCount = 0;\n      while (end < text.length) {\n        if (text[end] === \")\" && openCount === closeCount) break;\n        if (text[end] === \"(\") openCount++;\n        if (text[end] === \")\") closeCount++;\n        end++;\n      }\n      if (end === text.length) return null;\n      return { start: start + 1, end };\n    }\n    function addWeightToParentheses(text) {\n      const parenRegex = /^\\((.*)\\)$/;\n      const parenMatch = text.match(parenRegex);\n      const floatRegex = /:([+-]?(\\d*\\.)?\\d+([eE][+-]?\\d+)?)/;\n      const floatMatch = text.match(floatRegex);\n      if (parenMatch && !floatMatch) {\n        return `(${parenMatch[1]}:1.0)`;\n      } else {\n        return text;\n      }\n    }\n    function editAttention(event) {\n      const inputField = event.composedPath()[0];\n      const delta = parseFloat(editAttentionDelta.value);\n      if (inputField.tagName !== \"TEXTAREA\") return;\n      if (!(event.key === \"ArrowUp\" || event.key === \"ArrowDown\")) return;\n      if (!event.ctrlKey && !event.metaKey) return;\n      event.preventDefault();\n      let start = inputField.selectionStart;\n      let end = inputField.selectionEnd;\n      let selectedText = inputField.value.substring(start, end);\n      if (!selectedText) {\n        const nearestEnclosure = findNearestEnclosure(inputField.value, start);\n        if (nearestEnclosure) {\n          start = nearestEnclosure.start;\n          end = nearestEnclosure.end;\n          selectedText = inputField.value.substring(start, end);\n        } else {\n          const delimiters = \" .,\\\\/!?%^*;:{}=-_`~()\\r\\n\t\";\n          while (!delimiters.includes(inputField.value[start - 1]) && start > 0) {\n            start--;\n          }\n          while (!delimiters.includes(inputField.value[end]) && end < inputField.value.length) {\n            end++;\n          }\n          selectedText = inputField.value.substring(start, end);\n          if (!selectedText) return;\n        }\n      }\n      if (selectedText[selectedText.length - 1] === \" \") {\n        selectedText = selectedText.substring(0, selectedText.length - 1);\n        end -= 1;\n      }\n      if (inputField.value[start - 1] === \"(\" && inputField.value[end] === \")\") {\n        start -= 1;\n        end += 1;\n        selectedText = inputField.value.substring(start, end);\n      }\n      if (selectedText[0] !== \"(\" || selectedText[selectedText.length - 1] !== \")\") {\n        selectedText = `(${selectedText})`;\n      }\n      selectedText = addWeightToParentheses(selectedText);\n      const weightDelta = event.key === \"ArrowUp\" ? delta : -delta;\n      const updatedText = selectedText.replace(\n        /\\((.*):([+-]?\\d+(?:\\.\\d+)?)\\)/,\n        (_, text, weight) => {\n          weight = incrementWeight(weight, weightDelta);\n          if (weight == 1) {\n            return text;\n          } else {\n            return `(${text}:${weight})`;\n          }\n        }\n      );\n      inputField.setSelectionRange(start, end);\n      document.execCommand(\"insertText\", false, updatedText);\n      inputField.setSelectionRange(start, start + updatedText.length);\n    }\n    window.addEventListener(\"keydown\", editAttention);\n  }\n});\nconst PYTHON_MIRROR = {\n  settingId: \"Comfy-Desktop.UV.PythonInstallMirror\",\n  mirror: \"https://github.com/astral-sh/python-build-standalone/releases/download\",\n  fallbackMirror: \"https://python-standalone.org/mirror/astral-sh/python-build-standalone\",\n  validationPathSuffix: \"/20250115/cpython-3.10.16+20250115-aarch64-apple-darwin-debug-full.tar.zst.sha256\"\n};\n(async () => {\n  if (!isElectron()) return;\n  const electronAPI$1 = electronAPI();\n  const desktopAppVersion = await electronAPI$1.getElectronVersion();\n  const workflowStore = useWorkflowStore();\n  const toastStore = useToastStore();\n  const onChangeRestartApp = (newValue, oldValue) => {\n    if (oldValue !== void 0 && newValue !== oldValue) {\n      electronAPI$1.restartApp(\"Restart ComfyUI to apply changes.\", 1500);\n    }\n  };\n  app.registerExtension({\n    name: \"Comfy.ElectronAdapter\",\n    settings: [\n      {\n        id: \"Comfy-Desktop.AutoUpdate\",\n        category: [\"Comfy-Desktop\", \"General\", \"AutoUpdate\"],\n        name: \"Automatically check for updates\",\n        type: \"boolean\",\n        defaultValue: true,\n        onChange: onChangeRestartApp\n      },\n      {\n        id: \"Comfy-Desktop.SendStatistics\",\n        category: [\"Comfy-Desktop\", \"General\", \"Send Statistics\"],\n        name: \"Send anonymous usage metrics\",\n        type: \"boolean\",\n        defaultValue: true,\n        onChange: onChangeRestartApp\n      },\n      {\n        id: \"Comfy-Desktop.WindowStyle\",\n        category: [\"Comfy-Desktop\", \"General\", \"Window Style\"],\n        name: \"Window Style\",\n        tooltip: \"Custom: Replace the system title bar with ComfyUI's Top menu\",\n        type: \"combo\",\n        experimental: true,\n        defaultValue: \"default\",\n        options: [\"default\", \"custom\"],\n        onChange: (newValue, oldValue) => {\n          if (!oldValue) return;\n          electronAPI$1.Config.setWindowStyle(newValue);\n        }\n      },\n      {\n        id: \"Comfy-Desktop.UV.PythonInstallMirror\",\n        name: \"Python Install Mirror\",\n        tooltip: `Managed Python installations are downloaded from the Astral python-build-standalone project. This variable can be set to a mirror URL to use a different source for Python installations. The provided URL will replace https://github.com/astral-sh/python-build-standalone/releases/download in, e.g., https://github.com/astral-sh/python-build-standalone/releases/download/20240713/cpython-3.12.4%2B20240713-aarch64-apple-darwin-install_only.tar.gz. Distributions can be read from a local directory by using the file:// URL scheme.`,\n        type: \"url\",\n        defaultValue: \"\",\n        attrs: {\n          validateUrlFn(mirror) {\n            return checkMirrorReachable(\n              mirror + PYTHON_MIRROR.validationPathSuffix\n            );\n          }\n        }\n      },\n      {\n        id: \"Comfy-Desktop.UV.PypiInstallMirror\",\n        name: \"Pypi Install Mirror\",\n        tooltip: `Default pip install mirror`,\n        type: \"url\",\n        defaultValue: \"\",\n        attrs: {\n          validateUrlFn: checkMirrorReachable\n        }\n      },\n      {\n        id: \"Comfy-Desktop.UV.TorchInstallMirror\",\n        name: \"Torch Install Mirror\",\n        tooltip: `Pip install mirror for pytorch`,\n        type: \"url\",\n        defaultValue: \"\",\n        attrs: {\n          validateUrlFn: checkMirrorReachable\n        }\n      }\n    ],\n    commands: [\n      {\n        id: \"Comfy-Desktop.Folders.OpenLogsFolder\",\n        label: \"Open Logs Folder\",\n        icon: \"pi pi-folder-open\",\n        function() {\n          electronAPI$1.openLogsFolder();\n        }\n      },\n      {\n        id: \"Comfy-Desktop.Folders.OpenModelsFolder\",\n        label: \"Open Models Folder\",\n        icon: \"pi pi-folder-open\",\n        function() {\n          electronAPI$1.openModelsFolder();\n        }\n      },\n      {\n        id: \"Comfy-Desktop.Folders.OpenOutputsFolder\",\n        label: \"Open Outputs Folder\",\n        icon: \"pi pi-folder-open\",\n        function() {\n          electronAPI$1.openOutputsFolder();\n        }\n      },\n      {\n        id: \"Comfy-Desktop.Folders.OpenInputsFolder\",\n        label: \"Open Inputs Folder\",\n        icon: \"pi pi-folder-open\",\n        function() {\n          electronAPI$1.openInputsFolder();\n        }\n      },\n      {\n        id: \"Comfy-Desktop.Folders.OpenCustomNodesFolder\",\n        label: \"Open Custom Nodes Folder\",\n        icon: \"pi pi-folder-open\",\n        function() {\n          electronAPI$1.openCustomNodesFolder();\n        }\n      },\n      {\n        id: \"Comfy-Desktop.Folders.OpenModelConfig\",\n        label: \"Open extra_model_paths.yaml\",\n        icon: \"pi pi-file\",\n        function() {\n          electronAPI$1.openModelConfig();\n        }\n      },\n      {\n        id: \"Comfy-Desktop.OpenDevTools\",\n        label: \"Open DevTools\",\n        icon: \"pi pi-code\",\n        function() {\n          electronAPI$1.openDevTools();\n        }\n      },\n      {\n        id: \"Comfy-Desktop.OpenUserGuide\",\n        label: \"Desktop User Guide\",\n        icon: \"pi pi-book\",\n        function() {\n          window.open(\"https://comfyorg.notion.site/\", \"_blank\");\n        }\n      },\n      {\n        id: \"Comfy-Desktop.CheckForUpdates\",\n        label: \"Check for Updates\",\n        icon: \"pi pi-sync\",\n        async function() {\n          try {\n            const updateInfo = await electronAPI$1.checkForUpdates({\n              disableUpdateReadyAction: true\n            });\n            if (!updateInfo.isUpdateAvailable) {\n              toastStore.add({\n                severity: \"info\",\n                summary: t(\"desktopUpdate.noUpdateFound\"),\n                life: 5e3\n              });\n              return;\n            }\n            const proceed = await useDialogService().confirm({\n              title: t(\"desktopUpdate.updateFoundTitle\", {\n                version: updateInfo.version\n              }),\n              message: t(\"desktopUpdate.updateAvailableMessage\"),\n              type: \"default\"\n            });\n            if (proceed) {\n              try {\n                electronAPI$1.restartAndInstall();\n              } catch (error) {\n                log.error(\"Error installing update:\", error);\n                toastStore.add({\n                  severity: \"error\",\n                  summary: t(\"g.error\"),\n                  detail: t(\"desktopUpdate.errorInstallingUpdate\"),\n                  life: 1e4\n                });\n              }\n            }\n          } catch (error) {\n            log.error(\"Error checking for updates:\", error);\n            toastStore.add({\n              severity: \"error\",\n              summary: t(\"g.error\"),\n              detail: t(\"desktopUpdate.errorCheckingUpdate\"),\n              life: 1e4\n            });\n          }\n        }\n      },\n      {\n        id: \"Comfy-Desktop.Reinstall\",\n        label: \"Reinstall\",\n        icon: \"pi pi-refresh\",\n        async function() {\n          const proceed = await useDialogService().confirm({\n            message: t(\"desktopMenu.confirmReinstall\"),\n            title: t(\"desktopMenu.reinstall\"),\n            type: \"reinstall\"\n          });\n          if (proceed) electronAPI$1.reinstall();\n        }\n      },\n      {\n        id: \"Comfy-Desktop.Restart\",\n        label: \"Restart\",\n        icon: \"pi pi-refresh\",\n        function() {\n          electronAPI$1.restartApp();\n        }\n      },\n      {\n        id: \"Comfy-Desktop.Quit\",\n        label: \"Quit\",\n        icon: \"pi pi-sign-out\",\n        async function() {\n          if (workflowStore.modifiedWorkflows.length > 0) {\n            const confirmed = await useDialogService().confirm({\n              message: t(\"desktopMenu.confirmQuit\"),\n              title: t(\"desktopMenu.quit\"),\n              type: \"default\"\n            });\n            if (!confirmed) return;\n          }\n          electronAPI$1.quit();\n        }\n      }\n    ],\n    menuCommands: [\n      {\n        path: [\"Help\"],\n        commands: [\"Comfy-Desktop.OpenUserGuide\"]\n      },\n      {\n        path: [\"Help\"],\n        commands: [\"Comfy-Desktop.OpenDevTools\"]\n      },\n      {\n        path: [\"Help\", \"Open Folder\"],\n        commands: [\n          \"Comfy-Desktop.Folders.OpenLogsFolder\",\n          \"Comfy-Desktop.Folders.OpenModelsFolder\",\n          \"Comfy-Desktop.Folders.OpenOutputsFolder\",\n          \"Comfy-Desktop.Folders.OpenInputsFolder\",\n          \"Comfy-Desktop.Folders.OpenCustomNodesFolder\",\n          \"Comfy-Desktop.Folders.OpenModelConfig\"\n        ]\n      },\n      {\n        path: [\"Help\"],\n        commands: [\"Comfy-Desktop.CheckForUpdates\", \"Comfy-Desktop.Reinstall\"]\n      }\n    ],\n    keybindings: [\n      {\n        commandId: \"Workspace.CloseWorkflow\",\n        combo: {\n          key: \"w\",\n          ctrl: true\n        }\n      }\n    ],\n    aboutPageBadges: [\n      {\n        label: \"ComfyUI_desktop v\" + desktopAppVersion,\n        url: \"https://github.com/Comfy-Org/electron\",\n        icon: \"pi pi-github\"\n      }\n    ]\n  });\n})();\nvar __defProp$n = Object.defineProperty;\nvar __defNormalProp$n = (obj, key, value) => key in obj ? __defProp$n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$n = (obj, key, value) => __defNormalProp$n(obj, key + \"\", value);\nclass ExecutableGroupNodeChildDTO extends ExecutableNodeDTO {\n  constructor(node, subgraphNodePath, nodesByExecutionId, subgraphNode, groupNodeHandler) {\n    super(node, subgraphNodePath, nodesByExecutionId, subgraphNode);\n    __publicField$n(this, \"groupNodeHandler\");\n    this.groupNodeHandler = groupNodeHandler;\n  }\n  resolveInput(slot) {\n    var _a2;\n    const inputNode = this.node.getInputNode(slot);\n    if (!inputNode) return;\n    const link = this.node.getInputLink(slot);\n    if (!link) throw new Error(\"Failed to get input link\");\n    const id2 = String(inputNode.id).split(\":\").at(-1);\n    if (id2 === void 0) throw new Error(\"Invalid input node id\");\n    const inputNodeDto = (_a2 = this.nodesByExecutionId) == null ? void 0 : _a2.get(id2);\n    if (!inputNodeDto) {\n      throw new Error(\n        `Failed to get input node ${id2} for group node child ${this.id} with slot ${slot}`\n      );\n    }\n    return {\n      node: inputNodeDto,\n      origin_id: String(inputNode.id),\n      origin_slot: link.origin_slot\n    };\n  }\n}\nvar __defProp$m = Object.defineProperty;\nvar __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$m = (obj, key, value) => __defNormalProp$m(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nconst ORDER = Symbol();\nconst PREFIX$1 = \"workflow\";\nconst SEPARATOR$1 = \">\";\nfunction merge(target, source) {\n  if (typeof target === \"object\" && typeof source === \"object\") {\n    for (const key in source) {\n      const sv = source[key];\n      if (typeof sv === \"object\") {\n        let tv = target[key];\n        if (!tv) tv = target[key] = {};\n        merge(tv, source[key]);\n      } else {\n        target[key] = sv;\n      }\n    }\n  }\n  return target;\n}\nclass ManageGroupDialog extends ComfyDialog$1 {\n  // @ts-expect-error fixme ts strict error\n  constructor(app2) {\n    super();\n    __publicField$m(this, \"tabs\");\n    __publicField$m(this, \"selectedNodeIndex\");\n    __publicField$m(this, \"selectedTab\", \"Inputs\");\n    __publicField$m(this, \"selectedGroup\");\n    __publicField$m(this, \"modifications\", {});\n    __publicField$m(this, \"nodeItems\");\n    __publicField$m(this, \"app\");\n    __publicField$m(this, \"groupNodeType\");\n    __publicField$m(this, \"groupNodeDef\");\n    __publicField$m(this, \"groupData\");\n    __publicField$m(this, \"innerNodesList\");\n    __publicField$m(this, \"widgetsPage\");\n    __publicField$m(this, \"inputsPage\");\n    __publicField$m(this, \"outputsPage\");\n    __publicField$m(this, \"draggable\");\n    this.app = app2;\n    this.element = $el(\"dialog.comfy-group-manage\", {\n      parent: document.body\n    });\n  }\n  get selectedNodeInnerIndex() {\n    return +this.nodeItems[this.selectedNodeIndex].dataset.nodeindex;\n  }\n  // @ts-expect-error fixme ts strict error\n  changeTab(tab) {\n    this.tabs[this.selectedTab].tab.classList.remove(\"active\");\n    this.tabs[this.selectedTab].page.classList.remove(\"active\");\n    this.tabs[tab].tab.classList.add(\"active\");\n    this.tabs[tab].page.classList.add(\"active\");\n    this.selectedTab = tab;\n  }\n  // @ts-expect-error fixme ts strict error\n  changeNode(index, force) {\n    if (!force && this.selectedNodeIndex === index) return;\n    if (this.selectedNodeIndex != null) {\n      this.nodeItems[this.selectedNodeIndex].classList.remove(\"selected\");\n    }\n    this.nodeItems[index].classList.add(\"selected\");\n    this.selectedNodeIndex = index;\n    if (!this.buildInputsPage() && this.selectedTab === \"Inputs\") {\n      this.changeTab(\"Widgets\");\n    }\n    if (!this.buildWidgetsPage() && this.selectedTab === \"Widgets\") {\n      this.changeTab(\"Outputs\");\n    }\n    if (!this.buildOutputsPage() && this.selectedTab === \"Outputs\") {\n      this.changeTab(\"Inputs\");\n    }\n    this.changeTab(this.selectedTab);\n  }\n  getGroupData() {\n    this.groupNodeType = LiteGraph.registered_node_types[`${PREFIX$1}${SEPARATOR$1}` + this.selectedGroup];\n    this.groupNodeDef = this.groupNodeType.nodeData;\n    this.groupData = GroupNodeHandler.getGroupData(this.groupNodeType);\n  }\n  // @ts-expect-error fixme ts strict error\n  changeGroup(group, reset = true) {\n    var _a2;\n    this.selectedGroup = group;\n    this.getGroupData();\n    const nodes = this.groupData.nodeData.nodes;\n    this.nodeItems = nodes.map(\n      (n, i) => $el(\n        \"li.draggable-item\",\n        {\n          dataset: {\n            nodeindex: n.index + \"\"\n          },\n          onclick: () => {\n            this.changeNode(i);\n          }\n        },\n        [\n          $el(\"span.drag-handle\"),\n          $el(\n            \"div\",\n            {\n              textContent: n.title ?? n.type\n            },\n            n.title ? $el(\"span\", {\n              textContent: n.type\n            }) : []\n          )\n        ]\n      )\n    );\n    this.innerNodesList.replaceChildren(...this.nodeItems);\n    if (reset) {\n      this.selectedNodeIndex = null;\n      this.changeNode(0);\n    } else {\n      const items = this.draggable.getAllItems();\n      let index = items.findIndex((item) => item.classList.contains(\"selected\"));\n      if (index === -1) index = this.selectedNodeIndex;\n      this.changeNode(index, true);\n    }\n    const ordered = [...nodes];\n    (_a2 = this.draggable) == null ? void 0 : _a2.dispose();\n    this.draggable = new DraggableList(this.innerNodesList, \"li\");\n    this.draggable.addEventListener(\n      \"dragend\",\n      // @ts-expect-error fixme ts strict error\n      ({ detail: { oldPosition, newPosition } }) => {\n        if (oldPosition === newPosition) return;\n        ordered.splice(newPosition, 0, ordered.splice(oldPosition, 1)[0]);\n        for (let i = 0; i < ordered.length; i++) {\n          this.storeModification({\n            nodeIndex: ordered[i].index,\n            section: ORDER,\n            prop: \"order\",\n            value: i\n          });\n        }\n      }\n    );\n  }\n  storeModification(props) {\n    var _a2, _b2, _c;\n    const { nodeIndex, section, prop, value } = props;\n    const groupMod = (_a2 = this.modifications)[_b2 = this.selectedGroup] ?? (_a2[_b2] = {});\n    const nodesMod = groupMod.nodes ?? (groupMod.nodes = {});\n    const nodeMod = nodesMod[_c = nodeIndex ?? this.selectedNodeInnerIndex] ?? (nodesMod[_c] = {});\n    const typeMod = nodeMod[section] ?? (nodeMod[section] = {});\n    if (typeof value === \"object\") {\n      const objMod = typeMod[prop] ?? (typeMod[prop] = {});\n      Object.assign(objMod, value);\n    } else {\n      typeMod[prop] = value;\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  getEditElement(section, prop, value, placeholder, checked, checkable = true) {\n    var _a2, _b2, _c, _d;\n    if (value === placeholder) value = \"\";\n    const mods = (\n      // @ts-expect-error fixme ts strict error\n      (_d = (_c = (_b2 = (_a2 = this.modifications[this.selectedGroup]) == null ? void 0 : _a2.nodes) == null ? void 0 : _b2[this.selectedNodeInnerIndex]) == null ? void 0 : _c[section]) == null ? void 0 : _d[prop]\n    );\n    if (mods) {\n      if (mods.name != null) {\n        value = mods.name;\n      }\n      if (mods.visible != null) {\n        checked = mods.visible;\n      }\n    }\n    return $el(\"div\", [\n      $el(\"input\", {\n        value,\n        placeholder,\n        type: \"text\",\n        // @ts-expect-error fixme ts strict error\n        onchange: (e) => {\n          this.storeModification({\n            section,\n            prop,\n            value: { name: e.target.value }\n          });\n        }\n      }),\n      $el(\"label\", { textContent: \"Visible\" }, [\n        $el(\"input\", {\n          type: \"checkbox\",\n          checked,\n          disabled: !checkable,\n          // @ts-expect-error fixme ts strict error\n          onchange: (e) => {\n            this.storeModification({\n              section,\n              prop,\n              value: { visible: !!e.target.checked }\n            });\n          }\n        })\n      ])\n    ]);\n  }\n  buildWidgetsPage() {\n    var _a2, _b2;\n    const widgets = this.groupData.oldToNewWidgetMap[this.selectedNodeInnerIndex];\n    const items = Object.keys(widgets ?? {});\n    const type = app.graph.extra.groupNodes[this.selectedGroup];\n    const config = (_b2 = (_a2 = type.config) == null ? void 0 : _a2[this.selectedNodeInnerIndex]) == null ? void 0 : _b2.input;\n    this.widgetsPage.replaceChildren(\n      ...items.map((oldName) => {\n        var _a3;\n        return this.getEditElement(\n          \"input\",\n          oldName,\n          widgets[oldName],\n          oldName,\n          ((_a3 = config == null ? void 0 : config[oldName]) == null ? void 0 : _a3.visible) !== false\n        );\n      })\n    );\n    return !!items.length;\n  }\n  buildInputsPage() {\n    var _a2, _b2;\n    const inputs = this.groupData.nodeInputs[this.selectedNodeInnerIndex];\n    const items = Object.keys(inputs ?? {});\n    const type = app.graph.extra.groupNodes[this.selectedGroup];\n    const config = (_b2 = (_a2 = type.config) == null ? void 0 : _a2[this.selectedNodeInnerIndex]) == null ? void 0 : _b2.input;\n    this.inputsPage.replaceChildren(\n      ...items.map((oldName) => {\n        var _a3;\n        let value = inputs[oldName];\n        if (!value) {\n          return;\n        }\n        return this.getEditElement(\n          \"input\",\n          oldName,\n          value,\n          oldName,\n          ((_a3 = config == null ? void 0 : config[oldName]) == null ? void 0 : _a3.visible) !== false\n        );\n      }).filter(Boolean)\n    );\n    return !!items.length;\n  }\n  buildOutputsPage() {\n    var _a2, _b2;\n    const nodes = this.groupData.nodeData.nodes;\n    const innerNodeDef = this.groupData.getNodeDef(\n      nodes[this.selectedNodeInnerIndex]\n    );\n    const outputs = (innerNodeDef == null ? void 0 : innerNodeDef.output) ?? [];\n    const groupOutputs = this.groupData.oldToNewOutputMap[this.selectedNodeInnerIndex];\n    const type = app.graph.extra.groupNodes[this.selectedGroup];\n    const config = (_b2 = (_a2 = type.config) == null ? void 0 : _a2[this.selectedNodeInnerIndex]) == null ? void 0 : _b2.output;\n    const node = this.groupData.nodeData.nodes[this.selectedNodeInnerIndex];\n    const checkable = node.type !== \"PrimitiveNode\";\n    this.outputsPage.replaceChildren(\n      ...outputs.map((type2, slot) => {\n        var _a3, _b3, _c;\n        const groupOutputIndex = groupOutputs == null ? void 0 : groupOutputs[slot];\n        const oldName = ((_a3 = innerNodeDef.output_name) == null ? void 0 : _a3[slot]) ?? type2;\n        let value = (_b3 = config == null ? void 0 : config[slot]) == null ? void 0 : _b3.name;\n        const visible = ((_c = config == null ? void 0 : config[slot]) == null ? void 0 : _c.visible) || groupOutputIndex != null;\n        if (!value || value === oldName) {\n          value = \"\";\n        }\n        return this.getEditElement(\n          \"output\",\n          slot,\n          value,\n          oldName,\n          visible,\n          checkable\n        );\n      }).filter(Boolean)\n    );\n    return !!outputs.length;\n  }\n  // @ts-expect-error fixme ts strict error\n  show(type) {\n    var _a2;\n    const groupNodes = Object.keys(((_a2 = app.graph.extra) == null ? void 0 : _a2.groupNodes) ?? {}).sort(\n      (a, b) => a.localeCompare(b)\n    );\n    this.innerNodesList = $el(\n      \"ul.comfy-group-manage-list-items\"\n    );\n    this.widgetsPage = $el(\"section.comfy-group-manage-node-page\");\n    this.inputsPage = $el(\"section.comfy-group-manage-node-page\");\n    this.outputsPage = $el(\"section.comfy-group-manage-node-page\");\n    const pages = $el(\"div\", [\n      this.widgetsPage,\n      this.inputsPage,\n      this.outputsPage\n    ]);\n    this.tabs = [\n      [\"Inputs\", this.inputsPage],\n      [\"Widgets\", this.widgetsPage],\n      [\"Outputs\", this.outputsPage]\n      // @ts-expect-error fixme ts strict error\n    ].reduce((p, [name, page]) => {\n      p[name] = {\n        tab: $el(\"a\", {\n          onclick: () => {\n            this.changeTab(name);\n          },\n          textContent: name\n        }),\n        page\n      };\n      return p;\n    }, {});\n    const outer = $el(\"div.comfy-group-manage-outer\", [\n      $el(\"header\", [\n        $el(\"h2\", \"Group Nodes\"),\n        $el(\n          \"select\",\n          {\n            // @ts-expect-error fixme ts strict error\n            onchange: (e) => {\n              this.changeGroup(e.target.value);\n            }\n          },\n          groupNodes.map(\n            (g) => $el(\"option\", {\n              textContent: g,\n              selected: `${PREFIX$1}${SEPARATOR$1}${g}` === type,\n              value: g\n            })\n          )\n        )\n      ]),\n      $el(\"main\", [\n        $el(\"section.comfy-group-manage-list\", this.innerNodesList),\n        $el(\"section.comfy-group-manage-node\", [\n          $el(\n            \"header\",\n            Object.values(this.tabs).map((t2) => t2.tab)\n          ),\n          pages\n        ])\n      ]),\n      $el(\"footer\", [\n        $el(\n          \"button.comfy-btn\",\n          {\n            onclick: () => {\n              const node = app.graph.nodes.find(\n                (n) => n.type === `${PREFIX$1}${SEPARATOR$1}` + this.selectedGroup\n              );\n              if (node) {\n                useToastStore().addAlert(\n                  \"This group node is in use in the current workflow, please first remove these.\"\n                );\n                return;\n              }\n              if (confirm(\n                `Are you sure you want to remove the node: \"${this.selectedGroup}\"`\n              )) {\n                delete app.graph.extra.groupNodes[this.selectedGroup];\n                LiteGraph.unregisterNodeType(\n                  `${PREFIX$1}${SEPARATOR$1}` + this.selectedGroup\n                );\n              }\n              this.show();\n            }\n          },\n          \"Delete Group Node\"\n        ),\n        $el(\n          \"button.comfy-btn\",\n          {\n            onclick: async () => {\n              var _a3;\n              let nodesByType;\n              let recreateNodes = [];\n              const types = {};\n              for (const g in this.modifications) {\n                const type2 = app.graph.extra.groupNodes[g];\n                let config = type2.config ?? (type2.config = {});\n                let nodeMods = (_a3 = this.modifications[g]) == null ? void 0 : _a3.nodes;\n                if (nodeMods) {\n                  const keys = Object.keys(nodeMods);\n                  if (nodeMods[keys[0]][ORDER]) {\n                    const orderedNodes = [];\n                    const orderedMods = {};\n                    const orderedConfig = {};\n                    for (const n of keys) {\n                      const order = nodeMods[n][ORDER].order;\n                      orderedNodes[order] = type2.nodes[+n];\n                      orderedMods[order] = nodeMods[n];\n                      orderedNodes[order].index = order;\n                    }\n                    for (const l of type2.links) {\n                      if (l[0] != null) l[0] = type2.nodes[l[0]].index;\n                      if (l[2] != null) l[2] = type2.nodes[l[2]].index;\n                    }\n                    if (type2.external) {\n                      for (const ext2 of type2.external) {\n                        ext2[0] = type2.nodes[ext2[0]];\n                      }\n                    }\n                    for (const id2 of keys) {\n                      if (config[id2]) {\n                        orderedConfig[type2.nodes[id2].index] = config[id2];\n                      }\n                      delete config[id2];\n                    }\n                    type2.nodes = orderedNodes;\n                    nodeMods = orderedMods;\n                    type2.config = config = orderedConfig;\n                  }\n                  merge(config, nodeMods);\n                }\n                types[g] = type2;\n                if (!nodesByType) {\n                  nodesByType = app.graph.nodes.reduce((p, n) => {\n                    var _a4;\n                    p[_a4 = n.type] ?? (p[_a4] = []);\n                    p[n.type].push(n);\n                    return p;\n                  }, {});\n                }\n                const nodes = nodesByType[`${PREFIX$1}${SEPARATOR$1}` + g];\n                if (nodes) recreateNodes.push(...nodes);\n              }\n              await GroupNodeConfig.registerFromWorkflow(types, {});\n              for (const node of recreateNodes) {\n                node.recreate();\n              }\n              this.modifications = {};\n              this.app.graph.setDirtyCanvas(true, true);\n              this.changeGroup(this.selectedGroup, false);\n            }\n          },\n          \"Save\"\n        ),\n        $el(\n          \"button.comfy-btn\",\n          { onclick: () => this.element.close() },\n          \"Close\"\n        )\n      ])\n    ]);\n    this.element.replaceChildren(outer);\n    this.changeGroup(\n      type ? groupNodes.find((g) => `${PREFIX$1}${SEPARATOR$1}${g}` === type) ?? groupNodes[0] : groupNodes[0]\n    );\n    this.element.showModal();\n    this.element.addEventListener(\"close\", () => {\n      var _a3;\n      (_a3 = this.draggable) == null ? void 0 : _a3.dispose();\n      this.element.remove();\n    });\n  }\n}\nconst gcd = (a, b) => {\n  return b === 0 ? a : gcd(b, a % b);\n};\nconst lcm = (a, b) => {\n  return Math.abs(a * b) / gcd(a, b);\n};\nconst IGNORE_KEYS = /* @__PURE__ */ new Set([\n  \"default\",\n  \"forceInput\",\n  \"defaultInput\",\n  \"control_after_generate\",\n  \"multiline\",\n  \"tooltip\",\n  \"dynamicPrompts\"\n]);\nconst getRange = (options) => {\n  const min = options.min ?? -Infinity;\n  const max2 = options.max ?? Infinity;\n  return { min, max: max2 };\n};\nconst mergeNumericInputSpec = (spec1, spec2) => {\n  const type = spec1[0];\n  const options1 = spec1[1] ?? {};\n  const options2 = spec2[1] ?? {};\n  const range1 = getRange(options1);\n  const range2 = getRange(options2);\n  if (range1.min > range2.max || range1.max < range2.min) {\n    return null;\n  }\n  const step1 = options1.step ?? 1;\n  const step2 = options2.step ?? 1;\n  const mergedOptions = {\n    // Take intersection of ranges\n    min: Math.max(range1.min, range2.min),\n    max: Math.min(range1.max, range2.max),\n    step: lcm(step1, step2)\n  };\n  return mergeCommonInputSpec(\n    [type, { ...options1, ...mergedOptions }],\n    [type, { ...options2, ...mergedOptions }]\n  );\n};\nconst mergeComboInputSpec = (spec1, spec2) => {\n  const options1 = spec1[1] ?? {};\n  const options2 = spec2[1] ?? {};\n  const comboOptions1 = getComboSpecComboOptions(spec1);\n  const comboOptions2 = getComboSpecComboOptions(spec2);\n  const intersection = toolkit.intersection(comboOptions1, comboOptions2);\n  if (intersection.length === 0) {\n    return null;\n  }\n  return mergeCommonInputSpec(\n    [\"COMBO\", { ...options1, options: intersection }],\n    [\"COMBO\", { ...options2, options: intersection }]\n  );\n};\nconst mergeCommonInputSpec = (spec1, spec2) => {\n  const type = getInputSpecType(spec1);\n  const options1 = spec1[1] ?? {};\n  const options2 = spec2[1] ?? {};\n  const compareKeys = toolkit.union(toolkit.keys(options1), toolkit.keys(options2)).filter(\n    (key) => !IGNORE_KEYS.has(key)\n  );\n  const mergeIsValid = compareKeys.every((key) => {\n    const value1 = options1[key];\n    const value2 = options2[key];\n    return value1 === value2 || toolkit.isNil(value1) && toolkit.isNil(value2);\n  });\n  return mergeIsValid ? [type, { ...options1, ...options2 }] : null;\n};\nconst mergeInputSpec = (spec1, spec2) => {\n  const type1 = getInputSpecType(spec1);\n  const type2 = getInputSpecType(spec2);\n  if (type1 !== type2) {\n    return null;\n  }\n  if (isIntInputSpec(spec1) || isFloatInputSpec(spec1)) {\n    return mergeNumericInputSpec(spec1, spec2);\n  }\n  if (isComboInputSpec(spec1)) {\n    return mergeComboInputSpec(spec1, spec2);\n  }\n  return mergeCommonInputSpec(spec1, spec2);\n};\nvar __defProp$l = Object.defineProperty;\nvar __typeError$1 = (msg) => {\n  throw TypeError(msg);\n};\nvar __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$l = (obj, key, value) => __defNormalProp$l(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar __accessCheck$1 = (obj, member, msg) => member.has(obj) || __typeError$1(\"Cannot \" + msg);\nvar __privateAdd$1 = (obj, member, value) => member.has(obj) ? __typeError$1(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateMethod = (obj, member, method) => (__accessCheck$1(obj, member, \"access private method\"), method);\nvar _PrimitiveNode_instances, onFirstConnection_fn, createWidget_fn, mergeWidgetConfig_fn, isValidConnection_fn, removeWidgets_fn;\nconst replacePropertyName = \"Run widget replace on values\";\nclass PrimitiveNode extends LGraphNode {\n  constructor(title) {\n    super(title);\n    __privateAdd$1(this, _PrimitiveNode_instances);\n    __publicField$l(this, \"controlValues\");\n    __publicField$l(this, \"lastType\");\n    this.addOutput(\"connect to widget input\", \"*\");\n    this.serialize_widgets = true;\n    this.isVirtualNode = true;\n    if (!this.properties || !(replacePropertyName in this.properties)) {\n      this.addProperty(replacePropertyName, false, \"boolean\");\n    }\n  }\n  applyToGraph(extraLinks = []) {\n    var _a2, _b2, _c, _d, _e, _f;\n    if (!((_a2 = this.outputs[0].links) == null ? void 0 : _a2.length)) return;\n    const links = [\n      ...this.outputs[0].links.map((l) => app.graph.links[l]),\n      ...extraLinks\n    ];\n    let v = (_b2 = this.widgets) == null ? void 0 : _b2[0].value;\n    if (v && this.properties[replacePropertyName]) {\n      v = applyTextReplacements(app.graph, v);\n    }\n    for (const linkInfo of links) {\n      const node = (_c = this.graph) == null ? void 0 : _c.getNodeById(linkInfo.target_id);\n      const input = node == null ? void 0 : node.inputs[linkInfo.target_slot];\n      if (!input) {\n        console.warn(\"Unable to resolve node or input for link\", linkInfo);\n        continue;\n      }\n      const widgetName = (_d = input.widget) == null ? void 0 : _d.name;\n      if (!widgetName) {\n        console.warn(\"Invalid widget or widget name\", input.widget);\n        continue;\n      }\n      const widget = (_e = node.widgets) == null ? void 0 : _e.find((w) => w.name === widgetName);\n      if (!widget) {\n        console.warn(\n          `Unable to find widget \"${widgetName}\" on node [${node.id}]`\n        );\n        continue;\n      }\n      widget.value = v;\n      (_f = widget.callback) == null ? void 0 : _f.call(\n        widget,\n        widget.value,\n        app.canvas,\n        node,\n        app.canvas.graph_mouse,\n        {}\n      );\n    }\n  }\n  refreshComboInNode() {\n    var _a2;\n    const widget = (_a2 = this.widgets) == null ? void 0 : _a2[0];\n    if ((widget == null ? void 0 : widget.type) === \"combo\") {\n      widget.options.values = this.outputs[0].widget[GET_CONFIG]()[0];\n      if (!widget.options.values.includes(widget.value)) {\n        widget.value = widget.options.values[0];\n        widget.callback(widget.value);\n      }\n    }\n  }\n  onAfterGraphConfigured() {\n    var _a2, _b2;\n    if (((_a2 = this.outputs[0].links) == null ? void 0 : _a2.length) && !((_b2 = this.widgets) == null ? void 0 : _b2.length)) {\n      __privateMethod(this, _PrimitiveNode_instances, onFirstConnection_fn).call(this);\n      if (this.widgets && this.widgets_values) {\n        for (let i = 0; i < this.widgets_values.length; i++) {\n          const w = this.widgets[i];\n          if (w) {\n            w.value = this.widgets_values[i];\n          }\n        }\n      }\n      __privateMethod(this, _PrimitiveNode_instances, mergeWidgetConfig_fn).call(this);\n    }\n  }\n  onConnectionsChange(_type, _index, connected) {\n    var _a2;\n    if (app.configuringGraph) {\n      return;\n    }\n    const links = this.outputs[0].links;\n    if (connected) {\n      if ((links == null ? void 0 : links.length) && !((_a2 = this.widgets) == null ? void 0 : _a2.length)) {\n        __privateMethod(this, _PrimitiveNode_instances, onFirstConnection_fn).call(this);\n      }\n    } else {\n      __privateMethod(this, _PrimitiveNode_instances, mergeWidgetConfig_fn).call(this);\n      if (!(links == null ? void 0 : links.length)) {\n        this.onLastDisconnect();\n      }\n    }\n  }\n  onConnectOutput(slot, _type, input, target_node, target_slot) {\n    var _a2;\n    if (!input.widget && !(input.type in ComfyWidgets)) {\n      return false;\n    }\n    if ((_a2 = this.outputs[slot].links) == null ? void 0 : _a2.length) {\n      const valid = __privateMethod(this, _PrimitiveNode_instances, isValidConnection_fn).call(this, input);\n      if (valid) {\n        this.applyToGraph([{ target_id: target_node.id, target_slot }]);\n      }\n      return valid;\n    }\n    return true;\n  }\n  recreateWidget() {\n    var _a2, _b2;\n    const values = (_a2 = this.widgets) == null ? void 0 : _a2.map((w) => w.value);\n    __privateMethod(this, _PrimitiveNode_instances, removeWidgets_fn).call(this);\n    __privateMethod(this, _PrimitiveNode_instances, onFirstConnection_fn).call(this, true);\n    if ((values == null ? void 0 : values.length) && this.widgets) {\n      for (let i = 0; i < this.widgets.length; i++)\n        this.widgets[i].value = values[i];\n    }\n    return (_b2 = this.widgets) == null ? void 0 : _b2[0];\n  }\n  onLastDisconnect() {\n    this.outputs[0].type = \"*\";\n    this.outputs[0].name = \"connect to widget input\";\n    delete this.outputs[0].widget;\n    __privateMethod(this, _PrimitiveNode_instances, removeWidgets_fn).call(this);\n  }\n}\n_PrimitiveNode_instances = /* @__PURE__ */ new WeakSet();\nonFirstConnection_fn = function(recreating) {\n  var _a2;\n  if (!this.outputs[0].links) {\n    this.onLastDisconnect();\n    return;\n  }\n  const linkId = this.outputs[0].links[0];\n  const link = this.graph.links[linkId];\n  if (!link) return;\n  const theirNode = this.graph.getNodeById(link.target_id);\n  if (!theirNode || !theirNode.inputs) return;\n  const input = theirNode.inputs[link.target_slot];\n  if (!input) return;\n  let widget;\n  if (!input.widget) {\n    if (!(input.type in ComfyWidgets)) return;\n    widget = { name: input.name, [GET_CONFIG]: () => [input.type, {}] };\n  } else {\n    widget = input.widget;\n  }\n  const config = (_a2 = widget[GET_CONFIG]) == null ? void 0 : _a2.call(widget);\n  if (!config) return;\n  const { type } = getWidgetType(config);\n  this.outputs[0].type = type;\n  this.outputs[0].name = type;\n  this.outputs[0].widget = widget;\n  __privateMethod(this, _PrimitiveNode_instances, createWidget_fn).call(\n    this,\n    widget[CONFIG] ?? config,\n    theirNode,\n    widget.name,\n    // @ts-expect-error fixme ts strict error\n    recreating\n  );\n};\ncreateWidget_fn = function(inputData, node, widgetName, recreating) {\n  var _a2, _b2, _c, _d;\n  let type = inputData[0];\n  if (type instanceof Array) {\n    type = \"COMBO\";\n  }\n  const [oldWidth, oldHeight] = this.size;\n  let widget;\n  if (type in ComfyWidgets) {\n    widget = (ComfyWidgets[type](this, \"value\", inputData, app) || {}).widget;\n  } else {\n    widget = this.addWidget(type, \"value\", null, () => {\n    }, {});\n  }\n  if ((node == null ? void 0 : node.widgets) && widget) {\n    const theirWidget = node.widgets.find((w) => w.name === widgetName);\n    if (theirWidget) {\n      widget.value = theirWidget.value;\n    }\n  }\n  if (!((_a2 = inputData == null ? void 0 : inputData[1]) == null ? void 0 : _a2.control_after_generate) && (widget.type === \"number\" || widget.type === \"combo\")) {\n    let control_value = (_b2 = this.widgets_values) == null ? void 0 : _b2[1];\n    if (!control_value) {\n      control_value = \"fixed\";\n    }\n    addValueControlWidgets(\n      this,\n      widget,\n      control_value,\n      void 0,\n      inputData\n    );\n    let filter = (_c = this.widgets_values) == null ? void 0 : _c[2];\n    if (filter && this.widgets && this.widgets.length === 3) {\n      this.widgets[2].value = filter;\n    }\n  }\n  const controlValues = this.controlValues;\n  if (this.widgets && this.lastType === ((_d = this.widgets[0]) == null ? void 0 : _d.type) && (controlValues == null ? void 0 : controlValues.length) === this.widgets.length - 1) {\n    for (let i = 0; i < controlValues.length; i++) {\n      this.widgets[i + 1].value = controlValues[i];\n    }\n  }\n  widget.callback = useChainCallback(widget.callback, () => {\n    this.applyToGraph();\n  });\n  this.setSize([\n    Math.max(this.size[0], oldWidth),\n    Math.max(this.size[1], oldHeight)\n  ]);\n  if (!recreating) {\n    const sz = this.computeSize();\n    if (this.size[0] < sz[0]) {\n      this.size[0] = sz[0];\n    }\n    if (this.size[1] < sz[1]) {\n      this.size[1] = sz[1];\n    }\n    requestAnimationFrame(() => {\n      var _a3;\n      (_a3 = this.onResize) == null ? void 0 : _a3.call(this, this.size);\n    });\n  }\n};\nmergeWidgetConfig_fn = function() {\n  var _a2, _b2, _c, _d;\n  const output = this.outputs[0];\n  const links = output.links ?? [];\n  const hasConfig = !!((_a2 = output.widget) == null ? void 0 : _a2[CONFIG]);\n  if (hasConfig) {\n    (_b2 = output.widget) == null ? true : delete _b2[CONFIG];\n  }\n  if ((links == null ? void 0 : links.length) < 2 && hasConfig) {\n    if (links.length) {\n      this.recreateWidget();\n    }\n    return;\n  }\n  const config1 = (_d = (_c = output.widget) == null ? void 0 : _c[GET_CONFIG]) == null ? void 0 : _d.call(_c);\n  if (!config1) return;\n  const isNumber = config1[0] === \"INT\" || config1[0] === \"FLOAT\";\n  if (!isNumber) return;\n  for (const linkId of links) {\n    const link = app.graph.links[linkId];\n    if (!link) continue;\n    const theirNode = app.graph.getNodeById(link.target_id);\n    if (!theirNode) continue;\n    const theirInput = theirNode.inputs[link.target_slot];\n    __privateMethod(this, _PrimitiveNode_instances, isValidConnection_fn).call(this, theirInput, hasConfig);\n  }\n};\nisValidConnection_fn = function(input, forceUpdate) {\n  var _a2, _b2, _c;\n  const output = (_a2 = this.outputs) == null ? void 0 : _a2[0];\n  const config2 = (_c = (_b2 = input.widget) == null ? void 0 : _b2[GET_CONFIG]) == null ? void 0 : _c.call(_b2);\n  if (!config2) return false;\n  return !!mergeIfValid.call(\n    this,\n    output,\n    config2,\n    forceUpdate,\n    this.recreateWidget\n  );\n};\nremoveWidgets_fn = function() {\n  var _a2;\n  if (this.widgets) {\n    for (const w of this.widgets) {\n      if (w.onRemove) {\n        w.onRemove();\n      }\n    }\n    this.controlValues = [];\n    this.lastType = (_a2 = this.widgets[0]) == null ? void 0 : _a2.type;\n    for (let i = 1; i < this.widgets.length; i++) {\n      this.controlValues.push(this.widgets[i].value);\n    }\n    setTimeout(() => {\n      delete this.lastType;\n      delete this.controlValues;\n    }, 15);\n    this.widgets.length = 0;\n  }\n};\n__publicField$l(PrimitiveNode, \"category\");\nfunction getWidgetConfig(slot) {\n  var _a2, _b2, _c;\n  return ((_a2 = slot.widget) == null ? void 0 : _a2[CONFIG]) ?? ((_c = (_b2 = slot.widget) == null ? void 0 : _b2[GET_CONFIG]) == null ? void 0 : _c.call(_b2)) ?? [\n    \"*\",\n    {}\n  ];\n}\nfunction getConfig(widgetName) {\n  var _a2, _b2, _c, _d;\n  const { nodeData } = this.constructor;\n  return ((_b2 = (_a2 = nodeData == null ? void 0 : nodeData.input) == null ? void 0 : _a2.required) == null ? void 0 : _b2[widgetName]) ?? ((_d = (_c = nodeData == null ? void 0 : nodeData.input) == null ? void 0 : _c.optional) == null ? void 0 : _d[widgetName]);\n}\nfunction getWidgetType(config) {\n  let type = config[0];\n  if (type instanceof Array) {\n    type = \"COMBO\";\n  }\n  return { type };\n}\nfunction setWidgetConfig(slot, config) {\n  if (!slot.widget) return;\n  if (config) {\n    slot.widget[GET_CONFIG] = () => config;\n  } else {\n    delete slot.widget;\n  }\n  if (\"link\" in slot) {\n    const link = app.graph.links[slot.link ?? -1];\n    if (link) {\n      const originNode = app.graph.getNodeById(link.origin_id);\n      if (originNode && isPrimitiveNode(originNode)) {\n        if (config) {\n          originNode.recreateWidget();\n        } else if (!app.configuringGraph) {\n          originNode.disconnectOutput(0);\n          originNode.onLastDisconnect();\n        }\n      }\n    }\n  }\n}\nfunction mergeIfValid(output, config2, forceUpdate, recreateWidget, config1) {\n  if (!config1) {\n    config1 = getWidgetConfig(output);\n  }\n  const customSpec = mergeInputSpec(config1, config2);\n  if (customSpec || forceUpdate) {\n    if (customSpec) {\n      output.widget[CONFIG] = customSpec;\n    }\n    const widget = recreateWidget == null ? void 0 : recreateWidget.call(this);\n    if (widget) {\n      const min = widget.options.min;\n      const max2 = widget.options.max;\n      if (min != null && widget.value < min) widget.value = min;\n      if (max2 != null && widget.value > max2) widget.value = max2;\n      widget.callback(widget.value);\n    }\n  }\n  return { customConfig: (customSpec == null ? void 0 : customSpec[1]) ?? {} };\n}\napp.registerExtension({\n  name: \"Comfy.WidgetInputs\",\n  async beforeRegisterNodeDef(nodeType, _nodeData, app2) {\n    nodeType.prototype.convertWidgetToInput = function() {\n      console.warn(\n        \"Please remove call to convertWidgetToInput. Widget to socket conversion is no longer necessary, as they co-exist now.\"\n      );\n      return false;\n    };\n    nodeType.prototype.onGraphConfigured = useChainCallback(\n      nodeType.prototype.onGraphConfigured,\n      function() {\n        var _a2;\n        if (!this.inputs) return;\n        this.widgets ?? (this.widgets = []);\n        for (const input of this.inputs) {\n          if (input.widget) {\n            const name = input.widget.name;\n            if (!input.widget[GET_CONFIG]) {\n              input.widget[GET_CONFIG] = () => getConfig.call(this, name);\n            }\n            const w = (_a2 = this.widgets) == null ? void 0 : _a2.find((w2) => w2.name === name);\n            if (!w) {\n              this.removeInput(this.inputs.findIndex((i) => i === input));\n            }\n          }\n        }\n      }\n    );\n    nodeType.prototype.onConfigure = useChainCallback(\n      nodeType.prototype.onConfigure,\n      function() {\n        if (!app2.configuringGraph && this.inputs) {\n          for (const input of this.inputs) {\n            if (input.widget && !input.widget[GET_CONFIG]) {\n              const name = input.widget.name;\n              input.widget[GET_CONFIG] = () => getConfig.call(this, name);\n            }\n          }\n        }\n      }\n    );\n    function isNodeAtPos(pos) {\n      for (const n of app2.graph.nodes) {\n        if (n.pos[0] === pos[0] && n.pos[1] === pos[1]) {\n          return true;\n        }\n      }\n      return false;\n    }\n    const origOnInputDblClick = nodeType.prototype.onInputDblClick;\n    nodeType.prototype.onInputDblClick = function(...[slot, ...args]) {\n      var _a2, _b2, _c;\n      const r = origOnInputDblClick == null ? void 0 : origOnInputDblClick.apply(this, [slot, ...args]);\n      const input = this.inputs[slot];\n      if (!input.widget) {\n        if (!(input.type in ComfyWidgets) && !(((_c = (_b2 = (_a2 = input.widget) == null ? void 0 : _a2[GET_CONFIG]) == null ? void 0 : _b2.call(_a2)) == null ? void 0 : _c[0]) instanceof Array)) {\n          return r;\n        }\n      }\n      const node = LiteGraph.createNode(\"PrimitiveNode\");\n      if (!node) return r;\n      app2.graph.add(node);\n      const pos = [\n        this.pos[0] - node.size[0] - 30,\n        this.pos[1]\n      ];\n      while (isNodeAtPos(pos)) {\n        pos[1] += LiteGraph.NODE_TITLE_HEIGHT;\n      }\n      node.pos = pos;\n      node.connect(0, this, slot);\n      node.title = input.name;\n      return r;\n    };\n  },\n  registerCustomNodes() {\n    LiteGraph.registerNodeType(\n      \"PrimitiveNode\",\n      Object.assign(PrimitiveNode, {\n        title: \"Primitive\"\n      })\n    );\n    PrimitiveNode.category = \"utils\";\n  }\n});\nvar __defProp$k = Object.defineProperty;\nvar __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$k = (obj, key, value) => __defNormalProp$k(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), member.set(obj, value), value);\nvar _convertedToProcess;\nconst PREFIX = \"workflow\";\nconst SEPARATOR = \">\";\nconst Workflow = {\n  InUse: {\n    Free: 0,\n    Registered: 1,\n    InWorkflow: 2\n  },\n  // @ts-expect-error fixme ts strict error\n  isInUseGroupNode(name) {\n    var _a2, _b2;\n    const id2 = `${PREFIX}${SEPARATOR}${name}`;\n    if ((_b2 = (_a2 = app.graph.extra) == null ? void 0 : _a2.groupNodes) == null ? void 0 : _b2[name]) {\n      if (app.graph.nodes.find((n) => n.type === id2)) {\n        return Workflow.InUse.InWorkflow;\n      } else {\n        return Workflow.InUse.Registered;\n      }\n    }\n    return Workflow.InUse.Free;\n  },\n  storeGroupNode(name, data) {\n    let extra = app.graph.extra;\n    if (!extra) app.graph.extra = extra = {};\n    let groupNodes = extra.groupNodes;\n    if (!groupNodes) extra.groupNodes = groupNodes = {};\n    groupNodes[name] = data;\n  }\n};\nclass GroupNodeBuilder {\n  constructor(nodes) {\n    __publicField$k(this, \"nodes\");\n    __publicField$k(this, \"nodeData\");\n    this.nodes = nodes;\n  }\n  async build() {\n    const name = await this.getName();\n    if (!name) return;\n    this.sortNodes();\n    this.nodeData = this.getNodeData();\n    Workflow.storeGroupNode(name, this.nodeData);\n    return { name, nodeData: this.nodeData };\n  }\n  async getName() {\n    const name = await useDialogService().prompt({\n      title: t(\"groupNode.create\"),\n      message: t(\"groupNode.enterName\"),\n      defaultValue: \"\"\n    });\n    if (!name) return;\n    const used = Workflow.isInUseGroupNode(name);\n    switch (used) {\n      case Workflow.InUse.InWorkflow:\n        useToastStore().addAlert(\n          \"An in use group node with this name already exists embedded in this workflow, please remove any instances or use a new name.\"\n        );\n        return;\n      case Workflow.InUse.Registered:\n        if (!confirm(\n          \"A group node with this name already exists embedded in this workflow, are you sure you want to overwrite it?\"\n        )) {\n          return;\n        }\n        break;\n    }\n    return name;\n  }\n  sortNodes() {\n    const nodesInOrder = app.graph.computeExecutionOrder(false);\n    this.nodes = this.nodes.map((node) => ({ index: nodesInOrder.indexOf(node), node })).sort((a, b) => a.index - b.index || a.node.id - b.node.id).map(({ node }) => node);\n  }\n  getNodeData() {\n    const storeLinkTypes = (config) => {\n      for (const link of config.links) {\n        const origin = app.graph.getNodeById(link[4]);\n        const type = origin.outputs[link[1]].type;\n        link.push(type);\n      }\n    };\n    const storeExternalLinks = (config) => {\n      var _a2, _b2;\n      config.external = [];\n      for (let i = 0; i < this.nodes.length; i++) {\n        const node = this.nodes[i];\n        if (!((_a2 = node.outputs) == null ? void 0 : _a2.length)) continue;\n        for (let slot = 0; slot < node.outputs.length; slot++) {\n          let hasExternal = false;\n          const output = node.outputs[slot];\n          let type = output.type;\n          if (!((_b2 = output.links) == null ? void 0 : _b2.length)) continue;\n          for (const l of output.links) {\n            const link = app.graph.links[l];\n            if (!link) continue;\n            if (type === \"*\") type = link.type;\n            if (!app.canvas.selected_nodes[link.target_id]) {\n              hasExternal = true;\n              break;\n            }\n          }\n          if (hasExternal) {\n            config.external.push([i, slot, type]);\n          }\n        }\n      }\n    };\n    try {\n      const serialised = serialise(this.nodes, app.canvas.graph);\n      const config = JSON.parse(serialised);\n      storeLinkTypes(config);\n      storeExternalLinks(config);\n      return config;\n    } finally {\n    }\n  }\n}\nconst _GroupNodeConfig = class _GroupNodeConfig2 {\n  // @ts-expect-error fixme ts strict error\n  constructor(name, nodeData) {\n    __publicField$k(this, \"name\");\n    __publicField$k(this, \"nodeData\");\n    __publicField$k(this, \"inputCount\");\n    __publicField$k(this, \"oldToNewOutputMap\");\n    __publicField$k(this, \"newToOldOutputMap\");\n    __publicField$k(this, \"oldToNewInputMap\");\n    __publicField$k(this, \"oldToNewWidgetMap\");\n    __publicField$k(this, \"newToOldWidgetMap\");\n    __publicField$k(this, \"primitiveDefs\");\n    __publicField$k(this, \"widgetToPrimitive\");\n    __publicField$k(this, \"primitiveToWidget\");\n    __publicField$k(this, \"nodeInputs\");\n    __publicField$k(this, \"outputVisibility\");\n    __publicField$k(this, \"nodeDef\");\n    __publicField$k(this, \"inputs\");\n    __publicField$k(this, \"linksFrom\");\n    __publicField$k(this, \"linksTo\");\n    __publicField$k(this, \"externalFrom\");\n    __privateAdd(this, _convertedToProcess, []);\n    this.name = name;\n    this.nodeData = nodeData;\n    this.getLinks();\n    this.inputCount = 0;\n    this.oldToNewOutputMap = {};\n    this.newToOldOutputMap = {};\n    this.oldToNewInputMap = {};\n    this.oldToNewWidgetMap = {};\n    this.newToOldWidgetMap = {};\n    this.primitiveDefs = {};\n    this.widgetToPrimitive = {};\n    this.primitiveToWidget = {};\n    this.nodeInputs = {};\n    this.outputVisibility = [];\n  }\n  async registerType(source = PREFIX) {\n    this.nodeDef = {\n      output: [],\n      output_name: [],\n      output_is_list: [],\n      // @ts-expect-error Unused, doesn't exist\n      output_is_hidden: [],\n      name: source + SEPARATOR + this.name,\n      display_name: this.name,\n      category: \"group nodes\" + (SEPARATOR + source),\n      input: { required: {} },\n      description: `Group node combining ${this.nodeData.nodes.map((n) => n.type).join(\", \")}`,\n      python_module: \"custom_nodes.\" + this.name,\n      [GROUP]: this\n    };\n    this.inputs = [];\n    const seenInputs = {};\n    const seenOutputs = {};\n    for (let i = 0; i < this.nodeData.nodes.length; i++) {\n      const node = this.nodeData.nodes[i];\n      node.index = i;\n      this.processNode(node, seenInputs, seenOutputs);\n    }\n    for (const p of __privateGet(this, _convertedToProcess)) {\n      p();\n    }\n    __privateSet(this, _convertedToProcess, null);\n    await app.registerNodeDef(`${PREFIX}${SEPARATOR}` + this.name, this.nodeDef);\n    useNodeDefStore().addNodeDef(this.nodeDef);\n  }\n  getLinks() {\n    this.linksFrom = {};\n    this.linksTo = {};\n    this.externalFrom = {};\n    for (const l of this.nodeData.links) {\n      const [sourceNodeId, sourceNodeSlot, targetNodeId, targetNodeSlot] = l;\n      if (sourceNodeId == null) continue;\n      if (!this.linksFrom[sourceNodeId]) {\n        this.linksFrom[sourceNodeId] = {};\n      }\n      if (!this.linksFrom[sourceNodeId][sourceNodeSlot]) {\n        this.linksFrom[sourceNodeId][sourceNodeSlot] = [];\n      }\n      this.linksFrom[sourceNodeId][sourceNodeSlot].push(l);\n      if (!this.linksTo[targetNodeId]) {\n        this.linksTo[targetNodeId] = {};\n      }\n      this.linksTo[targetNodeId][targetNodeSlot] = l;\n    }\n    if (this.nodeData.external) {\n      for (const ext2 of this.nodeData.external) {\n        if (!this.externalFrom[ext2[0]]) {\n          this.externalFrom[ext2[0]] = { [ext2[1]]: ext2[2] };\n        } else {\n          this.externalFrom[ext2[0]][ext2[1]] = ext2[2];\n        }\n      }\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  processNode(node, seenInputs, seenOutputs) {\n    var _a2, _b2, _c;\n    const def = this.getNodeDef(node);\n    if (!def) return;\n    const inputs = { ...(_a2 = def.input) == null ? void 0 : _a2.required, ...(_b2 = def.input) == null ? void 0 : _b2.optional };\n    this.inputs.push(this.processNodeInputs(node, seenInputs, inputs));\n    if ((_c = def.output) == null ? void 0 : _c.length) this.processNodeOutputs(node, seenOutputs, def);\n  }\n  // @ts-expect-error fixme ts strict error\n  getNodeDef(node) {\n    var _a2, _b2;\n    const def = globalDefs[node.type];\n    if (def) return def;\n    const linksFrom = this.linksFrom[node.index];\n    if (node.type === \"PrimitiveNode\") {\n      if (!linksFrom) return;\n      let type = linksFrom[\"0\"][0][5];\n      if (type === \"COMBO\") {\n        const source = node.outputs[0].widget.name;\n        const fromTypeName = this.nodeData.nodes[linksFrom[\"0\"][0][2]].type;\n        const fromType = globalDefs[fromTypeName];\n        const input = fromType.input.required[source] ?? fromType.input.optional[source];\n        type = input[0];\n      }\n      const def2 = this.primitiveDefs[node.index] = {\n        input: {\n          required: {\n            value: [type, {}]\n          }\n        },\n        output: [type],\n        output_name: [],\n        output_is_list: []\n      };\n      return def2;\n    } else if (node.type === \"Reroute\") {\n      const linksTo = this.linksTo[node.index];\n      if (linksTo && linksFrom && !((_a2 = this.externalFrom[node.index]) == null ? void 0 : _a2[0])) {\n        return null;\n      }\n      let config = {};\n      let rerouteType = \"*\";\n      if (linksFrom) {\n        for (const [, , id2, slot] of linksFrom[\"0\"]) {\n          const node2 = this.nodeData.nodes[id2];\n          const input = node2.inputs[slot];\n          if (rerouteType === \"*\") {\n            rerouteType = input.type;\n          }\n          if (input.widget) {\n            const targetDef = globalDefs[node2.type];\n            const targetWidget = targetDef.input.required[input.widget.name] ?? targetDef.input.optional[input.widget.name];\n            const widget = [targetWidget[0], config];\n            const res = mergeIfValid(\n              {\n                // @ts-expect-error fixme ts strict error\n                widget\n              },\n              targetWidget,\n              false,\n              null,\n              widget\n            );\n            config = (res == null ? void 0 : res.customConfig) ?? config;\n          }\n        }\n      } else if (linksTo) {\n        const [id2, slot] = linksTo[\"0\"];\n        rerouteType = this.nodeData.nodes[id2].outputs[slot].type;\n      } else {\n        for (const l of this.nodeData.links) {\n          if (l[2] === node.index) {\n            rerouteType = l[5];\n            break;\n          }\n        }\n        if (rerouteType === \"*\") {\n          const t2 = (_b2 = this.externalFrom[node.index]) == null ? void 0 : _b2[0];\n          if (t2) {\n            rerouteType = t2;\n          }\n        }\n      }\n      config.forceInput = true;\n      return {\n        input: {\n          required: {\n            [rerouteType]: [rerouteType, config]\n          }\n        },\n        output: [rerouteType],\n        output_name: [],\n        output_is_list: []\n      };\n    }\n    console.warn(\n      \"Skipping virtual node \" + node.type + \" when building group node \" + this.name\n    );\n  }\n  // @ts-expect-error fixme ts strict error\n  getInputConfig(node, inputName, seenInputs, config, extra) {\n    var _a2, _b2, _c, _d, _e, _f, _g;\n    const customConfig = (_c = (_b2 = (_a2 = this.nodeData.config) == null ? void 0 : _a2[node.index]) == null ? void 0 : _b2.input) == null ? void 0 : _c[inputName];\n    let name = (customConfig == null ? void 0 : customConfig.name) ?? // @ts-expect-error fixme ts strict error\n    ((_e = (_d = node.inputs) == null ? void 0 : _d.find((inp) => inp.name === inputName)) == null ? void 0 : _e.label) ?? inputName;\n    let key = name;\n    let prefix = \"\";\n    if (node.type === \"PrimitiveNode\" && node.title || name in seenInputs) {\n      prefix = `${node.title ?? node.type} `;\n      key = name = `${prefix}${inputName}`;\n      if (name in seenInputs) {\n        name = `${prefix}${seenInputs[name]} ${inputName}`;\n      }\n    }\n    seenInputs[key] = (seenInputs[key] ?? 1) + 1;\n    if (inputName === \"seed\" || inputName === \"noise_seed\") {\n      if (!extra) extra = {};\n      extra.control_after_generate = `${prefix}control_after_generate`;\n    }\n    if (config[0] === \"IMAGEUPLOAD\") {\n      if (!extra) extra = {};\n      extra.widget = // @ts-expect-error fixme ts strict error\n      ((_g = this.oldToNewWidgetMap[node.index]) == null ? void 0 : _g[((_f = config[1]) == null ? void 0 : _f.widget) ?? \"image\"]) ?? \"image\";\n    }\n    if (extra) {\n      config = [config[0], { ...config[1], ...extra }];\n    }\n    return { name, config, customConfig };\n  }\n  // @ts-expect-error fixme ts strict error\n  processWidgetInputs(inputs, node, inputNames, seenInputs) {\n    var _a2;\n    const slots = [];\n    const converted = /* @__PURE__ */ new Map();\n    const widgetMap = this.oldToNewWidgetMap[node.index] = {};\n    for (const inputName of inputNames) {\n      if (useWidgetStore().inputIsWidget(inputs[inputName])) {\n        const convertedIndex = (_a2 = node.inputs) == null ? void 0 : _a2.findIndex(\n          // @ts-expect-error fixme ts strict error\n          (inp) => {\n            var _a3;\n            return inp.name === inputName && ((_a3 = inp.widget) == null ? void 0 : _a3.name) === inputName;\n          }\n        );\n        if (convertedIndex > -1) {\n          converted.set(convertedIndex, inputName);\n          widgetMap[inputName] = null;\n        } else {\n          const { name, config } = this.getInputConfig(\n            node,\n            inputName,\n            seenInputs,\n            inputs[inputName]\n          );\n          this.nodeDef.input.required[name] = config;\n          widgetMap[inputName] = name;\n          this.newToOldWidgetMap[name] = { node, inputName };\n        }\n      } else {\n        slots.push(inputName);\n      }\n    }\n    return { converted, slots };\n  }\n  // @ts-expect-error fixme ts strict error\n  checkPrimitiveConnection(link, inputName, inputs) {\n    const sourceNode = this.nodeData.nodes[link[0]];\n    if (sourceNode.type === \"PrimitiveNode\") {\n      const [sourceNodeId, _, targetNodeId, __] = link;\n      const primitiveDef = this.primitiveDefs[sourceNodeId];\n      const targetWidget = inputs[inputName];\n      const primitiveConfig = primitiveDef.input.required.value;\n      const output = { widget: primitiveConfig };\n      const config = mergeIfValid(\n        // @ts-expect-error invalid slot type\n        output,\n        targetWidget,\n        false,\n        null,\n        primitiveConfig\n      );\n      primitiveConfig[1] = (config == null ? void 0 : config.customConfig) ?? inputs[inputName][1] ? { ...inputs[inputName][1] } : {};\n      let name = this.oldToNewWidgetMap[sourceNodeId][\"value\"];\n      name = name.substr(0, name.length - 6);\n      primitiveConfig[1].control_after_generate = true;\n      primitiveConfig[1].control_prefix = name;\n      let toPrimitive = this.widgetToPrimitive[targetNodeId];\n      if (!toPrimitive) {\n        toPrimitive = this.widgetToPrimitive[targetNodeId] = {};\n      }\n      if (toPrimitive[inputName]) {\n        toPrimitive[inputName].push(sourceNodeId);\n      }\n      toPrimitive[inputName] = sourceNodeId;\n      let toWidget = this.primitiveToWidget[sourceNodeId];\n      if (!toWidget) {\n        toWidget = this.primitiveToWidget[sourceNodeId] = [];\n      }\n      toWidget.push({ nodeId: targetNodeId, inputName });\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  processInputSlots(inputs, node, slots, linksTo, inputMap, seenInputs) {\n    this.nodeInputs[node.index] = {};\n    for (let i = 0; i < slots.length; i++) {\n      const inputName = slots[i];\n      if (linksTo[i]) {\n        this.checkPrimitiveConnection(linksTo[i], inputName, inputs);\n        continue;\n      }\n      const { name, config, customConfig } = this.getInputConfig(\n        node,\n        inputName,\n        seenInputs,\n        inputs[inputName]\n      );\n      this.nodeInputs[node.index][inputName] = name;\n      if ((customConfig == null ? void 0 : customConfig.visible) === false) continue;\n      this.nodeDef.input.required[name] = config;\n      inputMap[i] = this.inputCount++;\n    }\n  }\n  processConvertedWidgets(inputs, node, slots, converted, linksTo, inputMap, seenInputs) {\n    const convertedSlots = [...converted.keys()].sort().map((k) => converted.get(k));\n    for (let i = 0; i < convertedSlots.length; i++) {\n      const inputName = convertedSlots[i];\n      if (linksTo[slots.length + i]) {\n        this.checkPrimitiveConnection(\n          linksTo[slots.length + i],\n          inputName,\n          inputs\n        );\n        continue;\n      }\n      const { name, config } = this.getInputConfig(\n        node,\n        inputName,\n        seenInputs,\n        inputs[inputName],\n        {\n          defaultInput: true\n        }\n      );\n      this.nodeDef.input.required[name] = config;\n      this.newToOldWidgetMap[name] = { node, inputName };\n      if (!this.oldToNewWidgetMap[node.index]) {\n        this.oldToNewWidgetMap[node.index] = {};\n      }\n      this.oldToNewWidgetMap[node.index][inputName] = name;\n      inputMap[slots.length + i] = this.inputCount++;\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  processNodeInputs(node, seenInputs, inputs) {\n    const inputMapping = [];\n    const inputNames = Object.keys(inputs);\n    if (!inputNames.length) return;\n    const { converted, slots } = this.processWidgetInputs(\n      inputs,\n      node,\n      inputNames,\n      seenInputs\n    );\n    const linksTo = this.linksTo[node.index] ?? {};\n    const inputMap = this.oldToNewInputMap[node.index] = {};\n    this.processInputSlots(inputs, node, slots, linksTo, inputMap, seenInputs);\n    __privateGet(this, _convertedToProcess).push(\n      () => this.processConvertedWidgets(\n        inputs,\n        node,\n        slots,\n        converted,\n        linksTo,\n        inputMap,\n        seenInputs\n      )\n    );\n    return inputMapping;\n  }\n  // @ts-expect-error fixme ts strict error\n  processNodeOutputs(node, seenOutputs, def) {\n    var _a2, _b2, _c, _d, _e;\n    const oldToNew = this.oldToNewOutputMap[node.index] = {};\n    for (let outputId = 0; outputId < def.output.length; outputId++) {\n      const linksFrom = this.linksFrom[node.index];\n      const hasLink = (\n        // @ts-expect-error fixme ts strict error\n        (linksFrom == null ? void 0 : linksFrom[outputId]) && !((_a2 = this.externalFrom[node.index]) == null ? void 0 : _a2[outputId])\n      );\n      const customConfig = (_d = (_c = (_b2 = this.nodeData.config) == null ? void 0 : _b2[node.index]) == null ? void 0 : _c.output) == null ? void 0 : _d[outputId];\n      const visible = (customConfig == null ? void 0 : customConfig.visible) ?? !hasLink;\n      this.outputVisibility.push(visible);\n      if (!visible) {\n        continue;\n      }\n      oldToNew[outputId] = this.nodeDef.output.length;\n      this.newToOldOutputMap[this.nodeDef.output.length] = {\n        node,\n        slot: outputId\n      };\n      this.nodeDef.output.push(def.output[outputId]);\n      this.nodeDef.output_is_list.push(def.output_is_list[outputId]);\n      let label = customConfig == null ? void 0 : customConfig.name;\n      if (!label) {\n        label = ((_e = def.output_name) == null ? void 0 : _e[outputId]) ?? def.output[outputId];\n        const output = node.outputs.find((o) => o.name === label);\n        if (output == null ? void 0 : output.label) {\n          label = output.label;\n        }\n      }\n      let name = label;\n      if (name in seenOutputs) {\n        const prefix = `${node.title ?? node.type} `;\n        name = `${prefix}${label}`;\n        if (name in seenOutputs) {\n          name = `${prefix}${node.index} ${label}`;\n        }\n      }\n      seenOutputs[name] = 1;\n      this.nodeDef.output_name.push(name);\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  static async registerFromWorkflow(groupNodes, missingNodeTypes) {\n    for (const g in groupNodes) {\n      const groupData = groupNodes[g];\n      let hasMissing = false;\n      for (const n of groupData.nodes) {\n        if (!(n.type in LiteGraph.registered_node_types)) {\n          missingNodeTypes.push({\n            type: n.type,\n            hint: ` (In group node '${PREFIX}${SEPARATOR}${g}')`\n          });\n          missingNodeTypes.push({\n            type: `${PREFIX}${SEPARATOR}` + g,\n            action: {\n              text: \"Remove from workflow\",\n              // @ts-expect-error fixme ts strict error\n              callback: (e) => {\n                delete groupNodes[g];\n                e.target.textContent = \"Removed\";\n                e.target.style.pointerEvents = \"none\";\n                e.target.style.opacity = 0.7;\n              }\n            }\n          });\n          hasMissing = true;\n        }\n      }\n      if (hasMissing) continue;\n      const config = new _GroupNodeConfig2(g, groupData);\n      await config.registerType();\n    }\n  }\n};\n_convertedToProcess = /* @__PURE__ */ new WeakMap();\nlet GroupNodeConfig = _GroupNodeConfig;\nclass GroupNodeHandler {\n  constructor(node) {\n    var _a2, _b2;\n    __publicField$k(this, \"node\");\n    __publicField$k(this, \"groupData\");\n    __publicField$k(this, \"innerNodes\");\n    this.node = node;\n    this.groupData = (_b2 = (_a2 = node.constructor) == null ? void 0 : _a2.nodeData) == null ? void 0 : _b2[GROUP];\n    this.node.setInnerNodes = (innerNodes) => {\n      this.innerNodes = innerNodes;\n      for (let innerNodeIndex = 0; innerNodeIndex < this.innerNodes.length; innerNodeIndex++) {\n        const innerNode = this.innerNodes[innerNodeIndex];\n        innerNode.graph ?? (innerNode.graph = this.node.graph);\n        for (const w of innerNode.widgets ?? []) {\n          if (w.type === \"converted-widget\") {\n            w.serializeValue = w.origSerializeValue;\n          }\n        }\n        innerNode.index = innerNodeIndex;\n        innerNode.getInputNode = (slot) => {\n          var _a3, _b3;\n          const externalSlot = (_a3 = this.groupData.oldToNewInputMap[innerNode.index]) == null ? void 0 : _a3[slot];\n          if (externalSlot != null) {\n            return this.node.getInputNode(externalSlot);\n          }\n          const innerLink = (_b3 = this.groupData.linksTo[innerNode.index]) == null ? void 0 : _b3[slot];\n          if (!innerLink) return null;\n          const inputNode = innerNodes[innerLink[0]];\n          if (inputNode.type === \"PrimitiveNode\") return null;\n          return inputNode;\n        };\n        innerNode.getInputLink = (slot) => {\n          var _a3, _b3;\n          const externalSlot = (_a3 = this.groupData.oldToNewInputMap[innerNode.index]) == null ? void 0 : _a3[slot];\n          if (externalSlot != null) {\n            const linkId = this.node.inputs[externalSlot].link;\n            let link2 = app.graph.links[linkId];\n            link2 = {\n              ...link2,\n              target_id: innerNode.id,\n              target_slot: +slot\n            };\n            return link2;\n          }\n          let link = (_b3 = this.groupData.linksTo[innerNode.index]) == null ? void 0 : _b3[slot];\n          if (!link) return null;\n          link = {\n            origin_id: innerNodes[link[0]].id,\n            origin_slot: link[1],\n            target_id: innerNode.id,\n            target_slot: +slot\n          };\n          return link;\n        };\n      }\n    };\n    this.node.updateLink = (link) => {\n      link = { ...link };\n      const output = this.groupData.newToOldOutputMap[link.origin_slot];\n      let innerNode = this.innerNodes[output.node.index];\n      let l;\n      while ((innerNode == null ? void 0 : innerNode.type) === \"Reroute\") {\n        l = innerNode.getInputLink(0);\n        innerNode = innerNode.getInputNode(0);\n      }\n      if (!innerNode) {\n        return null;\n      }\n      if (l && GroupNodeHandler.isGroupNode(innerNode)) {\n        return innerNode.updateLink(l);\n      }\n      link.origin_id = innerNode.id;\n      link.origin_slot = (l == null ? void 0 : l.origin_slot) ?? output.slot;\n      return link;\n    };\n    this.node.getInnerNodes = (computedNodeDtos, subgraphNodePath = [], nodes = [], visited = /* @__PURE__ */ new Set()) => {\n      var _a3;\n      if (visited.has(this.node))\n        throw new Error(\"RecursionError: while flattening subgraph\");\n      visited.add(this.node);\n      if (!this.innerNodes) {\n        this.node.setInnerNodes(\n          // @ts-expect-error fixme ts strict error\n          this.groupData.nodeData.nodes.map((n, i) => {\n            const innerNode = LiteGraph.createNode(n.type);\n            innerNode.configure(n);\n            innerNode.id = `${this.node.id}:${i}`;\n            innerNode.graph = this.node.graph;\n            return innerNode;\n          })\n        );\n      }\n      this.updateInnerWidgets();\n      const subgraphInstanceIdPath = [...subgraphNodePath, this.node.id];\n      const subgraphNode = ((_a3 = this.node.graph) == null ? void 0 : _a3.getNodeById(\n        subgraphNodePath.at(-1)\n      )) ?? void 0;\n      for (const node2 of this.innerNodes) {\n        node2.graph ?? (node2.graph = this.node.graph);\n        const currentId = String(node2.id);\n        node2.id = currentId.split(\":\").at(-1);\n        const aVeryRealNode = new ExecutableGroupNodeChildDTO(\n          node2,\n          subgraphInstanceIdPath,\n          computedNodeDtos,\n          subgraphNode\n        );\n        node2.id = currentId;\n        aVeryRealNode.groupNodeHandler = this;\n        nodes.push(aVeryRealNode);\n      }\n      return nodes;\n    };\n    this.node.recreate = async () => {\n      const id2 = this.node.id;\n      const sz = this.node.size;\n      const nodes = this.node.convertToNodes();\n      const groupNode = LiteGraph.createNode(this.node.type);\n      groupNode.id = id2;\n      groupNode.setInnerNodes(nodes);\n      groupNode[GROUP].populateWidgets();\n      app.graph.add(groupNode);\n      groupNode.setSize([\n        // @ts-expect-error fixme ts strict error\n        Math.max(groupNode.size[0], sz[0]),\n        // @ts-expect-error fixme ts strict error\n        Math.max(groupNode.size[1], sz[1])\n      ]);\n      const builder = new GroupNodeBuilder(nodes);\n      const nodeData = builder.getNodeData();\n      groupNode[GROUP].groupData.nodeData.links = nodeData.links;\n      groupNode[GROUP].replaceNodes(nodes);\n      return groupNode;\n    };\n    this.node.convertToNodes = () => {\n      const addInnerNodes = () => {\n        var _a3, _b3;\n        const c = { ...this.groupData.nodeData };\n        c.nodes = [...c.nodes];\n        const innerNodes = this.node.getInnerNodes();\n        let ids = [];\n        for (let i = 0; i < c.nodes.length; i++) {\n          let id2 = (_a3 = innerNodes == null ? void 0 : innerNodes[i]) == null ? void 0 : _a3.id;\n          if (id2 == null || isNaN(id2)) {\n            id2 = void 0;\n          } else {\n            ids.push(id2);\n          }\n          c.nodes[i] = { ...c.nodes[i], id: id2 };\n        }\n        deserialiseAndCreate(JSON.stringify(c), app.canvas);\n        const [x, y] = this.node.pos;\n        let top;\n        let left;\n        const selectedIds = ids.length ? ids : Object.keys(app.canvas.selected_nodes);\n        const newNodes = [];\n        for (let i = 0; i < selectedIds.length; i++) {\n          const id2 = selectedIds[i];\n          const newNode = app.graph.getNodeById(id2);\n          const innerNode = innerNodes[i];\n          newNodes.push(newNode);\n          if (left == null || newNode.pos[0] < left) {\n            left = newNode.pos[0];\n          }\n          if (top == null || newNode.pos[1] < top) {\n            top = newNode.pos[1];\n          }\n          if (!newNode.widgets) continue;\n          const map = this.groupData.oldToNewWidgetMap[innerNode.index];\n          if (map) {\n            const widgets = Object.keys(map);\n            for (const oldName of widgets) {\n              const newName = map[oldName];\n              if (!newName) continue;\n              const widgetIndex = this.node.widgets.findIndex(\n                (w) => w.name === newName\n              );\n              if (widgetIndex === -1) continue;\n              if (innerNode.type === \"PrimitiveNode\") {\n                for (let i2 = 0; i2 < newNode.widgets.length; i2++) {\n                  newNode.widgets[i2].value = // @ts-expect-error fixme ts strict error\n                  this.node.widgets[widgetIndex + i2].value;\n                }\n              } else {\n                const outerWidget = this.node.widgets[widgetIndex];\n                const newWidget = newNode.widgets.find(\n                  (w) => w.name === oldName\n                );\n                if (!newWidget) continue;\n                newWidget.value = outerWidget.value;\n                for (let w = 0; w < ((_b3 = outerWidget.linkedWidgets) == null ? void 0 : _b3.length); w++) {\n                  newWidget.linkedWidgets[w].value = // @ts-expect-error fixme ts strict error\n                  outerWidget.linkedWidgets[w].value;\n                }\n              }\n            }\n          }\n        }\n        for (const newNode of newNodes) {\n          newNode.pos[0] -= left - x;\n          newNode.pos[1] -= top - y;\n        }\n        return { newNodes, selectedIds };\n      };\n      const reconnectInputs = (selectedIds) => {\n        for (const innerNodeIndex in this.groupData.oldToNewInputMap) {\n          const id2 = selectedIds[innerNodeIndex];\n          const newNode = app.graph.getNodeById(id2);\n          const map = this.groupData.oldToNewInputMap[innerNodeIndex];\n          for (const innerInputId in map) {\n            const groupSlotId = map[innerInputId];\n            if (groupSlotId == null) continue;\n            const slot = node.inputs[groupSlotId];\n            if (slot.link == null) continue;\n            const link = app.graph.links[slot.link];\n            if (!link) continue;\n            const originNode = app.graph.getNodeById(link.origin_id);\n            originNode.connect(link.origin_slot, newNode, +innerInputId);\n          }\n        }\n      };\n      const reconnectOutputs = (selectedIds) => {\n        var _a3;\n        for (let groupOutputId = 0; groupOutputId < ((_a3 = node.outputs) == null ? void 0 : _a3.length); groupOutputId++) {\n          const output = node.outputs[groupOutputId];\n          if (!output.links) continue;\n          const links = [...output.links];\n          for (const l of links) {\n            const slot = this.groupData.newToOldOutputMap[groupOutputId];\n            const link = app.graph.links[l];\n            const targetNode = app.graph.getNodeById(link.target_id);\n            const newNode = app.graph.getNodeById(selectedIds[slot.node.index]);\n            newNode.connect(slot.slot, targetNode, link.target_slot);\n          }\n        }\n      };\n      app.canvas.emitBeforeChange();\n      try {\n        const { newNodes, selectedIds } = addInnerNodes();\n        reconnectInputs(selectedIds);\n        reconnectOutputs(selectedIds);\n        app.graph.remove(this.node);\n        return newNodes;\n      } finally {\n        app.canvas.emitAfterChange();\n      }\n    };\n    const getExtraMenuOptions = this.node.getExtraMenuOptions;\n    this.node.getExtraMenuOptions = function(_, options) {\n      getExtraMenuOptions == null ? void 0 : getExtraMenuOptions.apply(this, arguments);\n      let optionIndex = options.findIndex((o) => (o == null ? void 0 : o.content) === \"Outputs\");\n      if (optionIndex === -1) optionIndex = options.length;\n      else optionIndex++;\n      options.splice(\n        optionIndex,\n        0,\n        null,\n        {\n          content: \"Convert to nodes\",\n          // @ts-expect-error\n          callback: () => {\n            return this.convertToNodes();\n          }\n        },\n        {\n          content: \"Manage Group Node\",\n          callback: () => manageGroupNodes(this.type)\n        }\n      );\n    };\n    const onDrawTitleBox = this.node.onDrawTitleBox;\n    this.node.onDrawTitleBox = function(ctx, height) {\n      onDrawTitleBox == null ? void 0 : onDrawTitleBox.apply(this, arguments);\n      const fill = ctx.fillStyle;\n      ctx.beginPath();\n      ctx.rect(11, -height + 11, 2, 2);\n      ctx.rect(14, -height + 11, 2, 2);\n      ctx.rect(17, -height + 11, 2, 2);\n      ctx.rect(11, -height + 14, 2, 2);\n      ctx.rect(14, -height + 14, 2, 2);\n      ctx.rect(17, -height + 14, 2, 2);\n      ctx.rect(11, -height + 17, 2, 2);\n      ctx.rect(14, -height + 17, 2, 2);\n      ctx.rect(17, -height + 17, 2, 2);\n      ctx.fillStyle = this.boxcolor || LiteGraph.NODE_DEFAULT_BOXCOLOR;\n      ctx.fill();\n      ctx.fillStyle = fill;\n    };\n    const onDrawForeground = node.onDrawForeground;\n    const groupData = this.groupData.nodeData;\n    node.onDrawForeground = function(ctx) {\n      var _a3;\n      (_a3 = onDrawForeground == null ? void 0 : onDrawForeground.apply) == null ? void 0 : _a3.call(onDrawForeground, this, arguments);\n      const progressState = useExecutionStore().nodeProgressStates[this.id];\n      if (progressState && progressState.state === \"running\" && this.runningInternalNodeId !== null) {\n        const n = groupData.nodes[this.runningInternalNodeId];\n        if (!n) return;\n        const message = `Running ${n.title || n.type} (${this.runningInternalNodeId}/${groupData.nodes.length})`;\n        ctx.save();\n        ctx.font = \"12px sans-serif\";\n        const sz = ctx.measureText(message);\n        ctx.fillStyle = node.boxcolor || LiteGraph.NODE_DEFAULT_BOXCOLOR;\n        ctx.beginPath();\n        ctx.roundRect(\n          0,\n          -LiteGraph.NODE_TITLE_HEIGHT - 20,\n          sz.width + 12,\n          20,\n          5\n        );\n        ctx.fill();\n        ctx.fillStyle = \"#fff\";\n        ctx.fillText(message, 6, -LiteGraph.NODE_TITLE_HEIGHT - 6);\n        ctx.restore();\n      }\n    };\n    const onExecutionStart = this.node.onExecutionStart;\n    this.node.onExecutionStart = function() {\n      this.resetExecution = true;\n      return onExecutionStart == null ? void 0 : onExecutionStart.apply(this, arguments);\n    };\n    const self2 = this;\n    const onNodeCreated = this.node.onNodeCreated;\n    this.node.onNodeCreated = function() {\n      var _a3;\n      if (!this.widgets) {\n        return;\n      }\n      const config = self2.groupData.nodeData.config;\n      if (config) {\n        for (const n in config) {\n          const inputs = (_a3 = config[n]) == null ? void 0 : _a3.input;\n          for (const w in inputs) {\n            if (inputs[w].visible !== false) continue;\n            const widgetName = self2.groupData.oldToNewWidgetMap[n][w];\n            const widget = this.widgets.find((w2) => w2.name === widgetName);\n            if (widget) {\n              widget.type = \"hidden\";\n              widget.computeSize = () => [0, -4];\n            }\n          }\n        }\n      }\n      return onNodeCreated == null ? void 0 : onNodeCreated.apply(this, arguments);\n    };\n    function handleEvent(type, getId, getEvent) {\n      const handler2 = ({ detail }) => {\n        var _a3;\n        const id2 = getId(detail);\n        if (!id2) return;\n        const node2 = app.graph.getNodeById(id2);\n        if (node2) return;\n        const innerNodeIndex = (_a3 = this.innerNodes) == null ? void 0 : _a3.findIndex((n) => n.id == id2);\n        if (innerNodeIndex > -1) {\n          this.node.runningInternalNodeId = innerNodeIndex;\n          api.dispatchCustomEvent(\n            type,\n            // @ts-expect-error fixme ts strict error\n            getEvent(detail, `${this.node.id}`, this.node)\n          );\n        }\n      };\n      api.addEventListener(type, handler2);\n      return handler2;\n    }\n    const executing = handleEvent.call(\n      this,\n      \"executing\",\n      // @ts-expect-error fixme ts strict error\n      (d) => d,\n      // @ts-expect-error fixme ts strict error\n      (_, id2) => id2\n    );\n    const executed = handleEvent.call(\n      this,\n      \"executed\",\n      // @ts-expect-error fixme ts strict error\n      (d) => (d == null ? void 0 : d.display_node) || (d == null ? void 0 : d.node),\n      // @ts-expect-error fixme ts strict error\n      (d, id2, node2) => ({\n        ...d,\n        node: id2,\n        display_node: id2,\n        merge: !node2.resetExecution\n      })\n    );\n    const onRemoved = node.onRemoved;\n    this.node.onRemoved = function() {\n      onRemoved == null ? void 0 : onRemoved.apply(this, arguments);\n      api.removeEventListener(\"executing\", executing);\n      api.removeEventListener(\"executed\", executed);\n    };\n    this.node.refreshComboInNode = (defs) => {\n      var _a3, _b3, _c, _d;\n      for (const widgetName in this.groupData.newToOldWidgetMap) {\n        const widget = this.node.widgets.find((w) => w.name === widgetName);\n        if ((widget == null ? void 0 : widget.type) === \"combo\") {\n          const old = this.groupData.newToOldWidgetMap[widgetName];\n          const def = defs[old.node.type];\n          const input = ((_b3 = (_a3 = def == null ? void 0 : def.input) == null ? void 0 : _a3.required) == null ? void 0 : _b3[old.inputName]) ?? ((_d = (_c = def == null ? void 0 : def.input) == null ? void 0 : _c.optional) == null ? void 0 : _d[old.inputName]);\n          if (!input) continue;\n          widget.options.values = input[0];\n          if (old.inputName !== \"image\" && // @ts-expect-error Widget values\n          !widget.options.values.includes(widget.value)) {\n            widget.value = widget.options.values[0];\n            widget.callback(widget.value);\n          }\n        }\n      }\n    };\n  }\n  updateInnerWidgets() {\n    var _a2, _b2;\n    for (const newWidgetName in this.groupData.newToOldWidgetMap) {\n      const newWidget = this.node.widgets.find((w) => w.name === newWidgetName);\n      if (!newWidget) continue;\n      const newValue = newWidget.value;\n      const old = this.groupData.newToOldWidgetMap[newWidgetName];\n      let innerNode = this.innerNodes[old.node.index];\n      if (innerNode.type === \"PrimitiveNode\") {\n        innerNode.primitiveValue = newValue;\n        const primitiveLinked = this.groupData.primitiveToWidget[old.node.index];\n        for (const linked of primitiveLinked ?? []) {\n          const node = this.innerNodes[linked.nodeId];\n          const widget2 = node.widgets.find((w) => w.name === linked.inputName);\n          if (widget2) {\n            widget2.value = newValue;\n          }\n        }\n        continue;\n      } else if (innerNode.type === \"Reroute\") {\n        const rerouteLinks = this.groupData.linksFrom[old.node.index];\n        if (rerouteLinks) {\n          for (const [_, , targetNodeId, targetSlot] of rerouteLinks[\"0\"]) {\n            const node = this.innerNodes[targetNodeId];\n            const input = node.inputs[targetSlot];\n            if (input.widget) {\n              const widget2 = (_a2 = node.widgets) == null ? void 0 : _a2.find(\n                // @ts-expect-error fixme ts strict error\n                (w) => w.name === input.widget.name\n              );\n              if (widget2) {\n                widget2.value = newValue;\n              }\n            }\n          }\n        }\n      }\n      const widget = (_b2 = innerNode.widgets) == null ? void 0 : _b2.find((w) => w.name === old.inputName);\n      if (widget) {\n        widget.value = newValue;\n      }\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  populatePrimitive(_node, nodeId, oldName) {\n    var _a2, _b2;\n    const primitiveId = (_a2 = this.groupData.widgetToPrimitive[nodeId]) == null ? void 0 : _a2[oldName];\n    if (primitiveId == null) return;\n    const targetWidgetName = this.groupData.oldToNewWidgetMap[primitiveId][\"value\"];\n    const targetWidgetIndex = this.node.widgets.findIndex(\n      (w) => w.name === targetWidgetName\n    );\n    if (targetWidgetIndex > -1) {\n      const primitiveNode = this.innerNodes[primitiveId];\n      let len = primitiveNode.widgets.length;\n      if (len - 1 !== // @ts-expect-error fixme ts strict error\n      ((_b2 = this.node.widgets[targetWidgetIndex].linkedWidgets) == null ? void 0 : _b2.length)) {\n        len = 1;\n      }\n      for (let i = 0; i < len; i++) {\n        this.node.widgets[targetWidgetIndex + i].value = primitiveNode.widgets[i].value;\n      }\n    }\n    return true;\n  }\n  // @ts-expect-error fixme ts strict error\n  populateReroute(node, nodeId, map) {\n    var _a2, _b2, _c, _d, _e;\n    if (node.type !== \"Reroute\") return;\n    const link = (_b2 = (_a2 = this.groupData.linksFrom[nodeId]) == null ? void 0 : _a2[0]) == null ? void 0 : _b2[0];\n    if (!link) return;\n    const [, , targetNodeId, targetNodeSlot] = link;\n    const targetNode = this.groupData.nodeData.nodes[targetNodeId];\n    const inputs = targetNode.inputs;\n    const targetWidget = (_c = inputs == null ? void 0 : inputs[targetNodeSlot]) == null ? void 0 : _c.widget;\n    if (!targetWidget) return;\n    const offset = inputs.length - (((_d = targetNode.widgets_values) == null ? void 0 : _d.length) ?? 0);\n    const v = (_e = targetNode.widgets_values) == null ? void 0 : _e[targetNodeSlot - offset];\n    if (v == null) return;\n    const widgetName = Object.values(map)[0];\n    const widget = this.node.widgets.find((w) => w.name === widgetName);\n    if (widget) {\n      widget.value = v;\n    }\n  }\n  populateWidgets() {\n    var _a2, _b2, _c, _d;\n    if (!this.node.widgets) return;\n    for (let nodeId = 0; nodeId < this.groupData.nodeData.nodes.length; nodeId++) {\n      const node = this.groupData.nodeData.nodes[nodeId];\n      const map = this.groupData.oldToNewWidgetMap[nodeId] ?? {};\n      const widgets = Object.keys(map);\n      if (!((_a2 = node.widgets_values) == null ? void 0 : _a2.length)) {\n        this.populateReroute(node, nodeId, map);\n        continue;\n      }\n      let linkedShift = 0;\n      for (let i = 0; i < widgets.length; i++) {\n        const oldName = widgets[i];\n        const newName = map[oldName];\n        const widgetIndex = this.node.widgets.findIndex(\n          (w) => w.name === newName\n        );\n        const mainWidget = this.node.widgets[widgetIndex];\n        if (this.populatePrimitive(node, nodeId, oldName) || widgetIndex === -1) {\n          const innerWidget = (_b2 = this.innerNodes[nodeId].widgets) == null ? void 0 : _b2.find(\n            // @ts-expect-error fixme ts strict error\n            (w) => w.name === oldName\n          );\n          linkedShift += ((_c = innerWidget == null ? void 0 : innerWidget.linkedWidgets) == null ? void 0 : _c.length) ?? 0;\n        }\n        if (widgetIndex === -1) {\n          continue;\n        }\n        mainWidget.value = node.widgets_values[i + linkedShift];\n        for (let w = 0; w < ((_d = mainWidget.linkedWidgets) == null ? void 0 : _d.length); w++) {\n          this.node.widgets[widgetIndex + w + 1].value = node.widgets_values[i + ++linkedShift];\n        }\n      }\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  replaceNodes(nodes) {\n    let top;\n    let left;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (left == null || node.pos[0] < left) {\n        left = node.pos[0];\n      }\n      if (top == null || node.pos[1] < top) {\n        top = node.pos[1];\n      }\n      this.linkOutputs(node, i);\n      app.graph.remove(node);\n      node.id = `${this.node.id}:${i}`;\n    }\n    this.linkInputs();\n    this.node.pos = [left, top];\n  }\n  // @ts-expect-error fixme ts strict error\n  linkOutputs(originalNode, nodeId) {\n    var _a2;\n    if (!originalNode.outputs) return;\n    for (const output of originalNode.outputs) {\n      if (!output.links) continue;\n      const links = [...output.links];\n      for (const l of links) {\n        const link = app.graph.links[l];\n        if (!link) continue;\n        const targetNode = app.graph.getNodeById(link.target_id);\n        const newSlot = (_a2 = this.groupData.oldToNewOutputMap[nodeId]) == null ? void 0 : _a2[link.origin_slot];\n        if (newSlot != null) {\n          this.node.connect(newSlot, targetNode, link.target_slot);\n        }\n      }\n    }\n  }\n  linkInputs() {\n    for (const link of this.groupData.nodeData.links ?? []) {\n      const [, originSlot, targetId, targetSlot, actualOriginId] = link;\n      const originNode = app.graph.getNodeById(actualOriginId);\n      if (!originNode) continue;\n      originNode.connect(\n        originSlot,\n        // @ts-expect-error Valid - uses deprecated interface.  Required check: if (graph.getNodeById(this.node.id) !== this.node) report()\n        this.node.id,\n        this.groupData.oldToNewInputMap[targetId][targetSlot]\n      );\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  static getGroupData(node) {\n    var _a2, _b2;\n    return (_b2 = node.nodeData ?? ((_a2 = node.constructor) == null ? void 0 : _a2.nodeData)) == null ? void 0 : _b2[GROUP];\n  }\n  static isGroupNode(node) {\n    var _a2, _b2;\n    return !!((_b2 = (_a2 = node.constructor) == null ? void 0 : _a2.nodeData) == null ? void 0 : _b2[GROUP]);\n  }\n  static async fromNodes(nodes) {\n    const builder = new GroupNodeBuilder(nodes);\n    const res = await builder.build();\n    if (!res) return;\n    const { name, nodeData } = res;\n    const config = new GroupNodeConfig(name, nodeData);\n    await config.registerType();\n    const groupNode = LiteGraph.createNode(`${PREFIX}${SEPARATOR}${name}`);\n    groupNode.setInnerNodes(builder.nodes);\n    groupNode[GROUP].populateWidgets();\n    app.graph.add(groupNode);\n    groupNode[GROUP].replaceNodes(builder.nodes);\n    return groupNode;\n  }\n}\nfunction addConvertToGroupOptions() {\n  function addConvertOption(options, index) {\n    const selected = Object.values(app.canvas.selected_nodes ?? {});\n    const disabled = selected.length < 2 || selected.find((n) => GroupNodeHandler.isGroupNode(n));\n    options.splice(index, null, {\n      content: `Convert to Group Node (Deprecated)`,\n      disabled,\n      callback: convertSelectedNodesToGroupNode\n    });\n  }\n  function addManageOption(options, index) {\n    var _a2;\n    const groups = (_a2 = app.graph.extra) == null ? void 0 : _a2.groupNodes;\n    const disabled = !groups || !Object.keys(groups).length;\n    options.splice(index, null, {\n      content: `Manage Group Nodes`,\n      disabled,\n      callback: () => manageGroupNodes()\n    });\n  }\n  const getCanvasMenuOptions = LGraphCanvas.prototype.getCanvasMenuOptions;\n  LGraphCanvas.prototype.getCanvasMenuOptions = function() {\n    const options = getCanvasMenuOptions.apply(this, arguments);\n    const index = options.findIndex((o) => (o == null ? void 0 : o.content) === \"Add Group\");\n    const insertAt = index === -1 ? options.length - 1 : index + 2;\n    addConvertOption(options, insertAt);\n    addManageOption(options, insertAt + 1);\n    return options;\n  };\n  const getNodeMenuOptions = LGraphCanvas.prototype.getNodeMenuOptions;\n  LGraphCanvas.prototype.getNodeMenuOptions = function(node) {\n    const options = getNodeMenuOptions.apply(this, arguments);\n    if (!GroupNodeHandler.isGroupNode(node)) {\n      const index = options.findIndex((o) => (o == null ? void 0 : o.content) === \"Properties\");\n      const insertAt = index === -1 ? options.length - 1 : index;\n      addConvertOption(options, insertAt);\n    }\n    return options;\n  };\n}\nconst replaceLegacySeparators = (nodes) => {\n  for (const node of nodes) {\n    if (typeof node.type === \"string\" && node.type.startsWith(\"workflow/\")) {\n      node.type = node.type.replace(/^workflow\\//, `${PREFIX}${SEPARATOR}`);\n    }\n  }\n};\nasync function convertSelectedNodesToGroupNode() {\n  const nodes = Object.values(app.canvas.selected_nodes ?? {});\n  if (nodes.length === 0) {\n    throw new Error(\"No nodes selected\");\n  }\n  if (nodes.length === 1) {\n    throw new Error(\"Please select multiple nodes to convert to group node\");\n  }\n  for (const node of nodes) {\n    if (node instanceof SubgraphNode) {\n      throw new Error(\"Selected nodes contain a subgraph node\");\n    }\n    if (GroupNodeHandler.isGroupNode(node)) {\n      throw new Error(\"Selected nodes contain a group node\");\n    }\n  }\n  return await GroupNodeHandler.fromNodes(nodes);\n}\nfunction ungroupSelectedGroupNodes() {\n  var _a2;\n  const nodes = Object.values(app.canvas.selected_nodes ?? {});\n  for (const node of nodes) {\n    if (GroupNodeHandler.isGroupNode(node)) {\n      (_a2 = node.convertToNodes) == null ? void 0 : _a2.call(node);\n    }\n  }\n}\nfunction manageGroupNodes(type) {\n  new ManageGroupDialog(app).show(type);\n}\nconst id$1 = \"Comfy.GroupNode\";\nlet globalDefs;\nconst ext = {\n  name: id$1,\n  commands: [\n    {\n      id: \"Comfy.GroupNode.ConvertSelectedNodesToGroupNode\",\n      label: \"Convert selected nodes to group node\",\n      icon: \"pi pi-sitemap\",\n      versionAdded: \"1.3.17\",\n      function: convertSelectedNodesToGroupNode\n    },\n    {\n      id: \"Comfy.GroupNode.UngroupSelectedGroupNodes\",\n      label: \"Ungroup selected group nodes\",\n      icon: \"pi pi-sitemap\",\n      versionAdded: \"1.3.17\",\n      function: ungroupSelectedGroupNodes\n    },\n    {\n      id: \"Comfy.GroupNode.ManageGroupNodes\",\n      label: \"Manage group nodes\",\n      icon: \"pi pi-cog\",\n      versionAdded: \"1.3.17\",\n      function: manageGroupNodes\n    }\n  ],\n  keybindings: [\n    {\n      commandId: \"Comfy.GroupNode.ConvertSelectedNodesToGroupNode\",\n      combo: {\n        alt: true,\n        key: \"g\"\n      }\n    },\n    {\n      commandId: \"Comfy.GroupNode.UngroupSelectedGroupNodes\",\n      combo: {\n        alt: true,\n        shift: true,\n        key: \"G\"\n      }\n    }\n  ],\n  setup() {\n    addConvertToGroupOptions();\n  },\n  async beforeConfigureGraph(graphData, missingNodeTypes) {\n    var _a2;\n    const nodes = (_a2 = graphData == null ? void 0 : graphData.extra) == null ? void 0 : _a2.groupNodes;\n    if (nodes) {\n      replaceLegacySeparators(graphData.nodes);\n      await GroupNodeConfig.registerFromWorkflow(nodes, missingNodeTypes);\n    }\n  },\n  addCustomNodeDefs(defs) {\n    globalDefs = defs;\n  },\n  nodeCreated(node) {\n    var _a2, _b2;\n    if (GroupNodeHandler.isGroupNode(node)) {\n      node[GROUP] = new GroupNodeHandler(node);\n      if (node.title && ((_b2 = (_a2 = node[GROUP]) == null ? void 0 : _a2.groupData) == null ? void 0 : _b2.nodeData)) {\n        Workflow.storeGroupNode(node.title, node[GROUP].groupData.nodeData);\n      }\n    }\n  },\n  // @ts-expect-error fixme ts strict error\n  async refreshComboInNodes(defs) {\n    var _a2;\n    Object.assign(globalDefs, defs);\n    const nodes = (_a2 = app.graph.extra) == null ? void 0 : _a2.groupNodes;\n    if (nodes) {\n      await GroupNodeConfig.registerFromWorkflow(nodes, {});\n    }\n  }\n};\napp.registerExtension(ext);\nfunction setNodeMode(node, mode) {\n  var _a2;\n  node.mode = mode;\n  (_a2 = node.graph) == null ? void 0 : _a2.change();\n}\nfunction addNodesToGroup(group, items) {\n  const padding = useSettingStore().get(\"Comfy.GroupSelectedNodes.Padding\");\n  group.resizeTo([...group.children, ...items], padding);\n}\napp.registerExtension({\n  name: \"Comfy.GroupOptions\",\n  setup() {\n    const orig = LGraphCanvas.prototype.getCanvasMenuOptions;\n    LGraphCanvas.prototype.getCanvasMenuOptions = function() {\n      var _a2;\n      const options = orig.apply(this, arguments);\n      const group = this.graph.getGroupOnPos(\n        this.graph_mouse[0],\n        this.graph_mouse[1]\n      );\n      if (!group) {\n        if (this.selectedItems.size > 0) {\n          options.push({\n            content: \"Add Group For Selected Nodes\",\n            callback: () => {\n              const group2 = new LGraphGroup();\n              addNodesToGroup(group2, this.selectedItems);\n              this.graph.add(group2);\n              this.graph.change();\n            }\n          });\n        }\n        return options;\n      }\n      group.recomputeInsideNodes();\n      const nodesInGroup = group.nodes;\n      options.push({\n        content: \"Add Selected Nodes To Group\",\n        disabled: !((_a2 = this.selectedItems) == null ? void 0 : _a2.size),\n        callback: () => {\n          addNodesToGroup(group, this.selectedItems);\n          this.graph.change();\n        }\n      });\n      if (nodesInGroup.length === 0) {\n        return options;\n      } else {\n        options.push(null);\n      }\n      let allNodesAreSameMode = true;\n      for (let i = 1; i < nodesInGroup.length; i++) {\n        if (nodesInGroup[i].mode !== nodesInGroup[0].mode) {\n          allNodesAreSameMode = false;\n          break;\n        }\n      }\n      options.push({\n        content: \"Fit Group To Nodes\",\n        callback: () => {\n          group.recomputeInsideNodes();\n          const padding = useSettingStore().get(\n            \"Comfy.GroupSelectedNodes.Padding\"\n          );\n          group.resizeTo(group.children, padding);\n          this.graph.change();\n        }\n      });\n      options.push({\n        content: \"Select Nodes\",\n        callback: () => {\n          this.selectNodes(nodesInGroup);\n          this.graph.change();\n          this.canvas.focus();\n        }\n      });\n      if (allNodesAreSameMode) {\n        const mode = nodesInGroup[0].mode;\n        switch (mode) {\n          case 0:\n            options.push({\n              content: \"Set Group Nodes to Never\",\n              callback: () => {\n                for (const node of nodesInGroup) {\n                  setNodeMode(node, 2);\n                }\n              }\n            });\n            options.push({\n              content: \"Bypass Group Nodes\",\n              callback: () => {\n                for (const node of nodesInGroup) {\n                  setNodeMode(node, 4);\n                }\n              }\n            });\n            break;\n          case 2:\n            options.push({\n              content: \"Set Group Nodes to Always\",\n              callback: () => {\n                for (const node of nodesInGroup) {\n                  setNodeMode(node, 0);\n                }\n              }\n            });\n            options.push({\n              content: \"Bypass Group Nodes\",\n              callback: () => {\n                for (const node of nodesInGroup) {\n                  setNodeMode(node, 4);\n                }\n              }\n            });\n            break;\n          case 4:\n            options.push({\n              content: \"Set Group Nodes to Always\",\n              callback: () => {\n                for (const node of nodesInGroup) {\n                  setNodeMode(node, 0);\n                }\n              }\n            });\n            options.push({\n              content: \"Set Group Nodes to Never\",\n              callback: () => {\n                for (const node of nodesInGroup) {\n                  setNodeMode(node, 2);\n                }\n              }\n            });\n            break;\n          default:\n            options.push({\n              content: \"Set Group Nodes to Always\",\n              callback: () => {\n                for (const node of nodesInGroup) {\n                  setNodeMode(node, 0);\n                }\n              }\n            });\n            options.push({\n              content: \"Set Group Nodes to Never\",\n              callback: () => {\n                for (const node of nodesInGroup) {\n                  setNodeMode(node, 2);\n                }\n              }\n            });\n            options.push({\n              content: \"Bypass Group Nodes\",\n              callback: () => {\n                for (const node of nodesInGroup) {\n                  setNodeMode(node, 4);\n                }\n              }\n            });\n            break;\n        }\n      } else {\n        options.push({\n          content: \"Set Group Nodes to Always\",\n          callback: () => {\n            for (const node of nodesInGroup) {\n              setNodeMode(node, 0);\n            }\n          }\n        });\n        options.push({\n          content: \"Set Group Nodes to Never\",\n          callback: () => {\n            for (const node of nodesInGroup) {\n              setNodeMode(node, 2);\n            }\n          }\n        });\n        options.push({\n          content: \"Bypass Group Nodes\",\n          callback: () => {\n            for (const node of nodesInGroup) {\n              setNodeMode(node, 4);\n            }\n          }\n        });\n      }\n      return options;\n    };\n  }\n});\nconst _hoisted_1$f = { class: \"flex flex-col\" };\nconst _hoisted_2$c = {\n  key: 0,\n  class: \"relative show-fov\"\n};\nconst _hoisted_3$a = { class: \"pi pi-expand text-white text-lg\" };\nconst _hoisted_4$8 = {\n  class: \"absolute left-12 top-0 bg-black bg-opacity-50 p-4 rounded-lg shadow-lg\",\n  style: { \"width\": \"150px\" }\n};\nconst _sfc_main$j = /* @__PURE__ */ defineComponent({\n  __name: \"CameraControls\",\n  props: {\n    cameraType: {},\n    fov: {},\n    showFOVButton: { type: Boolean }\n  },\n  emits: [\"switchCamera\", \"updateFOV\"],\n  setup(__props, { emit: __emit }) {\n    const vTooltip = Tooltip;\n    const props = __props;\n    const emit = __emit;\n    const cameraType = ref(props.cameraType);\n    const fov2 = ref(props.fov);\n    const showFOVButton = ref(props.showFOVButton);\n    const showFOV = ref(false);\n    watch(\n      () => props.fov,\n      (newValue) => {\n        fov2.value = newValue;\n      }\n    );\n    watch(\n      () => props.showFOVButton,\n      (newValue) => {\n        showFOVButton.value = newValue;\n      }\n    );\n    watch(\n      () => props.cameraType,\n      (newValue) => {\n        cameraType.value = newValue;\n      }\n    );\n    const switchCamera = () => {\n      emit(\"switchCamera\");\n    };\n    const toggleFOV = () => {\n      showFOV.value = !showFOV.value;\n    };\n    const updateFOV = () => {\n      emit(\"updateFOV\", fov2.value);\n    };\n    const getCameraIcon = computed(() => {\n      return props.cameraType === \"perspective\" ? \"pi-camera\" : \"pi-camera\";\n    });\n    const closeCameraSlider = (e) => {\n      const target = e.target;\n      if (!target.closest(\".show-fov\")) {\n        showFOV.value = false;\n      }\n    };\n    onMounted(() => {\n      document.addEventListener(\"click\", closeCameraSlider);\n    });\n    onUnmounted(() => {\n      document.removeEventListener(\"click\", closeCameraSlider);\n    });\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", _hoisted_1$f, [\n        createVNode(unref(Button), {\n          class: \"p-button-rounded p-button-text\",\n          onClick: switchCamera\n        }, {\n          default: withCtx(() => [\n            withDirectives(createElementVNode(\"i\", {\n              class: normalizeClass([\"pi\", getCameraIcon.value, \"text-white text-lg\"])\n            }, null, 2), [\n              [\n                unref(vTooltip),\n                {\n                  value: unref(t)(\"load3d.switchCamera\"),\n                  showDelay: 300\n                },\n                void 0,\n                { right: true }\n              ]\n            ])\n          ]),\n          _: 1\n        }),\n        showFOVButton.value ? (openBlock(), createElementBlock(\"div\", _hoisted_2$c, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text\",\n            onClick: toggleFOV\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_3$a, null, 512), [\n                [\n                  unref(vTooltip),\n                  { value: unref(t)(\"load3d.fov\"), showDelay: 300 },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          }),\n          withDirectives(createElementVNode(\"div\", _hoisted_4$8, [\n            createVNode(unref(Slider), {\n              modelValue: fov2.value,\n              \"onUpdate:modelValue\": _cache2[0] || (_cache2[0] = ($event) => fov2.value = $event),\n              class: \"w-full\",\n              min: 10,\n              max: 150,\n              step: 1,\n              onChange: updateFOV\n            }, null, 8, [\"modelValue\"])\n          ], 512), [\n            [vShow, showFOV.value]\n          ])\n        ])) : createCommentVNode(\"\", true)\n      ]);\n    };\n  }\n});\nconst _hoisted_1$e = { class: \"flex flex-col\" };\nconst _hoisted_2$b = { class: \"relative show-export-formats\" };\nconst _hoisted_3$9 = { class: \"pi pi-download text-white text-lg\" };\nconst _hoisted_4$7 = { class: \"absolute left-12 top-0 bg-black bg-opacity-50 rounded-lg shadow-lg\" };\nconst _hoisted_5$6 = { class: \"flex flex-col\" };\nconst _sfc_main$i = /* @__PURE__ */ defineComponent({\n  __name: \"ExportControls\",\n  emits: [\"exportModel\"],\n  setup(__props, { emit: __emit }) {\n    const vTooltip = Tooltip;\n    const emit = __emit;\n    const showExportFormats = ref(false);\n    const exportFormats = [\n      { label: \"GLB\", value: \"glb\" },\n      { label: \"OBJ\", value: \"obj\" },\n      { label: \"STL\", value: \"stl\" }\n    ];\n    const toggleExportFormats = () => {\n      showExportFormats.value = !showExportFormats.value;\n    };\n    const exportModel = (format) => {\n      emit(\"exportModel\", format);\n      showExportFormats.value = false;\n    };\n    const closeExportFormatsList = (e) => {\n      const target = e.target;\n      if (!target.closest(\".show-export-formats\")) {\n        showExportFormats.value = false;\n      }\n    };\n    onMounted(() => {\n      document.addEventListener(\"click\", closeExportFormatsList);\n    });\n    onUnmounted(() => {\n      document.removeEventListener(\"click\", closeExportFormatsList);\n    });\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", _hoisted_1$e, [\n        createElementVNode(\"div\", _hoisted_2$b, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text\",\n            onClick: toggleExportFormats\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_3$9, null, 512), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: unref(t)(\"load3d.exportModel\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          }),\n          withDirectives(createElementVNode(\"div\", _hoisted_4$7, [\n            createElementVNode(\"div\", _hoisted_5$6, [\n              (openBlock(), createElementBlock(Fragment, null, renderList(exportFormats, (format) => {\n                return createVNode(unref(Button), {\n                  key: format.value,\n                  class: \"p-button-text text-white\",\n                  onClick: ($event) => exportModel(format.value)\n                }, {\n                  default: withCtx(() => [\n                    createTextVNode(toDisplayString(format.label), 1)\n                  ]),\n                  _: 2\n                }, 1032, [\"onClick\"]);\n              }), 64))\n            ])\n          ], 512), [\n            [vShow, showExportFormats.value]\n          ])\n        ])\n      ]);\n    };\n  }\n});\nconst _hoisted_1$d = { class: \"flex flex-col\" };\nconst _hoisted_2$a = {\n  key: 0,\n  class: \"relative show-light-intensity\"\n};\nconst _hoisted_3$8 = { class: \"pi pi-sun text-white text-lg\" };\nconst _hoisted_4$6 = {\n  class: \"absolute left-12 top-0 bg-black bg-opacity-50 p-4 rounded-lg shadow-lg\",\n  style: { \"width\": \"150px\" }\n};\nconst _sfc_main$h = /* @__PURE__ */ defineComponent({\n  __name: \"LightControls\",\n  props: {\n    lightIntensity: {},\n    showLightIntensityButton: { type: Boolean }\n  },\n  emits: [\"updateLightIntensity\"],\n  setup(__props, { emit: __emit }) {\n    const vTooltip = Tooltip;\n    const props = __props;\n    const emit = __emit;\n    const lightIntensity = ref(props.lightIntensity);\n    const showLightIntensityButton = ref(props.showLightIntensityButton);\n    const showLightIntensity = ref(false);\n    const lightIntensityMaximum = useSettingStore().get(\n      \"Comfy.Load3D.LightIntensityMaximum\"\n    );\n    const lightIntensityMinimum = useSettingStore().get(\n      \"Comfy.Load3D.LightIntensityMinimum\"\n    );\n    const lightAdjustmentIncrement = useSettingStore().get(\n      \"Comfy.Load3D.LightAdjustmentIncrement\"\n    );\n    watch(\n      () => props.lightIntensity,\n      (newValue) => {\n        lightIntensity.value = newValue;\n      }\n    );\n    watch(\n      () => props.showLightIntensityButton,\n      (newValue) => {\n        showLightIntensityButton.value = newValue;\n      }\n    );\n    const toggleLightIntensity = () => {\n      showLightIntensity.value = !showLightIntensity.value;\n    };\n    const updateLightIntensity = () => {\n      emit(\"updateLightIntensity\", lightIntensity.value);\n    };\n    const closeLightSlider = (e) => {\n      const target = e.target;\n      if (!target.closest(\".show-light-intensity\")) {\n        showLightIntensity.value = false;\n      }\n    };\n    onMounted(() => {\n      document.addEventListener(\"click\", closeLightSlider);\n    });\n    onUnmounted(() => {\n      document.removeEventListener(\"click\", closeLightSlider);\n    });\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", _hoisted_1$d, [\n        showLightIntensityButton.value ? (openBlock(), createElementBlock(\"div\", _hoisted_2$a, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text\",\n            onClick: toggleLightIntensity\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_3$8, null, 512), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: unref(t)(\"load3d.lightIntensity\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          }),\n          withDirectives(createElementVNode(\"div\", _hoisted_4$6, [\n            createVNode(unref(Slider), {\n              modelValue: lightIntensity.value,\n              \"onUpdate:modelValue\": _cache2[0] || (_cache2[0] = ($event) => lightIntensity.value = $event),\n              class: \"w-full\",\n              min: unref(lightIntensityMinimum),\n              max: unref(lightIntensityMaximum),\n              step: unref(lightAdjustmentIncrement),\n              onChange: updateLightIntensity\n            }, null, 8, [\"modelValue\", \"min\", \"max\", \"step\"])\n          ], 512), [\n            [vShow, showLightIntensity.value]\n          ])\n        ])) : createCommentVNode(\"\", true)\n      ]);\n    };\n  }\n});\nconst _hoisted_1$c = { class: \"flex flex-col\" };\nconst _hoisted_2$9 = { class: \"relative show-up-direction\" };\nconst _hoisted_3$7 = { class: \"pi pi-arrow-up text-white text-lg\" };\nconst _hoisted_4$5 = { class: \"absolute left-12 top-0 bg-black bg-opacity-50 rounded-lg shadow-lg\" };\nconst _hoisted_5$5 = { class: \"flex flex-col\" };\nconst _hoisted_6$4 = { class: \"relative show-material-mode\" };\nconst _hoisted_7$3 = { class: \"pi pi-box text-white text-lg\" };\nconst _hoisted_8$2 = { class: \"absolute left-12 top-0 bg-black bg-opacity-50 rounded-lg shadow-lg\" };\nconst _hoisted_9$2 = { class: \"flex flex-col\" };\nconst _hoisted_10$1 = {\n  key: 0,\n  class: \"relative show-edge-threshold\"\n};\nconst _hoisted_11 = { class: \"pi pi-sliders-h text-white text-lg\" };\nconst _hoisted_12 = {\n  class: \"absolute left-12 top-0 bg-black bg-opacity-50 p-4 rounded-lg shadow-lg\",\n  style: { \"width\": \"150px\" }\n};\nconst _hoisted_13 = { class: \"text-white text-xs mb-1 block\" };\nconst _sfc_main$g = /* @__PURE__ */ defineComponent({\n  __name: \"ModelControls\",\n  props: {\n    inputSpec: {},\n    upDirection: {},\n    materialMode: {},\n    edgeThreshold: {}\n  },\n  emits: [\"updateUpDirection\", \"updateMaterialMode\", \"updateEdgeThreshold\"],\n  setup(__props, { emit: __emit }) {\n    const vTooltip = Tooltip;\n    const props = __props;\n    const emit = __emit;\n    const upDirection = ref(props.upDirection || \"original\");\n    const materialMode = ref(props.materialMode || \"original\");\n    const edgeThreshold = ref(props.edgeThreshold || 85);\n    const showUpDirection = ref(false);\n    const showMaterialMode = ref(false);\n    const showEdgeThreshold = ref(false);\n    const upDirections = [\n      \"original\",\n      \"-x\",\n      \"+x\",\n      \"-y\",\n      \"+y\",\n      \"-z\",\n      \"+z\"\n    ];\n    const materialModes = computed(() => {\n      const modes = [\n        \"original\",\n        \"normal\",\n        \"wireframe\"\n        //'depth' disable for now\n      ];\n      if (!props.inputSpec.isAnimation && !props.inputSpec.isPreview) {\n        modes.push(\"lineart\");\n      }\n      return modes;\n    });\n    watch(\n      () => props.upDirection,\n      (newValue) => {\n        if (newValue) {\n          upDirection.value = newValue;\n        }\n      }\n    );\n    watch(\n      () => props.materialMode,\n      (newValue) => {\n        if (newValue) {\n          materialMode.value = newValue;\n        }\n      }\n    );\n    watch(\n      () => props.edgeThreshold,\n      (newValue) => {\n        edgeThreshold.value = newValue;\n      }\n    );\n    const toggleUpDirection = () => {\n      showUpDirection.value = !showUpDirection.value;\n      showMaterialMode.value = false;\n      showEdgeThreshold.value = false;\n    };\n    const selectUpDirection = (direction) => {\n      upDirection.value = direction;\n      emit(\"updateUpDirection\", direction);\n      showUpDirection.value = false;\n    };\n    const formatOption = (option) => {\n      if (option === \"original\") return \"Original\";\n      return option.toUpperCase();\n    };\n    const toggleMaterialMode = () => {\n      showMaterialMode.value = !showMaterialMode.value;\n      showUpDirection.value = false;\n      showEdgeThreshold.value = false;\n    };\n    const selectMaterialMode = (mode) => {\n      materialMode.value = mode;\n      emit(\"updateMaterialMode\", mode);\n      showMaterialMode.value = false;\n    };\n    const formatMaterialMode = (mode) => {\n      return t(`load3d.materialModes.${mode}`);\n    };\n    const toggleEdgeThreshold = () => {\n      showEdgeThreshold.value = !showEdgeThreshold.value;\n      showUpDirection.value = false;\n      showMaterialMode.value = false;\n    };\n    const updateEdgeThreshold = () => {\n      emit(\"updateEdgeThreshold\", edgeThreshold.value);\n    };\n    const closeSceneSlider = (e) => {\n      const target = e.target;\n      if (!target.closest(\".show-up-direction\")) {\n        showUpDirection.value = false;\n      }\n      if (!target.closest(\".show-material-mode\")) {\n        showMaterialMode.value = false;\n      }\n      if (!target.closest(\".show-edge-threshold\")) {\n        showEdgeThreshold.value = false;\n      }\n    };\n    onMounted(() => {\n      document.addEventListener(\"click\", closeSceneSlider);\n    });\n    onUnmounted(() => {\n      document.removeEventListener(\"click\", closeSceneSlider);\n    });\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", _hoisted_1$c, [\n        createElementVNode(\"div\", _hoisted_2$9, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text\",\n            onClick: toggleUpDirection\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_3$7, null, 512), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: unref(t)(\"load3d.upDirection\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          }),\n          withDirectives(createElementVNode(\"div\", _hoisted_4$5, [\n            createElementVNode(\"div\", _hoisted_5$5, [\n              (openBlock(), createElementBlock(Fragment, null, renderList(upDirections, (direction) => {\n                return createVNode(unref(Button), {\n                  key: direction,\n                  class: normalizeClass([\"p-button-text text-white\", { \"bg-blue-500\": upDirection.value === direction }]),\n                  onClick: ($event) => selectUpDirection(direction)\n                }, {\n                  default: withCtx(() => [\n                    createTextVNode(toDisplayString(formatOption(direction)), 1)\n                  ]),\n                  _: 2\n                }, 1032, [\"class\", \"onClick\"]);\n              }), 64))\n            ])\n          ], 512), [\n            [vShow, showUpDirection.value]\n          ])\n        ]),\n        createElementVNode(\"div\", _hoisted_6$4, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text\",\n            onClick: toggleMaterialMode\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_7$3, null, 512), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: unref(t)(\"load3d.materialMode\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          }),\n          withDirectives(createElementVNode(\"div\", _hoisted_8$2, [\n            createElementVNode(\"div\", _hoisted_9$2, [\n              (openBlock(true), createElementBlock(Fragment, null, renderList(materialModes.value, (mode) => {\n                return openBlock(), createBlock(unref(Button), {\n                  key: mode,\n                  class: normalizeClass([\"p-button-text text-white\", { \"bg-blue-500\": materialMode.value === mode }]),\n                  onClick: ($event) => selectMaterialMode(mode)\n                }, {\n                  default: withCtx(() => [\n                    createTextVNode(toDisplayString(formatMaterialMode(mode)), 1)\n                  ]),\n                  _: 2\n                }, 1032, [\"class\", \"onClick\"]);\n              }), 128))\n            ])\n          ], 512), [\n            [vShow, showMaterialMode.value]\n          ])\n        ]),\n        materialMode.value === \"lineart\" ? (openBlock(), createElementBlock(\"div\", _hoisted_10$1, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text\",\n            onClick: toggleEdgeThreshold\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_11, null, 512), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: unref(t)(\"load3d.edgeThreshold\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          }),\n          withDirectives(createElementVNode(\"div\", _hoisted_12, [\n            createElementVNode(\"label\", _hoisted_13, toDisplayString(unref(t)(\"load3d.edgeThreshold\")) + \": \" + toDisplayString(edgeThreshold.value) + \"\", 1),\n            createVNode(unref(Slider), {\n              modelValue: edgeThreshold.value,\n              \"onUpdate:modelValue\": _cache2[0] || (_cache2[0] = ($event) => edgeThreshold.value = $event),\n              class: \"w-full\",\n              min: 0,\n              max: 120,\n              step: 1,\n              onChange: updateEdgeThreshold\n            }, null, 8, [\"modelValue\"])\n          ], 512), [\n            [vShow, showEdgeThreshold.value]\n          ])\n        ])) : createCommentVNode(\"\", true)\n      ]);\n    };\n  }\n});\nconst _hoisted_1$b = { class: \"flex flex-col\" };\nconst _hoisted_2$8 = { class: \"pi pi-table text-white text-lg\" };\nconst _hoisted_3$6 = { key: 0 };\nconst _hoisted_4$4 = { class: \"pi pi-palette text-white text-lg\" };\nconst _hoisted_5$4 = [\"value\"];\nconst _hoisted_6$3 = { key: 1 };\nconst _hoisted_7$2 = { class: \"pi pi-image text-white text-lg\" };\nconst _hoisted_8$1 = { key: 2 };\nconst _hoisted_9$1 = { class: \"pi pi-times text-white text-lg\" };\nconst _sfc_main$f = /* @__PURE__ */ defineComponent({\n  __name: \"SceneControls\",\n  props: {\n    backgroundColor: {},\n    showGrid: { type: Boolean },\n    hasBackgroundImage: { type: Boolean }\n  },\n  emits: [\"toggleGrid\", \"updateBackgroundColor\", \"updateBackgroundImage\"],\n  setup(__props, { emit: __emit }) {\n    const vTooltip = Tooltip;\n    const props = __props;\n    const emit = __emit;\n    const backgroundColor = ref(props.backgroundColor);\n    const showGrid = ref(props.showGrid);\n    const hasBackgroundImage = ref(props.hasBackgroundImage);\n    const colorPickerRef = ref(null);\n    const imagePickerRef = ref(null);\n    watch(\n      () => props.backgroundColor,\n      (newValue) => {\n        backgroundColor.value = newValue;\n      }\n    );\n    watch(\n      () => props.showGrid,\n      (newValue) => {\n        showGrid.value = newValue;\n      }\n    );\n    watch(\n      () => props.hasBackgroundImage,\n      (newValue) => {\n        hasBackgroundImage.value = newValue;\n      }\n    );\n    const toggleGrid = () => {\n      showGrid.value = !showGrid.value;\n      emit(\"toggleGrid\", showGrid.value);\n    };\n    const updateBackgroundColor = (color) => {\n      emit(\"updateBackgroundColor\", color);\n    };\n    const openColorPicker = () => {\n      var _a2;\n      (_a2 = colorPickerRef.value) == null ? void 0 : _a2.click();\n    };\n    const openImagePicker = () => {\n      var _a2;\n      (_a2 = imagePickerRef.value) == null ? void 0 : _a2.click();\n    };\n    const uploadBackgroundImage = (event) => {\n      const input = event.target;\n      if (input.files && input.files[0]) {\n        emit(\"updateBackgroundImage\", input.files[0]);\n      }\n    };\n    const removeBackgroundImage = () => {\n      emit(\"updateBackgroundImage\", null);\n    };\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", _hoisted_1$b, [\n        createVNode(unref(Button), {\n          class: normalizeClass([\"p-button-rounded p-button-text\", { \"p-button-outlined\": showGrid.value }]),\n          onClick: toggleGrid\n        }, {\n          default: withCtx(() => [\n            withDirectives(createElementVNode(\"i\", _hoisted_2$8, null, 512), [\n              [\n                unref(vTooltip),\n                { value: unref(t)(\"load3d.showGrid\"), showDelay: 300 },\n                void 0,\n                { right: true }\n              ]\n            ])\n          ]),\n          _: 1\n        }, 8, [\"class\"]),\n        !hasBackgroundImage.value ? (openBlock(), createElementBlock(\"div\", _hoisted_3$6, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text\",\n            onClick: openColorPicker\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_4$4, null, 512), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: unref(t)(\"load3d.backgroundColor\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ]),\n              createElementVNode(\"input\", {\n                ref_key: \"colorPickerRef\",\n                ref: colorPickerRef,\n                type: \"color\",\n                value: backgroundColor.value,\n                class: \"absolute opacity-0 w-0 h-0 p-0 m-0 pointer-events-none\",\n                onInput: _cache2[0] || (_cache2[0] = ($event) => updateBackgroundColor($event.target.value))\n              }, null, 40, _hoisted_5$4)\n            ]),\n            _: 1\n          })\n        ])) : createCommentVNode(\"\", true),\n        !hasBackgroundImage.value ? (openBlock(), createElementBlock(\"div\", _hoisted_6$3, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text\",\n            onClick: openImagePicker\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_7$2, null, 512), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: unref(t)(\"load3d.uploadBackgroundImage\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ]),\n              createElementVNode(\"input\", {\n                ref_key: \"imagePickerRef\",\n                ref: imagePickerRef,\n                type: \"file\",\n                accept: \"image/*\",\n                class: \"absolute opacity-0 w-0 h-0 p-0 m-0 pointer-events-none\",\n                onChange: uploadBackgroundImage\n              }, null, 544)\n            ]),\n            _: 1\n          })\n        ])) : createCommentVNode(\"\", true),\n        hasBackgroundImage.value ? (openBlock(), createElementBlock(\"div\", _hoisted_8$1, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text\",\n            onClick: removeBackgroundImage\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_9$1, null, 512), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: unref(t)(\"load3d.removeBackgroundImage\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          })\n        ])) : createCommentVNode(\"\", true)\n      ]);\n    };\n  }\n});\nconst _hoisted_1$a = { class: \"absolute top-12 left-2 flex flex-col pointer-events-auto z-20 bg-gray-700 bg-opacity-30 rounded-lg\" };\nconst _hoisted_2$7 = { class: \"relative show-menu\" };\nconst _hoisted_3$5 = { class: \"absolute left-12 top-0 bg-black bg-opacity-50 rounded-lg shadow-lg\" };\nconst _hoisted_4$3 = { class: \"flex flex-col\" };\nconst _hoisted_5$3 = { class: \"text-white\" };\nconst _hoisted_6$2 = { class: \"bg-gray-700 bg-opacity-30 rounded-lg\" };\nconst _hoisted_7$1 = { key: 0 };\nconst _sfc_main$e = /* @__PURE__ */ defineComponent({\n  __name: \"Load3DControls\",\n  props: {\n    inputSpec: {},\n    backgroundColor: {},\n    showGrid: { type: Boolean },\n    showPreview: { type: Boolean },\n    lightIntensity: {},\n    showLightIntensityButton: { type: Boolean },\n    fov: {},\n    showFOVButton: { type: Boolean },\n    showPreviewButton: { type: Boolean },\n    cameraType: {},\n    hasBackgroundImage: { type: Boolean },\n    upDirection: {},\n    materialMode: {},\n    edgeThreshold: {}\n  },\n  emits: [\"switchCamera\", \"toggleGrid\", \"updateBackgroundColor\", \"updateLightIntensity\", \"updateFOV\", \"togglePreview\", \"updateBackgroundImage\", \"updateUpDirection\", \"updateMaterialMode\", \"updateEdgeThreshold\", \"exportModel\"],\n  setup(__props, { emit: __emit }) {\n    const vTooltip = Tooltip;\n    const props = __props;\n    const isMenuOpen = ref(false);\n    const activeCategory = ref(\"scene\");\n    const categoryLabels = {\n      scene: \"load3d.scene\",\n      model: \"load3d.model\",\n      camera: \"load3d.camera\",\n      light: \"load3d.light\",\n      export: \"load3d.export\"\n    };\n    const availableCategories = computed(() => {\n      const baseCategories = [\"scene\", \"model\", \"camera\", \"light\"];\n      if (!props.inputSpec.isAnimation) {\n        return [...baseCategories, \"export\"];\n      }\n      return baseCategories;\n    });\n    const toggleMenu = () => {\n      isMenuOpen.value = !isMenuOpen.value;\n    };\n    const selectCategory = (category) => {\n      activeCategory.value = category;\n      isMenuOpen.value = false;\n    };\n    const getCategoryIcon = (category) => {\n      const icons = {\n        scene: \"pi pi-image\",\n        model: \"pi pi-box\",\n        camera: \"pi pi-camera\",\n        light: \"pi pi-sun\",\n        export: \"pi pi-download\"\n      };\n      return `${icons[category]} text-white text-lg`;\n    };\n    const emit = __emit;\n    const backgroundColor = ref(props.backgroundColor);\n    const showGrid = ref(props.showGrid);\n    const showPreview = ref(props.showPreview);\n    const lightIntensity = ref(props.lightIntensity);\n    const upDirection = ref(props.upDirection || \"original\");\n    const materialMode = ref(props.materialMode || \"original\");\n    const showLightIntensityButton = ref(props.showLightIntensityButton);\n    const fov2 = ref(props.fov);\n    const showFOVButton = ref(props.showFOVButton);\n    const showPreviewButton = ref(props.showPreviewButton);\n    const hasBackgroundImage = ref(props.hasBackgroundImage);\n    const edgeThreshold = ref(props.edgeThreshold);\n    const switchCamera = () => {\n      emit(\"switchCamera\");\n    };\n    const togglePreview = () => {\n      showPreview.value = !showPreview.value;\n      emit(\"togglePreview\", showPreview.value);\n    };\n    const handleToggleGrid = (value) => {\n      emit(\"toggleGrid\", value);\n    };\n    const handleBackgroundColorChange = (value) => {\n      emit(\"updateBackgroundColor\", value);\n    };\n    const handleBackgroundImageUpdate = (file2) => {\n      emit(\"updateBackgroundImage\", file2);\n    };\n    const handleUpdateUpDirection = (direction) => {\n      emit(\"updateUpDirection\", direction);\n    };\n    const handleUpdateMaterialMode = (mode) => {\n      emit(\"updateMaterialMode\", mode);\n    };\n    const handleUpdateEdgeThreshold = (value) => {\n      emit(\"updateEdgeThreshold\", value);\n    };\n    const handleUpdateLightIntensity = (value) => {\n      emit(\"updateLightIntensity\", value);\n    };\n    const handleUpdateFOV = (value) => {\n      emit(\"updateFOV\", value);\n    };\n    const handleExportModel = (format) => {\n      emit(\"exportModel\", format);\n    };\n    const closeSlider = (e) => {\n      const target = e.target;\n      if (!target.closest(\".show-menu\")) {\n        isMenuOpen.value = false;\n      }\n    };\n    watch(\n      () => props.upDirection,\n      (newValue) => {\n        if (newValue) {\n          upDirection.value = newValue;\n        }\n      }\n    );\n    watch(\n      () => props.backgroundColor,\n      (newValue) => {\n        backgroundColor.value = newValue;\n      }\n    );\n    watch(\n      () => props.fov,\n      (newValue) => {\n        fov2.value = newValue;\n      }\n    );\n    watch(\n      () => props.lightIntensity,\n      (newValue) => {\n        lightIntensity.value = newValue;\n      }\n    );\n    watch(\n      () => props.showFOVButton,\n      (newValue) => {\n        showFOVButton.value = newValue;\n      }\n    );\n    watch(\n      () => props.showLightIntensityButton,\n      (newValue) => {\n        showLightIntensityButton.value = newValue;\n      }\n    );\n    watch(\n      () => props.upDirection,\n      (newValue) => {\n        upDirection.value = newValue;\n      }\n    );\n    watch(\n      () => props.materialMode,\n      (newValue) => {\n        materialMode.value = newValue;\n      }\n    );\n    watch(\n      () => props.showPreviewButton,\n      (newValue) => {\n        showPreviewButton.value = newValue;\n      }\n    );\n    watch(\n      () => props.showPreview,\n      (newValue) => {\n        showPreview.value = newValue;\n      }\n    );\n    watch(\n      () => props.hasBackgroundImage,\n      (newValue) => {\n        hasBackgroundImage.value = newValue;\n      }\n    );\n    watch(\n      () => props.materialMode,\n      (newValue) => {\n        if (newValue) {\n          materialMode.value = newValue;\n        }\n      }\n    );\n    watch(\n      () => props.edgeThreshold,\n      (newValue) => {\n        edgeThreshold.value = newValue;\n      }\n    );\n    onMounted(() => {\n      document.addEventListener(\"click\", closeSlider);\n    });\n    onUnmounted(() => {\n      document.removeEventListener(\"click\", closeSlider);\n    });\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", _hoisted_1$a, [\n        createElementVNode(\"div\", _hoisted_2$7, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text bg-opacity-30\",\n            onClick: toggleMenu\n          }, {\n            default: withCtx(() => _cache2[0] || (_cache2[0] = [\n              createElementVNode(\"i\", { class: \"pi pi-bars text-white text-lg\" }, null, -1)\n            ])),\n            _: 1\n          }),\n          withDirectives(createElementVNode(\"div\", _hoisted_3$5, [\n            createElementVNode(\"div\", _hoisted_4$3, [\n              (openBlock(true), createElementBlock(Fragment, null, renderList(availableCategories.value, (category) => {\n                return openBlock(), createBlock(unref(Button), {\n                  key: category,\n                  class: normalizeClass([\"p-button-text w-full flex items-center justify-start\", { \"bg-gray-600\": activeCategory.value === category }]),\n                  onClick: ($event) => selectCategory(category)\n                }, {\n                  default: withCtx(() => [\n                    createElementVNode(\"i\", {\n                      class: normalizeClass(getCategoryIcon(category))\n                    }, null, 2),\n                    createElementVNode(\"span\", _hoisted_5$3, toDisplayString(unref(t)(categoryLabels[category])), 1)\n                  ]),\n                  _: 2\n                }, 1032, [\"class\", \"onClick\"]);\n              }), 128))\n            ])\n          ], 512), [\n            [vShow, isMenuOpen.value]\n          ])\n        ]),\n        withDirectives(createElementVNode(\"div\", _hoisted_6$2, [\n          activeCategory.value === \"scene\" ? (openBlock(), createBlock(_sfc_main$f, {\n            key: 0,\n            ref: \"sceneControlsRef\",\n            \"background-color\": backgroundColor.value,\n            \"show-grid\": showGrid.value,\n            \"has-background-image\": hasBackgroundImage.value,\n            onToggleGrid: handleToggleGrid,\n            onUpdateBackgroundColor: handleBackgroundColorChange,\n            onUpdateBackgroundImage: handleBackgroundImageUpdate\n          }, null, 8, [\"background-color\", \"show-grid\", \"has-background-image\"])) : createCommentVNode(\"\", true),\n          activeCategory.value === \"model\" ? (openBlock(), createBlock(_sfc_main$g, {\n            key: 1,\n            ref: \"modelControlsRef\",\n            \"input-spec\": _ctx.inputSpec,\n            \"up-direction\": upDirection.value,\n            \"material-mode\": materialMode.value,\n            \"edge-threshold\": edgeThreshold.value,\n            onUpdateUpDirection: handleUpdateUpDirection,\n            onUpdateMaterialMode: handleUpdateMaterialMode,\n            onUpdateEdgeThreshold: handleUpdateEdgeThreshold\n          }, null, 8, [\"input-spec\", \"up-direction\", \"material-mode\", \"edge-threshold\"])) : createCommentVNode(\"\", true),\n          activeCategory.value === \"camera\" ? (openBlock(), createBlock(_sfc_main$j, {\n            key: 2,\n            ref: \"cameraControlsRef\",\n            \"camera-type\": _ctx.cameraType,\n            fov: fov2.value,\n            \"show-f-o-v-button\": showFOVButton.value,\n            onSwitchCamera: switchCamera,\n            onUpdateFOV: handleUpdateFOV\n          }, null, 8, [\"camera-type\", \"fov\", \"show-f-o-v-button\"])) : createCommentVNode(\"\", true),\n          activeCategory.value === \"light\" ? (openBlock(), createBlock(_sfc_main$h, {\n            key: 3,\n            ref: \"lightControlsRef\",\n            \"light-intensity\": lightIntensity.value,\n            \"show-light-intensity-button\": showLightIntensityButton.value,\n            onUpdateLightIntensity: handleUpdateLightIntensity\n          }, null, 8, [\"light-intensity\", \"show-light-intensity-button\"])) : createCommentVNode(\"\", true),\n          activeCategory.value === \"export\" ? (openBlock(), createBlock(_sfc_main$i, {\n            key: 4,\n            ref: \"exportControlsRef\",\n            onExportModel: handleExportModel\n          }, null, 512)) : createCommentVNode(\"\", true)\n        ], 512), [\n          [vShow, activeCategory.value]\n        ]),\n        showPreviewButton.value ? (openBlock(), createElementBlock(\"div\", _hoisted_7$1, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text\",\n            onClick: togglePreview\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", {\n                class: normalizeClass([\n                  \"pi\",\n                  showPreview.value ? \"pi-eye\" : \"pi-eye-slash\",\n                  \"text-white text-lg\"\n                ])\n              }, null, 2), [\n                [\n                  unref(vTooltip),\n                  { value: unref(t)(\"load3d.previewOutput\"), showDelay: 300 },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          })\n        ])) : createCommentVNode(\"\", true)\n      ]);\n    };\n  }\n});\nconst _hoisted_1$9 = {\n  key: 0,\n  class: \"absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\"\n};\nconst _hoisted_2$6 = { class: \"flex flex-col items-center\" };\nconst _hoisted_3$4 = { class: \"text-white mt-4 text-lg\" };\nconst _sfc_main$d = /* @__PURE__ */ defineComponent({\n  __name: \"LoadingOverlay\",\n  setup(__props, { expose: __expose }) {\n    const modelLoading = ref(false);\n    const loadingMessage = ref(\"\");\n    const startLoading = async (message) => {\n      loadingMessage.value = message || t(\"load3d.loadingModel\");\n      modelLoading.value = true;\n      await nextTick();\n    };\n    const endLoading = async () => {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n      modelLoading.value = false;\n    };\n    __expose({\n      startLoading,\n      endLoading\n    });\n    return (_ctx, _cache2) => {\n      return openBlock(), createBlock(Transition, { name: \"fade\" }, {\n        default: withCtx(() => [\n          modelLoading.value ? (openBlock(), createElementBlock(\"div\", _hoisted_1$9, [\n            createElementVNode(\"div\", _hoisted_2$6, [\n              _cache2[0] || (_cache2[0] = createElementVNode(\"div\", { class: \"spinner\" }, null, -1)),\n              createElementVNode(\"div\", _hoisted_3$4, toDisplayString(loadingMessage.value), 1)\n            ])\n          ])) : createCommentVNode(\"\", true)\n        ]),\n        _: 1\n      });\n    };\n  }\n});\nconst LoadingOverlay = /* @__PURE__ */ _export_sfc(_sfc_main$d, [[\"__scopeId\", \"data-v-fd51e330\"]]);\nconst REVISION = \"170\";\nconst MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\nconst TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst ConstantColorFactor = 211;\nconst OneMinusConstantColorFactor = 212;\nconst ConstantAlphaFactor = 213;\nconst OneMinusConstantAlphaFactor = 214;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\nconst AgXToneMapping = 6;\nconst NeutralToneMapping = 7;\nconst AttachedBindMode = \"attached\";\nconst DetachedBindMode = \"detached\";\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst RepeatWrapping = 1e3;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedInt248Type = 1020;\nconst UnsignedInt5999Type = 35902;\nconst AlphaFormat = 1021;\nconst RGBFormat = 1022;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBAIntegerFormat = 1033;\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst RGB_BPTC_SIGNED_Format = 36494;\nconst RGB_BPTC_UNSIGNED_Format = 36495;\nconst RED_RGTC1_Format = 36283;\nconst SIGNED_RED_RGTC1_Format = 36284;\nconst RED_GREEN_RGTC2_Format = 36285;\nconst SIGNED_RED_GREEN_RGTC2_Format = 36286;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\nconst NoColorSpace = \"\";\nconst SRGBColorSpace = \"srgb\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst LinearTransfer = \"linear\";\nconst SRGBTransfer = \"srgb\";\nconst KeepStencilOp = 7680;\nconst AlwaysStencilFunc = 519;\nconst NeverCompare = 512;\nconst LessCompare = 513;\nconst EqualCompare = 514;\nconst LessEqualCompare = 515;\nconst GreaterCompare = 516;\nconst NotEqualCompare = 517;\nconst GreaterEqualCompare = 518;\nconst AlwaysCompare = 519;\nconst StaticDrawUsage = 35044;\nconst GLSL3 = \"300 es\";\nconst WebGLCoordinateSystem = 2e3;\nconst WebGPUCoordinateSystem = 2001;\nclass EventDispatcher {\n  addEventListener(type, listener) {\n    if (this._listeners === void 0) this._listeners = {};\n    const listeners = this._listeners;\n    if (listeners[type] === void 0) {\n      listeners[type] = [];\n    }\n    if (listeners[type].indexOf(listener) === -1) {\n      listeners[type].push(listener);\n    }\n  }\n  hasEventListener(type, listener) {\n    if (this._listeners === void 0) return false;\n    const listeners = this._listeners;\n    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n  }\n  removeEventListener(type, listener) {\n    if (this._listeners === void 0) return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[type];\n    if (listenerArray !== void 0) {\n      const index = listenerArray.indexOf(listener);\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n  }\n  dispatchEvent(event) {\n    if (this._listeners === void 0) return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[event.type];\n    if (listenerArray !== void 0) {\n      event.target = this;\n      const array = listenerArray.slice(0);\n      for (let i = 0, l = array.length; i < l; i++) {\n        array[i].call(this, event);\n      }\n      event.target = null;\n    }\n  }\n}\nconst _lut = [\"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"0a\", \"0b\", \"0c\", \"0d\", \"0e\", \"0f\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"1a\", \"1b\", \"1c\", \"1d\", \"1e\", \"1f\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"2a\", \"2b\", \"2c\", \"2d\", \"2e\", \"2f\", \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"3a\", \"3b\", \"3c\", \"3d\", \"3e\", \"3f\", \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"4a\", \"4b\", \"4c\", \"4d\", \"4e\", \"4f\", \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\", \"5a\", \"5b\", \"5c\", \"5d\", \"5e\", \"5f\", \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\", \"6a\", \"6b\", \"6c\", \"6d\", \"6e\", \"6f\", \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\", \"7a\", \"7b\", \"7c\", \"7d\", \"7e\", \"7f\", \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"8a\", \"8b\", \"8c\", \"8d\", \"8e\", \"8f\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\", \"9a\", \"9b\", \"9c\", \"9d\", \"9e\", \"9f\", \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"a7\", \"a8\", \"a9\", \"aa\", \"ab\", \"ac\", \"ad\", \"ae\", \"af\", \"b0\", \"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\", \"b9\", \"ba\", \"bb\", \"bc\", \"bd\", \"be\", \"bf\", \"c0\", \"c1\", \"c2\", \"c3\", \"c4\", \"c5\", \"c6\", \"c7\", \"c8\", \"c9\", \"ca\", \"cb\", \"cc\", \"cd\", \"ce\", \"cf\", \"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\", \"da\", \"db\", \"dc\", \"dd\", \"de\", \"df\", \"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\", \"e6\", \"e7\", \"e8\", \"e9\", \"ea\", \"eb\", \"ec\", \"ed\", \"ee\", \"ef\", \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \"f9\", \"fa\", \"fb\", \"fc\", \"fd\", \"fe\", \"ff\"];\nlet _seed = 1234567;\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\nfunction generateUUID() {\n  const d0 = Math.random() * 4294967295 | 0;\n  const d1 = Math.random() * 4294967295 | 0;\n  const d2 = Math.random() * 4294967295 | 0;\n  const d3 = Math.random() * 4294967295 | 0;\n  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + \"-\" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + \"-\" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + \"-\" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + \"-\" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];\n  return uuid.toLowerCase();\n}\nfunction clamp(value, min, max2) {\n  return Math.max(min, Math.min(max2, value));\n}\nfunction euclideanModulo(n, m) {\n  return (n % m + m) % m;\n}\nfunction mapLinear(x, a1, a2, b1, b2) {\n  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n}\nfunction inverseLerp(x, y, value) {\n  if (x !== y) {\n    return (value - x) / (y - x);\n  } else {\n    return 0;\n  }\n}\nfunction lerp(x, y, t2) {\n  return (1 - t2) * x + t2 * y;\n}\nfunction damp(x, y, lambda, dt) {\n  return lerp(x, y, 1 - Math.exp(-lambda * dt));\n}\nfunction pingpong(x, length = 1) {\n  return length - Math.abs(euclideanModulo(x, length * 2) - length);\n}\nfunction smoothstep(x, min, max2) {\n  if (x <= min) return 0;\n  if (x >= max2) return 1;\n  x = (x - min) / (max2 - min);\n  return x * x * (3 - 2 * x);\n}\nfunction smootherstep(x, min, max2) {\n  if (x <= min) return 0;\n  if (x >= max2) return 1;\n  x = (x - min) / (max2 - min);\n  return x * x * x * (x * (x * 6 - 15) + 10);\n}\nfunction randInt(low, high) {\n  return low + Math.floor(Math.random() * (high - low + 1));\n}\nfunction randFloat(low, high) {\n  return low + Math.random() * (high - low);\n}\nfunction randFloatSpread(range) {\n  return range * (0.5 - Math.random());\n}\nfunction seededRandom(s) {\n  if (s !== void 0) _seed = s;\n  let t2 = _seed += 1831565813;\n  t2 = Math.imul(t2 ^ t2 >>> 15, t2 | 1);\n  t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, t2 | 61);\n  return ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;\n}\nfunction degToRad(degrees) {\n  return degrees * DEG2RAD;\n}\nfunction radToDeg(radians) {\n  return radians * RAD2DEG;\n}\nfunction isPowerOfTwo(value) {\n  return (value & value - 1) === 0 && value !== 0;\n}\nfunction ceilPowerOfTwo(value) {\n  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\nfunction floorPowerOfTwo(value) {\n  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n}\nfunction setQuaternionFromProperEuler(q, a, b, c, order) {\n  const cos = Math.cos;\n  const sin = Math.sin;\n  const c2 = cos(b / 2);\n  const s2 = sin(b / 2);\n  const c13 = cos((a + c) / 2);\n  const s13 = sin((a + c) / 2);\n  const c1_3 = cos((a - c) / 2);\n  const s1_3 = sin((a - c) / 2);\n  const c3_1 = cos((c - a) / 2);\n  const s3_1 = sin((c - a) / 2);\n  switch (order) {\n    case \"XYX\":\n      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);\n      break;\n    case \"YZY\":\n      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);\n      break;\n    case \"ZXZ\":\n      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);\n      break;\n    case \"XZX\":\n      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);\n      break;\n    case \"YXY\":\n      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);\n      break;\n    case \"ZYZ\":\n      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);\n      break;\n    default:\n      console.warn(\"THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: \" + order);\n  }\n}\nfunction denormalize(value, array) {\n  switch (array.constructor) {\n    case Float32Array:\n      return value;\n    case Uint32Array:\n      return value / 4294967295;\n    case Uint16Array:\n      return value / 65535;\n    case Uint8Array:\n      return value / 255;\n    case Int32Array:\n      return Math.max(value / 2147483647, -1);\n    case Int16Array:\n      return Math.max(value / 32767, -1);\n    case Int8Array:\n      return Math.max(value / 127, -1);\n    default:\n      throw new Error(\"Invalid component type.\");\n  }\n}\nfunction normalize(value, array) {\n  switch (array.constructor) {\n    case Float32Array:\n      return value;\n    case Uint32Array:\n      return Math.round(value * 4294967295);\n    case Uint16Array:\n      return Math.round(value * 65535);\n    case Uint8Array:\n      return Math.round(value * 255);\n    case Int32Array:\n      return Math.round(value * 2147483647);\n    case Int16Array:\n      return Math.round(value * 32767);\n    case Int8Array:\n      return Math.round(value * 127);\n    default:\n      throw new Error(\"Invalid component type.\");\n  }\n}\nconst MathUtils = {\n  DEG2RAD,\n  RAD2DEG,\n  generateUUID,\n  clamp,\n  euclideanModulo,\n  mapLinear,\n  inverseLerp,\n  lerp,\n  damp,\n  pingpong,\n  smoothstep,\n  smootherstep,\n  randInt,\n  randFloat,\n  randFloatSpread,\n  seededRandom,\n  degToRad,\n  radToDeg,\n  isPowerOfTwo,\n  ceilPowerOfTwo,\n  floorPowerOfTwo,\n  setQuaternionFromProperEuler,\n  normalize,\n  denormalize\n};\nclass Vector2 {\n  constructor(x = 0, y = 0) {\n    Vector2.prototype.isVector2 = true;\n    this.x = x;\n    this.y = y;\n  }\n  get width() {\n    return this.x;\n  }\n  set width(value) {\n    this.x = value;\n  }\n  get height() {\n    return this.y;\n  }\n  set height(value) {\n    this.y = value;\n  }\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    return this;\n  }\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n    return this;\n  }\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    return this;\n  }\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    return this;\n  }\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    return this;\n  }\n  sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    return this;\n  }\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    return this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    return this;\n  }\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    return this;\n  }\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  applyMatrix3(m) {\n    const x = this.x, y = this.y;\n    const e = m.elements;\n    this.x = e[0] * x + e[3] * y + e[6];\n    this.y = e[1] * x + e[4] * y + e[7];\n    return this;\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    return this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    return this;\n  }\n  clamp(min, max2) {\n    this.x = Math.max(min.x, Math.min(max2.x, this.x));\n    this.y = Math.max(min.y, Math.min(max2.y, this.y));\n    return this;\n  }\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    return this;\n  }\n  clampLength(min, max2) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max2, length)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n  roundToZero() {\n    this.x = Math.trunc(this.x);\n    this.y = Math.trunc(this.y);\n    return this;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y * v.y;\n  }\n  cross(v) {\n    return this.x * v.y - this.y * v.x;\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y);\n  }\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n  angle() {\n    const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n    return angle;\n  }\n  angleTo(v) {\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n    if (denominator === 0) return Math.PI / 2;\n    const theta = this.dot(v) / denominator;\n    return Math.acos(clamp(theta, -1, 1));\n  }\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n  distanceToSquared(v) {\n    const dx = this.x - v.x, dy = this.y - v.y;\n    return dx * dx + dy * dy;\n  }\n  manhattanDistanceTo(v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n  }\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === this.y;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    return this;\n  }\n  rotateAround(center, angle) {\n    const c = Math.cos(angle), s = Math.sin(angle);\n    const x = this.x - center.x;\n    const y = this.y - center.y;\n    this.x = x * c - y * s + center.x;\n    this.y = x * s + y * c + center.y;\n    return this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    return this;\n  }\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n  }\n}\nclass Matrix3 {\n  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n    Matrix3.prototype.isMatrix3 = true;\n    this.elements = [\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1\n    ];\n    if (n11 !== void 0) {\n      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n    }\n  }\n  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n    const te = this.elements;\n    te[0] = n11;\n    te[1] = n21;\n    te[2] = n31;\n    te[3] = n12;\n    te[4] = n22;\n    te[5] = n32;\n    te[6] = n13;\n    te[7] = n23;\n    te[8] = n33;\n    return this;\n  }\n  identity() {\n    this.set(\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  copy(m) {\n    const te = this.elements;\n    const me = m.elements;\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n    return this;\n  }\n  extractBasis(xAxis, yAxis, zAxis) {\n    xAxis.setFromMatrix3Column(this, 0);\n    yAxis.setFromMatrix3Column(this, 1);\n    zAxis.setFromMatrix3Column(this, 2);\n    return this;\n  }\n  setFromMatrix4(m) {\n    const me = m.elements;\n    this.set(\n      me[0],\n      me[4],\n      me[8],\n      me[1],\n      me[5],\n      me[9],\n      me[2],\n      me[6],\n      me[10]\n    );\n    return this;\n  }\n  multiply(m) {\n    return this.multiplyMatrices(this, m);\n  }\n  premultiply(m) {\n    return this.multiplyMatrices(m, this);\n  }\n  multiplyMatrices(a, b) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n    const a11 = ae[0], a12 = ae[3], a13 = ae[6];\n    const a21 = ae[1], a22 = ae[4], a23 = ae[7];\n    const a31 = ae[2], a32 = ae[5], a33 = ae[8];\n    const b11 = be[0], b12 = be[3], b13 = be[6];\n    const b21 = be[1], b22 = be[4], b23 = be[7];\n    const b31 = be[2], b32 = be[5], b33 = be[8];\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n    te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n    te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n    te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n    te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n    te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n    te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n    return this;\n  }\n  multiplyScalar(s) {\n    const te = this.elements;\n    te[0] *= s;\n    te[3] *= s;\n    te[6] *= s;\n    te[1] *= s;\n    te[4] *= s;\n    te[7] *= s;\n    te[2] *= s;\n    te[5] *= s;\n    te[8] *= s;\n    return this;\n  }\n  determinant() {\n    const te = this.elements;\n    const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];\n    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n  }\n  invert() {\n    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const detInv = 1 / det;\n    te[0] = t11 * detInv;\n    te[1] = (n31 * n23 - n33 * n21) * detInv;\n    te[2] = (n32 * n21 - n31 * n22) * detInv;\n    te[3] = t12 * detInv;\n    te[4] = (n33 * n11 - n31 * n13) * detInv;\n    te[5] = (n31 * n12 - n32 * n11) * detInv;\n    te[6] = t13 * detInv;\n    te[7] = (n21 * n13 - n23 * n11) * detInv;\n    te[8] = (n22 * n11 - n21 * n12) * detInv;\n    return this;\n  }\n  transpose() {\n    let tmp;\n    const m = this.elements;\n    tmp = m[1];\n    m[1] = m[3];\n    m[3] = tmp;\n    tmp = m[2];\n    m[2] = m[6];\n    m[6] = tmp;\n    tmp = m[5];\n    m[5] = m[7];\n    m[7] = tmp;\n    return this;\n  }\n  getNormalMatrix(matrix4) {\n    return this.setFromMatrix4(matrix4).invert().transpose();\n  }\n  transposeIntoArray(r) {\n    const m = this.elements;\n    r[0] = m[0];\n    r[1] = m[3];\n    r[2] = m[6];\n    r[3] = m[1];\n    r[4] = m[4];\n    r[5] = m[7];\n    r[6] = m[2];\n    r[7] = m[5];\n    r[8] = m[8];\n    return this;\n  }\n  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n    const c = Math.cos(rotation);\n    const s = Math.sin(rotation);\n    this.set(\n      sx * c,\n      sx * s,\n      -sx * (c * cx + s * cy) + cx + tx,\n      -sy * s,\n      sy * c,\n      -sy * (-s * cx + c * cy) + cy + ty,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  //\n  scale(sx, sy) {\n    this.premultiply(_m3.makeScale(sx, sy));\n    return this;\n  }\n  rotate(theta) {\n    this.premultiply(_m3.makeRotation(-theta));\n    return this;\n  }\n  translate(tx, ty) {\n    this.premultiply(_m3.makeTranslation(tx, ty));\n    return this;\n  }\n  // for 2D Transforms\n  makeTranslation(x, y) {\n    if (x.isVector2) {\n      this.set(\n        1,\n        0,\n        x.x,\n        0,\n        1,\n        x.y,\n        0,\n        0,\n        1\n      );\n    } else {\n      this.set(\n        1,\n        0,\n        x,\n        0,\n        1,\n        y,\n        0,\n        0,\n        1\n      );\n    }\n    return this;\n  }\n  makeRotation(theta) {\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    this.set(\n      c,\n      -s,\n      0,\n      s,\n      c,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  makeScale(x, y) {\n    this.set(\n      x,\n      0,\n      0,\n      0,\n      y,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  //\n  equals(matrix) {\n    const te = this.elements;\n    const me = matrix.elements;\n    for (let i = 0; i < 9; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n    return true;\n  }\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 9; i++) {\n      this.elements[i] = array[i + offset];\n    }\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    const te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    return array;\n  }\n  clone() {\n    return new this.constructor().fromArray(this.elements);\n  }\n}\nconst _m3 = /* @__PURE__ */ new Matrix3();\nfunction arrayNeedsUint32(array) {\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (array[i] >= 65535) return true;\n  }\n  return false;\n}\nfunction createElementNS(name) {\n  return document.createElementNS(\"http://www.w3.org/1999/xhtml\", name);\n}\nfunction createCanvasElement() {\n  const canvas = createElementNS(\"canvas\");\n  canvas.style.display = \"block\";\n  return canvas;\n}\nconst _cache = {};\nfunction warnOnce(message) {\n  if (message in _cache) return;\n  _cache[message] = true;\n  console.warn(message);\n}\nfunction probeAsync(gl, sync, interval) {\n  return new Promise(function(resolve, reject) {\n    function probe() {\n      switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {\n        case gl.WAIT_FAILED:\n          reject();\n          break;\n        case gl.TIMEOUT_EXPIRED:\n          setTimeout(probe, interval);\n          break;\n        default:\n          resolve();\n      }\n    }\n    setTimeout(probe, interval);\n  });\n}\nfunction toNormalizedProjectionMatrix(projectionMatrix) {\n  const m = projectionMatrix.elements;\n  m[2] = 0.5 * m[2] + 0.5 * m[3];\n  m[6] = 0.5 * m[6] + 0.5 * m[7];\n  m[10] = 0.5 * m[10] + 0.5 * m[11];\n  m[14] = 0.5 * m[14] + 0.5 * m[15];\n}\nfunction toReversedProjectionMatrix(projectionMatrix) {\n  const m = projectionMatrix.elements;\n  const isPerspectiveMatrix = m[11] === -1;\n  if (isPerspectiveMatrix) {\n    m[10] = -m[10] - 1;\n    m[14] = -m[14];\n  } else {\n    m[10] = -m[10];\n    m[14] = -m[14] + 1;\n  }\n}\nconst ColorManagement = {\n  enabled: true,\n  workingColorSpace: LinearSRGBColorSpace,\n  /**\n   * Implementations of supported color spaces.\n   *\n   * Required:\n   *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n   *\t- whitePoint: reference white [ x y ]\n   *\t- transfer: transfer function (pre-defined)\n   *\t- toXYZ: Matrix3 RGB to XYZ transform\n   *\t- fromXYZ: Matrix3 XYZ to RGB transform\n   *\t- luminanceCoefficients: RGB luminance coefficients\n   *\n   * Optional:\n   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\n   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n   *\n   * Reference:\n   * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n   */\n  spaces: {},\n  convert: function(color, sourceColorSpace, targetColorSpace) {\n    if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\n      return color;\n    }\n    if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\n      color.r = SRGBToLinear(color.r);\n      color.g = SRGBToLinear(color.g);\n      color.b = SRGBToLinear(color.b);\n    }\n    if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {\n      color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\n      color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\n    }\n    if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\n      color.r = LinearToSRGB(color.r);\n      color.g = LinearToSRGB(color.g);\n      color.b = LinearToSRGB(color.b);\n    }\n    return color;\n  },\n  fromWorkingColorSpace: function(color, targetColorSpace) {\n    return this.convert(color, this.workingColorSpace, targetColorSpace);\n  },\n  toWorkingColorSpace: function(color, sourceColorSpace) {\n    return this.convert(color, sourceColorSpace, this.workingColorSpace);\n  },\n  getPrimaries: function(colorSpace) {\n    return this.spaces[colorSpace].primaries;\n  },\n  getTransfer: function(colorSpace) {\n    if (colorSpace === NoColorSpace) return LinearTransfer;\n    return this.spaces[colorSpace].transfer;\n  },\n  getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {\n    return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\n  },\n  define: function(colorSpaces) {\n    Object.assign(this.spaces, colorSpaces);\n  },\n  // Internal APIs\n  _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {\n    return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);\n  },\n  _getDrawingBufferColorSpace: function(colorSpace) {\n    return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\n  },\n  _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {\n    return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\n  }\n};\nfunction SRGBToLinear(c) {\n  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n}\nfunction LinearToSRGB(c) {\n  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n}\nconst REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];\nconst REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\nconst D65 = [0.3127, 0.329];\nconst LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(\n  0.4123908,\n  0.3575843,\n  0.1804808,\n  0.212639,\n  0.7151687,\n  0.0721923,\n  0.0193308,\n  0.1191948,\n  0.9505322\n);\nconst XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(\n  3.2409699,\n  -1.5373832,\n  -0.4986108,\n  -0.9692436,\n  1.8759675,\n  0.0415551,\n  0.0556301,\n  -0.203977,\n  1.0569715\n);\nColorManagement.define({\n  [LinearSRGBColorSpace]: {\n    primaries: REC709_PRIMARIES,\n    whitePoint: D65,\n    transfer: LinearTransfer,\n    toXYZ: LINEAR_REC709_TO_XYZ,\n    fromXYZ: XYZ_TO_LINEAR_REC709,\n    luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n    workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n    outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n  },\n  [SRGBColorSpace]: {\n    primaries: REC709_PRIMARIES,\n    whitePoint: D65,\n    transfer: SRGBTransfer,\n    toXYZ: LINEAR_REC709_TO_XYZ,\n    fromXYZ: XYZ_TO_LINEAR_REC709,\n    luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n    outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n  }\n});\nlet _canvas;\nclass ImageUtils {\n  static getDataURL(image) {\n    if (/^data:/i.test(image.src)) {\n      return image.src;\n    }\n    if (typeof HTMLCanvasElement === \"undefined\") {\n      return image.src;\n    }\n    let canvas;\n    if (image instanceof HTMLCanvasElement) {\n      canvas = image;\n    } else {\n      if (_canvas === void 0) _canvas = createElementNS(\"canvas\");\n      _canvas.width = image.width;\n      _canvas.height = image.height;\n      const context = _canvas.getContext(\"2d\");\n      if (image instanceof ImageData) {\n        context.putImageData(image, 0, 0);\n      } else {\n        context.drawImage(image, 0, 0, image.width, image.height);\n      }\n      canvas = _canvas;\n    }\n    if (canvas.width > 2048 || canvas.height > 2048) {\n      console.warn(\"THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons\", image);\n      return canvas.toDataURL(\"image/jpeg\", 0.6);\n    } else {\n      return canvas.toDataURL(\"image/png\");\n    }\n  }\n  static sRGBToLinear(image) {\n    if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n      const canvas = createElementNS(\"canvas\");\n      canvas.width = image.width;\n      canvas.height = image.height;\n      const context = canvas.getContext(\"2d\");\n      context.drawImage(image, 0, 0, image.width, image.height);\n      const imageData = context.getImageData(0, 0, image.width, image.height);\n      const data = imageData.data;\n      for (let i = 0; i < data.length; i++) {\n        data[i] = SRGBToLinear(data[i] / 255) * 255;\n      }\n      context.putImageData(imageData, 0, 0);\n      return canvas;\n    } else if (image.data) {\n      const data = image.data.slice(0);\n      for (let i = 0; i < data.length; i++) {\n        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {\n          data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);\n        } else {\n          data[i] = SRGBToLinear(data[i]);\n        }\n      }\n      return {\n        data,\n        width: image.width,\n        height: image.height\n      };\n    } else {\n      console.warn(\"THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.\");\n      return image;\n    }\n  }\n}\nlet _sourceId = 0;\nclass Source {\n  constructor(data = null) {\n    this.isSource = true;\n    Object.defineProperty(this, \"id\", { value: _sourceId++ });\n    this.uuid = generateUUID();\n    this.data = data;\n    this.dataReady = true;\n    this.version = 0;\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  toJSON(meta) {\n    const isRootObject = meta === void 0 || typeof meta === \"string\";\n    if (!isRootObject && meta.images[this.uuid] !== void 0) {\n      return meta.images[this.uuid];\n    }\n    const output = {\n      uuid: this.uuid,\n      url: \"\"\n    };\n    const data = this.data;\n    if (data !== null) {\n      let url2;\n      if (Array.isArray(data)) {\n        url2 = [];\n        for (let i = 0, l = data.length; i < l; i++) {\n          if (data[i].isDataTexture) {\n            url2.push(serializeImage(data[i].image));\n          } else {\n            url2.push(serializeImage(data[i]));\n          }\n        }\n      } else {\n        url2 = serializeImage(data);\n      }\n      output.url = url2;\n    }\n    if (!isRootObject) {\n      meta.images[this.uuid] = output;\n    }\n    return output;\n  }\n}\nfunction serializeImage(image) {\n  if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n    return ImageUtils.getDataURL(image);\n  } else {\n    if (image.data) {\n      return {\n        data: Array.from(image.data),\n        width: image.width,\n        height: image.height,\n        type: image.data.constructor.name\n      };\n    } else {\n      console.warn(\"THREE.Texture: Unable to serialize Texture.\");\n      return {};\n    }\n  }\n}\nlet _textureId = 0;\nclass Texture extends EventDispatcher {\n  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {\n    super();\n    this.isTexture = true;\n    Object.defineProperty(this, \"id\", { value: _textureId++ });\n    this.uuid = generateUUID();\n    this.name = \"\";\n    this.source = new Source(image);\n    this.mipmaps = [];\n    this.mapping = mapping;\n    this.channel = 0;\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n    this.magFilter = magFilter;\n    this.minFilter = minFilter;\n    this.anisotropy = anisotropy;\n    this.format = format;\n    this.internalFormat = null;\n    this.type = type;\n    this.offset = new Vector2(0, 0);\n    this.repeat = new Vector2(1, 1);\n    this.center = new Vector2(0, 0);\n    this.rotation = 0;\n    this.matrixAutoUpdate = true;\n    this.matrix = new Matrix3();\n    this.generateMipmaps = true;\n    this.premultiplyAlpha = false;\n    this.flipY = true;\n    this.unpackAlignment = 4;\n    this.colorSpace = colorSpace;\n    this.userData = {};\n    this.version = 0;\n    this.onUpdate = null;\n    this.isRenderTargetTexture = false;\n    this.pmremVersion = 0;\n  }\n  get image() {\n    return this.source.data;\n  }\n  set image(value = null) {\n    this.source.data = value;\n  }\n  updateMatrix() {\n    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.name = source.name;\n    this.source = source.source;\n    this.mipmaps = source.mipmaps.slice(0);\n    this.mapping = source.mapping;\n    this.channel = source.channel;\n    this.wrapS = source.wrapS;\n    this.wrapT = source.wrapT;\n    this.magFilter = source.magFilter;\n    this.minFilter = source.minFilter;\n    this.anisotropy = source.anisotropy;\n    this.format = source.format;\n    this.internalFormat = source.internalFormat;\n    this.type = source.type;\n    this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    this.center.copy(source.center);\n    this.rotation = source.rotation;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrix.copy(source.matrix);\n    this.generateMipmaps = source.generateMipmaps;\n    this.premultiplyAlpha = source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    this.unpackAlignment = source.unpackAlignment;\n    this.colorSpace = source.colorSpace;\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n    this.needsUpdate = true;\n    return this;\n  }\n  toJSON(meta) {\n    const isRootObject = meta === void 0 || typeof meta === \"string\";\n    if (!isRootObject && meta.textures[this.uuid] !== void 0) {\n      return meta.textures[this.uuid];\n    }\n    const output = {\n      metadata: {\n        version: 4.6,\n        type: \"Texture\",\n        generator: \"Texture.toJSON\"\n      },\n      uuid: this.uuid,\n      name: this.name,\n      image: this.source.toJSON(meta).uuid,\n      mapping: this.mapping,\n      channel: this.channel,\n      repeat: [this.repeat.x, this.repeat.y],\n      offset: [this.offset.x, this.offset.y],\n      center: [this.center.x, this.center.y],\n      rotation: this.rotation,\n      wrap: [this.wrapS, this.wrapT],\n      format: this.format,\n      internalFormat: this.internalFormat,\n      type: this.type,\n      colorSpace: this.colorSpace,\n      minFilter: this.minFilter,\n      magFilter: this.magFilter,\n      anisotropy: this.anisotropy,\n      flipY: this.flipY,\n      generateMipmaps: this.generateMipmaps,\n      premultiplyAlpha: this.premultiplyAlpha,\n      unpackAlignment: this.unpackAlignment\n    };\n    if (Object.keys(this.userData).length > 0) output.userData = this.userData;\n    if (!isRootObject) {\n      meta.textures[this.uuid] = output;\n    }\n    return output;\n  }\n  dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n  transformUv(uv) {\n    if (this.mapping !== UVMapping) return uv;\n    uv.applyMatrix3(this.matrix);\n    if (uv.x < 0 || uv.x > 1) {\n      switch (this.wrapS) {\n        case RepeatWrapping:\n          uv.x = uv.x - Math.floor(uv.x);\n          break;\n        case ClampToEdgeWrapping:\n          uv.x = uv.x < 0 ? 0 : 1;\n          break;\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n            uv.x = Math.ceil(uv.x) - uv.x;\n          } else {\n            uv.x = uv.x - Math.floor(uv.x);\n          }\n          break;\n      }\n    }\n    if (uv.y < 0 || uv.y > 1) {\n      switch (this.wrapT) {\n        case RepeatWrapping:\n          uv.y = uv.y - Math.floor(uv.y);\n          break;\n        case ClampToEdgeWrapping:\n          uv.y = uv.y < 0 ? 0 : 1;\n          break;\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n            uv.y = Math.ceil(uv.y) - uv.y;\n          } else {\n            uv.y = uv.y - Math.floor(uv.y);\n          }\n          break;\n      }\n    }\n    if (this.flipY) {\n      uv.y = 1 - uv.y;\n    }\n    return uv;\n  }\n  set needsUpdate(value) {\n    if (value === true) {\n      this.version++;\n      this.source.needsUpdate = true;\n    }\n  }\n  set needsPMREMUpdate(value) {\n    if (value === true) {\n      this.pmremVersion++;\n    }\n  }\n}\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.DEFAULT_ANISOTROPY = 1;\nclass Vector4 {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    Vector4.prototype.isVector4 = true;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n  get width() {\n    return this.z;\n  }\n  set width(value) {\n    this.z = value;\n  }\n  get height() {\n    return this.w;\n  }\n  set height(value) {\n    this.w = value;\n  }\n  set(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    this.w = scalar;\n    return this;\n  }\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  setZ(z) {\n    this.z = z;\n    return this;\n  }\n  setW(w) {\n    this.w = w;\n    return this;\n  }\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      case 2:\n        this.z = value;\n        break;\n      case 3:\n        this.w = value;\n        break;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n    return this;\n  }\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      case 3:\n        return this.w;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y, this.z, this.w);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    this.w = v.w !== void 0 ? v.w : 1;\n    return this;\n  }\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    this.w += v.w;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    this.w += s;\n    return this;\n  }\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    this.w = a.w + b.w;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    this.w += v.w * s;\n    return this;\n  }\n  sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    this.w -= v.w;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    this.w -= s;\n    return this;\n  }\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    this.w = a.w - b.w;\n    return this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    this.w *= v.w;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    this.w *= scalar;\n    return this;\n  }\n  applyMatrix4(m) {\n    const x = this.x, y = this.y, z = this.z, w = this.w;\n    const e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n    return this;\n  }\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= v.z;\n    this.w /= v.w;\n    return this;\n  }\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  setAxisAngleFromQuaternion(q) {\n    this.w = 2 * Math.acos(q.w);\n    const s = Math.sqrt(1 - q.w * q.w);\n    if (s < 1e-4) {\n      this.x = 1;\n      this.y = 0;\n      this.z = 0;\n    } else {\n      this.x = q.x / s;\n      this.y = q.y / s;\n      this.z = q.z / s;\n    }\n    return this;\n  }\n  setAxisAngleFromRotationMatrix(m) {\n    let angle, x, y, z;\n    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];\n    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n        this.set(1, 0, 0, 0);\n        return this;\n      }\n      angle = Math.PI;\n      const xx = (m11 + 1) / 2;\n      const yy = (m22 + 1) / 2;\n      const zz = (m33 + 1) / 2;\n      const xy = (m12 + m21) / 4;\n      const xz = (m13 + m31) / 4;\n      const yz = (m23 + m32) / 4;\n      if (xx > yy && xx > zz) {\n        if (xx < epsilon) {\n          x = 0;\n          y = 0.707106781;\n          z = 0.707106781;\n        } else {\n          x = Math.sqrt(xx);\n          y = xy / x;\n          z = xz / x;\n        }\n      } else if (yy > zz) {\n        if (yy < epsilon) {\n          x = 0.707106781;\n          y = 0;\n          z = 0.707106781;\n        } else {\n          y = Math.sqrt(yy);\n          x = xy / y;\n          z = yz / y;\n        }\n      } else {\n        if (zz < epsilon) {\n          x = 0.707106781;\n          y = 0.707106781;\n          z = 0;\n        } else {\n          z = Math.sqrt(zz);\n          x = xz / z;\n          y = yz / z;\n        }\n      }\n      this.set(x, y, z, angle);\n      return this;\n    }\n    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));\n    if (Math.abs(s) < 1e-3) s = 1;\n    this.x = (m32 - m23) / s;\n    this.y = (m13 - m31) / s;\n    this.z = (m21 - m12) / s;\n    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n    return this;\n  }\n  setFromMatrixPosition(m) {\n    const e = m.elements;\n    this.x = e[12];\n    this.y = e[13];\n    this.z = e[14];\n    this.w = e[15];\n    return this;\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    this.w = Math.min(this.w, v.w);\n    return this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n    this.w = Math.max(this.w, v.w);\n    return this;\n  }\n  clamp(min, max2) {\n    this.x = Math.max(min.x, Math.min(max2.x, this.x));\n    this.y = Math.max(min.y, Math.min(max2.y, this.y));\n    this.z = Math.max(min.z, Math.min(max2.z, this.z));\n    this.w = Math.max(min.w, Math.min(max2.w, this.w));\n    return this;\n  }\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n    this.w = Math.max(minVal, Math.min(maxVal, this.w));\n    return this;\n  }\n  clampLength(min, max2) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max2, length)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    this.w = Math.floor(this.w);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    this.w = Math.ceil(this.w);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    this.w = Math.round(this.w);\n    return this;\n  }\n  roundToZero() {\n    this.x = Math.trunc(this.x);\n    this.y = Math.trunc(this.y);\n    this.z = Math.trunc(this.z);\n    this.w = Math.trunc(this.w);\n    return this;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    this.w = -this.w;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n  }\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    this.w += (v.w - this.w) * alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    this.w = v1.w + (v2.w - v1.w) * alpha;\n    return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    array[offset + 3] = this.w;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    this.w = attribute.getW(index);\n    return this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    this.w = Math.random();\n    return this;\n  }\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n    yield this.z;\n    yield this.w;\n  }\n}\nclass RenderTarget extends EventDispatcher {\n  constructor(width = 1, height = 1, options = {}) {\n    super();\n    this.isRenderTarget = true;\n    this.width = width;\n    this.height = height;\n    this.depth = 1;\n    this.scissor = new Vector4(0, 0, width, height);\n    this.scissorTest = false;\n    this.viewport = new Vector4(0, 0, width, height);\n    const image = { width, height, depth: 1 };\n    options = Object.assign({\n      generateMipmaps: false,\n      internalFormat: null,\n      minFilter: LinearFilter,\n      depthBuffer: true,\n      stencilBuffer: false,\n      resolveDepthBuffer: true,\n      resolveStencilBuffer: true,\n      depthTexture: null,\n      samples: 0,\n      count: 1\n    }, options);\n    const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);\n    texture.flipY = false;\n    texture.generateMipmaps = options.generateMipmaps;\n    texture.internalFormat = options.internalFormat;\n    this.textures = [];\n    const count = options.count;\n    for (let i = 0; i < count; i++) {\n      this.textures[i] = texture.clone();\n      this.textures[i].isRenderTargetTexture = true;\n    }\n    this.depthBuffer = options.depthBuffer;\n    this.stencilBuffer = options.stencilBuffer;\n    this.resolveDepthBuffer = options.resolveDepthBuffer;\n    this.resolveStencilBuffer = options.resolveStencilBuffer;\n    this.depthTexture = options.depthTexture;\n    this.samples = options.samples;\n  }\n  get texture() {\n    return this.textures[0];\n  }\n  set texture(value) {\n    this.textures[0] = value;\n  }\n  setSize(width, height, depth = 1) {\n    if (this.width !== width || this.height !== height || this.depth !== depth) {\n      this.width = width;\n      this.height = height;\n      this.depth = depth;\n      for (let i = 0, il = this.textures.length; i < il; i++) {\n        this.textures[i].image.width = width;\n        this.textures[i].image.height = height;\n        this.textures[i].image.depth = depth;\n      }\n      this.dispose();\n    }\n    this.viewport.set(0, 0, width, height);\n    this.scissor.set(0, 0, width, height);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.width = source.width;\n    this.height = source.height;\n    this.depth = source.depth;\n    this.scissor.copy(source.scissor);\n    this.scissorTest = source.scissorTest;\n    this.viewport.copy(source.viewport);\n    this.textures.length = 0;\n    for (let i = 0, il = source.textures.length; i < il; i++) {\n      this.textures[i] = source.textures[i].clone();\n      this.textures[i].isRenderTargetTexture = true;\n    }\n    const image = Object.assign({}, source.texture.image);\n    this.texture.source = new Source(image);\n    this.depthBuffer = source.depthBuffer;\n    this.stencilBuffer = source.stencilBuffer;\n    this.resolveDepthBuffer = source.resolveDepthBuffer;\n    this.resolveStencilBuffer = source.resolveStencilBuffer;\n    if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();\n    this.samples = source.samples;\n    return this;\n  }\n  dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n}\nclass WebGLRenderTarget extends RenderTarget {\n  constructor(width = 1, height = 1, options = {}) {\n    super(width, height, options);\n    this.isWebGLRenderTarget = true;\n  }\n}\nclass DataArrayTexture extends Texture {\n  constructor(data = null, width = 1, height = 1, depth = 1) {\n    super(null);\n    this.isDataArrayTexture = true;\n    this.image = { data, width, height, depth };\n    this.magFilter = NearestFilter;\n    this.minFilter = NearestFilter;\n    this.wrapR = ClampToEdgeWrapping;\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n    this.layerUpdates = /* @__PURE__ */ new Set();\n  }\n  addLayerUpdate(layerIndex) {\n    this.layerUpdates.add(layerIndex);\n  }\n  clearLayerUpdates() {\n    this.layerUpdates.clear();\n  }\n}\nclass Data3DTexture extends Texture {\n  constructor(data = null, width = 1, height = 1, depth = 1) {\n    super(null);\n    this.isData3DTexture = true;\n    this.image = { data, width, height, depth };\n    this.magFilter = NearestFilter;\n    this.minFilter = NearestFilter;\n    this.wrapR = ClampToEdgeWrapping;\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n  }\n}\nclass Quaternion {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    this.isQuaternion = true;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n  }\n  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {\n    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\n    if (t2 === 0) {\n      dst[dstOffset + 0] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n      return;\n    }\n    if (t2 === 1) {\n      dst[dstOffset + 0] = x1;\n      dst[dstOffset + 1] = y1;\n      dst[dstOffset + 2] = z1;\n      dst[dstOffset + 3] = w1;\n      return;\n    }\n    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n      let s = 1 - t2;\n      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;\n      if (sqrSin > Number.EPSILON) {\n        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);\n        s = Math.sin(s * len) / sin;\n        t2 = Math.sin(t2 * len) / sin;\n      }\n      const tDir = t2 * dir;\n      x0 = x0 * s + x1 * tDir;\n      y0 = y0 * s + y1 * tDir;\n      z0 = z0 * s + z1 * tDir;\n      w0 = w0 * s + w1 * tDir;\n      if (s === 1 - t2) {\n        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n        x0 *= f;\n        y0 *= f;\n        z0 *= f;\n        w0 *= f;\n      }\n    }\n    dst[dstOffset] = x0;\n    dst[dstOffset + 1] = y0;\n    dst[dstOffset + 2] = z0;\n    dst[dstOffset + 3] = w0;\n  }\n  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n    const x0 = src0[srcOffset0];\n    const y0 = src0[srcOffset0 + 1];\n    const z0 = src0[srcOffset0 + 2];\n    const w0 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1];\n    const y1 = src1[srcOffset1 + 1];\n    const z1 = src1[srcOffset1 + 2];\n    const w1 = src1[srcOffset1 + 3];\n    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n    return dst;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    this._x = value;\n    this._onChangeCallback();\n  }\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    this._y = value;\n    this._onChangeCallback();\n  }\n  get z() {\n    return this._z;\n  }\n  set z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n  get w() {\n    return this._w;\n  }\n  set w(value) {\n    this._w = value;\n    this._onChangeCallback();\n  }\n  set(x, y, z, w) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n    this._onChangeCallback();\n    return this;\n  }\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._w);\n  }\n  copy(quaternion) {\n    this._x = quaternion.x;\n    this._y = quaternion.y;\n    this._z = quaternion.z;\n    this._w = quaternion.w;\n    this._onChangeCallback();\n    return this;\n  }\n  setFromEuler(euler, update = true) {\n    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n    const cos = Math.cos;\n    const sin = Math.sin;\n    const c1 = cos(x / 2);\n    const c2 = cos(y / 2);\n    const c3 = cos(z / 2);\n    const s1 = sin(x / 2);\n    const s2 = sin(y / 2);\n    const s3 = sin(z / 2);\n    switch (order) {\n      case \"XYZ\":\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      case \"YXZ\":\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n      case \"ZXY\":\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      case \"ZYX\":\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n      case \"YZX\":\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      case \"XZY\":\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n      default:\n        console.warn(\"THREE.Quaternion: .setFromEuler() encountered an unknown order: \" + order);\n    }\n    if (update === true) this._onChangeCallback();\n    return this;\n  }\n  setFromAxisAngle(axis, angle) {\n    const halfAngle = angle / 2, s = Math.sin(halfAngle);\n    this._x = axis.x * s;\n    this._y = axis.y * s;\n    this._z = axis.z * s;\n    this._w = Math.cos(halfAngle);\n    this._onChangeCallback();\n    return this;\n  }\n  setFromRotationMatrix(m) {\n    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\n    if (trace > 0) {\n      const s = 0.5 / Math.sqrt(trace + 1);\n      this._w = 0.25 / s;\n      this._x = (m32 - m23) * s;\n      this._y = (m13 - m31) * s;\n      this._z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n      this._w = (m32 - m23) / s;\n      this._x = 0.25 * s;\n      this._y = (m12 + m21) / s;\n      this._z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\n      this._w = (m13 - m31) / s;\n      this._x = (m12 + m21) / s;\n      this._y = 0.25 * s;\n      this._z = (m23 + m32) / s;\n    } else {\n      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\n      this._w = (m21 - m12) / s;\n      this._x = (m13 + m31) / s;\n      this._y = (m23 + m32) / s;\n      this._z = 0.25 * s;\n    }\n    this._onChangeCallback();\n    return this;\n  }\n  setFromUnitVectors(vFrom, vTo) {\n    let r = vFrom.dot(vTo) + 1;\n    if (r < Number.EPSILON) {\n      r = 0;\n      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n        this._x = -vFrom.y;\n        this._y = vFrom.x;\n        this._z = 0;\n        this._w = r;\n      } else {\n        this._x = 0;\n        this._y = -vFrom.z;\n        this._z = vFrom.y;\n        this._w = r;\n      }\n    } else {\n      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n      this._w = r;\n    }\n    return this.normalize();\n  }\n  angleTo(q) {\n    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n  }\n  rotateTowards(q, step) {\n    const angle = this.angleTo(q);\n    if (angle === 0) return this;\n    const t2 = Math.min(1, step / angle);\n    this.slerp(q, t2);\n    return this;\n  }\n  identity() {\n    return this.set(0, 0, 0, 1);\n  }\n  invert() {\n    return this.conjugate();\n  }\n  conjugate() {\n    this._x *= -1;\n    this._y *= -1;\n    this._z *= -1;\n    this._onChangeCallback();\n    return this;\n  }\n  dot(v) {\n    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n  }\n  lengthSq() {\n    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n  }\n  length() {\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  }\n  normalize() {\n    let l = this.length();\n    if (l === 0) {\n      this._x = 0;\n      this._y = 0;\n      this._z = 0;\n      this._w = 1;\n    } else {\n      l = 1 / l;\n      this._x = this._x * l;\n      this._y = this._y * l;\n      this._z = this._z * l;\n      this._w = this._w * l;\n    }\n    this._onChangeCallback();\n    return this;\n  }\n  multiply(q) {\n    return this.multiplyQuaternions(this, q);\n  }\n  premultiply(q) {\n    return this.multiplyQuaternions(q, this);\n  }\n  multiplyQuaternions(a, b) {\n    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n    this._onChangeCallback();\n    return this;\n  }\n  slerp(qb, t2) {\n    if (t2 === 0) return this;\n    if (t2 === 1) return this.copy(qb);\n    const x = this._x, y = this._y, z = this._z, w = this._w;\n    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n    if (cosHalfTheta < 0) {\n      this._w = -qb._w;\n      this._x = -qb._x;\n      this._y = -qb._y;\n      this._z = -qb._z;\n      cosHalfTheta = -cosHalfTheta;\n    } else {\n      this.copy(qb);\n    }\n    if (cosHalfTheta >= 1) {\n      this._w = w;\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      return this;\n    }\n    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n    if (sqrSinHalfTheta <= Number.EPSILON) {\n      const s = 1 - t2;\n      this._w = s * w + t2 * this._w;\n      this._x = s * x + t2 * this._x;\n      this._y = s * y + t2 * this._y;\n      this._z = s * z + t2 * this._z;\n      this.normalize();\n      return this;\n    }\n    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n    const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;\n    this._w = w * ratioA + this._w * ratioB;\n    this._x = x * ratioA + this._x * ratioB;\n    this._y = y * ratioA + this._y * ratioB;\n    this._z = z * ratioA + this._z * ratioB;\n    this._onChangeCallback();\n    return this;\n  }\n  slerpQuaternions(qa, qb, t2) {\n    return this.copy(qa).slerp(qb, t2);\n  }\n  random() {\n    const theta1 = 2 * Math.PI * Math.random();\n    const theta2 = 2 * Math.PI * Math.random();\n    const x0 = Math.random();\n    const r1 = Math.sqrt(1 - x0);\n    const r2 = Math.sqrt(x0);\n    return this.set(\n      r1 * Math.sin(theta1),\n      r1 * Math.cos(theta1),\n      r2 * Math.sin(theta2),\n      r2 * Math.cos(theta2)\n    );\n  }\n  equals(quaternion) {\n    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n  }\n  fromArray(array, offset = 0) {\n    this._x = array[offset];\n    this._y = array[offset + 1];\n    this._z = array[offset + 2];\n    this._w = array[offset + 3];\n    this._onChangeCallback();\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._w;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this._x = attribute.getX(index);\n    this._y = attribute.getY(index);\n    this._z = attribute.getZ(index);\n    this._w = attribute.getW(index);\n    this._onChangeCallback();\n    return this;\n  }\n  toJSON() {\n    return this.toArray();\n  }\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n    return this;\n  }\n  _onChangeCallback() {\n  }\n  *[Symbol.iterator]() {\n    yield this._x;\n    yield this._y;\n    yield this._z;\n    yield this._w;\n  }\n}\nclass Vector3 {\n  constructor(x = 0, y = 0, z = 0) {\n    Vector3.prototype.isVector3 = true;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  set(x, y, z) {\n    if (z === void 0) z = this.z;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    return this;\n  }\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  setZ(z) {\n    this.z = z;\n    return this;\n  }\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      case 2:\n        this.z = value;\n        break;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n    return this;\n  }\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y, this.z);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    return this;\n  }\n  add(v) {\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    return this;\n  }\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    return this;\n  }\n  sub(v) {\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    return this;\n  }\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    return this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n  }\n  multiplyVectors(a, b) {\n    this.x = a.x * b.x;\n    this.y = a.y * b.y;\n    this.z = a.z * b.z;\n    return this;\n  }\n  applyEuler(euler) {\n    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n  }\n  applyAxisAngle(axis, angle) {\n    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n  }\n  applyMatrix3(m) {\n    const x = this.x, y = this.y, z = this.z;\n    const e = m.elements;\n    this.x = e[0] * x + e[3] * y + e[6] * z;\n    this.y = e[1] * x + e[4] * y + e[7] * z;\n    this.z = e[2] * x + e[5] * y + e[8] * z;\n    return this;\n  }\n  applyNormalMatrix(m) {\n    return this.applyMatrix3(m).normalize();\n  }\n  applyMatrix4(m) {\n    const x = this.x, y = this.y, z = this.z;\n    const e = m.elements;\n    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n    return this;\n  }\n  applyQuaternion(q) {\n    const vx = this.x, vy = this.y, vz = this.z;\n    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n    const tx = 2 * (qy * vz - qz * vy);\n    const ty = 2 * (qz * vx - qx * vz);\n    const tz = 2 * (qx * vy - qy * vx);\n    this.x = vx + qw * tx + qy * tz - qz * ty;\n    this.y = vy + qw * ty + qz * tx - qx * tz;\n    this.z = vz + qw * tz + qx * ty - qy * tx;\n    return this;\n  }\n  project(camera) {\n    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n  }\n  unproject(camera) {\n    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n  }\n  transformDirection(m) {\n    const x = this.x, y = this.y, z = this.z;\n    const e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z;\n    this.y = e[1] * x + e[5] * y + e[9] * z;\n    this.z = e[2] * x + e[6] * y + e[10] * z;\n    return this.normalize();\n  }\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= v.z;\n    return this;\n  }\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    return this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n    return this;\n  }\n  clamp(min, max2) {\n    this.x = Math.max(min.x, Math.min(max2.x, this.x));\n    this.y = Math.max(min.y, Math.min(max2.y, this.y));\n    this.z = Math.max(min.z, Math.min(max2.z, this.z));\n    return this;\n  }\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n    return this;\n  }\n  clampLength(min, max2) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max2, length)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    return this;\n  }\n  roundToZero() {\n    this.x = Math.trunc(this.x);\n    this.y = Math.trunc(this.y);\n    this.z = Math.trunc(this.z);\n    return this;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  }\n  // TODO lengthSquared?\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n  }\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    return this;\n  }\n  cross(v) {\n    return this.crossVectors(this, v);\n  }\n  crossVectors(a, b) {\n    const ax = a.x, ay = a.y, az = a.z;\n    const bx = b.x, by = b.y, bz = b.z;\n    this.x = ay * bz - az * by;\n    this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n    return this;\n  }\n  projectOnVector(v) {\n    const denominator = v.lengthSq();\n    if (denominator === 0) return this.set(0, 0, 0);\n    const scalar = v.dot(this) / denominator;\n    return this.copy(v).multiplyScalar(scalar);\n  }\n  projectOnPlane(planeNormal) {\n    _vector$c.copy(this).projectOnVector(planeNormal);\n    return this.sub(_vector$c);\n  }\n  reflect(normal) {\n    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n  }\n  angleTo(v) {\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n    if (denominator === 0) return Math.PI / 2;\n    const theta = this.dot(v) / denominator;\n    return Math.acos(clamp(theta, -1, 1));\n  }\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n  distanceToSquared(v) {\n    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n    return dx * dx + dy * dy + dz * dz;\n  }\n  manhattanDistanceTo(v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n  }\n  setFromSpherical(s) {\n    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n  }\n  setFromSphericalCoords(radius, phi, theta) {\n    const sinPhiRadius = Math.sin(phi) * radius;\n    this.x = sinPhiRadius * Math.sin(theta);\n    this.y = Math.cos(phi) * radius;\n    this.z = sinPhiRadius * Math.cos(theta);\n    return this;\n  }\n  setFromCylindrical(c) {\n    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n  }\n  setFromCylindricalCoords(radius, theta, y) {\n    this.x = radius * Math.sin(theta);\n    this.y = y;\n    this.z = radius * Math.cos(theta);\n    return this;\n  }\n  setFromMatrixPosition(m) {\n    const e = m.elements;\n    this.x = e[12];\n    this.y = e[13];\n    this.z = e[14];\n    return this;\n  }\n  setFromMatrixScale(m) {\n    const sx = this.setFromMatrixColumn(m, 0).length();\n    const sy = this.setFromMatrixColumn(m, 1).length();\n    const sz = this.setFromMatrixColumn(m, 2).length();\n    this.x = sx;\n    this.y = sy;\n    this.z = sz;\n    return this;\n  }\n  setFromMatrixColumn(m, index) {\n    return this.fromArray(m.elements, index * 4);\n  }\n  setFromMatrix3Column(m, index) {\n    return this.fromArray(m.elements, index * 3);\n  }\n  setFromEuler(e) {\n    this.x = e._x;\n    this.y = e._y;\n    this.z = e._z;\n    return this;\n  }\n  setFromColor(c) {\n    this.x = c.r;\n    this.y = c.g;\n    this.z = c.b;\n    return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    return this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    return this;\n  }\n  randomDirection() {\n    const theta = Math.random() * Math.PI * 2;\n    const u = Math.random() * 2 - 1;\n    const c = Math.sqrt(1 - u * u);\n    this.x = c * Math.cos(theta);\n    this.y = u;\n    this.z = c * Math.sin(theta);\n    return this;\n  }\n  *[Symbol.iterator]() {\n    yield this.x;\n    yield this.y;\n    yield this.z;\n  }\n}\nconst _vector$c = /* @__PURE__ */ new Vector3();\nconst _quaternion$4 = /* @__PURE__ */ new Quaternion();\nclass Box3 {\n  constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {\n    this.isBox3 = true;\n    this.min = min;\n    this.max = max2;\n  }\n  set(min, max2) {\n    this.min.copy(min);\n    this.max.copy(max2);\n    return this;\n  }\n  setFromArray(array) {\n    this.makeEmpty();\n    for (let i = 0, il = array.length; i < il; i += 3) {\n      this.expandByPoint(_vector$b.fromArray(array, i));\n    }\n    return this;\n  }\n  setFromBufferAttribute(attribute) {\n    this.makeEmpty();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));\n    }\n    return this;\n  }\n  setFromPoints(points) {\n    this.makeEmpty();\n    for (let i = 0, il = points.length; i < il; i++) {\n      this.expandByPoint(points[i]);\n    }\n    return this;\n  }\n  setFromCenterAndSize(center, size) {\n    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n    this.min.copy(center).sub(halfSize);\n    this.max.copy(center).add(halfSize);\n    return this;\n  }\n  setFromObject(object, precise = false) {\n    this.makeEmpty();\n    return this.expandByObject(object, precise);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(box) {\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n    return this;\n  }\n  makeEmpty() {\n    this.min.x = this.min.y = this.min.z = Infinity;\n    this.max.x = this.max.y = this.max.z = -Infinity;\n    return this;\n  }\n  isEmpty() {\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n  }\n  getCenter(target) {\n    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n  }\n  getSize(target) {\n    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n  }\n  expandByPoint(point) {\n    this.min.min(point);\n    this.max.max(point);\n    return this;\n  }\n  expandByVector(vector) {\n    this.min.sub(vector);\n    this.max.add(vector);\n    return this;\n  }\n  expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n    return this;\n  }\n  expandByObject(object, precise = false) {\n    object.updateWorldMatrix(false, false);\n    const geometry = object.geometry;\n    if (geometry !== void 0) {\n      const positionAttribute = geometry.getAttribute(\"position\");\n      if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {\n        for (let i = 0, l = positionAttribute.count; i < l; i++) {\n          if (object.isMesh === true) {\n            object.getVertexPosition(i, _vector$b);\n          } else {\n            _vector$b.fromBufferAttribute(positionAttribute, i);\n          }\n          _vector$b.applyMatrix4(object.matrixWorld);\n          this.expandByPoint(_vector$b);\n        }\n      } else {\n        if (object.boundingBox !== void 0) {\n          if (object.boundingBox === null) {\n            object.computeBoundingBox();\n          }\n          _box$4.copy(object.boundingBox);\n        } else {\n          if (geometry.boundingBox === null) {\n            geometry.computeBoundingBox();\n          }\n          _box$4.copy(geometry.boundingBox);\n        }\n        _box$4.applyMatrix4(object.matrixWorld);\n        this.union(_box$4);\n      }\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      this.expandByObject(children[i], precise);\n    }\n    return this;\n  }\n  containsPoint(point) {\n    return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\n  }\n  containsBox(box) {\n    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n  }\n  getParameter(point, target) {\n    return target.set(\n      (point.x - this.min.x) / (this.max.x - this.min.x),\n      (point.y - this.min.y) / (this.max.y - this.min.y),\n      (point.z - this.min.z) / (this.max.z - this.min.z)\n    );\n  }\n  intersectsBox(box) {\n    return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\n  }\n  intersectsSphere(sphere) {\n    this.clampPoint(sphere.center, _vector$b);\n    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n  }\n  intersectsPlane(plane) {\n    let min, max2;\n    if (plane.normal.x > 0) {\n      min = plane.normal.x * this.min.x;\n      max2 = plane.normal.x * this.max.x;\n    } else {\n      min = plane.normal.x * this.max.x;\n      max2 = plane.normal.x * this.min.x;\n    }\n    if (plane.normal.y > 0) {\n      min += plane.normal.y * this.min.y;\n      max2 += plane.normal.y * this.max.y;\n    } else {\n      min += plane.normal.y * this.max.y;\n      max2 += plane.normal.y * this.min.y;\n    }\n    if (plane.normal.z > 0) {\n      min += plane.normal.z * this.min.z;\n      max2 += plane.normal.z * this.max.z;\n    } else {\n      min += plane.normal.z * this.max.z;\n      max2 += plane.normal.z * this.min.z;\n    }\n    return min <= -plane.constant && max2 >= -plane.constant;\n  }\n  intersectsTriangle(triangle) {\n    if (this.isEmpty()) {\n      return false;\n    }\n    this.getCenter(_center);\n    _extents.subVectors(this.max, _center);\n    _v0$3.subVectors(triangle.a, _center);\n    _v1$7.subVectors(triangle.b, _center);\n    _v2$4.subVectors(triangle.c, _center);\n    _f0.subVectors(_v1$7, _v0$3);\n    _f1.subVectors(_v2$4, _v1$7);\n    _f2.subVectors(_v0$3, _v2$4);\n    let axes = [\n      0,\n      -_f0.z,\n      _f0.y,\n      0,\n      -_f1.z,\n      _f1.y,\n      0,\n      -_f2.z,\n      _f2.y,\n      _f0.z,\n      0,\n      -_f0.x,\n      _f1.z,\n      0,\n      -_f1.x,\n      _f2.z,\n      0,\n      -_f2.x,\n      -_f0.y,\n      _f0.x,\n      0,\n      -_f1.y,\n      _f1.x,\n      0,\n      -_f2.y,\n      _f2.x,\n      0\n    ];\n    if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {\n      return false;\n    }\n    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {\n      return false;\n    }\n    _triangleNormal.crossVectors(_f0, _f1);\n    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n    return satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents);\n  }\n  clampPoint(point, target) {\n    return target.copy(point).clamp(this.min, this.max);\n  }\n  distanceToPoint(point) {\n    return this.clampPoint(point, _vector$b).distanceTo(point);\n  }\n  getBoundingSphere(target) {\n    if (this.isEmpty()) {\n      target.makeEmpty();\n    } else {\n      this.getCenter(target.center);\n      target.radius = this.getSize(_vector$b).length() * 0.5;\n    }\n    return target;\n  }\n  intersect(box) {\n    this.min.max(box.min);\n    this.max.min(box.max);\n    if (this.isEmpty()) this.makeEmpty();\n    return this;\n  }\n  union(box) {\n    this.min.min(box.min);\n    this.max.max(box.max);\n    return this;\n  }\n  applyMatrix4(matrix) {\n    if (this.isEmpty()) return this;\n    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\n    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);\n    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\n    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\n    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\n    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);\n    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\n    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\n    this.setFromPoints(_points);\n    return this;\n  }\n  translate(offset) {\n    this.min.add(offset);\n    this.max.add(offset);\n    return this;\n  }\n  equals(box) {\n    return box.min.equals(this.min) && box.max.equals(this.max);\n  }\n}\nconst _points = [\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3()\n];\nconst _vector$b = /* @__PURE__ */ new Vector3();\nconst _box$4 = /* @__PURE__ */ new Box3();\nconst _v0$3 = /* @__PURE__ */ new Vector3();\nconst _v1$7 = /* @__PURE__ */ new Vector3();\nconst _v2$4 = /* @__PURE__ */ new Vector3();\nconst _f0 = /* @__PURE__ */ new Vector3();\nconst _f1 = /* @__PURE__ */ new Vector3();\nconst _f2 = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _extents = /* @__PURE__ */ new Vector3();\nconst _triangleNormal = /* @__PURE__ */ new Vector3();\nconst _testAxis = /* @__PURE__ */ new Vector3();\nfunction satForAxes(axes, v0, v1, v2, extents) {\n  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n    _testAxis.fromArray(axes, i);\n    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n    const p0 = v0.dot(_testAxis);\n    const p1 = v1.dot(_testAxis);\n    const p2 = v2.dot(_testAxis);\n    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n      return false;\n    }\n  }\n  return true;\n}\nconst _box$3 = /* @__PURE__ */ new Box3();\nconst _v1$6 = /* @__PURE__ */ new Vector3();\nconst _v2$3 = /* @__PURE__ */ new Vector3();\nclass Sphere {\n  constructor(center = new Vector3(), radius = -1) {\n    this.isSphere = true;\n    this.center = center;\n    this.radius = radius;\n  }\n  set(center, radius) {\n    this.center.copy(center);\n    this.radius = radius;\n    return this;\n  }\n  setFromPoints(points, optionalCenter) {\n    const center = this.center;\n    if (optionalCenter !== void 0) {\n      center.copy(optionalCenter);\n    } else {\n      _box$3.setFromPoints(points).getCenter(center);\n    }\n    let maxRadiusSq = 0;\n    for (let i = 0, il = points.length; i < il; i++) {\n      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n    }\n    this.radius = Math.sqrt(maxRadiusSq);\n    return this;\n  }\n  copy(sphere) {\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n    return this;\n  }\n  isEmpty() {\n    return this.radius < 0;\n  }\n  makeEmpty() {\n    this.center.set(0, 0, 0);\n    this.radius = -1;\n    return this;\n  }\n  containsPoint(point) {\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\n  }\n  distanceToPoint(point) {\n    return point.distanceTo(this.center) - this.radius;\n  }\n  intersectsSphere(sphere) {\n    const radiusSum = this.radius + sphere.radius;\n    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n  }\n  intersectsBox(box) {\n    return box.intersectsSphere(this);\n  }\n  intersectsPlane(plane) {\n    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n  }\n  clampPoint(point, target) {\n    const deltaLengthSq = this.center.distanceToSquared(point);\n    target.copy(point);\n    if (deltaLengthSq > this.radius * this.radius) {\n      target.sub(this.center).normalize();\n      target.multiplyScalar(this.radius).add(this.center);\n    }\n    return target;\n  }\n  getBoundingBox(target) {\n    if (this.isEmpty()) {\n      target.makeEmpty();\n      return target;\n    }\n    target.set(this.center, this.center);\n    target.expandByScalar(this.radius);\n    return target;\n  }\n  applyMatrix4(matrix) {\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n    return this;\n  }\n  translate(offset) {\n    this.center.add(offset);\n    return this;\n  }\n  expandByPoint(point) {\n    if (this.isEmpty()) {\n      this.center.copy(point);\n      this.radius = 0;\n      return this;\n    }\n    _v1$6.subVectors(point, this.center);\n    const lengthSq = _v1$6.lengthSq();\n    if (lengthSq > this.radius * this.radius) {\n      const length = Math.sqrt(lengthSq);\n      const delta = (length - this.radius) * 0.5;\n      this.center.addScaledVector(_v1$6, delta / length);\n      this.radius += delta;\n    }\n    return this;\n  }\n  union(sphere) {\n    if (sphere.isEmpty()) {\n      return this;\n    }\n    if (this.isEmpty()) {\n      this.copy(sphere);\n      return this;\n    }\n    if (this.center.equals(sphere.center) === true) {\n      this.radius = Math.max(this.radius, sphere.radius);\n    } else {\n      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);\n      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));\n      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));\n    }\n    return this;\n  }\n  equals(sphere) {\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nconst _vector$a = /* @__PURE__ */ new Vector3();\nconst _segCenter = /* @__PURE__ */ new Vector3();\nconst _segDir = /* @__PURE__ */ new Vector3();\nconst _diff = /* @__PURE__ */ new Vector3();\nconst _edge1 = /* @__PURE__ */ new Vector3();\nconst _edge2 = /* @__PURE__ */ new Vector3();\nconst _normal$1 = /* @__PURE__ */ new Vector3();\nclass Ray {\n  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n    this.origin = origin;\n    this.direction = direction;\n  }\n  set(origin, direction) {\n    this.origin.copy(origin);\n    this.direction.copy(direction);\n    return this;\n  }\n  copy(ray) {\n    this.origin.copy(ray.origin);\n    this.direction.copy(ray.direction);\n    return this;\n  }\n  at(t2, target) {\n    return target.copy(this.origin).addScaledVector(this.direction, t2);\n  }\n  lookAt(v) {\n    this.direction.copy(v).sub(this.origin).normalize();\n    return this;\n  }\n  recast(t2) {\n    this.origin.copy(this.at(t2, _vector$a));\n    return this;\n  }\n  closestPointToPoint(point, target) {\n    target.subVectors(point, this.origin);\n    const directionDistance = target.dot(this.direction);\n    if (directionDistance < 0) {\n      return target.copy(this.origin);\n    }\n    return target.copy(this.origin).addScaledVector(this.direction, directionDistance);\n  }\n  distanceToPoint(point) {\n    return Math.sqrt(this.distanceSqToPoint(point));\n  }\n  distanceSqToPoint(point) {\n    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);\n    if (directionDistance < 0) {\n      return this.origin.distanceToSquared(point);\n    }\n    _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);\n    return _vector$a.distanceToSquared(point);\n  }\n  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n    _segDir.copy(v1).sub(v0).normalize();\n    _diff.copy(this.origin).sub(_segCenter);\n    const segExtent = v0.distanceTo(v1) * 0.5;\n    const a01 = -this.direction.dot(_segDir);\n    const b0 = _diff.dot(this.direction);\n    const b1 = -_diff.dot(_segDir);\n    const c = _diff.lengthSq();\n    const det = Math.abs(1 - a01 * a01);\n    let s0, s1, sqrDist, extDet;\n    if (det > 0) {\n      s0 = a01 * b1 - b0;\n      s1 = a01 * b0 - b1;\n      extDet = segExtent * det;\n      if (s0 >= 0) {\n        if (s1 >= -extDet) {\n          if (s1 <= extDet) {\n            const invDet = 1 / det;\n            s0 *= invDet;\n            s1 *= invDet;\n            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n          } else {\n            s1 = segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          s1 = -segExtent;\n          s0 = Math.max(0, -(a01 * s1 + b0));\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      } else {\n        if (s1 <= -extDet) {\n          s0 = Math.max(0, -(-a01 * segExtent + b0));\n          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        } else if (s1 <= extDet) {\n          s0 = 0;\n          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = s1 * (s1 + 2 * b1) + c;\n        } else {\n          s0 = Math.max(0, -(a01 * segExtent + b0));\n          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      }\n    } else {\n      s1 = a01 > 0 ? -segExtent : segExtent;\n      s0 = Math.max(0, -(a01 * s1 + b0));\n      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n    }\n    if (optionalPointOnRay) {\n      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);\n    }\n    if (optionalPointOnSegment) {\n      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);\n    }\n    return sqrDist;\n  }\n  intersectSphere(sphere, target) {\n    _vector$a.subVectors(sphere.center, this.origin);\n    const tca = _vector$a.dot(this.direction);\n    const d2 = _vector$a.dot(_vector$a) - tca * tca;\n    const radius2 = sphere.radius * sphere.radius;\n    if (d2 > radius2) return null;\n    const thc = Math.sqrt(radius2 - d2);\n    const t0 = tca - thc;\n    const t1 = tca + thc;\n    if (t1 < 0) return null;\n    if (t0 < 0) return this.at(t1, target);\n    return this.at(t0, target);\n  }\n  intersectsSphere(sphere) {\n    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n  }\n  distanceToPlane(plane) {\n    const denominator = plane.normal.dot(this.direction);\n    if (denominator === 0) {\n      if (plane.distanceToPoint(this.origin) === 0) {\n        return 0;\n      }\n      return null;\n    }\n    const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n    return t2 >= 0 ? t2 : null;\n  }\n  intersectPlane(plane, target) {\n    const t2 = this.distanceToPlane(plane);\n    if (t2 === null) {\n      return null;\n    }\n    return this.at(t2, target);\n  }\n  intersectsPlane(plane) {\n    const distToPoint = plane.distanceToPoint(this.origin);\n    if (distToPoint === 0) {\n      return true;\n    }\n    const denominator = plane.normal.dot(this.direction);\n    if (denominator * distToPoint < 0) {\n      return true;\n    }\n    return false;\n  }\n  intersectBox(box, target) {\n    let tmin, tmax, tymin, tymax, tzmin, tzmax;\n    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;\n    const origin = this.origin;\n    if (invdirx >= 0) {\n      tmin = (box.min.x - origin.x) * invdirx;\n      tmax = (box.max.x - origin.x) * invdirx;\n    } else {\n      tmin = (box.max.x - origin.x) * invdirx;\n      tmax = (box.min.x - origin.x) * invdirx;\n    }\n    if (invdiry >= 0) {\n      tymin = (box.min.y - origin.y) * invdiry;\n      tymax = (box.max.y - origin.y) * invdiry;\n    } else {\n      tymin = (box.max.y - origin.y) * invdiry;\n      tymax = (box.min.y - origin.y) * invdiry;\n    }\n    if (tmin > tymax || tymin > tmax) return null;\n    if (tymin > tmin || isNaN(tmin)) tmin = tymin;\n    if (tymax < tmax || isNaN(tmax)) tmax = tymax;\n    if (invdirz >= 0) {\n      tzmin = (box.min.z - origin.z) * invdirz;\n      tzmax = (box.max.z - origin.z) * invdirz;\n    } else {\n      tzmin = (box.max.z - origin.z) * invdirz;\n      tzmax = (box.min.z - origin.z) * invdirz;\n    }\n    if (tmin > tzmax || tzmin > tmax) return null;\n    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n    if (tmax < 0) return null;\n    return this.at(tmin >= 0 ? tmin : tmax, target);\n  }\n  intersectsBox(box) {\n    return this.intersectBox(box, _vector$a) !== null;\n  }\n  intersectTriangle(a, b, c, backfaceCulling, target) {\n    _edge1.subVectors(b, a);\n    _edge2.subVectors(c, a);\n    _normal$1.crossVectors(_edge1, _edge2);\n    let DdN = this.direction.dot(_normal$1);\n    let sign2;\n    if (DdN > 0) {\n      if (backfaceCulling) return null;\n      sign2 = 1;\n    } else if (DdN < 0) {\n      sign2 = -1;\n      DdN = -DdN;\n    } else {\n      return null;\n    }\n    _diff.subVectors(this.origin, a);\n    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n    if (DdQxE2 < 0) {\n      return null;\n    }\n    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));\n    if (DdE1xQ < 0) {\n      return null;\n    }\n    if (DdQxE2 + DdE1xQ > DdN) {\n      return null;\n    }\n    const QdN = -sign2 * _diff.dot(_normal$1);\n    if (QdN < 0) {\n      return null;\n    }\n    return this.at(QdN / DdN, target);\n  }\n  applyMatrix4(matrix4) {\n    this.origin.applyMatrix4(matrix4);\n    this.direction.transformDirection(matrix4);\n    return this;\n  }\n  equals(ray) {\n    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nclass Matrix4 {\n  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n    Matrix4.prototype.isMatrix4 = true;\n    this.elements = [\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1\n    ];\n    if (n11 !== void 0) {\n      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);\n    }\n  }\n  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n    const te = this.elements;\n    te[0] = n11;\n    te[4] = n12;\n    te[8] = n13;\n    te[12] = n14;\n    te[1] = n21;\n    te[5] = n22;\n    te[9] = n23;\n    te[13] = n24;\n    te[2] = n31;\n    te[6] = n32;\n    te[10] = n33;\n    te[14] = n34;\n    te[3] = n41;\n    te[7] = n42;\n    te[11] = n43;\n    te[15] = n44;\n    return this;\n  }\n  identity() {\n    this.set(\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  clone() {\n    return new Matrix4().fromArray(this.elements);\n  }\n  copy(m) {\n    const te = this.elements;\n    const me = m.elements;\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n    te[9] = me[9];\n    te[10] = me[10];\n    te[11] = me[11];\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    te[15] = me[15];\n    return this;\n  }\n  copyPosition(m) {\n    const te = this.elements, me = m.elements;\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    return this;\n  }\n  setFromMatrix3(m) {\n    const me = m.elements;\n    this.set(\n      me[0],\n      me[3],\n      me[6],\n      0,\n      me[1],\n      me[4],\n      me[7],\n      0,\n      me[2],\n      me[5],\n      me[8],\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  extractBasis(xAxis, yAxis, zAxis) {\n    xAxis.setFromMatrixColumn(this, 0);\n    yAxis.setFromMatrixColumn(this, 1);\n    zAxis.setFromMatrixColumn(this, 2);\n    return this;\n  }\n  makeBasis(xAxis, yAxis, zAxis) {\n    this.set(\n      xAxis.x,\n      yAxis.x,\n      zAxis.x,\n      0,\n      xAxis.y,\n      yAxis.y,\n      zAxis.y,\n      0,\n      xAxis.z,\n      yAxis.z,\n      zAxis.z,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  extractRotation(m) {\n    const te = this.elements;\n    const me = m.elements;\n    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n    te[0] = me[0] * scaleX;\n    te[1] = me[1] * scaleX;\n    te[2] = me[2] * scaleX;\n    te[3] = 0;\n    te[4] = me[4] * scaleY;\n    te[5] = me[5] * scaleY;\n    te[6] = me[6] * scaleY;\n    te[7] = 0;\n    te[8] = me[8] * scaleZ;\n    te[9] = me[9] * scaleZ;\n    te[10] = me[10] * scaleZ;\n    te[11] = 0;\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  }\n  makeRotationFromEuler(euler) {\n    const te = this.elements;\n    const x = euler.x, y = euler.y, z = euler.z;\n    const a = Math.cos(x), b = Math.sin(x);\n    const c = Math.cos(y), d = Math.sin(y);\n    const e = Math.cos(z), f = Math.sin(z);\n    if (euler.order === \"XYZ\") {\n      const ae = a * e, af = a * f, be = b * e, bf = b * f;\n      te[0] = c * e;\n      te[4] = -c * f;\n      te[8] = d;\n      te[1] = af + be * d;\n      te[5] = ae - bf * d;\n      te[9] = -b * c;\n      te[2] = bf - ae * d;\n      te[6] = be + af * d;\n      te[10] = a * c;\n    } else if (euler.order === \"YXZ\") {\n      const ce = c * e, cf = c * f, de = d * e, df = d * f;\n      te[0] = ce + df * b;\n      te[4] = de * b - cf;\n      te[8] = a * d;\n      te[1] = a * f;\n      te[5] = a * e;\n      te[9] = -b;\n      te[2] = cf * b - de;\n      te[6] = df + ce * b;\n      te[10] = a * c;\n    } else if (euler.order === \"ZXY\") {\n      const ce = c * e, cf = c * f, de = d * e, df = d * f;\n      te[0] = ce - df * b;\n      te[4] = -a * f;\n      te[8] = de + cf * b;\n      te[1] = cf + de * b;\n      te[5] = a * e;\n      te[9] = df - ce * b;\n      te[2] = -a * d;\n      te[6] = b;\n      te[10] = a * c;\n    } else if (euler.order === \"ZYX\") {\n      const ae = a * e, af = a * f, be = b * e, bf = b * f;\n      te[0] = c * e;\n      te[4] = be * d - af;\n      te[8] = ae * d + bf;\n      te[1] = c * f;\n      te[5] = bf * d + ae;\n      te[9] = af * d - be;\n      te[2] = -d;\n      te[6] = b * c;\n      te[10] = a * c;\n    } else if (euler.order === \"YZX\") {\n      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n      te[0] = c * e;\n      te[4] = bd - ac * f;\n      te[8] = bc * f + ad;\n      te[1] = f;\n      te[5] = a * e;\n      te[9] = -b * e;\n      te[2] = -d * e;\n      te[6] = ad * f + bc;\n      te[10] = ac - bd * f;\n    } else if (euler.order === \"XZY\") {\n      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n      te[0] = c * e;\n      te[4] = -f;\n      te[8] = d * e;\n      te[1] = ac * f + bd;\n      te[5] = a * e;\n      te[9] = ad * f - bc;\n      te[2] = bc * f - ad;\n      te[6] = b * e;\n      te[10] = bd * f + ac;\n    }\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  }\n  makeRotationFromQuaternion(q) {\n    return this.compose(_zero, q, _one);\n  }\n  lookAt(eye, target, up) {\n    const te = this.elements;\n    _z.subVectors(eye, target);\n    if (_z.lengthSq() === 0) {\n      _z.z = 1;\n    }\n    _z.normalize();\n    _x.crossVectors(up, _z);\n    if (_x.lengthSq() === 0) {\n      if (Math.abs(up.z) === 1) {\n        _z.x += 1e-4;\n      } else {\n        _z.z += 1e-4;\n      }\n      _z.normalize();\n      _x.crossVectors(up, _z);\n    }\n    _x.normalize();\n    _y.crossVectors(_z, _x);\n    te[0] = _x.x;\n    te[4] = _y.x;\n    te[8] = _z.x;\n    te[1] = _x.y;\n    te[5] = _y.y;\n    te[9] = _z.y;\n    te[2] = _x.z;\n    te[6] = _y.z;\n    te[10] = _z.z;\n    return this;\n  }\n  multiply(m) {\n    return this.multiplyMatrices(this, m);\n  }\n  premultiply(m) {\n    return this.multiplyMatrices(m, this);\n  }\n  multiplyMatrices(a, b) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n    return this;\n  }\n  multiplyScalar(s) {\n    const te = this.elements;\n    te[0] *= s;\n    te[4] *= s;\n    te[8] *= s;\n    te[12] *= s;\n    te[1] *= s;\n    te[5] *= s;\n    te[9] *= s;\n    te[13] *= s;\n    te[2] *= s;\n    te[6] *= s;\n    te[10] *= s;\n    te[14] *= s;\n    te[3] *= s;\n    te[7] *= s;\n    te[11] *= s;\n    te[15] *= s;\n    return this;\n  }\n  determinant() {\n    const te = this.elements;\n    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n  }\n  transpose() {\n    const te = this.elements;\n    let tmp;\n    tmp = te[1];\n    te[1] = te[4];\n    te[4] = tmp;\n    tmp = te[2];\n    te[2] = te[8];\n    te[8] = tmp;\n    tmp = te[6];\n    te[6] = te[9];\n    te[9] = tmp;\n    tmp = te[3];\n    te[3] = te[12];\n    te[12] = tmp;\n    tmp = te[7];\n    te[7] = te[13];\n    te[13] = tmp;\n    tmp = te[11];\n    te[11] = te[14];\n    te[14] = tmp;\n    return this;\n  }\n  setPosition(x, y, z) {\n    const te = this.elements;\n    if (x.isVector3) {\n      te[12] = x.x;\n      te[13] = x.y;\n      te[14] = x.z;\n    } else {\n      te[12] = x;\n      te[13] = y;\n      te[14] = z;\n    }\n    return this;\n  }\n  invert() {\n    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const detInv = 1 / det;\n    te[0] = t11 * detInv;\n    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n    te[4] = t12 * detInv;\n    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n    te[8] = t13 * detInv;\n    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n    te[12] = t14 * detInv;\n    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n    return this;\n  }\n  scale(v) {\n    const te = this.elements;\n    const x = v.x, y = v.y, z = v.z;\n    te[0] *= x;\n    te[4] *= y;\n    te[8] *= z;\n    te[1] *= x;\n    te[5] *= y;\n    te[9] *= z;\n    te[2] *= x;\n    te[6] *= y;\n    te[10] *= z;\n    te[3] *= x;\n    te[7] *= y;\n    te[11] *= z;\n    return this;\n  }\n  getMaxScaleOnAxis() {\n    const te = this.elements;\n    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n  }\n  makeTranslation(x, y, z) {\n    if (x.isVector3) {\n      this.set(\n        1,\n        0,\n        0,\n        x.x,\n        0,\n        1,\n        0,\n        x.y,\n        0,\n        0,\n        1,\n        x.z,\n        0,\n        0,\n        0,\n        1\n      );\n    } else {\n      this.set(\n        1,\n        0,\n        0,\n        x,\n        0,\n        1,\n        0,\n        y,\n        0,\n        0,\n        1,\n        z,\n        0,\n        0,\n        0,\n        1\n      );\n    }\n    return this;\n  }\n  makeRotationX(theta) {\n    const c = Math.cos(theta), s = Math.sin(theta);\n    this.set(\n      1,\n      0,\n      0,\n      0,\n      0,\n      c,\n      -s,\n      0,\n      0,\n      s,\n      c,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  makeRotationY(theta) {\n    const c = Math.cos(theta), s = Math.sin(theta);\n    this.set(\n      c,\n      0,\n      s,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -s,\n      0,\n      c,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  makeRotationZ(theta) {\n    const c = Math.cos(theta), s = Math.sin(theta);\n    this.set(\n      c,\n      -s,\n      0,\n      0,\n      s,\n      c,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  makeRotationAxis(axis, angle) {\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n    const t2 = 1 - c;\n    const x = axis.x, y = axis.y, z = axis.z;\n    const tx = t2 * x, ty = t2 * y;\n    this.set(\n      tx * x + c,\n      tx * y - s * z,\n      tx * z + s * y,\n      0,\n      tx * y + s * z,\n      ty * y + c,\n      ty * z - s * x,\n      0,\n      tx * z - s * y,\n      ty * z + s * x,\n      t2 * z * z + c,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  makeScale(x, y, z) {\n    this.set(\n      x,\n      0,\n      0,\n      0,\n      0,\n      y,\n      0,\n      0,\n      0,\n      0,\n      z,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  makeShear(xy, xz, yx, yz, zx, zy) {\n    this.set(\n      1,\n      yx,\n      zx,\n      0,\n      xy,\n      1,\n      zy,\n      0,\n      xz,\n      yz,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1\n    );\n    return this;\n  }\n  compose(position, quaternion, scale) {\n    const te = this.elements;\n    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n    const x2 = x + x, y2 = y + y, z2 = z + z;\n    const xx = x * x2, xy = x * y2, xz = x * z2;\n    const yy = y * y2, yz = y * z2, zz = z * z2;\n    const wx = w * x2, wy = w * y2, wz = w * z2;\n    const sx = scale.x, sy = scale.y, sz = scale.z;\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n    te[12] = position.x;\n    te[13] = position.y;\n    te[14] = position.z;\n    te[15] = 1;\n    return this;\n  }\n  decompose(position, quaternion, scale) {\n    const te = this.elements;\n    let sx = _v1$5.set(te[0], te[1], te[2]).length();\n    const sy = _v1$5.set(te[4], te[5], te[6]).length();\n    const sz = _v1$5.set(te[8], te[9], te[10]).length();\n    const det = this.determinant();\n    if (det < 0) sx = -sx;\n    position.x = te[12];\n    position.y = te[13];\n    position.z = te[14];\n    _m1$4.copy(this);\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n    _m1$4.elements[0] *= invSX;\n    _m1$4.elements[1] *= invSX;\n    _m1$4.elements[2] *= invSX;\n    _m1$4.elements[4] *= invSY;\n    _m1$4.elements[5] *= invSY;\n    _m1$4.elements[6] *= invSY;\n    _m1$4.elements[8] *= invSZ;\n    _m1$4.elements[9] *= invSZ;\n    _m1$4.elements[10] *= invSZ;\n    quaternion.setFromRotationMatrix(_m1$4);\n    scale.x = sx;\n    scale.y = sy;\n    scale.z = sz;\n    return this;\n  }\n  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n    const te = this.elements;\n    const x = 2 * near / (right - left);\n    const y = 2 * near / (top - bottom);\n    const a = (right + left) / (right - left);\n    const b = (top + bottom) / (top - bottom);\n    let c, d;\n    if (coordinateSystem === WebGLCoordinateSystem) {\n      c = -(far + near) / (far - near);\n      d = -2 * far * near / (far - near);\n    } else if (coordinateSystem === WebGPUCoordinateSystem) {\n      c = -far / (far - near);\n      d = -far * near / (far - near);\n    } else {\n      throw new Error(\"THREE.Matrix4.makePerspective(): Invalid coordinate system: \" + coordinateSystem);\n    }\n    te[0] = x;\n    te[4] = 0;\n    te[8] = a;\n    te[12] = 0;\n    te[1] = 0;\n    te[5] = y;\n    te[9] = b;\n    te[13] = 0;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = c;\n    te[14] = d;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = -1;\n    te[15] = 0;\n    return this;\n  }\n  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n    const te = this.elements;\n    const w = 1 / (right - left);\n    const h = 1 / (top - bottom);\n    const p = 1 / (far - near);\n    const x = (right + left) * w;\n    const y = (top + bottom) * h;\n    let z, zInv;\n    if (coordinateSystem === WebGLCoordinateSystem) {\n      z = (far + near) * p;\n      zInv = -2 * p;\n    } else if (coordinateSystem === WebGPUCoordinateSystem) {\n      z = near * p;\n      zInv = -1 * p;\n    } else {\n      throw new Error(\"THREE.Matrix4.makeOrthographic(): Invalid coordinate system: \" + coordinateSystem);\n    }\n    te[0] = 2 * w;\n    te[4] = 0;\n    te[8] = 0;\n    te[12] = -x;\n    te[1] = 0;\n    te[5] = 2 * h;\n    te[9] = 0;\n    te[13] = -y;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = zInv;\n    te[14] = -z;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n    te[15] = 1;\n    return this;\n  }\n  equals(matrix) {\n    const te = this.elements;\n    const me = matrix.elements;\n    for (let i = 0; i < 16; i++) {\n      if (te[i] !== me[i]) return false;\n    }\n    return true;\n  }\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 16; i++) {\n      this.elements[i] = array[i + offset];\n    }\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    const te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    array[offset + 9] = te[9];\n    array[offset + 10] = te[10];\n    array[offset + 11] = te[11];\n    array[offset + 12] = te[12];\n    array[offset + 13] = te[13];\n    array[offset + 14] = te[14];\n    array[offset + 15] = te[15];\n    return array;\n  }\n}\nconst _v1$5 = /* @__PURE__ */ new Vector3();\nconst _m1$4 = /* @__PURE__ */ new Matrix4();\nconst _zero = /* @__PURE__ */ new Vector3(0, 0, 0);\nconst _one = /* @__PURE__ */ new Vector3(1, 1, 1);\nconst _x = /* @__PURE__ */ new Vector3();\nconst _y = /* @__PURE__ */ new Vector3();\nconst _z = /* @__PURE__ */ new Vector3();\nconst _matrix$2 = /* @__PURE__ */ new Matrix4();\nconst _quaternion$3 = /* @__PURE__ */ new Quaternion();\nclass Euler {\n  constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {\n    this.isEuler = true;\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    this._x = value;\n    this._onChangeCallback();\n  }\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    this._y = value;\n    this._onChangeCallback();\n  }\n  get z() {\n    return this._z;\n  }\n  set z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n  get order() {\n    return this._order;\n  }\n  set order(value) {\n    this._order = value;\n    this._onChangeCallback();\n  }\n  set(x, y, z, order = this._order) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n    this._onChangeCallback();\n    return this;\n  }\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._order);\n  }\n  copy(euler) {\n    this._x = euler._x;\n    this._y = euler._y;\n    this._z = euler._z;\n    this._order = euler._order;\n    this._onChangeCallback();\n    return this;\n  }\n  setFromRotationMatrix(m, order = this._order, update = true) {\n    const te = m.elements;\n    const m11 = te[0], m12 = te[4], m13 = te[8];\n    const m21 = te[1], m22 = te[5], m23 = te[9];\n    const m31 = te[2], m32 = te[6], m33 = te[10];\n    switch (order) {\n      case \"XYZ\":\n        this._y = Math.asin(clamp(m13, -1, 1));\n        if (Math.abs(m13) < 0.9999999) {\n          this._x = Math.atan2(-m23, m33);\n          this._z = Math.atan2(-m12, m11);\n        } else {\n          this._x = Math.atan2(m32, m22);\n          this._z = 0;\n        }\n        break;\n      case \"YXZ\":\n        this._x = Math.asin(-clamp(m23, -1, 1));\n        if (Math.abs(m23) < 0.9999999) {\n          this._y = Math.atan2(m13, m33);\n          this._z = Math.atan2(m21, m22);\n        } else {\n          this._y = Math.atan2(-m31, m11);\n          this._z = 0;\n        }\n        break;\n      case \"ZXY\":\n        this._x = Math.asin(clamp(m32, -1, 1));\n        if (Math.abs(m32) < 0.9999999) {\n          this._y = Math.atan2(-m31, m33);\n          this._z = Math.atan2(-m12, m22);\n        } else {\n          this._y = 0;\n          this._z = Math.atan2(m21, m11);\n        }\n        break;\n      case \"ZYX\":\n        this._y = Math.asin(-clamp(m31, -1, 1));\n        if (Math.abs(m31) < 0.9999999) {\n          this._x = Math.atan2(m32, m33);\n          this._z = Math.atan2(m21, m11);\n        } else {\n          this._x = 0;\n          this._z = Math.atan2(-m12, m22);\n        }\n        break;\n      case \"YZX\":\n        this._z = Math.asin(clamp(m21, -1, 1));\n        if (Math.abs(m21) < 0.9999999) {\n          this._x = Math.atan2(-m23, m22);\n          this._y = Math.atan2(-m31, m11);\n        } else {\n          this._x = 0;\n          this._y = Math.atan2(m13, m33);\n        }\n        break;\n      case \"XZY\":\n        this._z = Math.asin(-clamp(m12, -1, 1));\n        if (Math.abs(m12) < 0.9999999) {\n          this._x = Math.atan2(m32, m22);\n          this._y = Math.atan2(m13, m11);\n        } else {\n          this._x = Math.atan2(-m23, m33);\n          this._y = 0;\n        }\n        break;\n      default:\n        console.warn(\"THREE.Euler: .setFromRotationMatrix() encountered an unknown order: \" + order);\n    }\n    this._order = order;\n    if (update === true) this._onChangeCallback();\n    return this;\n  }\n  setFromQuaternion(q, order, update) {\n    _matrix$2.makeRotationFromQuaternion(q);\n    return this.setFromRotationMatrix(_matrix$2, order, update);\n  }\n  setFromVector3(v, order = this._order) {\n    return this.set(v.x, v.y, v.z, order);\n  }\n  reorder(newOrder) {\n    _quaternion$3.setFromEuler(this);\n    return this.setFromQuaternion(_quaternion$3, newOrder);\n  }\n  equals(euler) {\n    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n  }\n  fromArray(array) {\n    this._x = array[0];\n    this._y = array[1];\n    this._z = array[2];\n    if (array[3] !== void 0) this._order = array[3];\n    this._onChangeCallback();\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._order;\n    return array;\n  }\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n    return this;\n  }\n  _onChangeCallback() {\n  }\n  *[Symbol.iterator]() {\n    yield this._x;\n    yield this._y;\n    yield this._z;\n    yield this._order;\n  }\n}\nEuler.DEFAULT_ORDER = \"XYZ\";\nclass Layers {\n  constructor() {\n    this.mask = 1 | 0;\n  }\n  set(channel) {\n    this.mask = (1 << channel | 0) >>> 0;\n  }\n  enable(channel) {\n    this.mask |= 1 << channel | 0;\n  }\n  enableAll() {\n    this.mask = 4294967295 | 0;\n  }\n  toggle(channel) {\n    this.mask ^= 1 << channel | 0;\n  }\n  disable(channel) {\n    this.mask &= ~(1 << channel | 0);\n  }\n  disableAll() {\n    this.mask = 0;\n  }\n  test(layers) {\n    return (this.mask & layers.mask) !== 0;\n  }\n  isEnabled(channel) {\n    return (this.mask & (1 << channel | 0)) !== 0;\n  }\n}\nlet _object3DId = 0;\nconst _v1$4 = /* @__PURE__ */ new Vector3();\nconst _q1 = /* @__PURE__ */ new Quaternion();\nconst _m1$3 = /* @__PURE__ */ new Matrix4();\nconst _target = /* @__PURE__ */ new Vector3();\nconst _position$3 = /* @__PURE__ */ new Vector3();\nconst _scale$2 = /* @__PURE__ */ new Vector3();\nconst _quaternion$2 = /* @__PURE__ */ new Quaternion();\nconst _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);\nconst _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);\nconst _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);\nconst _addedEvent = { type: \"added\" };\nconst _removedEvent = { type: \"removed\" };\nconst _childaddedEvent = { type: \"childadded\", child: null };\nconst _childremovedEvent = { type: \"childremoved\", child: null };\nclass Object3D extends EventDispatcher {\n  constructor() {\n    super();\n    this.isObject3D = true;\n    Object.defineProperty(this, \"id\", { value: _object3DId++ });\n    this.uuid = generateUUID();\n    this.name = \"\";\n    this.type = \"Object3D\";\n    this.parent = null;\n    this.children = [];\n    this.up = Object3D.DEFAULT_UP.clone();\n    const position = new Vector3();\n    const rotation = new Euler();\n    const quaternion = new Quaternion();\n    const scale = new Vector3(1, 1, 1);\n    function onRotationChange() {\n      quaternion.setFromEuler(rotation, false);\n    }\n    function onQuaternionChange() {\n      rotation.setFromQuaternion(quaternion, void 0, false);\n    }\n    rotation._onChange(onRotationChange);\n    quaternion._onChange(onQuaternionChange);\n    Object.defineProperties(this, {\n      position: {\n        configurable: true,\n        enumerable: true,\n        value: position\n      },\n      rotation: {\n        configurable: true,\n        enumerable: true,\n        value: rotation\n      },\n      quaternion: {\n        configurable: true,\n        enumerable: true,\n        value: quaternion\n      },\n      scale: {\n        configurable: true,\n        enumerable: true,\n        value: scale\n      },\n      modelViewMatrix: {\n        value: new Matrix4()\n      },\n      normalMatrix: {\n        value: new Matrix3()\n      }\n    });\n    this.matrix = new Matrix4();\n    this.matrixWorld = new Matrix4();\n    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;\n    this.matrixWorldNeedsUpdate = false;\n    this.layers = new Layers();\n    this.visible = true;\n    this.castShadow = false;\n    this.receiveShadow = false;\n    this.frustumCulled = true;\n    this.renderOrder = 0;\n    this.animations = [];\n    this.userData = {};\n  }\n  onBeforeShadow() {\n  }\n  onAfterShadow() {\n  }\n  onBeforeRender() {\n  }\n  onAfterRender() {\n  }\n  applyMatrix4(matrix) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n    this.matrix.premultiply(matrix);\n    this.matrix.decompose(this.position, this.quaternion, this.scale);\n  }\n  applyQuaternion(q) {\n    this.quaternion.premultiply(q);\n    return this;\n  }\n  setRotationFromAxisAngle(axis, angle) {\n    this.quaternion.setFromAxisAngle(axis, angle);\n  }\n  setRotationFromEuler(euler) {\n    this.quaternion.setFromEuler(euler, true);\n  }\n  setRotationFromMatrix(m) {\n    this.quaternion.setFromRotationMatrix(m);\n  }\n  setRotationFromQuaternion(q) {\n    this.quaternion.copy(q);\n  }\n  rotateOnAxis(axis, angle) {\n    _q1.setFromAxisAngle(axis, angle);\n    this.quaternion.multiply(_q1);\n    return this;\n  }\n  rotateOnWorldAxis(axis, angle) {\n    _q1.setFromAxisAngle(axis, angle);\n    this.quaternion.premultiply(_q1);\n    return this;\n  }\n  rotateX(angle) {\n    return this.rotateOnAxis(_xAxis, angle);\n  }\n  rotateY(angle) {\n    return this.rotateOnAxis(_yAxis, angle);\n  }\n  rotateZ(angle) {\n    return this.rotateOnAxis(_zAxis, angle);\n  }\n  translateOnAxis(axis, distance) {\n    _v1$4.copy(axis).applyQuaternion(this.quaternion);\n    this.position.add(_v1$4.multiplyScalar(distance));\n    return this;\n  }\n  translateX(distance) {\n    return this.translateOnAxis(_xAxis, distance);\n  }\n  translateY(distance) {\n    return this.translateOnAxis(_yAxis, distance);\n  }\n  translateZ(distance) {\n    return this.translateOnAxis(_zAxis, distance);\n  }\n  localToWorld(vector) {\n    this.updateWorldMatrix(true, false);\n    return vector.applyMatrix4(this.matrixWorld);\n  }\n  worldToLocal(vector) {\n    this.updateWorldMatrix(true, false);\n    return vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());\n  }\n  lookAt(x, y, z) {\n    if (x.isVector3) {\n      _target.copy(x);\n    } else {\n      _target.set(x, y, z);\n    }\n    const parent = this.parent;\n    this.updateWorldMatrix(true, false);\n    _position$3.setFromMatrixPosition(this.matrixWorld);\n    if (this.isCamera || this.isLight) {\n      _m1$3.lookAt(_position$3, _target, this.up);\n    } else {\n      _m1$3.lookAt(_target, _position$3, this.up);\n    }\n    this.quaternion.setFromRotationMatrix(_m1$3);\n    if (parent) {\n      _m1$3.extractRotation(parent.matrixWorld);\n      _q1.setFromRotationMatrix(_m1$3);\n      this.quaternion.premultiply(_q1.invert());\n    }\n  }\n  add(object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n      return this;\n    }\n    if (object === this) {\n      console.error(\"THREE.Object3D.add: object can't be added as a child of itself.\", object);\n      return this;\n    }\n    if (object && object.isObject3D) {\n      object.removeFromParent();\n      object.parent = this;\n      this.children.push(object);\n      object.dispatchEvent(_addedEvent);\n      _childaddedEvent.child = object;\n      this.dispatchEvent(_childaddedEvent);\n      _childaddedEvent.child = null;\n    } else {\n      console.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object);\n    }\n    return this;\n  }\n  remove(object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.remove(arguments[i]);\n      }\n      return this;\n    }\n    const index = this.children.indexOf(object);\n    if (index !== -1) {\n      object.parent = null;\n      this.children.splice(index, 1);\n      object.dispatchEvent(_removedEvent);\n      _childremovedEvent.child = object;\n      this.dispatchEvent(_childremovedEvent);\n      _childremovedEvent.child = null;\n    }\n    return this;\n  }\n  removeFromParent() {\n    const parent = this.parent;\n    if (parent !== null) {\n      parent.remove(this);\n    }\n    return this;\n  }\n  clear() {\n    return this.remove(...this.children);\n  }\n  attach(object) {\n    this.updateWorldMatrix(true, false);\n    _m1$3.copy(this.matrixWorld).invert();\n    if (object.parent !== null) {\n      object.parent.updateWorldMatrix(true, false);\n      _m1$3.multiply(object.parent.matrixWorld);\n    }\n    object.applyMatrix4(_m1$3);\n    object.removeFromParent();\n    object.parent = this;\n    this.children.push(object);\n    object.updateWorldMatrix(false, true);\n    object.dispatchEvent(_addedEvent);\n    _childaddedEvent.child = object;\n    this.dispatchEvent(_childaddedEvent);\n    _childaddedEvent.child = null;\n    return this;\n  }\n  getObjectById(id2) {\n    return this.getObjectByProperty(\"id\", id2);\n  }\n  getObjectByName(name) {\n    return this.getObjectByProperty(\"name\", name);\n  }\n  getObjectByProperty(name, value) {\n    if (this[name] === value) return this;\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      const child = this.children[i];\n      const object = child.getObjectByProperty(name, value);\n      if (object !== void 0) {\n        return object;\n      }\n    }\n    return void 0;\n  }\n  getObjectsByProperty(name, value, result = []) {\n    if (this[name] === value) result.push(this);\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].getObjectsByProperty(name, value, result);\n    }\n    return result;\n  }\n  getWorldPosition(target) {\n    this.updateWorldMatrix(true, false);\n    return target.setFromMatrixPosition(this.matrixWorld);\n  }\n  getWorldQuaternion(target) {\n    this.updateWorldMatrix(true, false);\n    this.matrixWorld.decompose(_position$3, target, _scale$2);\n    return target;\n  }\n  getWorldScale(target) {\n    this.updateWorldMatrix(true, false);\n    this.matrixWorld.decompose(_position$3, _quaternion$2, target);\n    return target;\n  }\n  getWorldDirection(target) {\n    this.updateWorldMatrix(true, false);\n    const e = this.matrixWorld.elements;\n    return target.set(e[8], e[9], e[10]).normalize();\n  }\n  raycast() {\n  }\n  traverse(callback) {\n    callback(this);\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverse(callback);\n    }\n  }\n  traverseVisible(callback) {\n    if (this.visible === false) return;\n    callback(this);\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverseVisible(callback);\n    }\n  }\n  traverseAncestors(callback) {\n    const parent = this.parent;\n    if (parent !== null) {\n      callback(parent);\n      parent.traverseAncestors(callback);\n    }\n  }\n  updateMatrix() {\n    this.matrix.compose(this.position, this.quaternion, this.scale);\n    this.matrixWorldNeedsUpdate = true;\n  }\n  updateMatrixWorld(force) {\n    if (this.matrixAutoUpdate) this.updateMatrix();\n    if (this.matrixWorldNeedsUpdate || force) {\n      if (this.matrixWorldAutoUpdate === true) {\n        if (this.parent === null) {\n          this.matrixWorld.copy(this.matrix);\n        } else {\n          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        }\n      }\n      this.matrixWorldNeedsUpdate = false;\n      force = true;\n    }\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      const child = children[i];\n      child.updateMatrixWorld(force);\n    }\n  }\n  updateWorldMatrix(updateParents, updateChildren) {\n    const parent = this.parent;\n    if (updateParents === true && parent !== null) {\n      parent.updateWorldMatrix(true, false);\n    }\n    if (this.matrixAutoUpdate) this.updateMatrix();\n    if (this.matrixWorldAutoUpdate === true) {\n      if (this.parent === null) {\n        this.matrixWorld.copy(this.matrix);\n      } else {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n      }\n    }\n    if (updateChildren === true) {\n      const children = this.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        const child = children[i];\n        child.updateWorldMatrix(false, true);\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRootObject = meta === void 0 || typeof meta === \"string\";\n    const output = {};\n    if (isRootObject) {\n      meta = {\n        geometries: {},\n        materials: {},\n        textures: {},\n        images: {},\n        shapes: {},\n        skeletons: {},\n        animations: {},\n        nodes: {}\n      };\n      output.metadata = {\n        version: 4.6,\n        type: \"Object\",\n        generator: \"Object3D.toJSON\"\n      };\n    }\n    const object = {};\n    object.uuid = this.uuid;\n    object.type = this.type;\n    if (this.name !== \"\") object.name = this.name;\n    if (this.castShadow === true) object.castShadow = true;\n    if (this.receiveShadow === true) object.receiveShadow = true;\n    if (this.visible === false) object.visible = false;\n    if (this.frustumCulled === false) object.frustumCulled = false;\n    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n    if (Object.keys(this.userData).length > 0) object.userData = this.userData;\n    object.layers = this.layers.mask;\n    object.matrix = this.matrix.toArray();\n    object.up = this.up.toArray();\n    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n    if (this.isInstancedMesh) {\n      object.type = \"InstancedMesh\";\n      object.count = this.count;\n      object.instanceMatrix = this.instanceMatrix.toJSON();\n      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n    }\n    if (this.isBatchedMesh) {\n      object.type = \"BatchedMesh\";\n      object.perObjectFrustumCulled = this.perObjectFrustumCulled;\n      object.sortObjects = this.sortObjects;\n      object.drawRanges = this._drawRanges;\n      object.reservedRanges = this._reservedRanges;\n      object.visibility = this._visibility;\n      object.active = this._active;\n      object.bounds = this._bounds.map((bound) => ({\n        boxInitialized: bound.boxInitialized,\n        boxMin: bound.box.min.toArray(),\n        boxMax: bound.box.max.toArray(),\n        sphereInitialized: bound.sphereInitialized,\n        sphereRadius: bound.sphere.radius,\n        sphereCenter: bound.sphere.center.toArray()\n      }));\n      object.maxInstanceCount = this._maxInstanceCount;\n      object.maxVertexCount = this._maxVertexCount;\n      object.maxIndexCount = this._maxIndexCount;\n      object.geometryInitialized = this._geometryInitialized;\n      object.geometryCount = this._geometryCount;\n      object.matricesTexture = this._matricesTexture.toJSON(meta);\n      if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);\n      if (this.boundingSphere !== null) {\n        object.boundingSphere = {\n          center: object.boundingSphere.center.toArray(),\n          radius: object.boundingSphere.radius\n        };\n      }\n      if (this.boundingBox !== null) {\n        object.boundingBox = {\n          min: object.boundingBox.min.toArray(),\n          max: object.boundingBox.max.toArray()\n        };\n      }\n    }\n    function serialize(library, element) {\n      if (library[element.uuid] === void 0) {\n        library[element.uuid] = element.toJSON(meta);\n      }\n      return element.uuid;\n    }\n    if (this.isScene) {\n      if (this.background) {\n        if (this.background.isColor) {\n          object.background = this.background.toJSON();\n        } else if (this.background.isTexture) {\n          object.background = this.background.toJSON(meta).uuid;\n        }\n      }\n      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {\n        object.environment = this.environment.toJSON(meta).uuid;\n      }\n    } else if (this.isMesh || this.isLine || this.isPoints) {\n      object.geometry = serialize(meta.geometries, this.geometry);\n      const parameters = this.geometry.parameters;\n      if (parameters !== void 0 && parameters.shapes !== void 0) {\n        const shapes = parameters.shapes;\n        if (Array.isArray(shapes)) {\n          for (let i = 0, l = shapes.length; i < l; i++) {\n            const shape = shapes[i];\n            serialize(meta.shapes, shape);\n          }\n        } else {\n          serialize(meta.shapes, shapes);\n        }\n      }\n    }\n    if (this.isSkinnedMesh) {\n      object.bindMode = this.bindMode;\n      object.bindMatrix = this.bindMatrix.toArray();\n      if (this.skeleton !== void 0) {\n        serialize(meta.skeletons, this.skeleton);\n        object.skeleton = this.skeleton.uuid;\n      }\n    }\n    if (this.material !== void 0) {\n      if (Array.isArray(this.material)) {\n        const uuids = [];\n        for (let i = 0, l = this.material.length; i < l; i++) {\n          uuids.push(serialize(meta.materials, this.material[i]));\n        }\n        object.material = uuids;\n      } else {\n        object.material = serialize(meta.materials, this.material);\n      }\n    }\n    if (this.children.length > 0) {\n      object.children = [];\n      for (let i = 0; i < this.children.length; i++) {\n        object.children.push(this.children[i].toJSON(meta).object);\n      }\n    }\n    if (this.animations.length > 0) {\n      object.animations = [];\n      for (let i = 0; i < this.animations.length; i++) {\n        const animation = this.animations[i];\n        object.animations.push(serialize(meta.animations, animation));\n      }\n    }\n    if (isRootObject) {\n      const geometries = extractFromCache(meta.geometries);\n      const materials = extractFromCache(meta.materials);\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const shapes = extractFromCache(meta.shapes);\n      const skeletons = extractFromCache(meta.skeletons);\n      const animations = extractFromCache(meta.animations);\n      const nodes = extractFromCache(meta.nodes);\n      if (geometries.length > 0) output.geometries = geometries;\n      if (materials.length > 0) output.materials = materials;\n      if (textures.length > 0) output.textures = textures;\n      if (images.length > 0) output.images = images;\n      if (shapes.length > 0) output.shapes = shapes;\n      if (skeletons.length > 0) output.skeletons = skeletons;\n      if (animations.length > 0) output.animations = animations;\n      if (nodes.length > 0) output.nodes = nodes;\n    }\n    output.object = object;\n    return output;\n    function extractFromCache(cache2) {\n      const values = [];\n      for (const key in cache2) {\n        const data = cache2[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n  }\n  clone(recursive) {\n    return new this.constructor().copy(this, recursive);\n  }\n  copy(source, recursive = true) {\n    this.name = source.name;\n    this.up.copy(source.up);\n    this.position.copy(source.position);\n    this.rotation.order = source.rotation.order;\n    this.quaternion.copy(source.quaternion);\n    this.scale.copy(source.scale);\n    this.matrix.copy(source.matrix);\n    this.matrixWorld.copy(source.matrixWorld);\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n    this.layers.mask = source.layers.mask;\n    this.visible = source.visible;\n    this.castShadow = source.castShadow;\n    this.receiveShadow = source.receiveShadow;\n    this.frustumCulled = source.frustumCulled;\n    this.renderOrder = source.renderOrder;\n    this.animations = source.animations.slice();\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n    if (recursive === true) {\n      for (let i = 0; i < source.children.length; i++) {\n        const child = source.children[i];\n        this.add(child.clone());\n      }\n    }\n    return this;\n  }\n}\nObject3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);\nObject3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\nObject3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\nconst _v0$2 = /* @__PURE__ */ new Vector3();\nconst _v1$3 = /* @__PURE__ */ new Vector3();\nconst _v2$2 = /* @__PURE__ */ new Vector3();\nconst _v3$2 = /* @__PURE__ */ new Vector3();\nconst _vab = /* @__PURE__ */ new Vector3();\nconst _vac = /* @__PURE__ */ new Vector3();\nconst _vbc = /* @__PURE__ */ new Vector3();\nconst _vap = /* @__PURE__ */ new Vector3();\nconst _vbp = /* @__PURE__ */ new Vector3();\nconst _vcp = /* @__PURE__ */ new Vector3();\nconst _v40 = /* @__PURE__ */ new Vector4();\nconst _v41 = /* @__PURE__ */ new Vector4();\nconst _v42 = /* @__PURE__ */ new Vector4();\nclass Triangle {\n  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n  static getNormal(a, b, c, target) {\n    target.subVectors(c, b);\n    _v0$2.subVectors(a, b);\n    target.cross(_v0$2);\n    const targetLengthSq = target.lengthSq();\n    if (targetLengthSq > 0) {\n      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n    }\n    return target.set(0, 0, 0);\n  }\n  // static/instance method to calculate barycentric coordinates\n  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n  static getBarycoord(point, a, b, c, target) {\n    _v0$2.subVectors(c, a);\n    _v1$3.subVectors(b, a);\n    _v2$2.subVectors(point, a);\n    const dot00 = _v0$2.dot(_v0$2);\n    const dot01 = _v0$2.dot(_v1$3);\n    const dot02 = _v0$2.dot(_v2$2);\n    const dot11 = _v1$3.dot(_v1$3);\n    const dot12 = _v1$3.dot(_v2$2);\n    const denom = dot00 * dot11 - dot01 * dot01;\n    if (denom === 0) {\n      target.set(0, 0, 0);\n      return null;\n    }\n    const invDenom = 1 / denom;\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    return target.set(1 - u - v, v, u);\n  }\n  static containsPoint(point, a, b, c) {\n    if (this.getBarycoord(point, a, b, c, _v3$2) === null) {\n      return false;\n    }\n    return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;\n  }\n  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {\n    if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {\n      target.x = 0;\n      target.y = 0;\n      if (\"z\" in target) target.z = 0;\n      if (\"w\" in target) target.w = 0;\n      return null;\n    }\n    target.setScalar(0);\n    target.addScaledVector(v1, _v3$2.x);\n    target.addScaledVector(v2, _v3$2.y);\n    target.addScaledVector(v3, _v3$2.z);\n    return target;\n  }\n  static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {\n    _v40.setScalar(0);\n    _v41.setScalar(0);\n    _v42.setScalar(0);\n    _v40.fromBufferAttribute(attr, i1);\n    _v41.fromBufferAttribute(attr, i2);\n    _v42.fromBufferAttribute(attr, i3);\n    target.setScalar(0);\n    target.addScaledVector(_v40, barycoord.x);\n    target.addScaledVector(_v41, barycoord.y);\n    target.addScaledVector(_v42, barycoord.z);\n    return target;\n  }\n  static isFrontFacing(a, b, c, direction) {\n    _v0$2.subVectors(c, b);\n    _v1$3.subVectors(a, b);\n    return _v0$2.cross(_v1$3).dot(direction) < 0 ? true : false;\n  }\n  set(a, b, c) {\n    this.a.copy(a);\n    this.b.copy(b);\n    this.c.copy(c);\n    return this;\n  }\n  setFromPointsAndIndices(points, i0, i1, i2) {\n    this.a.copy(points[i0]);\n    this.b.copy(points[i1]);\n    this.c.copy(points[i2]);\n    return this;\n  }\n  setFromAttributeAndIndices(attribute, i0, i1, i2) {\n    this.a.fromBufferAttribute(attribute, i0);\n    this.b.fromBufferAttribute(attribute, i1);\n    this.c.fromBufferAttribute(attribute, i2);\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(triangle) {\n    this.a.copy(triangle.a);\n    this.b.copy(triangle.b);\n    this.c.copy(triangle.c);\n    return this;\n  }\n  getArea() {\n    _v0$2.subVectors(this.c, this.b);\n    _v1$3.subVectors(this.a, this.b);\n    return _v0$2.cross(_v1$3).length() * 0.5;\n  }\n  getMidpoint(target) {\n    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n  }\n  getNormal(target) {\n    return Triangle.getNormal(this.a, this.b, this.c, target);\n  }\n  getPlane(target) {\n    return target.setFromCoplanarPoints(this.a, this.b, this.c);\n  }\n  getBarycoord(point, target) {\n    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n  }\n  getInterpolation(point, v1, v2, v3, target) {\n    return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);\n  }\n  containsPoint(point) {\n    return Triangle.containsPoint(point, this.a, this.b, this.c);\n  }\n  isFrontFacing(direction) {\n    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n  }\n  intersectsBox(box) {\n    return box.intersectsTriangle(this);\n  }\n  closestPointToPoint(p, target) {\n    const a = this.a, b = this.b, c = this.c;\n    let v, w;\n    _vab.subVectors(b, a);\n    _vac.subVectors(c, a);\n    _vap.subVectors(p, a);\n    const d1 = _vab.dot(_vap);\n    const d2 = _vac.dot(_vap);\n    if (d1 <= 0 && d2 <= 0) {\n      return target.copy(a);\n    }\n    _vbp.subVectors(p, b);\n    const d3 = _vab.dot(_vbp);\n    const d4 = _vac.dot(_vbp);\n    if (d3 >= 0 && d4 <= d3) {\n      return target.copy(b);\n    }\n    const vc = d1 * d4 - d3 * d2;\n    if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n      v = d1 / (d1 - d3);\n      return target.copy(a).addScaledVector(_vab, v);\n    }\n    _vcp.subVectors(p, c);\n    const d5 = _vab.dot(_vcp);\n    const d6 = _vac.dot(_vcp);\n    if (d6 >= 0 && d5 <= d6) {\n      return target.copy(c);\n    }\n    const vb = d5 * d2 - d1 * d6;\n    if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n      w = d2 / (d2 - d6);\n      return target.copy(a).addScaledVector(_vac, w);\n    }\n    const va = d3 * d6 - d5 * d4;\n    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n      _vbc.subVectors(c, b);\n      w = (d4 - d3) / (d4 - d3 + (d5 - d6));\n      return target.copy(b).addScaledVector(_vbc, w);\n    }\n    const denom = 1 / (va + vb + vc);\n    v = vb * denom;\n    w = vc * denom;\n    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n  }\n  equals(triangle) {\n    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n  }\n}\nconst _colorKeywords = {\n  \"aliceblue\": 15792383,\n  \"antiquewhite\": 16444375,\n  \"aqua\": 65535,\n  \"aquamarine\": 8388564,\n  \"azure\": 15794175,\n  \"beige\": 16119260,\n  \"bisque\": 16770244,\n  \"black\": 0,\n  \"blanchedalmond\": 16772045,\n  \"blue\": 255,\n  \"blueviolet\": 9055202,\n  \"brown\": 10824234,\n  \"burlywood\": 14596231,\n  \"cadetblue\": 6266528,\n  \"chartreuse\": 8388352,\n  \"chocolate\": 13789470,\n  \"coral\": 16744272,\n  \"cornflowerblue\": 6591981,\n  \"cornsilk\": 16775388,\n  \"crimson\": 14423100,\n  \"cyan\": 65535,\n  \"darkblue\": 139,\n  \"darkcyan\": 35723,\n  \"darkgoldenrod\": 12092939,\n  \"darkgray\": 11119017,\n  \"darkgreen\": 25600,\n  \"darkgrey\": 11119017,\n  \"darkkhaki\": 12433259,\n  \"darkmagenta\": 9109643,\n  \"darkolivegreen\": 5597999,\n  \"darkorange\": 16747520,\n  \"darkorchid\": 10040012,\n  \"darkred\": 9109504,\n  \"darksalmon\": 15308410,\n  \"darkseagreen\": 9419919,\n  \"darkslateblue\": 4734347,\n  \"darkslategray\": 3100495,\n  \"darkslategrey\": 3100495,\n  \"darkturquoise\": 52945,\n  \"darkviolet\": 9699539,\n  \"deeppink\": 16716947,\n  \"deepskyblue\": 49151,\n  \"dimgray\": 6908265,\n  \"dimgrey\": 6908265,\n  \"dodgerblue\": 2003199,\n  \"firebrick\": 11674146,\n  \"floralwhite\": 16775920,\n  \"forestgreen\": 2263842,\n  \"fuchsia\": 16711935,\n  \"gainsboro\": 14474460,\n  \"ghostwhite\": 16316671,\n  \"gold\": 16766720,\n  \"goldenrod\": 14329120,\n  \"gray\": 8421504,\n  \"green\": 32768,\n  \"greenyellow\": 11403055,\n  \"grey\": 8421504,\n  \"honeydew\": 15794160,\n  \"hotpink\": 16738740,\n  \"indianred\": 13458524,\n  \"indigo\": 4915330,\n  \"ivory\": 16777200,\n  \"khaki\": 15787660,\n  \"lavender\": 15132410,\n  \"lavenderblush\": 16773365,\n  \"lawngreen\": 8190976,\n  \"lemonchiffon\": 16775885,\n  \"lightblue\": 11393254,\n  \"lightcoral\": 15761536,\n  \"lightcyan\": 14745599,\n  \"lightgoldenrodyellow\": 16448210,\n  \"lightgray\": 13882323,\n  \"lightgreen\": 9498256,\n  \"lightgrey\": 13882323,\n  \"lightpink\": 16758465,\n  \"lightsalmon\": 16752762,\n  \"lightseagreen\": 2142890,\n  \"lightskyblue\": 8900346,\n  \"lightslategray\": 7833753,\n  \"lightslategrey\": 7833753,\n  \"lightsteelblue\": 11584734,\n  \"lightyellow\": 16777184,\n  \"lime\": 65280,\n  \"limegreen\": 3329330,\n  \"linen\": 16445670,\n  \"magenta\": 16711935,\n  \"maroon\": 8388608,\n  \"mediumaquamarine\": 6737322,\n  \"mediumblue\": 205,\n  \"mediumorchid\": 12211667,\n  \"mediumpurple\": 9662683,\n  \"mediumseagreen\": 3978097,\n  \"mediumslateblue\": 8087790,\n  \"mediumspringgreen\": 64154,\n  \"mediumturquoise\": 4772300,\n  \"mediumvioletred\": 13047173,\n  \"midnightblue\": 1644912,\n  \"mintcream\": 16121850,\n  \"mistyrose\": 16770273,\n  \"moccasin\": 16770229,\n  \"navajowhite\": 16768685,\n  \"navy\": 128,\n  \"oldlace\": 16643558,\n  \"olive\": 8421376,\n  \"olivedrab\": 7048739,\n  \"orange\": 16753920,\n  \"orangered\": 16729344,\n  \"orchid\": 14315734,\n  \"palegoldenrod\": 15657130,\n  \"palegreen\": 10025880,\n  \"paleturquoise\": 11529966,\n  \"palevioletred\": 14381203,\n  \"papayawhip\": 16773077,\n  \"peachpuff\": 16767673,\n  \"peru\": 13468991,\n  \"pink\": 16761035,\n  \"plum\": 14524637,\n  \"powderblue\": 11591910,\n  \"purple\": 8388736,\n  \"rebeccapurple\": 6697881,\n  \"red\": 16711680,\n  \"rosybrown\": 12357519,\n  \"royalblue\": 4286945,\n  \"saddlebrown\": 9127187,\n  \"salmon\": 16416882,\n  \"sandybrown\": 16032864,\n  \"seagreen\": 3050327,\n  \"seashell\": 16774638,\n  \"sienna\": 10506797,\n  \"silver\": 12632256,\n  \"skyblue\": 8900331,\n  \"slateblue\": 6970061,\n  \"slategray\": 7372944,\n  \"slategrey\": 7372944,\n  \"snow\": 16775930,\n  \"springgreen\": 65407,\n  \"steelblue\": 4620980,\n  \"tan\": 13808780,\n  \"teal\": 32896,\n  \"thistle\": 14204888,\n  \"tomato\": 16737095,\n  \"turquoise\": 4251856,\n  \"violet\": 15631086,\n  \"wheat\": 16113331,\n  \"white\": 16777215,\n  \"whitesmoke\": 16119285,\n  \"yellow\": 16776960,\n  \"yellowgreen\": 10145074\n};\nconst _hslA = { h: 0, s: 0, l: 0 };\nconst _hslB = { h: 0, s: 0, l: 0 };\nfunction hue2rgb(p, q, t2) {\n  if (t2 < 0) t2 += 1;\n  if (t2 > 1) t2 -= 1;\n  if (t2 < 1 / 6) return p + (q - p) * 6 * t2;\n  if (t2 < 1 / 2) return q;\n  if (t2 < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t2);\n  return p;\n}\nclass Color {\n  constructor(r, g, b) {\n    this.isColor = true;\n    this.r = 1;\n    this.g = 1;\n    this.b = 1;\n    return this.set(r, g, b);\n  }\n  set(r, g, b) {\n    if (g === void 0 && b === void 0) {\n      const value = r;\n      if (value && value.isColor) {\n        this.copy(value);\n      } else if (typeof value === \"number\") {\n        this.setHex(value);\n      } else if (typeof value === \"string\") {\n        this.setStyle(value);\n      }\n    } else {\n      this.setRGB(r, g, b);\n    }\n    return this;\n  }\n  setScalar(scalar) {\n    this.r = scalar;\n    this.g = scalar;\n    this.b = scalar;\n    return this;\n  }\n  setHex(hex, colorSpace = SRGBColorSpace) {\n    hex = Math.floor(hex);\n    this.r = (hex >> 16 & 255) / 255;\n    this.g = (hex >> 8 & 255) / 255;\n    this.b = (hex & 255) / 255;\n    ColorManagement.toWorkingColorSpace(this, colorSpace);\n    return this;\n  }\n  setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    ColorManagement.toWorkingColorSpace(this, colorSpace);\n    return this;\n  }\n  setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {\n    h = euclideanModulo(h, 1);\n    s = clamp(s, 0, 1);\n    l = clamp(l, 0, 1);\n    if (s === 0) {\n      this.r = this.g = this.b = l;\n    } else {\n      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n      const q = 2 * l - p;\n      this.r = hue2rgb(q, p, h + 1 / 3);\n      this.g = hue2rgb(q, p, h);\n      this.b = hue2rgb(q, p, h - 1 / 3);\n    }\n    ColorManagement.toWorkingColorSpace(this, colorSpace);\n    return this;\n  }\n  setStyle(style, colorSpace = SRGBColorSpace) {\n    function handleAlpha(string) {\n      if (string === void 0) return;\n      if (parseFloat(string) < 1) {\n        console.warn(\"THREE.Color: Alpha component of \" + style + \" will be ignored.\");\n      }\n    }\n    let m;\n    if (m = /^(\\w+)\\(([^\\)]*)\\)/.exec(style)) {\n      let color;\n      const name = m[1];\n      const components = m[2];\n      switch (name) {\n        case \"rgb\":\n        case \"rgba\":\n          if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            handleAlpha(color[4]);\n            return this.setRGB(\n              Math.min(255, parseInt(color[1], 10)) / 255,\n              Math.min(255, parseInt(color[2], 10)) / 255,\n              Math.min(255, parseInt(color[3], 10)) / 255,\n              colorSpace\n            );\n          }\n          if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            handleAlpha(color[4]);\n            return this.setRGB(\n              Math.min(100, parseInt(color[1], 10)) / 100,\n              Math.min(100, parseInt(color[2], 10)) / 100,\n              Math.min(100, parseInt(color[3], 10)) / 100,\n              colorSpace\n            );\n          }\n          break;\n        case \"hsl\":\n        case \"hsla\":\n          if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            handleAlpha(color[4]);\n            return this.setHSL(\n              parseFloat(color[1]) / 360,\n              parseFloat(color[2]) / 100,\n              parseFloat(color[3]) / 100,\n              colorSpace\n            );\n          }\n          break;\n        default:\n          console.warn(\"THREE.Color: Unknown color model \" + style);\n      }\n    } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n      const hex = m[1];\n      const size = hex.length;\n      if (size === 3) {\n        return this.setRGB(\n          parseInt(hex.charAt(0), 16) / 15,\n          parseInt(hex.charAt(1), 16) / 15,\n          parseInt(hex.charAt(2), 16) / 15,\n          colorSpace\n        );\n      } else if (size === 6) {\n        return this.setHex(parseInt(hex, 16), colorSpace);\n      } else {\n        console.warn(\"THREE.Color: Invalid hex color \" + style);\n      }\n    } else if (style && style.length > 0) {\n      return this.setColorName(style, colorSpace);\n    }\n    return this;\n  }\n  setColorName(style, colorSpace = SRGBColorSpace) {\n    const hex = _colorKeywords[style.toLowerCase()];\n    if (hex !== void 0) {\n      this.setHex(hex, colorSpace);\n    } else {\n      console.warn(\"THREE.Color: Unknown color \" + style);\n    }\n    return this;\n  }\n  clone() {\n    return new this.constructor(this.r, this.g, this.b);\n  }\n  copy(color) {\n    this.r = color.r;\n    this.g = color.g;\n    this.b = color.b;\n    return this;\n  }\n  copySRGBToLinear(color) {\n    this.r = SRGBToLinear(color.r);\n    this.g = SRGBToLinear(color.g);\n    this.b = SRGBToLinear(color.b);\n    return this;\n  }\n  copyLinearToSRGB(color) {\n    this.r = LinearToSRGB(color.r);\n    this.g = LinearToSRGB(color.g);\n    this.b = LinearToSRGB(color.b);\n    return this;\n  }\n  convertSRGBToLinear() {\n    this.copySRGBToLinear(this);\n    return this;\n  }\n  convertLinearToSRGB() {\n    this.copyLinearToSRGB(this);\n    return this;\n  }\n  getHex(colorSpace = SRGBColorSpace) {\n    ColorManagement.fromWorkingColorSpace(_color$1.copy(this), colorSpace);\n    return Math.round(clamp(_color$1.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color$1.g * 255, 0, 255)) * 256 + Math.round(clamp(_color$1.b * 255, 0, 255));\n  }\n  getHexString(colorSpace = SRGBColorSpace) {\n    return (\"000000\" + this.getHex(colorSpace).toString(16)).slice(-6);\n  }\n  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {\n    ColorManagement.fromWorkingColorSpace(_color$1.copy(this), colorSpace);\n    const r = _color$1.r, g = _color$1.g, b = _color$1.b;\n    const max2 = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let hue, saturation;\n    const lightness = (min + max2) / 2;\n    if (min === max2) {\n      hue = 0;\n      saturation = 0;\n    } else {\n      const delta = max2 - min;\n      saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);\n      switch (max2) {\n        case r:\n          hue = (g - b) / delta + (g < b ? 6 : 0);\n          break;\n        case g:\n          hue = (b - r) / delta + 2;\n          break;\n        case b:\n          hue = (r - g) / delta + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    target.h = hue;\n    target.s = saturation;\n    target.l = lightness;\n    return target;\n  }\n  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\n    ColorManagement.fromWorkingColorSpace(_color$1.copy(this), colorSpace);\n    target.r = _color$1.r;\n    target.g = _color$1.g;\n    target.b = _color$1.b;\n    return target;\n  }\n  getStyle(colorSpace = SRGBColorSpace) {\n    ColorManagement.fromWorkingColorSpace(_color$1.copy(this), colorSpace);\n    const r = _color$1.r, g = _color$1.g, b = _color$1.b;\n    if (colorSpace !== SRGBColorSpace) {\n      return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;\n    }\n    return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;\n  }\n  offsetHSL(h, s, l) {\n    this.getHSL(_hslA);\n    return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);\n  }\n  add(color) {\n    this.r += color.r;\n    this.g += color.g;\n    this.b += color.b;\n    return this;\n  }\n  addColors(color1, color2) {\n    this.r = color1.r + color2.r;\n    this.g = color1.g + color2.g;\n    this.b = color1.b + color2.b;\n    return this;\n  }\n  addScalar(s) {\n    this.r += s;\n    this.g += s;\n    this.b += s;\n    return this;\n  }\n  sub(color) {\n    this.r = Math.max(0, this.r - color.r);\n    this.g = Math.max(0, this.g - color.g);\n    this.b = Math.max(0, this.b - color.b);\n    return this;\n  }\n  multiply(color) {\n    this.r *= color.r;\n    this.g *= color.g;\n    this.b *= color.b;\n    return this;\n  }\n  multiplyScalar(s) {\n    this.r *= s;\n    this.g *= s;\n    this.b *= s;\n    return this;\n  }\n  lerp(color, alpha) {\n    this.r += (color.r - this.r) * alpha;\n    this.g += (color.g - this.g) * alpha;\n    this.b += (color.b - this.b) * alpha;\n    return this;\n  }\n  lerpColors(color1, color2, alpha) {\n    this.r = color1.r + (color2.r - color1.r) * alpha;\n    this.g = color1.g + (color2.g - color1.g) * alpha;\n    this.b = color1.b + (color2.b - color1.b) * alpha;\n    return this;\n  }\n  lerpHSL(color, alpha) {\n    this.getHSL(_hslA);\n    color.getHSL(_hslB);\n    const h = lerp(_hslA.h, _hslB.h, alpha);\n    const s = lerp(_hslA.s, _hslB.s, alpha);\n    const l = lerp(_hslA.l, _hslB.l, alpha);\n    this.setHSL(h, s, l);\n    return this;\n  }\n  setFromVector3(v) {\n    this.r = v.x;\n    this.g = v.y;\n    this.b = v.z;\n    return this;\n  }\n  applyMatrix3(m) {\n    const r = this.r, g = this.g, b = this.b;\n    const e = m.elements;\n    this.r = e[0] * r + e[3] * g + e[6] * b;\n    this.g = e[1] * r + e[4] * g + e[7] * b;\n    this.b = e[2] * r + e[5] * g + e[8] * b;\n    return this;\n  }\n  equals(c) {\n    return c.r === this.r && c.g === this.g && c.b === this.b;\n  }\n  fromArray(array, offset = 0) {\n    this.r = array[offset];\n    this.g = array[offset + 1];\n    this.b = array[offset + 2];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.r;\n    array[offset + 1] = this.g;\n    array[offset + 2] = this.b;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this.r = attribute.getX(index);\n    this.g = attribute.getY(index);\n    this.b = attribute.getZ(index);\n    return this;\n  }\n  toJSON() {\n    return this.getHex();\n  }\n  *[Symbol.iterator]() {\n    yield this.r;\n    yield this.g;\n    yield this.b;\n  }\n}\nconst _color$1 = /* @__PURE__ */ new Color();\nColor.NAMES = _colorKeywords;\nlet _materialId = 0;\nclass Material extends EventDispatcher {\n  static get type() {\n    return \"Material\";\n  }\n  get type() {\n    return this.constructor.type;\n  }\n  set type(_value) {\n  }\n  constructor() {\n    super();\n    this.isMaterial = true;\n    Object.defineProperty(this, \"id\", { value: _materialId++ });\n    this.uuid = generateUUID();\n    this.name = \"\";\n    this.blending = NormalBlending;\n    this.side = FrontSide;\n    this.vertexColors = false;\n    this.opacity = 1;\n    this.transparent = false;\n    this.alphaHash = false;\n    this.blendSrc = SrcAlphaFactor;\n    this.blendDst = OneMinusSrcAlphaFactor;\n    this.blendEquation = AddEquation;\n    this.blendSrcAlpha = null;\n    this.blendDstAlpha = null;\n    this.blendEquationAlpha = null;\n    this.blendColor = new Color(0, 0, 0);\n    this.blendAlpha = 0;\n    this.depthFunc = LessEqualDepth;\n    this.depthTest = true;\n    this.depthWrite = true;\n    this.stencilWriteMask = 255;\n    this.stencilFunc = AlwaysStencilFunc;\n    this.stencilRef = 0;\n    this.stencilFuncMask = 255;\n    this.stencilFail = KeepStencilOp;\n    this.stencilZFail = KeepStencilOp;\n    this.stencilZPass = KeepStencilOp;\n    this.stencilWrite = false;\n    this.clippingPlanes = null;\n    this.clipIntersection = false;\n    this.clipShadows = false;\n    this.shadowSide = null;\n    this.colorWrite = true;\n    this.precision = null;\n    this.polygonOffset = false;\n    this.polygonOffsetFactor = 0;\n    this.polygonOffsetUnits = 0;\n    this.dithering = false;\n    this.alphaToCoverage = false;\n    this.premultipliedAlpha = false;\n    this.forceSinglePass = false;\n    this.visible = true;\n    this.toneMapped = true;\n    this.userData = {};\n    this.version = 0;\n    this._alphaTest = 0;\n  }\n  get alphaTest() {\n    return this._alphaTest;\n  }\n  set alphaTest(value) {\n    if (this._alphaTest > 0 !== value > 0) {\n      this.version++;\n    }\n    this._alphaTest = value;\n  }\n  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer\n  onBeforeRender() {\n  }\n  onBeforeCompile() {\n  }\n  customProgramCacheKey() {\n    return this.onBeforeCompile.toString();\n  }\n  setValues(values) {\n    if (values === void 0) return;\n    for (const key in values) {\n      const newValue = values[key];\n      if (newValue === void 0) {\n        console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);\n        continue;\n      }\n      const currentValue = this[key];\n      if (currentValue === void 0) {\n        console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);\n        continue;\n      }\n      if (currentValue && currentValue.isColor) {\n        currentValue.set(newValue);\n      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {\n        currentValue.copy(newValue);\n      } else {\n        this[key] = newValue;\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRootObject = meta === void 0 || typeof meta === \"string\";\n    if (isRootObject) {\n      meta = {\n        textures: {},\n        images: {}\n      };\n    }\n    const data = {\n      metadata: {\n        version: 4.6,\n        type: \"Material\",\n        generator: \"Material.toJSON\"\n      }\n    };\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== \"\") data.name = this.name;\n    if (this.color && this.color.isColor) data.color = this.color.getHex();\n    if (this.roughness !== void 0) data.roughness = this.roughness;\n    if (this.metalness !== void 0) data.metalness = this.metalness;\n    if (this.sheen !== void 0) data.sheen = this.sheen;\n    if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();\n    if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;\n    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n    if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n    if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;\n    if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();\n    if (this.shininess !== void 0) data.shininess = this.shininess;\n    if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;\n    if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;\n    if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n    }\n    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n    }\n    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n    }\n    if (this.dispersion !== void 0) data.dispersion = this.dispersion;\n    if (this.iridescence !== void 0) data.iridescence = this.iridescence;\n    if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;\n    if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n    if (this.iridescenceMap && this.iridescenceMap.isTexture) {\n      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;\n    }\n    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {\n      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;\n    }\n    if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;\n    if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;\n    if (this.anisotropyMap && this.anisotropyMap.isTexture) {\n      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;\n    }\n    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n    if (this.lightMap && this.lightMap.isTexture) {\n      data.lightMap = this.lightMap.toJSON(meta).uuid;\n      data.lightMapIntensity = this.lightMapIntensity;\n    }\n    if (this.aoMap && this.aoMap.isTexture) {\n      data.aoMap = this.aoMap.toJSON(meta).uuid;\n      data.aoMapIntensity = this.aoMapIntensity;\n    }\n    if (this.bumpMap && this.bumpMap.isTexture) {\n      data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n      data.bumpScale = this.bumpScale;\n    }\n    if (this.normalMap && this.normalMap.isTexture) {\n      data.normalMap = this.normalMap.toJSON(meta).uuid;\n      data.normalMapType = this.normalMapType;\n      data.normalScale = this.normalScale.toArray();\n    }\n    if (this.displacementMap && this.displacementMap.isTexture) {\n      data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n      data.displacementScale = this.displacementScale;\n      data.displacementBias = this.displacementBias;\n    }\n    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;\n    if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;\n    if (this.envMap && this.envMap.isTexture) {\n      data.envMap = this.envMap.toJSON(meta).uuid;\n      if (this.combine !== void 0) data.combine = this.combine;\n    }\n    if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();\n    if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;\n    if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;\n    if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;\n    if (this.gradientMap && this.gradientMap.isTexture) {\n      data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n    }\n    if (this.transmission !== void 0) data.transmission = this.transmission;\n    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n    if (this.thickness !== void 0) data.thickness = this.thickness;\n    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n    if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;\n    if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();\n    if (this.size !== void 0) data.size = this.size;\n    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n    if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;\n    if (this.blending !== NormalBlending) data.blending = this.blending;\n    if (this.side !== FrontSide) data.side = this.side;\n    if (this.vertexColors === true) data.vertexColors = true;\n    if (this.opacity < 1) data.opacity = this.opacity;\n    if (this.transparent === true) data.transparent = true;\n    if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;\n    if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;\n    if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;\n    if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;\n    if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;\n    if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;\n    if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();\n    if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;\n    if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;\n    if (this.depthTest === false) data.depthTest = this.depthTest;\n    if (this.depthWrite === false) data.depthWrite = this.depthWrite;\n    if (this.colorWrite === false) data.colorWrite = this.colorWrite;\n    if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;\n    if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;\n    if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;\n    if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;\n    if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;\n    if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;\n    if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;\n    if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;\n    if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;\n    if (this.polygonOffset === true) data.polygonOffset = true;\n    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n    if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;\n    if (this.dashSize !== void 0) data.dashSize = this.dashSize;\n    if (this.gapSize !== void 0) data.gapSize = this.gapSize;\n    if (this.scale !== void 0) data.scale = this.scale;\n    if (this.dithering === true) data.dithering = true;\n    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n    if (this.alphaHash === true) data.alphaHash = true;\n    if (this.alphaToCoverage === true) data.alphaToCoverage = true;\n    if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;\n    if (this.forceSinglePass === true) data.forceSinglePass = true;\n    if (this.wireframe === true) data.wireframe = true;\n    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n    if (this.wireframeLinecap !== \"round\") data.wireframeLinecap = this.wireframeLinecap;\n    if (this.wireframeLinejoin !== \"round\") data.wireframeLinejoin = this.wireframeLinejoin;\n    if (this.flatShading === true) data.flatShading = true;\n    if (this.visible === false) data.visible = false;\n    if (this.toneMapped === false) data.toneMapped = false;\n    if (this.fog === false) data.fog = false;\n    if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n    function extractFromCache(cache2) {\n      const values = [];\n      for (const key in cache2) {\n        const data2 = cache2[key];\n        delete data2.metadata;\n        values.push(data2);\n      }\n      return values;\n    }\n    if (isRootObject) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n    }\n    return data;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.name = source.name;\n    this.blending = source.blending;\n    this.side = source.side;\n    this.vertexColors = source.vertexColors;\n    this.opacity = source.opacity;\n    this.transparent = source.transparent;\n    this.blendSrc = source.blendSrc;\n    this.blendDst = source.blendDst;\n    this.blendEquation = source.blendEquation;\n    this.blendSrcAlpha = source.blendSrcAlpha;\n    this.blendDstAlpha = source.blendDstAlpha;\n    this.blendEquationAlpha = source.blendEquationAlpha;\n    this.blendColor.copy(source.blendColor);\n    this.blendAlpha = source.blendAlpha;\n    this.depthFunc = source.depthFunc;\n    this.depthTest = source.depthTest;\n    this.depthWrite = source.depthWrite;\n    this.stencilWriteMask = source.stencilWriteMask;\n    this.stencilFunc = source.stencilFunc;\n    this.stencilRef = source.stencilRef;\n    this.stencilFuncMask = source.stencilFuncMask;\n    this.stencilFail = source.stencilFail;\n    this.stencilZFail = source.stencilZFail;\n    this.stencilZPass = source.stencilZPass;\n    this.stencilWrite = source.stencilWrite;\n    const srcPlanes = source.clippingPlanes;\n    let dstPlanes = null;\n    if (srcPlanes !== null) {\n      const n = srcPlanes.length;\n      dstPlanes = new Array(n);\n      for (let i = 0; i !== n; ++i) {\n        dstPlanes[i] = srcPlanes[i].clone();\n      }\n    }\n    this.clippingPlanes = dstPlanes;\n    this.clipIntersection = source.clipIntersection;\n    this.clipShadows = source.clipShadows;\n    this.shadowSide = source.shadowSide;\n    this.colorWrite = source.colorWrite;\n    this.precision = source.precision;\n    this.polygonOffset = source.polygonOffset;\n    this.polygonOffsetFactor = source.polygonOffsetFactor;\n    this.polygonOffsetUnits = source.polygonOffsetUnits;\n    this.dithering = source.dithering;\n    this.alphaTest = source.alphaTest;\n    this.alphaHash = source.alphaHash;\n    this.alphaToCoverage = source.alphaToCoverage;\n    this.premultipliedAlpha = source.premultipliedAlpha;\n    this.forceSinglePass = source.forceSinglePass;\n    this.visible = source.visible;\n    this.toneMapped = source.toneMapped;\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n    return this;\n  }\n  dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  onBuild() {\n    console.warn(\"Material: onBuild() has been removed.\");\n  }\n}\nclass MeshBasicMaterial extends Material {\n  static get type() {\n    return \"MeshBasicMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshBasicMaterial = true;\n    this.color = new Color(16777215);\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity = 1;\n    this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.envMapRotation = new Euler();\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.envMapRotation.copy(source.envMapRotation);\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.fog = source.fog;\n    return this;\n  }\n}\nconst _vector$9 = /* @__PURE__ */ new Vector3();\nconst _vector2$1 = /* @__PURE__ */ new Vector2();\nclass BufferAttribute {\n  constructor(array, itemSize, normalized = false) {\n    if (Array.isArray(array)) {\n      throw new TypeError(\"THREE.BufferAttribute: array should be a Typed Array.\");\n    }\n    this.isBufferAttribute = true;\n    this.name = \"\";\n    this.array = array;\n    this.itemSize = itemSize;\n    this.count = array !== void 0 ? array.length / itemSize : 0;\n    this.normalized = normalized;\n    this.usage = StaticDrawUsage;\n    this.updateRanges = [];\n    this.gpuType = FloatType;\n    this.version = 0;\n  }\n  onUploadCallback() {\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  setUsage(value) {\n    this.usage = value;\n    return this;\n  }\n  addUpdateRange(start, count) {\n    this.updateRanges.push({ start, count });\n  }\n  clearUpdateRanges() {\n    this.updateRanges.length = 0;\n  }\n  copy(source) {\n    this.name = source.name;\n    this.array = new source.array.constructor(source.array);\n    this.itemSize = source.itemSize;\n    this.count = source.count;\n    this.normalized = source.normalized;\n    this.usage = source.usage;\n    this.gpuType = source.gpuType;\n    return this;\n  }\n  copyAt(index1, attribute, index2) {\n    index1 *= this.itemSize;\n    index2 *= attribute.itemSize;\n    for (let i = 0, l = this.itemSize; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n    return this;\n  }\n  copyArray(array) {\n    this.array.set(array);\n    return this;\n  }\n  applyMatrix3(m) {\n    if (this.itemSize === 2) {\n      for (let i = 0, l = this.count; i < l; i++) {\n        _vector2$1.fromBufferAttribute(this, i);\n        _vector2$1.applyMatrix3(m);\n        this.setXY(i, _vector2$1.x, _vector2$1.y);\n      }\n    } else if (this.itemSize === 3) {\n      for (let i = 0, l = this.count; i < l; i++) {\n        _vector$9.fromBufferAttribute(this, i);\n        _vector$9.applyMatrix3(m);\n        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n    }\n    return this;\n  }\n  applyMatrix4(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.fromBufferAttribute(this, i);\n      _vector$9.applyMatrix4(m);\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n    return this;\n  }\n  applyNormalMatrix(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.fromBufferAttribute(this, i);\n      _vector$9.applyNormalMatrix(m);\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n    return this;\n  }\n  transformDirection(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.fromBufferAttribute(this, i);\n      _vector$9.transformDirection(m);\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n    return this;\n  }\n  set(value, offset = 0) {\n    this.array.set(value, offset);\n    return this;\n  }\n  getComponent(index, component) {\n    let value = this.array[index * this.itemSize + component];\n    if (this.normalized) value = denormalize(value, this.array);\n    return value;\n  }\n  setComponent(index, component, value) {\n    if (this.normalized) value = normalize(value, this.array);\n    this.array[index * this.itemSize + component] = value;\n    return this;\n  }\n  getX(index) {\n    let x = this.array[index * this.itemSize];\n    if (this.normalized) x = denormalize(x, this.array);\n    return x;\n  }\n  setX(index, x) {\n    if (this.normalized) x = normalize(x, this.array);\n    this.array[index * this.itemSize] = x;\n    return this;\n  }\n  getY(index) {\n    let y = this.array[index * this.itemSize + 1];\n    if (this.normalized) y = denormalize(y, this.array);\n    return y;\n  }\n  setY(index, y) {\n    if (this.normalized) y = normalize(y, this.array);\n    this.array[index * this.itemSize + 1] = y;\n    return this;\n  }\n  getZ(index) {\n    let z = this.array[index * this.itemSize + 2];\n    if (this.normalized) z = denormalize(z, this.array);\n    return z;\n  }\n  setZ(index, z) {\n    if (this.normalized) z = normalize(z, this.array);\n    this.array[index * this.itemSize + 2] = z;\n    return this;\n  }\n  getW(index) {\n    let w = this.array[index * this.itemSize + 3];\n    if (this.normalized) w = denormalize(w, this.array);\n    return w;\n  }\n  setW(index, w) {\n    if (this.normalized) w = normalize(w, this.array);\n    this.array[index * this.itemSize + 3] = w;\n    return this;\n  }\n  setXY(index, x, y) {\n    index *= this.itemSize;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n    }\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    return this;\n  }\n  setXYZ(index, x, y, z) {\n    index *= this.itemSize;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n      z = normalize(z, this.array);\n    }\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n    return this;\n  }\n  setXYZW(index, x, y, z, w) {\n    index *= this.itemSize;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n      z = normalize(z, this.array);\n      w = normalize(w, this.array);\n    }\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n    this.array[index + 3] = w;\n    return this;\n  }\n  onUpload(callback) {\n    this.onUploadCallback = callback;\n    return this;\n  }\n  clone() {\n    return new this.constructor(this.array, this.itemSize).copy(this);\n  }\n  toJSON() {\n    const data = {\n      itemSize: this.itemSize,\n      type: this.array.constructor.name,\n      array: Array.from(this.array),\n      normalized: this.normalized\n    };\n    if (this.name !== \"\") data.name = this.name;\n    if (this.usage !== StaticDrawUsage) data.usage = this.usage;\n    return data;\n  }\n}\nclass Uint16BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint16Array(array), itemSize, normalized);\n  }\n}\nclass Uint32BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint32Array(array), itemSize, normalized);\n  }\n}\nclass Float32BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Float32Array(array), itemSize, normalized);\n  }\n}\nlet _id$2 = 0;\nconst _m1$2 = /* @__PURE__ */ new Matrix4();\nconst _obj = /* @__PURE__ */ new Object3D();\nconst _offset = /* @__PURE__ */ new Vector3();\nconst _box$2 = /* @__PURE__ */ new Box3();\nconst _boxMorphTargets = /* @__PURE__ */ new Box3();\nconst _vector$8 = /* @__PURE__ */ new Vector3();\nclass BufferGeometry extends EventDispatcher {\n  constructor() {\n    super();\n    this.isBufferGeometry = true;\n    Object.defineProperty(this, \"id\", { value: _id$2++ });\n    this.uuid = generateUUID();\n    this.name = \"\";\n    this.type = \"BufferGeometry\";\n    this.index = null;\n    this.indirect = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.morphTargetsRelative = false;\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.drawRange = { start: 0, count: Infinity };\n    this.userData = {};\n  }\n  getIndex() {\n    return this.index;\n  }\n  setIndex(index) {\n    if (Array.isArray(index)) {\n      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n    } else {\n      this.index = index;\n    }\n    return this;\n  }\n  setIndirect(indirect) {\n    this.indirect = indirect;\n    return this;\n  }\n  getIndirect() {\n    return this.indirect;\n  }\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n  setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n    return this;\n  }\n  deleteAttribute(name) {\n    delete this.attributes[name];\n    return this;\n  }\n  hasAttribute(name) {\n    return this.attributes[name] !== void 0;\n  }\n  addGroup(start, count, materialIndex = 0) {\n    this.groups.push({\n      start,\n      count,\n      materialIndex\n    });\n  }\n  clearGroups() {\n    this.groups = [];\n  }\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n  applyMatrix4(matrix) {\n    const position = this.attributes.position;\n    if (position !== void 0) {\n      position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n    const normal = this.attributes.normal;\n    if (normal !== void 0) {\n      const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      normal.applyNormalMatrix(normalMatrix);\n      normal.needsUpdate = true;\n    }\n    const tangent = this.attributes.tangent;\n    if (tangent !== void 0) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  applyQuaternion(q) {\n    _m1$2.makeRotationFromQuaternion(q);\n    this.applyMatrix4(_m1$2);\n    return this;\n  }\n  rotateX(angle) {\n    _m1$2.makeRotationX(angle);\n    this.applyMatrix4(_m1$2);\n    return this;\n  }\n  rotateY(angle) {\n    _m1$2.makeRotationY(angle);\n    this.applyMatrix4(_m1$2);\n    return this;\n  }\n  rotateZ(angle) {\n    _m1$2.makeRotationZ(angle);\n    this.applyMatrix4(_m1$2);\n    return this;\n  }\n  translate(x, y, z) {\n    _m1$2.makeTranslation(x, y, z);\n    this.applyMatrix4(_m1$2);\n    return this;\n  }\n  scale(x, y, z) {\n    _m1$2.makeScale(x, y, z);\n    this.applyMatrix4(_m1$2);\n    return this;\n  }\n  lookAt(vector) {\n    _obj.lookAt(vector);\n    _obj.updateMatrix();\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n  setFromPoints(points) {\n    const positionAttribute = this.getAttribute(\"position\");\n    if (positionAttribute === void 0) {\n      const position = [];\n      for (let i = 0, l = points.length; i < l; i++) {\n        const point = points[i];\n        position.push(point.x, point.y, point.z || 0);\n      }\n      this.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n    } else {\n      for (let i = 0, l = positionAttribute.count; i < l; i++) {\n        const point = points[i];\n        positionAttribute.setXYZ(i, point.x, point.y, point.z || 0);\n      }\n      if (points.length > positionAttribute.count) {\n        console.warn(\"THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.\");\n      }\n      positionAttribute.needsUpdate = true;\n    }\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n    if (position && position.isGLBufferAttribute) {\n      console.error(\"THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.\", this);\n      this.boundingBox.set(\n        new Vector3(-Infinity, -Infinity, -Infinity),\n        new Vector3(Infinity, Infinity, Infinity)\n      );\n      return;\n    }\n    if (position !== void 0) {\n      this.boundingBox.setFromBufferAttribute(position);\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _box$2.setFromBufferAttribute(morphAttribute);\n          if (this.morphTargetsRelative) {\n            _vector$8.addVectors(this.boundingBox.min, _box$2.min);\n            this.boundingBox.expandByPoint(_vector$8);\n            _vector$8.addVectors(this.boundingBox.max, _box$2.max);\n            this.boundingBox.expandByPoint(_vector$8);\n          } else {\n            this.boundingBox.expandByPoint(_box$2.min);\n            this.boundingBox.expandByPoint(_box$2.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n    if (position && position.isGLBufferAttribute) {\n      console.error(\"THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.\", this);\n      this.boundingSphere.set(new Vector3(), Infinity);\n      return;\n    }\n    if (position) {\n      const center = this.boundingSphere.center;\n      _box$2.setFromBufferAttribute(position);\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n          if (this.morphTargetsRelative) {\n            _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);\n            _box$2.expandByPoint(_vector$8);\n            _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);\n            _box$2.expandByPoint(_vector$8);\n          } else {\n            _box$2.expandByPoint(_boxMorphTargets.min);\n            _box$2.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n      _box$2.getCenter(center);\n      let maxRadiusSq = 0;\n      for (let i = 0, il = position.count; i < il; i++) {\n        _vector$8.fromBufferAttribute(position, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n      }\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          const morphTargetsRelative = this.morphTargetsRelative;\n          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n            _vector$8.fromBufferAttribute(morphAttribute, j);\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n              _vector$8.add(_offset);\n            }\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n          }\n        }\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n  }\n  computeTangents() {\n    const index = this.index;\n    const attributes = this.attributes;\n    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {\n      console.error(\"THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)\");\n      return;\n    }\n    const positionAttribute = attributes.position;\n    const normalAttribute = attributes.normal;\n    const uvAttribute = attributes.uv;\n    if (this.hasAttribute(\"tangent\") === false) {\n      this.setAttribute(\"tangent\", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));\n    }\n    const tangentAttribute = this.getAttribute(\"tangent\");\n    const tan1 = [], tan2 = [];\n    for (let i = 0; i < positionAttribute.count; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();\n    function handleTriangle(a, b, c) {\n      vA.fromBufferAttribute(positionAttribute, a);\n      vB.fromBufferAttribute(positionAttribute, b);\n      vC.fromBufferAttribute(positionAttribute, c);\n      uvA.fromBufferAttribute(uvAttribute, a);\n      uvB.fromBufferAttribute(uvAttribute, b);\n      uvC.fromBufferAttribute(uvAttribute, c);\n      vB.sub(vA);\n      vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);\n      if (!isFinite(r)) return;\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n    let groups = this.groups;\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: index.count\n      }];\n    }\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(\n          index.getX(j + 0),\n          index.getX(j + 1),\n          index.getX(j + 2)\n        );\n      }\n    }\n    const tmp = new Vector3(), tmp2 = new Vector3();\n    const n = new Vector3(), n2 = new Vector3();\n    function handleVertex(v) {\n      n.fromBufferAttribute(normalAttribute, v);\n      n2.copy(n);\n      const t2 = tan1[v];\n      tmp.copy(t2);\n      tmp.sub(n.multiplyScalar(n.dot(t2))).normalize();\n      tmp2.crossVectors(n2, t2);\n      const test = tmp2.dot(tan2[v]);\n      const w = test < 0 ? -1 : 1;\n      tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);\n    }\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(index.getX(j + 0));\n        handleVertex(index.getX(j + 1));\n        handleVertex(index.getX(j + 2));\n      }\n    }\n  }\n  computeVertexNormals() {\n    const index = this.index;\n    const positionAttribute = this.getAttribute(\"position\");\n    if (positionAttribute !== void 0) {\n      let normalAttribute = this.getAttribute(\"normal\");\n      if (normalAttribute === void 0) {\n        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n        this.setAttribute(\"normal\", normalAttribute);\n      } else {\n        for (let i = 0, il = normalAttribute.count; i < il; i++) {\n          normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n      const cb = new Vector3(), ab = new Vector3();\n      if (index) {\n        for (let i = 0, il = index.count; i < il; i += 3) {\n          const vA = index.getX(i + 0);\n          const vB = index.getX(i + 1);\n          const vC = index.getX(i + 2);\n          pA.fromBufferAttribute(positionAttribute, vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          pC.fromBufferAttribute(positionAttribute, vC);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          nA.fromBufferAttribute(normalAttribute, vA);\n          nB.fromBufferAttribute(normalAttribute, vB);\n          nC.fromBufferAttribute(normalAttribute, vC);\n          nA.add(cb);\n          nB.add(cb);\n          nC.add(cb);\n          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } else {\n        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n          pA.fromBufferAttribute(positionAttribute, i + 0);\n          pB.fromBufferAttribute(positionAttribute, i + 1);\n          pC.fromBufferAttribute(positionAttribute, i + 2);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n        }\n      }\n      this.normalizeNormals();\n      normalAttribute.needsUpdate = true;\n    }\n  }\n  normalizeNormals() {\n    const normals = this.attributes.normal;\n    for (let i = 0, il = normals.count; i < il; i++) {\n      _vector$8.fromBufferAttribute(normals, i);\n      _vector$8.normalize();\n      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);\n    }\n  }\n  toNonIndexed() {\n    function convertBufferAttribute(attribute, indices2) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const normalized = attribute.normalized;\n      const array2 = new array.constructor(indices2.length * itemSize);\n      let index = 0, index2 = 0;\n      for (let i = 0, l = indices2.length; i < l; i++) {\n        if (attribute.isInterleavedBufferAttribute) {\n          index = indices2[i] * attribute.data.stride + attribute.offset;\n        } else {\n          index = indices2[i] * itemSize;\n        }\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new BufferAttribute(array2, itemSize, normalized);\n    }\n    if (this.index === null) {\n      console.warn(\"THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.\");\n      return this;\n    }\n    const geometry2 = new BufferGeometry();\n    const indices = this.index.array;\n    const attributes = this.attributes;\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      const newAttribute = convertBufferAttribute(attribute, indices);\n      geometry2.setAttribute(name, newAttribute);\n    }\n    const morphAttributes = this.morphAttributes;\n    for (const name in morphAttributes) {\n      const morphArray = [];\n      const morphAttribute = morphAttributes[name];\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const attribute = morphAttribute[i];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        morphArray.push(newAttribute);\n      }\n      geometry2.morphAttributes[name] = morphArray;\n    }\n    geometry2.morphTargetsRelative = this.morphTargetsRelative;\n    const groups = this.groups;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n    return geometry2;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.6,\n        type: \"BufferGeometry\",\n        generator: \"BufferGeometry.toJSON\"\n      }\n    };\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== \"\") data.name = this.name;\n    if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n    if (this.parameters !== void 0) {\n      const parameters = this.parameters;\n      for (const key in parameters) {\n        if (parameters[key] !== void 0) data[key] = parameters[key];\n      }\n      return data;\n    }\n    data.data = { attributes: {} };\n    const index = this.index;\n    if (index !== null) {\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: Array.prototype.slice.call(index.array)\n      };\n    }\n    const attributes = this.attributes;\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      data.data.attributes[key] = attribute.toJSON(data.data);\n    }\n    const morphAttributes = {};\n    let hasMorphAttributes = false;\n    for (const key in this.morphAttributes) {\n      const attributeArray = this.morphAttributes[key];\n      const array = [];\n      for (let i = 0, il = attributeArray.length; i < il; i++) {\n        const attribute = attributeArray[i];\n        array.push(attribute.toJSON(data.data));\n      }\n      if (array.length > 0) {\n        morphAttributes[key] = array;\n        hasMorphAttributes = true;\n      }\n    }\n    if (hasMorphAttributes) {\n      data.data.morphAttributes = morphAttributes;\n      data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n    const groups = this.groups;\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(JSON.stringify(groups));\n    }\n    const boundingSphere = this.boundingSphere;\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n      };\n    }\n    return data;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    const data = {};\n    this.name = source.name;\n    const index = source.index;\n    if (index !== null) {\n      this.setIndex(index.clone(data));\n    }\n    const attributes = source.attributes;\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      this.setAttribute(name, attribute.clone(data));\n    }\n    const morphAttributes = source.morphAttributes;\n    for (const name in morphAttributes) {\n      const array = [];\n      const morphAttribute = morphAttributes[name];\n      for (let i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone(data));\n      }\n      this.morphAttributes[name] = array;\n    }\n    this.morphTargetsRelative = source.morphTargetsRelative;\n    const groups = source.groups;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    }\n    const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n    const boundingSphere = source.boundingSphere;\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count;\n    this.userData = source.userData;\n    return this;\n  }\n  dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n  }\n}\nconst _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();\nconst _ray$3 = /* @__PURE__ */ new Ray();\nconst _sphere$6 = /* @__PURE__ */ new Sphere();\nconst _sphereHitAt = /* @__PURE__ */ new Vector3();\nconst _vA$1 = /* @__PURE__ */ new Vector3();\nconst _vB$1 = /* @__PURE__ */ new Vector3();\nconst _vC$1 = /* @__PURE__ */ new Vector3();\nconst _tempA = /* @__PURE__ */ new Vector3();\nconst _morphA = /* @__PURE__ */ new Vector3();\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nconst _intersectionPointWorld = /* @__PURE__ */ new Vector3();\nclass Mesh extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n    super();\n    this.isMesh = true;\n    this.type = \"Mesh\";\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    if (source.morphTargetInfluences !== void 0) {\n      this.morphTargetInfluences = source.morphTargetInfluences.slice();\n    }\n    if (source.morphTargetDictionary !== void 0) {\n      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n    }\n    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    const morphAttributes = geometry.morphAttributes;\n    const keys = Object.keys(morphAttributes);\n    if (keys.length > 0) {\n      const morphAttribute = morphAttributes[keys[0]];\n      if (morphAttribute !== void 0) {\n        this.morphTargetInfluences = [];\n        this.morphTargetDictionary = {};\n        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n          const name = morphAttribute[m].name || String(m);\n          this.morphTargetInfluences.push(0);\n          this.morphTargetDictionary[name] = m;\n        }\n      }\n    }\n  }\n  getVertexPosition(index, target) {\n    const geometry = this.geometry;\n    const position = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    target.fromBufferAttribute(position, index);\n    const morphInfluences = this.morphTargetInfluences;\n    if (morphPosition && morphInfluences) {\n      _morphA.set(0, 0, 0);\n      for (let i = 0, il = morphPosition.length; i < il; i++) {\n        const influence = morphInfluences[i];\n        const morphAttribute = morphPosition[i];\n        if (influence === 0) continue;\n        _tempA.fromBufferAttribute(morphAttribute, index);\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(target), influence);\n        }\n      }\n      target.add(_morphA);\n    }\n    return target;\n  }\n  raycast(raycaster, intersects2) {\n    const geometry = this.geometry;\n    const material = this.material;\n    const matrixWorld = this.matrixWorld;\n    if (material === void 0) return;\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n    _sphere$6.copy(geometry.boundingSphere);\n    _sphere$6.applyMatrix4(matrixWorld);\n    _ray$3.copy(raycaster.ray).recast(raycaster.near);\n    if (_sphere$6.containsPoint(_ray$3.origin) === false) {\n      if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;\n      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;\n    }\n    _inverseMatrix$3.copy(matrixWorld).invert();\n    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);\n    if (geometry.boundingBox !== null) {\n      if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;\n    }\n    this._computeIntersections(raycaster, intersects2, _ray$3);\n  }\n  _computeIntersections(raycaster, intersects2, rayLocalSpace) {\n    let intersection;\n    const geometry = this.geometry;\n    const material = this.material;\n    const index = geometry.index;\n    const position = geometry.attributes.position;\n    const uv = geometry.attributes.uv;\n    const uv1 = geometry.attributes.uv1;\n    const normal = geometry.attributes.normal;\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    if (index !== null) {\n      if (Array.isArray(material)) {\n        for (let i = 0, il = groups.length; i < il; i++) {\n          const group = groups[i];\n          const groupMaterial = material[group.materialIndex];\n          const start = Math.max(group.start, drawRange.start);\n          const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n          for (let j = start, jl = end; j < jl; j += 3) {\n            const a = index.getX(j);\n            const b = index.getX(j + 1);\n            const c = index.getX(j + 2);\n            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(j / 3);\n              intersection.face.materialIndex = group.materialIndex;\n              intersects2.push(intersection);\n            }\n          }\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n        for (let i = start, il = end; i < il; i += 3) {\n          const a = index.getX(i);\n          const b = index.getX(i + 1);\n          const c = index.getX(i + 2);\n          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n          if (intersection) {\n            intersection.faceIndex = Math.floor(i / 3);\n            intersects2.push(intersection);\n          }\n        }\n      }\n    } else if (position !== void 0) {\n      if (Array.isArray(material)) {\n        for (let i = 0, il = groups.length; i < il; i++) {\n          const group = groups[i];\n          const groupMaterial = material[group.materialIndex];\n          const start = Math.max(group.start, drawRange.start);\n          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n          for (let j = start, jl = end; j < jl; j += 3) {\n            const a = j;\n            const b = j + 1;\n            const c = j + 2;\n            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(j / 3);\n              intersection.face.materialIndex = group.materialIndex;\n              intersects2.push(intersection);\n            }\n          }\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(position.count, drawRange.start + drawRange.count);\n        for (let i = start, il = end; i < il; i += 3) {\n          const a = i;\n          const b = i + 1;\n          const c = i + 2;\n          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n          if (intersection) {\n            intersection.faceIndex = Math.floor(i / 3);\n            intersects2.push(intersection);\n          }\n        }\n      }\n    }\n  }\n}\nfunction checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {\n  let intersect2;\n  if (material.side === BackSide) {\n    intersect2 = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect2 = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);\n  }\n  if (intersect2 === null) return null;\n  _intersectionPointWorld.copy(point);\n  _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n  if (distance < raycaster.near || distance > raycaster.far) return null;\n  return {\n    distance,\n    point: _intersectionPointWorld.clone(),\n    object\n  };\n}\nfunction checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {\n  object.getVertexPosition(a, _vA$1);\n  object.getVertexPosition(b, _vB$1);\n  object.getVertexPosition(c, _vC$1);\n  const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n  if (intersection) {\n    const barycoord = new Vector3();\n    Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);\n    if (uv) {\n      intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());\n    }\n    if (uv1) {\n      intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());\n    }\n    if (normal) {\n      intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());\n      if (intersection.normal.dot(ray.direction) > 0) {\n        intersection.normal.multiplyScalar(-1);\n      }\n    }\n    const face = {\n      a,\n      b,\n      c,\n      normal: new Vector3(),\n      materialIndex: 0\n    };\n    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n    intersection.face = face;\n    intersection.barycoord = barycoord;\n  }\n  return intersection;\n}\nclass BoxGeometry extends BufferGeometry {\n  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {\n    super();\n    this.type = \"BoxGeometry\";\n    this.parameters = {\n      width,\n      height,\n      depth,\n      widthSegments,\n      heightSegments,\n      depthSegments\n    };\n    const scope = this;\n    widthSegments = Math.floor(widthSegments);\n    heightSegments = Math.floor(heightSegments);\n    depthSegments = Math.floor(depthSegments);\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    let numberOfVertices = 0;\n    let groupStart = 0;\n    buildPlane(\"z\", \"y\", \"x\", -1, -1, depth, height, width, depthSegments, heightSegments, 0);\n    buildPlane(\"z\", \"y\", \"x\", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);\n    buildPlane(\"x\", \"z\", \"y\", 1, 1, width, depth, height, widthSegments, depthSegments, 2);\n    buildPlane(\"x\", \"z\", \"y\", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);\n    buildPlane(\"x\", \"y\", \"z\", 1, -1, width, height, depth, widthSegments, heightSegments, 4);\n    buildPlane(\"x\", \"y\", \"z\", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {\n      const segmentWidth = width2 / gridX;\n      const segmentHeight = height2 / gridY;\n      const widthHalf = width2 / 2;\n      const heightHalf = height2 / 2;\n      const depthHalf = depth2 / 2;\n      const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      let vertexCounter = 0;\n      let groupCount = 0;\n      const vector = new Vector3();\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y = iy * segmentHeight - heightHalf;\n        for (let ix = 0; ix < gridX1; ix++) {\n          const x = ix * segmentWidth - widthHalf;\n          vector[u] = x * udir;\n          vector[v] = y * vdir;\n          vector[w] = depthHalf;\n          vertices.push(vector.x, vector.y, vector.z);\n          vector[u] = 0;\n          vector[v] = 0;\n          vector[w] = depth2 > 0 ? 1 : -1;\n          normals.push(vector.x, vector.y, vector.z);\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY);\n          vertexCounter += 1;\n        }\n      }\n      for (let iy = 0; iy < gridY; iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a = numberOfVertices + ix + gridX1 * iy;\n          const b = numberOfVertices + ix + gridX1 * (iy + 1);\n          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n          const d = numberOfVertices + (ix + 1) + gridX1 * iy;\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n          groupCount += 6;\n        }\n      }\n      scope.addGroup(groupStart, groupCount, materialIndex);\n      groupStart += groupCount;\n      numberOfVertices += vertexCounter;\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n  }\n}\nfunction cloneUniforms(src) {\n  const dst = {};\n  for (const u in src) {\n    dst[u] = {};\n    for (const p in src[u]) {\n      const property = src[u][p];\n      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n        if (property.isRenderTargetTexture) {\n          console.warn(\"UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().\");\n          dst[u][p] = null;\n        } else {\n          dst[u][p] = property.clone();\n        }\n      } else if (Array.isArray(property)) {\n        dst[u][p] = property.slice();\n      } else {\n        dst[u][p] = property;\n      }\n    }\n  }\n  return dst;\n}\nfunction mergeUniforms(uniforms2) {\n  const merged = {};\n  for (let u = 0; u < uniforms2.length; u++) {\n    const tmp = cloneUniforms(uniforms2[u]);\n    for (const p in tmp) {\n      merged[p] = tmp[p];\n    }\n  }\n  return merged;\n}\nfunction cloneUniformsGroups(src) {\n  const dst = [];\n  for (let u = 0; u < src.length; u++) {\n    dst.push(src[u].clone());\n  }\n  return dst;\n}\nfunction getUnlitUniformColorSpace(renderer) {\n  const currentRenderTarget = renderer.getRenderTarget();\n  if (currentRenderTarget === null) {\n    return renderer.outputColorSpace;\n  }\n  if (currentRenderTarget.isXRRenderTarget === true) {\n    return currentRenderTarget.texture.colorSpace;\n  }\n  return ColorManagement.workingColorSpace;\n}\nconst UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\nvar default_vertex = \"void main() {\\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\nvar default_fragment = \"void main() {\\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\nclass ShaderMaterial extends Material {\n  static get type() {\n    return \"ShaderMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    this.isShaderMaterial = true;\n    this.defines = {};\n    this.uniforms = {};\n    this.uniformsGroups = [];\n    this.vertexShader = default_vertex;\n    this.fragmentShader = default_fragment;\n    this.linewidth = 1;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.fog = false;\n    this.lights = false;\n    this.clipping = false;\n    this.forceSinglePass = true;\n    this.extensions = {\n      clipCullDistance: false,\n      // set to use vertex shader clipping\n      multiDraw: false\n      // set to use vertex shader multi_draw / enable gl_DrawID\n    };\n    this.defaultAttributeValues = {\n      \"color\": [1, 1, 1],\n      \"uv\": [0, 0],\n      \"uv1\": [0, 0]\n    };\n    this.index0AttributeName = void 0;\n    this.uniformsNeedUpdate = false;\n    this.glslVersion = null;\n    if (parameters !== void 0) {\n      this.setValues(parameters);\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.fragmentShader = source.fragmentShader;\n    this.vertexShader = source.vertexShader;\n    this.uniforms = cloneUniforms(source.uniforms);\n    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);\n    this.defines = Object.assign({}, source.defines);\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.fog = source.fog;\n    this.lights = source.lights;\n    this.clipping = source.clipping;\n    this.extensions = Object.assign({}, source.extensions);\n    this.glslVersion = source.glslVersion;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.glslVersion = this.glslVersion;\n    data.uniforms = {};\n    for (const name in this.uniforms) {\n      const uniform = this.uniforms[name];\n      const value = uniform.value;\n      if (value && value.isTexture) {\n        data.uniforms[name] = {\n          type: \"t\",\n          value: value.toJSON(meta).uuid\n        };\n      } else if (value && value.isColor) {\n        data.uniforms[name] = {\n          type: \"c\",\n          value: value.getHex()\n        };\n      } else if (value && value.isVector2) {\n        data.uniforms[name] = {\n          type: \"v2\",\n          value: value.toArray()\n        };\n      } else if (value && value.isVector3) {\n        data.uniforms[name] = {\n          type: \"v3\",\n          value: value.toArray()\n        };\n      } else if (value && value.isVector4) {\n        data.uniforms[name] = {\n          type: \"v4\",\n          value: value.toArray()\n        };\n      } else if (value && value.isMatrix3) {\n        data.uniforms[name] = {\n          type: \"m3\",\n          value: value.toArray()\n        };\n      } else if (value && value.isMatrix4) {\n        data.uniforms[name] = {\n          type: \"m4\",\n          value: value.toArray()\n        };\n      } else {\n        data.uniforms[name] = {\n          value\n        };\n      }\n    }\n    if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n    data.vertexShader = this.vertexShader;\n    data.fragmentShader = this.fragmentShader;\n    data.lights = this.lights;\n    data.clipping = this.clipping;\n    const extensions = {};\n    for (const key in this.extensions) {\n      if (this.extensions[key] === true) extensions[key] = true;\n    }\n    if (Object.keys(extensions).length > 0) data.extensions = extensions;\n    return data;\n  }\n}\nclass Camera extends Object3D {\n  constructor() {\n    super();\n    this.isCamera = true;\n    this.type = \"Camera\";\n    this.matrixWorldInverse = new Matrix4();\n    this.projectionMatrix = new Matrix4();\n    this.projectionMatrixInverse = new Matrix4();\n    this.coordinateSystem = WebGLCoordinateSystem;\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.matrixWorldInverse.copy(source.matrixWorldInverse);\n    this.projectionMatrix.copy(source.projectionMatrix);\n    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n    this.coordinateSystem = source.coordinateSystem;\n    return this;\n  }\n  getWorldDirection(target) {\n    return super.getWorldDirection(target).negate();\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n  updateWorldMatrix(updateParents, updateChildren) {\n    super.updateWorldMatrix(updateParents, updateChildren);\n    this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nconst _v3$1 = /* @__PURE__ */ new Vector3();\nconst _minTarget = /* @__PURE__ */ new Vector2();\nconst _maxTarget = /* @__PURE__ */ new Vector2();\nclass PerspectiveCamera extends Camera {\n  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {\n    super();\n    this.isPerspectiveCamera = true;\n    this.type = \"PerspectiveCamera\";\n    this.fov = fov2;\n    this.zoom = 1;\n    this.near = near;\n    this.far = far;\n    this.focus = 10;\n    this.aspect = aspect2;\n    this.view = null;\n    this.filmGauge = 35;\n    this.filmOffset = 0;\n    this.updateProjectionMatrix();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.fov = source.fov;\n    this.zoom = source.zoom;\n    this.near = source.near;\n    this.far = source.far;\n    this.focus = source.focus;\n    this.aspect = source.aspect;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n    this.filmGauge = source.filmGauge;\n    this.filmOffset = source.filmOffset;\n    return this;\n  }\n  /**\n   * Sets the FOV by focal length in respect to the current .filmGauge.\n   *\n   * The default film gauge is 35, so that the focal length can be specified for\n   * a 35mm (full frame) camera.\n   *\n   * Values for focal length and film gauge must have the same unit.\n   */\n  setFocalLength(focalLength) {\n    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);\n    this.updateProjectionMatrix();\n  }\n  /**\n   * Calculates the focal length from the current .fov and .filmGauge.\n   */\n  getFocalLength() {\n    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);\n    return 0.5 * this.getFilmHeight() / vExtentSlope;\n  }\n  getEffectiveFOV() {\n    return RAD2DEG * 2 * Math.atan(\n      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom\n    );\n  }\n  getFilmWidth() {\n    return this.filmGauge * Math.min(this.aspect, 1);\n  }\n  getFilmHeight() {\n    return this.filmGauge / Math.max(this.aspect, 1);\n  }\n  /**\n   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.\n   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.\n   */\n  getViewBounds(distance, minTarget, maxTarget) {\n    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);\n    minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);\n    _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);\n    maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);\n  }\n  /**\n   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.\n   * Copies the result into the target Vector2, where x is width and y is height.\n   */\n  getViewSize(distance, target) {\n    this.getViewBounds(distance, _minTarget, _maxTarget);\n    return target.subVectors(_maxTarget, _minTarget);\n  }\n  /**\n   * Sets an offset in a larger frustum. This is useful for multi-window or\n   * multi-monitor/multi-machine setups.\n   *\n   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n   * the monitors are in grid like this\n   *\n   *   +---+---+---+\n   *   | A | B | C |\n   *   +---+---+---+\n   *   | D | E | F |\n   *   +---+---+---+\n   *\n   * then for each monitor you would call it like this\n   *\n   *   const w = 1920;\n   *   const h = 1080;\n   *   const fullWidth = w * 3;\n   *   const fullHeight = h * 2;\n   *\n   *   --A--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n   *   --B--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n   *   --C--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n   *   --D--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n   *   --E--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n   *   --F--\n   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n   *\n   *   Note there is no reason monitors have to be the same size or in a grid.\n   */\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    this.aspect = fullWidth / fullHeight;\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  }\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n    this.updateProjectionMatrix();\n  }\n  updateProjectionMatrix() {\n    const near = this.near;\n    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;\n    let height = 2 * top;\n    let width = this.aspect * height;\n    let left = -0.5 * width;\n    const view = this.view;\n    if (this.view !== null && this.view.enabled) {\n      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;\n      left += view.offsetX * width / fullWidth;\n      top -= view.offsetY * height / fullHeight;\n      width *= view.width / fullWidth;\n      height *= view.height / fullHeight;\n    }\n    const skew = this.filmOffset;\n    if (skew !== 0) left += near * skew / this.getFilmWidth();\n    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.fov = this.fov;\n    data.object.zoom = this.zoom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n    data.object.focus = this.focus;\n    data.object.aspect = this.aspect;\n    if (this.view !== null) data.object.view = Object.assign({}, this.view);\n    data.object.filmGauge = this.filmGauge;\n    data.object.filmOffset = this.filmOffset;\n    return data;\n  }\n}\nconst fov = -90;\nconst aspect = 1;\nclass CubeCamera extends Object3D {\n  constructor(near, far, renderTarget) {\n    super();\n    this.type = \"CubeCamera\";\n    this.renderTarget = renderTarget;\n    this.coordinateSystem = null;\n    this.activeMipmapLevel = 0;\n    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPX.layers = this.layers;\n    this.add(cameraPX);\n    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNX.layers = this.layers;\n    this.add(cameraNX);\n    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPY.layers = this.layers;\n    this.add(cameraPY);\n    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNY.layers = this.layers;\n    this.add(cameraNY);\n    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPZ.layers = this.layers;\n    this.add(cameraPZ);\n    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNZ.layers = this.layers;\n    this.add(cameraNZ);\n  }\n  updateCoordinateSystem() {\n    const coordinateSystem = this.coordinateSystem;\n    const cameras = this.children.concat();\n    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;\n    for (const camera of cameras) this.remove(camera);\n    if (coordinateSystem === WebGLCoordinateSystem) {\n      cameraPX.up.set(0, 1, 0);\n      cameraPX.lookAt(1, 0, 0);\n      cameraNX.up.set(0, 1, 0);\n      cameraNX.lookAt(-1, 0, 0);\n      cameraPY.up.set(0, 0, -1);\n      cameraPY.lookAt(0, 1, 0);\n      cameraNY.up.set(0, 0, 1);\n      cameraNY.lookAt(0, -1, 0);\n      cameraPZ.up.set(0, 1, 0);\n      cameraPZ.lookAt(0, 0, 1);\n      cameraNZ.up.set(0, 1, 0);\n      cameraNZ.lookAt(0, 0, -1);\n    } else if (coordinateSystem === WebGPUCoordinateSystem) {\n      cameraPX.up.set(0, -1, 0);\n      cameraPX.lookAt(-1, 0, 0);\n      cameraNX.up.set(0, -1, 0);\n      cameraNX.lookAt(1, 0, 0);\n      cameraPY.up.set(0, 0, 1);\n      cameraPY.lookAt(0, 1, 0);\n      cameraNY.up.set(0, 0, -1);\n      cameraNY.lookAt(0, -1, 0);\n      cameraPZ.up.set(0, -1, 0);\n      cameraPZ.lookAt(0, 0, 1);\n      cameraNZ.up.set(0, -1, 0);\n      cameraNZ.lookAt(0, 0, -1);\n    } else {\n      throw new Error(\"THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: \" + coordinateSystem);\n    }\n    for (const camera of cameras) {\n      this.add(camera);\n      camera.updateMatrixWorld();\n    }\n  }\n  update(renderer, scene) {\n    if (this.parent === null) this.updateMatrixWorld();\n    const { renderTarget, activeMipmapLevel } = this;\n    if (this.coordinateSystem !== renderer.coordinateSystem) {\n      this.coordinateSystem = renderer.coordinateSystem;\n      this.updateCoordinateSystem();\n    }\n    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;\n    const currentRenderTarget = renderer.getRenderTarget();\n    const currentActiveCubeFace = renderer.getActiveCubeFace();\n    const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();\n    const currentXrEnabled = renderer.xr.enabled;\n    renderer.xr.enabled = false;\n    const generateMipmaps = renderTarget.texture.generateMipmaps;\n    renderTarget.texture.generateMipmaps = false;\n    renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);\n    renderer.render(scene, cameraPX);\n    renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);\n    renderer.render(scene, cameraNX);\n    renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);\n    renderer.render(scene, cameraPY);\n    renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);\n    renderer.render(scene, cameraNY);\n    renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);\n    renderer.render(scene, cameraPZ);\n    renderTarget.texture.generateMipmaps = generateMipmaps;\n    renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);\n    renderer.render(scene, cameraNZ);\n    renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);\n    renderer.xr.enabled = currentXrEnabled;\n    renderTarget.texture.needsPMREMUpdate = true;\n  }\n}\nclass CubeTexture extends Texture {\n  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {\n    images = images !== void 0 ? images : [];\n    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;\n    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);\n    this.isCubeTexture = true;\n    this.flipY = false;\n  }\n  get images() {\n    return this.image;\n  }\n  set images(value) {\n    this.image = value;\n  }\n}\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n  constructor(size = 1, options = {}) {\n    super(size, size, options);\n    this.isWebGLCubeRenderTarget = true;\n    const image = { width: size, height: size, depth: 1 };\n    const images = [image, image, image, image, image, image];\n    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);\n    this.texture.isRenderTargetTexture = true;\n    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;\n    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;\n  }\n  fromEquirectangularTexture(renderer, texture) {\n    this.texture.type = texture.type;\n    this.texture.colorSpace = texture.colorSpace;\n    this.texture.generateMipmaps = texture.generateMipmaps;\n    this.texture.minFilter = texture.minFilter;\n    this.texture.magFilter = texture.magFilter;\n    const shader2 = {\n      uniforms: {\n        tEquirect: { value: null }\n      },\n      vertexShader: (\n        /* glsl */\n        `\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`\n      ),\n      fragmentShader: (\n        /* glsl */\n        `\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n      )\n    };\n    const geometry = new BoxGeometry(5, 5, 5);\n    const material = new ShaderMaterial({\n      name: \"CubemapFromEquirect\",\n      uniforms: cloneUniforms(shader2.uniforms),\n      vertexShader: shader2.vertexShader,\n      fragmentShader: shader2.fragmentShader,\n      side: BackSide,\n      blending: NoBlending\n    });\n    material.uniforms.tEquirect.value = texture;\n    const mesh = new Mesh(geometry, material);\n    const currentMinFilter = texture.minFilter;\n    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;\n    const camera = new CubeCamera(1, 10, this);\n    camera.update(renderer, mesh);\n    texture.minFilter = currentMinFilter;\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    return this;\n  }\n  clear(renderer, color, depth, stencil) {\n    const currentRenderTarget = renderer.getRenderTarget();\n    for (let i = 0; i < 6; i++) {\n      renderer.setRenderTarget(this, i);\n      renderer.clear(color, depth, stencil);\n    }\n    renderer.setRenderTarget(currentRenderTarget);\n  }\n}\nconst _vector1 = /* @__PURE__ */ new Vector3();\nconst _vector2 = /* @__PURE__ */ new Vector3();\nconst _normalMatrix = /* @__PURE__ */ new Matrix3();\nclass Plane {\n  constructor(normal = new Vector3(1, 0, 0), constant = 0) {\n    this.isPlane = true;\n    this.normal = normal;\n    this.constant = constant;\n  }\n  set(normal, constant) {\n    this.normal.copy(normal);\n    this.constant = constant;\n    return this;\n  }\n  setComponents(x, y, z, w) {\n    this.normal.set(x, y, z);\n    this.constant = w;\n    return this;\n  }\n  setFromNormalAndCoplanarPoint(normal, point) {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal);\n    return this;\n  }\n  setFromCoplanarPoints(a, b, c) {\n    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();\n    this.setFromNormalAndCoplanarPoint(normal, a);\n    return this;\n  }\n  copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n    return this;\n  }\n  normalize() {\n    const inverseNormalLength = 1 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n    return this;\n  }\n  negate() {\n    this.constant *= -1;\n    this.normal.negate();\n    return this;\n  }\n  distanceToPoint(point) {\n    return this.normal.dot(point) + this.constant;\n  }\n  distanceToSphere(sphere) {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n  projectPoint(point, target) {\n    return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));\n  }\n  intersectLine(line, target) {\n    const direction = line.delta(_vector1);\n    const denominator = this.normal.dot(direction);\n    if (denominator === 0) {\n      if (this.distanceToPoint(line.start) === 0) {\n        return target.copy(line.start);\n      }\n      return null;\n    }\n    const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;\n    if (t2 < 0 || t2 > 1) {\n      return null;\n    }\n    return target.copy(line.start).addScaledVector(direction, t2);\n  }\n  intersectsLine(line) {\n    const startSign = this.distanceToPoint(line.start);\n    const endSign = this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n  }\n  intersectsBox(box) {\n    return box.intersectsPlane(this);\n  }\n  intersectsSphere(sphere) {\n    return sphere.intersectsPlane(this);\n  }\n  coplanarPoint(target) {\n    return target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n  applyMatrix4(matrix, optionalNormalMatrix) {\n    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n    const normal = this.normal.applyMatrix3(normalMatrix).normalize();\n    this.constant = -referencePoint.dot(normal);\n    return this;\n  }\n  translate(offset) {\n    this.constant -= offset.dot(this.normal);\n    return this;\n  }\n  equals(plane) {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nconst _sphere$5 = /* @__PURE__ */ new Sphere();\nconst _vector$7 = /* @__PURE__ */ new Vector3();\nclass Frustum {\n  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {\n    this.planes = [p0, p1, p2, p3, p4, p5];\n  }\n  set(p0, p1, p2, p3, p4, p5) {\n    const planes = this.planes;\n    planes[0].copy(p0);\n    planes[1].copy(p1);\n    planes[2].copy(p2);\n    planes[3].copy(p3);\n    planes[4].copy(p4);\n    planes[5].copy(p5);\n    return this;\n  }\n  copy(frustum) {\n    const planes = this.planes;\n    for (let i = 0; i < 6; i++) {\n      planes[i].copy(frustum.planes[i]);\n    }\n    return this;\n  }\n  setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem) {\n    const planes = this.planes;\n    const me = m.elements;\n    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\n    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\n    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\n    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\n    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n    if (coordinateSystem === WebGLCoordinateSystem) {\n      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n    } else if (coordinateSystem === WebGPUCoordinateSystem) {\n      planes[5].setComponents(me2, me6, me10, me14).normalize();\n    } else {\n      throw new Error(\"THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: \" + coordinateSystem);\n    }\n    return this;\n  }\n  intersectsObject(object) {\n    if (object.boundingSphere !== void 0) {\n      if (object.boundingSphere === null) object.computeBoundingSphere();\n      _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);\n    } else {\n      const geometry = object.geometry;\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n      _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n    }\n    return this.intersectsSphere(_sphere$5);\n  }\n  intersectsSprite(sprite) {\n    _sphere$5.center.set(0, 0, 0);\n    _sphere$5.radius = 0.7071067811865476;\n    _sphere$5.applyMatrix4(sprite.matrixWorld);\n    return this.intersectsSphere(_sphere$5);\n  }\n  intersectsSphere(sphere) {\n    const planes = this.planes;\n    const center = sphere.center;\n    const negRadius = -sphere.radius;\n    for (let i = 0; i < 6; i++) {\n      const distance = planes[i].distanceToPoint(center);\n      if (distance < negRadius) {\n        return false;\n      }\n    }\n    return true;\n  }\n  intersectsBox(box) {\n    const planes = this.planes;\n    for (let i = 0; i < 6; i++) {\n      const plane = planes[i];\n      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n      if (plane.distanceToPoint(_vector$7) < 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  containsPoint(point) {\n    const planes = this.planes;\n    for (let i = 0; i < 6; i++) {\n      if (planes[i].distanceToPoint(point) < 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nfunction WebGLAnimation() {\n  let context = null;\n  let isAnimating = false;\n  let animationLoop = null;\n  let requestId = null;\n  function onAnimationFrame(time, frame) {\n    animationLoop(time, frame);\n    requestId = context.requestAnimationFrame(onAnimationFrame);\n  }\n  return {\n    start: function() {\n      if (isAnimating === true) return;\n      if (animationLoop === null) return;\n      requestId = context.requestAnimationFrame(onAnimationFrame);\n      isAnimating = true;\n    },\n    stop: function() {\n      context.cancelAnimationFrame(requestId);\n      isAnimating = false;\n    },\n    setAnimationLoop: function(callback) {\n      animationLoop = callback;\n    },\n    setContext: function(value) {\n      context = value;\n    }\n  };\n}\nfunction WebGLAttributes(gl) {\n  const buffers = /* @__PURE__ */ new WeakMap();\n  function createBuffer(attribute, bufferType) {\n    const array = attribute.array;\n    const usage = attribute.usage;\n    const size = array.byteLength;\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(bufferType, buffer);\n    gl.bufferData(bufferType, array, usage);\n    attribute.onUploadCallback();\n    let type;\n    if (array instanceof Float32Array) {\n      type = gl.FLOAT;\n    } else if (array instanceof Uint16Array) {\n      if (attribute.isFloat16BufferAttribute) {\n        type = gl.HALF_FLOAT;\n      } else {\n        type = gl.UNSIGNED_SHORT;\n      }\n    } else if (array instanceof Int16Array) {\n      type = gl.SHORT;\n    } else if (array instanceof Uint32Array) {\n      type = gl.UNSIGNED_INT;\n    } else if (array instanceof Int32Array) {\n      type = gl.INT;\n    } else if (array instanceof Int8Array) {\n      type = gl.BYTE;\n    } else if (array instanceof Uint8Array) {\n      type = gl.UNSIGNED_BYTE;\n    } else if (array instanceof Uint8ClampedArray) {\n      type = gl.UNSIGNED_BYTE;\n    } else {\n      throw new Error(\"THREE.WebGLAttributes: Unsupported buffer data format: \" + array);\n    }\n    return {\n      buffer,\n      type,\n      bytesPerElement: array.BYTES_PER_ELEMENT,\n      version: attribute.version,\n      size\n    };\n  }\n  function updateBuffer(buffer, attribute, bufferType) {\n    const array = attribute.array;\n    const updateRanges = attribute.updateRanges;\n    gl.bindBuffer(bufferType, buffer);\n    if (updateRanges.length === 0) {\n      gl.bufferSubData(bufferType, 0, array);\n    } else {\n      updateRanges.sort((a, b) => a.start - b.start);\n      let mergeIndex = 0;\n      for (let i = 1; i < updateRanges.length; i++) {\n        const previousRange = updateRanges[mergeIndex];\n        const range = updateRanges[i];\n        if (range.start <= previousRange.start + previousRange.count + 1) {\n          previousRange.count = Math.max(\n            previousRange.count,\n            range.start + range.count - previousRange.start\n          );\n        } else {\n          ++mergeIndex;\n          updateRanges[mergeIndex] = range;\n        }\n      }\n      updateRanges.length = mergeIndex + 1;\n      for (let i = 0, l = updateRanges.length; i < l; i++) {\n        const range = updateRanges[i];\n        gl.bufferSubData(\n          bufferType,\n          range.start * array.BYTES_PER_ELEMENT,\n          array,\n          range.start,\n          range.count\n        );\n      }\n      attribute.clearUpdateRanges();\n    }\n    attribute.onUploadCallback();\n  }\n  function get(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    return buffers.get(attribute);\n  }\n  function remove(attribute) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    const data = buffers.get(attribute);\n    if (data) {\n      gl.deleteBuffer(data.buffer);\n      buffers.delete(attribute);\n    }\n  }\n  function update(attribute, bufferType) {\n    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;\n    if (attribute.isGLBufferAttribute) {\n      const cached = buffers.get(attribute);\n      if (!cached || cached.version < attribute.version) {\n        buffers.set(attribute, {\n          buffer: attribute.buffer,\n          type: attribute.type,\n          bytesPerElement: attribute.elementSize,\n          version: attribute.version\n        });\n      }\n      return;\n    }\n    const data = buffers.get(attribute);\n    if (data === void 0) {\n      buffers.set(attribute, createBuffer(attribute, bufferType));\n    } else if (data.version < attribute.version) {\n      if (data.size !== attribute.array.byteLength) {\n        throw new Error(\"THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.\");\n      }\n      updateBuffer(data.buffer, attribute, bufferType);\n      data.version = attribute.version;\n    }\n  }\n  return {\n    get,\n    remove,\n    update\n  };\n}\nclass PlaneGeometry extends BufferGeometry {\n  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n    super();\n    this.type = \"PlaneGeometry\";\n    this.parameters = {\n      width,\n      height,\n      widthSegments,\n      heightSegments\n    };\n    const width_half = width / 2;\n    const height_half = height / 2;\n    const gridX = Math.floor(widthSegments);\n    const gridY = Math.floor(heightSegments);\n    const gridX1 = gridX + 1;\n    const gridY1 = gridY + 1;\n    const segment_width = width / gridX;\n    const segment_height = height / gridY;\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    for (let iy = 0; iy < gridY1; iy++) {\n      const y = iy * segment_height - height_half;\n      for (let ix = 0; ix < gridX1; ix++) {\n        const x = ix * segment_width - width_half;\n        vertices.push(x, -y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(ix / gridX);\n        uvs.push(1 - iy / gridY);\n      }\n    }\n    for (let iy = 0; iy < gridY; iy++) {\n      for (let ix = 0; ix < gridX; ix++) {\n        const a = ix + gridX1 * iy;\n        const b = ix + gridX1 * (iy + 1);\n        const c = ix + 1 + gridX1 * (iy + 1);\n        const d = ix + 1 + gridX1 * iy;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);\n  }\n}\nvar alphahash_fragment = \"#ifdef USE_ALPHAHASH\\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\\n#endif\";\nvar alphahash_pars_fragment = \"#ifdef USE_ALPHAHASH\\n\tconst float ALPHA_HASH_SCALE = 0.05;\\n\tfloat hash2D( vec2 value ) {\\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\\n\t}\\n\tfloat hash3D( vec3 value ) {\\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\\n\t}\\n\tfloat getAlphaHashThreshold( vec3 position ) {\\n\t\tfloat maxDeriv = max(\\n\t\t\tlength( dFdx( position.xyz ) ),\\n\t\t\tlength( dFdy( position.xyz ) )\\n\t\t);\\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\\n\t\tvec2 pixScales = vec2(\\n\t\t\texp2( floor( log2( pixScale ) ) ),\\n\t\t\texp2( ceil( log2( pixScale ) ) )\\n\t\t);\\n\t\tvec2 alpha = vec2(\\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\\n\t\t);\\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\\n\t\tvec3 cases = vec3(\\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\\n\t\t);\\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\\n\t\t\t: cases.z;\\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\\n\t}\\n#endif\";\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\\n#endif\";\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\";\nvar alphatest_fragment = \"#ifdef USE_ALPHATEST\\n\t#ifdef ALPHA_TO_COVERAGE\\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\\n\tif ( diffuseColor.a == 0.0 ) discard;\\n\t#else\\n\tif ( diffuseColor.a < alphaTest ) discard;\\n\t#endif\\n#endif\";\nvar alphatest_pars_fragment = \"#ifdef USE_ALPHATEST\\n\tuniform float alphaTest;\\n#endif\";\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_CLEARCOAT ) \\n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\\n\t#endif\\n\t#if defined( USE_SHEEN ) \\n\t\tsheenSpecularIndirect *= ambientOcclusion;\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\\n\t#endif\\n#endif\";\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\nvar batching_pars_vertex = \"#ifdef USE_BATCHING\\n\t#if ! defined( GL_ANGLE_multi_draw )\\n\t#define gl_DrawID _gl_DrawID\\n\tuniform int _gl_DrawID;\\n\t#endif\\n\tuniform highp sampler2D batchingTexture;\\n\tuniform highp usampler2D batchingIdTexture;\\n\tmat4 getBatchingMatrix( const in float i ) {\\n\t\tint size = textureSize( batchingTexture, 0 ).x;\\n\t\tint j = int( i ) * 4;\\n\t\tint x = j % size;\\n\t\tint y = j / size;\\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\\n\t\treturn mat4( v1, v2, v3, v4 );\\n\t}\\n\tfloat getIndirectIndex( const in int i ) {\\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\\n\t\tint x = i % size;\\n\t\tint y = i / size;\\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\\n\t}\\n#endif\\n#ifdef USE_BATCHING_COLOR\\n\tuniform sampler2D batchingColorTexture;\\n\tvec3 getBatchingColor( const in float i ) {\\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\\n\t\tint j = int( i );\\n\t\tint x = j % size;\\n\t\tint y = j / size;\\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\\n\t}\\n#endif\";\nvar batching_vertex = \"#ifdef USE_BATCHING\\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\\n#endif\";\nvar begin_vertex = \"vec3 transformed = vec3( position );\\n#ifdef USE_ALPHAHASH\\n\tvPosition = vec3( position );\\n#endif\";\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\nvar bsdfs = \"float G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( lightDir + viewDir );\\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n} // validated\";\nvar iridescence_fragment = \"#ifdef USE_IRIDESCENCE\\n\tconst mat3 XYZ_TO_REC709 = mat3(\\n\t\t 3.2404542, -0.9692660,  0.0556434,\\n\t\t-1.5371385,  1.8760108, -0.2040259,\\n\t\t-0.4985314,  0.0415560,  1.0572252\\n\t);\\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\\n\t}\\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\\n\t}\\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\\n\t}\\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\\n\t\txyz /= 1.0685e-7;\\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\\n\t\treturn rgb;\\n\t}\\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\\n\t\tvec3 I;\\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\\n\t\tif ( cosTheta2Sq < 0.0 ) {\\n\t\t\treturn vec3( 1.0 );\\n\t\t}\\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\\n\t\tfloat T121 = 1.0 - R12;\\n\t\tfloat phi12 = 0.0;\\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\\n\t\tfloat phi21 = PI - phi12;\\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\\n\t\tvec3 phi23 = vec3( 0.0 );\\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\\n\t\tvec3 phi = vec3( phi21 ) + phi23;\\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\\n\t\tvec3 r123 = sqrt( R123 );\\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\\n\t\tvec3 C0 = R12 + Rs;\\n\t\tI = C0;\\n\t\tvec3 Cm = Rs - T121;\\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\\n\t\t\tCm *= r123;\\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\\n\t\t\tI += Cm * Sm;\\n\t\t}\\n\t\treturn max( I, vec3( 0.0 ) );\\n\t}\\n#endif\";\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\";\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\tvec4 plane;\\n\t#ifdef ALPHA_TO_COVERAGE\\n\t\tfloat distanceToPlane, distanceGradient;\\n\t\tfloat clipOpacity = 1.0;\\n\t\t#pragma unroll_loop_start\\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\t\t\tplane = clippingPlanes[ i ];\\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\\n\t\t\tif ( clipOpacity == 0.0 ) discard;\\n\t\t}\\n\t\t#pragma unroll_loop_end\\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\t\t\tfloat unionClipOpacity = 1.0;\\n\t\t\t#pragma unroll_loop_start\\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\t\t\t\tplane = clippingPlanes[ i ];\\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\\n\t\t\t}\\n\t\t\t#pragma unroll_loop_end\\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\\n\t\t#endif\\n\t\tdiffuseColor.a *= clipOpacity;\\n\t\tif ( diffuseColor.a == 0.0 ) discard;\\n\t#else\\n\t\t#pragma unroll_loop_start\\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\t\t\tplane = clippingPlanes[ i ];\\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\t\t}\\n\t\t#pragma unroll_loop_end\\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\t\t\tbool clipped = true;\\n\t\t\t#pragma unroll_loop_start\\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\t\t\t\tplane = clippingPlanes[ i ];\\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\t\t\t}\\n\t\t\t#pragma unroll_loop_end\\n\t\t\tif ( clipped ) discard;\\n\t\t#endif\\n\t#endif\\n#endif\";\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\tvarying vec3 vClipPosition;\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\tvarying vec3 vClipPosition;\\n#endif\";\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\tvClipPosition = - mvPosition.xyz;\\n#endif\";\nvar color_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\nvar color_pars_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\tvarying vec3 vColor;\\n#endif\";\nvar color_pars_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\\n\tvarying vec3 vColor;\\n#endif\";\nvar color_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\\n\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\tvColor.xyz *= instanceColor.xyz;\\n#endif\\n#ifdef USE_BATCHING_COLOR\\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\\n\tvColor.xyz *= batchingColor.xyz;\\n#endif\";\nvar common = \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nvec3 pow2( const in vec3 x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract( sin( sn ) * c );\\n}\\n#ifdef HIGH_PRECISION\\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\tfloat precisionSafeLength( vec3 v ) {\\n\t\tfloat maxComponent = max3( abs( v ) );\\n\t\treturn length( v / maxComponent ) * maxComponent;\\n\t}\\n#endif\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\n#ifdef USE_ALPHAHASH\\n\tvarying vec3 vPosition;\\n#endif\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\tmat3 tmp;\\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\treturn tmp;\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\treturn vec2( u, v );\\n}\\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n}\\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n} // validated\";\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\t#define cubeUV_minMipLevel 4.0\\n\t#define cubeUV_minTileSize 16.0\\n\tfloat getFace( vec3 direction ) {\\n\t\tvec3 absDirection = abs( direction );\\n\t\tfloat face = - 1.0;\\n\t\tif ( absDirection.x > absDirection.z ) {\\n\t\t\tif ( absDirection.x > absDirection.y )\\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\t\t\telse\\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\t\t} else {\\n\t\t\tif ( absDirection.z > absDirection.y )\\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\t\t\telse\\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\t\t}\\n\t\treturn face;\\n\t}\\n\tvec2 getUV( vec3 direction, float face ) {\\n\t\tvec2 uv;\\n\t\tif ( face == 0.0 ) {\\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\t\t} else if ( face == 1.0 ) {\\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\t\t} else if ( face == 2.0 ) {\\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\t\t} else if ( face == 3.0 ) {\\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\t\t} else if ( face == 4.0 ) {\\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\t\t} else {\\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\t\t}\\n\t\treturn 0.5 * ( uv + 1.0 );\\n\t}\\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\t\tfloat face = getFace( direction );\\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\t\tfloat faceSize = exp2( mipInt );\\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\\n\t\tif ( face > 2.0 ) {\\n\t\t\tuv.y += faceSize;\\n\t\t\tface -= 3.0;\\n\t\t}\\n\t\tuv.x += face * faceSize;\\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\\n\t\t#ifdef texture2DGradEXT\\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\\n\t\t#else\\n\t\t\treturn texture2D( envMap, uv ).rgb;\\n\t\t#endif\\n\t}\\n\t#define cubeUV_r0 1.0\\n\t#define cubeUV_m0 - 2.0\\n\t#define cubeUV_r1 0.8\\n\t#define cubeUV_m1 - 1.0\\n\t#define cubeUV_r4 0.4\\n\t#define cubeUV_m4 2.0\\n\t#define cubeUV_r5 0.305\\n\t#define cubeUV_m5 3.0\\n\t#define cubeUV_r6 0.21\\n\t#define cubeUV_m6 4.0\\n\tfloat roughnessToMip( float roughness ) {\\n\t\tfloat mip = 0.0;\\n\t\tif ( roughness >= cubeUV_r1 ) {\\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\\n\t\t} else if ( roughness >= cubeUV_r4 ) {\\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\\n\t\t} else if ( roughness >= cubeUV_r5 ) {\\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\\n\t\t} else if ( roughness >= cubeUV_r6 ) {\\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\\n\t\t} else {\\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\\n\t\treturn mip;\\n\t}\\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\\n\t\tfloat mipF = fract( mip );\\n\t\tfloat mipInt = floor( mip );\\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\t\tif ( mipF == 0.0 ) {\\n\t\t\treturn vec4( color0, 1.0 );\\n\t\t} else {\\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\t\t}\\n\t}\\n#endif\";\nvar defaultnormal_vertex = \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_TANGENT\\n\tvec3 transformedTangent = objectTangent;\\n#endif\\n#ifdef USE_BATCHING\\n\tmat3 bm = mat3( batchingMatrix );\\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\\n\ttransformedNormal = bm * transformedNormal;\\n\t#ifdef USE_TANGENT\\n\t\ttransformedTangent = bm * transformedTangent;\\n\t#endif\\n#endif\\n#ifdef USE_INSTANCING\\n\tmat3 im = mat3( instanceMatrix );\\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\\n\ttransformedNormal = im * transformedNormal;\\n\t#ifdef USE_TANGENT\\n\t\ttransformedTangent = im * transformedTangent;\\n\t#endif\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\\n\t#ifdef FLIP_SIDED\\n\t\ttransformedTangent = - transformedTangent;\\n\t#endif\\n#endif\";\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\";\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\\n#endif\";\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\\n\t#endif\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\";\nvar colorspace_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\nvar colorspace_pars_fragment = \"vec4 LinearTransferOETF( in vec4 value ) {\\n\treturn value;\\n}\\nvec4 sRGBTransferEOTF( in vec4 value ) {\\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 sRGBTransferOETF( in vec4 value ) {\\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\";\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\t#ifdef ENV_WORLDPOS\\n\t\tvec3 cameraToFrag;\\n\t\tif ( isOrthographic ) {\\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\t\t} else {\\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\t\t}\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#else\\n\t\tvec4 envColor = vec4( 0.0 );\\n\t#endif\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\";\nvar envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\tuniform float envMapIntensity;\\n\tuniform float flipEnvMap;\\n\tuniform mat3 envMapRotation;\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\t\\n#endif\";\nvar envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\tuniform float reflectivity;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\\n\t\t#define ENV_WORLDPOS\\n\t#endif\\n\t#ifdef ENV_WORLDPOS\\n\t\tvarying vec3 vWorldPosition;\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\";\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\\n\t\t#define ENV_WORLDPOS\\n\t#endif\\n\t#ifdef ENV_WORLDPOS\\n\t\t\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\";\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\t#ifdef ENV_WORLDPOS\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex;\\n\t\tif ( isOrthographic ) {\\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\t\t} else {\\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\t}\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\";\nvar fog_vertex = \"#ifdef USE_FOG\\n\tvFogDepth = - mvPosition.z;\\n#endif\";\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\tvarying float vFogDepth;\\n#endif\";\nvar fog_fragment = \"#ifdef USE_FOG\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\tvarying float vFogDepth;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\nvar gradientmap_pars_fragment = \"#ifdef USE_GRADIENTMAP\\n\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\tfloat dotNL = dot( normal, lightDirection );\\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\t#ifdef USE_GRADIENTMAP\\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\\n\t#else\\n\t\tvec2 fw = fwidth( coord ) * 0.5;\\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\\n\t#endif\\n}\";\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\nvar lights_lambert_fragment = \"LambertMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularStrength = specularStrength;\";\nvar lights_lambert_pars_fragment = \"varying vec3 vViewPosition;\\nstruct LambertMaterial {\\n\tvec3 diffuseColor;\\n\tfloat specularStrength;\\n};\\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\";\nvar lights_pars_begin = \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\n#if defined( USE_LIGHT_PROBES )\\n\tuniform vec3 lightProbe[ 9 ];\\n#endif\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\treturn irradiance;\\n}\\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\tif ( cutoffDistance > 0.0 ) {\\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t}\\n\treturn distanceFalloff;\\n}\\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\\n\t\tlight.color = directionalLight.color;\\n\t\tlight.direction = directionalLight.direction;\\n\t\tlight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\\n\t\tvec3 lVector = pointLight.position - geometryPosition;\\n\t\tlight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tlight.color = pointLight.color;\\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\\n\t\tvec3 lVector = spotLight.position - geometryPosition;\\n\t\tlight.direction = normalize( lVector );\\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\tif ( spotAttenuation > 0.0 ) {\\n\t\t\tfloat lightDistance = length( lVector );\\n\t\t\tlight.color = spotLight.color * spotAttenuation;\\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\t\t} else {\\n\t\t\tlight.color = vec3( 0.0 );\\n\t\t\tlight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\tstruct RectAreaLight {\\n\t\tvec3 color;\\n\t\tvec3 position;\\n\t\tvec3 halfWidth;\\n\t\tvec3 halfHeight;\\n\t};\\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\treturn irradiance;\\n\t}\\n#endif\";\nvar envmap_physical_pars_fragment = \"#ifdef USE_ENVMAP\\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t\t#else\\n\t\t\treturn vec3( 0.0 );\\n\t\t#endif\\n\t}\\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\\n\t\t\treturn envMapColor.rgb * envMapIntensity;\\n\t\t#else\\n\t\t\treturn vec3( 0.0 );\\n\t\t#endif\\n\t}\\n\t#ifdef USE_ANISOTROPY\\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\\n\t\t\t#else\\n\t\t\t\treturn vec3( 0.0 );\\n\t\t\t#endif\\n\t\t}\\n\t#endif\\n#endif\";\nvar lights_toon_fragment = \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\nvar lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\nstruct ToonMaterial {\\n\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\";\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\nstruct BlinnPhongMaterial {\\n\tvec3 diffuseColor;\\n\tvec3 specularColor;\\n\tfloat specularShininess;\\n\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\";\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\\nmaterial.roughness = min( material.roughness, 1.0 );\\n#ifdef IOR\\n\tmaterial.ior = ior;\\n\t#ifdef USE_SPECULAR\\n\t\tfloat specularIntensityFactor = specularIntensity;\\n\t\tvec3 specularColorFactor = specularColor;\\n\t\t#ifdef USE_SPECULAR_COLORMAP\\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\\n\t\t#endif\\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\\n\t\t#endif\\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\\n\t#else\\n\t\tfloat specularIntensityFactor = 1.0;\\n\t\tvec3 specularColorFactor = vec3( 1.0 );\\n\t\tmaterial.specularF90 = 1.0;\\n\t#endif\\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n\tmaterial.specularF90 = 1.0;\\n#endif\\n#ifdef USE_CLEARCOAT\\n\tmaterial.clearcoat = clearcoat;\\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\tmaterial.clearcoatF0 = vec3( 0.04 );\\n\tmaterial.clearcoatF90 = 1.0;\\n\t#ifdef USE_CLEARCOATMAP\\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\\n\t#endif\\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\\n\t#endif\\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\tmaterial.clearcoatRoughness += geometryRoughness;\\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_DISPERSION\\n\tmaterial.dispersion = dispersion;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\tmaterial.iridescence = iridescence;\\n\tmaterial.iridescenceIOR = iridescenceIOR;\\n\t#ifdef USE_IRIDESCENCEMAP\\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\\n\t#endif\\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\\n\t#else\\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\\n\t#endif\\n#endif\\n#ifdef USE_SHEEN\\n\tmaterial.sheenColor = sheenColor;\\n\t#ifdef USE_SHEEN_COLORMAP\\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\\n\t#endif\\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\\n\t#endif\\n#endif\\n#ifdef USE_ANISOTROPY\\n\t#ifdef USE_ANISOTROPYMAP\\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\\n\t#else\\n\t\tvec2 anisotropyV = anisotropyVector;\\n\t#endif\\n\tmaterial.anisotropy = length( anisotropyV );\\n\tif( material.anisotropy == 0.0 ) {\\n\t\tanisotropyV = vec2( 1.0, 0.0 );\\n\t} else {\\n\t\tanisotropyV /= material.anisotropy;\\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\\n\t}\\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\\n#endif\";\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\tvec3 diffuseColor;\\n\tfloat roughness;\\n\tvec3 specularColor;\\n\tfloat specularF90;\\n\tfloat dispersion;\\n\t#ifdef USE_CLEARCOAT\\n\t\tfloat clearcoat;\\n\t\tfloat clearcoatRoughness;\\n\t\tvec3 clearcoatF0;\\n\t\tfloat clearcoatF90;\\n\t#endif\\n\t#ifdef USE_IRIDESCENCE\\n\t\tfloat iridescence;\\n\t\tfloat iridescenceIOR;\\n\t\tfloat iridescenceThickness;\\n\t\tvec3 iridescenceFresnel;\\n\t\tvec3 iridescenceF0;\\n\t#endif\\n\t#ifdef USE_SHEEN\\n\t\tvec3 sheenColor;\\n\t\tfloat sheenRoughness;\\n\t#endif\\n\t#ifdef IOR\\n\t\tfloat ior;\\n\t#endif\\n\t#ifdef USE_TRANSMISSION\\n\t\tfloat transmission;\\n\t\tfloat transmissionAlpha;\\n\t\tfloat thickness;\\n\t\tfloat attenuationDistance;\\n\t\tvec3 attenuationColor;\\n\t#endif\\n\t#ifdef USE_ANISOTROPY\\n\t\tfloat anisotropy;\\n\t\tfloat alphaT;\\n\t\tvec3 anisotropyT;\\n\t\tvec3 anisotropyB;\\n\t#endif\\n};\\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\\nvec3 sheenSpecularDirect = vec3( 0.0 );\\nvec3 sheenSpecularIndirect = vec3(0.0 );\\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\\n    float x2 = x * x;\\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\\n}\\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\n#ifdef USE_ANISOTROPY\\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\\n\t\tfloat v = 0.5 / ( gv + gl );\\n\t\treturn saturate(v);\\n\t}\\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\\n\t\tfloat a2 = alphaT * alphaB;\\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\\n\t\thighp float v2 = dot( v, v );\\n\t\tfloat w2 = a2 / v2;\\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\\n\t}\\n#endif\\n#ifdef USE_CLEARCOAT\\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\\n\t\tvec3 f0 = material.clearcoatF0;\\n\t\tfloat f90 = material.clearcoatF90;\\n\t\tfloat roughness = material.clearcoatRoughness;\\n\t\tfloat alpha = pow2( roughness );\\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\t\tfloat D = D_GGX( alpha, dotNH );\\n\t\treturn F * ( V * D );\\n\t}\\n#endif\\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\\n\tvec3 f0 = material.specularColor;\\n\tfloat f90 = material.specularF90;\\n\tfloat roughness = material.roughness;\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( lightDir + viewDir );\\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\t#ifdef USE_IRIDESCENCE\\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\\n\t#endif\\n\t#ifdef USE_ANISOTROPY\\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\\n\t#else\\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\t\tfloat D = D_GGX( alpha, dotNH );\\n\t#endif\\n\treturn F * ( V * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\tconst float LUT_SIZE = 64.0;\\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\tfloat dotNV = saturate( dot( N, V ) );\\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\tfloat l = length( f );\\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\tfloat x = dot( v1, v2 );\\n\tfloat y = abs( x );\\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\tfloat v = a / b;\\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\tvec3 lightNormal = cross( v1, v2 );\\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\tvec3 T1, T2;\\n\tT1 = normalize( V - N * dot( V, N ) );\\n\tT2 = - cross( N, T1 );\\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\tvec3 coords[ 4 ];\\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\tvec3 vectorFormFactor = vec3( 0.0 );\\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\treturn vec3( result );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie( float roughness, float dotNH ) {\\n\tfloat alpha = pow2( roughness );\\n\tfloat invAlpha = 1.0 / alpha;\\n\tfloat cos2h = dotNH * dotNH;\\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\\n}\\nfloat V_Neubelt( float dotNV, float dotNL ) {\\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\\n}\\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\\n\tvec3 halfDir = normalize( lightDir + viewDir );\\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\\n\tfloat V = V_Neubelt( dotNV, dotNL );\\n\treturn sheenColor * ( D * V );\\n}\\n#endif\\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\tfloat r2 = roughness * roughness;\\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\\n\treturn saturate( DG * RECIPROCAL_PI );\\n}\\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\\n\treturn fab;\\n}\\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\treturn specularColor * fab.x + specularF90 * fab.y;\\n}\\n#ifdef USE_IRIDESCENCE\\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#else\\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#endif\\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\t#ifdef USE_IRIDESCENCE\\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\\n\t#else\\n\t\tvec3 Fr = specularColor;\\n\t#endif\\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\\n\tfloat Ess = fab.x + fab.y;\\n\tfloat Ems = 1.0 - Ess;\\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\tsingleScatter += FssEss;\\n\tmultiScatter += Fms * Ems;\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\t\tvec3 normal = geometryNormal;\\n\t\tvec3 viewDir = geometryViewDir;\\n\t\tvec3 position = geometryPosition;\\n\t\tvec3 lightPos = rectAreaLight.position;\\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\t\tvec3 lightColor = rectAreaLight.color;\\n\t\tfloat roughness = material.roughness;\\n\t\tvec3 rectCoords[ 4 ];\\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\t\tvec4 t1 = texture2D( ltc_1, uv );\\n\t\tvec4 t2 = texture2D( ltc_2, uv );\\n\t\tmat3 mInv = mat3(\\n\t\t\tvec3( t1.x, 0, t1.y ),\\n\t\t\tvec3(    0, 1,    0 ),\\n\t\t\tvec3( t1.z, 0, t1.w )\\n\t\t);\\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifdef USE_CLEARCOAT\\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\\n\t#endif\\n\t#ifdef USE_SHEEN\\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\\n\t#endif\\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\t#ifdef USE_CLEARCOAT\\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\\n\t#endif\\n\t#ifdef USE_SHEEN\\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\\n\t#endif\\n\tvec3 singleScattering = vec3( 0.0 );\\n\tvec3 multiScattering = vec3( 0.0 );\\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\t#ifdef USE_IRIDESCENCE\\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\\n\t#else\\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\\n\t#endif\\n\tvec3 totalScattering = singleScattering + multiScattering;\\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\\n\treflectedLight.indirectSpecular += radiance * singleScattering;\\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\nvar lights_fragment_begin = \"\\nvec3 geometryPosition = - vViewPosition;\\nvec3 geometryNormal = normal;\\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\nvec3 geometryClearcoatNormal = vec3( 0.0 );\\n#ifdef USE_CLEARCOAT\\n\tgeometryClearcoatNormal = clearcoatNormal;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\\n\tif ( material.iridescenceThickness == 0.0 ) {\\n\t\tmaterial.iridescence = 0.0;\\n\t} else {\\n\t\tmaterial.iridescence = saturate( material.iridescence );\\n\t}\\n\tif ( material.iridescence > 0.0 ) {\\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\\n\t}\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\tPointLightShadow pointLightShadow;\\n\t#endif\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\t\tpointLightShadow = pointLightShadows[ i ];\\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tvec4 spotColor;\\n\tvec3 spotLightCoord;\\n\tbool inSpotLightMap;\\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\tSpotLightShadow spotLightShadow;\\n\t#endif\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\\n\t\t#else\\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\t\t#endif\\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\\n\t\t#endif\\n\t\t#undef SPOT_LIGHT_MAP_INDEX\\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\t\tspotLightShadow = spotLightShadows[ i ];\\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\tDirectionalLightShadow directionalLightShadow;\\n\t#endif\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\tRectAreaLight rectAreaLight;\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\t\trectAreaLight = rectAreaLights[ i ];\\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 iblIrradiance = vec3( 0.0 );\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#if defined( USE_LIGHT_PROBES )\\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\t#pragma unroll_loop_start\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\\n\t\t}\\n\t\t#pragma unroll_loop_end\\n\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\tvec3 radiance = vec3( 0.0 );\\n\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\";\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\\n\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\t#ifdef USE_ANISOTROPY\\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\\n\t#else\\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\\n\t#endif\\n\t#ifdef USE_CLEARCOAT\\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\\n\t#endif\\n#endif\";\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\\n#endif\";\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF )\\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF )\\n\tuniform float logDepthBufFC;\\n\tvarying float vFragDepth;\\n\tvarying float vIsPerspective;\\n#endif\";\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\tvarying float vFragDepth;\\n\tvarying float vIsPerspective;\\n#endif\";\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\tvFragDepth = 1.0 + gl_Position.w;\\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n#endif\";\nvar map_fragment = \"#ifdef USE_MAP\\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\\n\t#ifdef DECODE_VIDEO_TEXTURE\\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\\n\t#endif\\n\tdiffuseColor *= sampledDiffuseColor;\\n#endif\";\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\";\nvar map_particle_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\t#if defined( USE_POINTS_UV )\\n\t\tvec2 uv = vUv;\\n\t#else\\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\t#endif\\n#endif\\n#ifdef USE_MAP\\n\tdiffuseColor *= texture2D( map, uv );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\";\nvar map_particle_pars_fragment = \"#if defined( USE_POINTS_UV )\\n\tvarying vec2 vUv;\\n#else\\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\t\tuniform mat3 uvTransform;\\n\t#endif\\n#endif\\n#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\";\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\\n\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\nvar morphinstance_vertex = \"#ifdef USE_INSTANCING_MORPH\\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\\n\t}\\n#endif\";\nvar morphcolor_vertex = \"#if defined( USE_MORPHCOLORS )\\n\tvColor *= morphTargetBaseInfluence;\\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\t\t#if defined( USE_COLOR_ALPHA )\\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\\n\t\t#elif defined( USE_COLOR )\\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\\n\t\t#endif\\n\t}\\n#endif\";\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal *= morphTargetBaseInfluence;\\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\\n\t}\\n#endif\";\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_INSTANCING_MORPH\\n\t\tuniform float morphTargetBaseInfluence;\\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\\n\t#endif\\n\tuniform sampler2DArray morphTargetsTexture;\\n\tuniform ivec2 morphTargetsTextureSize;\\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\\n\t}\\n#endif\";\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\ttransformed *= morphTargetBaseInfluence;\\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\\n\t}\\n#endif\";\nvar normal_fragment_begin = \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\tvec3 fdx = dFdx( vViewPosition );\\n\tvec3 fdy = dFdy( vViewPosition );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal );\\n\t#ifdef DOUBLE_SIDED\\n\t\tnormal *= faceDirection;\\n\t#endif\\n#endif\\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\\n\t#ifdef USE_TANGENT\\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\\n\t#else\\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\\n\t\t#if defined( USE_NORMALMAP )\\n\t\t\tvNormalMapUv\\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\\n\t\t\tvClearcoatNormalMapUv\\n\t\t#else\\n\t\t\tvUv\\n\t\t#endif\\n\t\t);\\n\t#endif\\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\\n\t\ttbn[0] *= faceDirection;\\n\t\ttbn[1] *= faceDirection;\\n\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\t#ifdef USE_TANGENT\\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\\n\t#else\\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\\n\t#endif\\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\\n\t\ttbn2[0] *= faceDirection;\\n\t\ttbn2[1] *= faceDirection;\\n\t#endif\\n#endif\\nvec3 nonPerturbedNormal = normal;\";\nvar normal_fragment_maps = \"#ifdef USE_NORMALMAP_OBJECTSPACE\\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\\n\t#ifdef FLIP_SIDED\\n\t\tnormal = - normal;\\n\t#endif\\n\t#ifdef DOUBLE_SIDED\\n\t\tnormal = normal * faceDirection;\\n\t#endif\\n\tnormal = normalize( normalMatrix * normal );\\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\\n\tmapN.xy *= normalScale;\\n\tnormal = normalize( tbn * mapN );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\";\nvar normal_pars_fragment = \"#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n\t#ifdef USE_TANGENT\\n\t\tvarying vec3 vTangent;\\n\t\tvarying vec3 vBitangent;\\n\t#endif\\n#endif\";\nvar normal_pars_vertex = \"#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n\t#ifdef USE_TANGENT\\n\t\tvarying vec3 vTangent;\\n\t\tvarying vec3 vBitangent;\\n\t#endif\\n#endif\";\nvar normal_vertex = \"#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n\t#ifdef USE_TANGENT\\n\t\tvTangent = normalize( transformedTangent );\\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\t#endif\\n#endif\";\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n#endif\\n#ifdef USE_NORMALMAP_OBJECTSPACE\\n\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( uv.st );\\n\t\tvec2 st1 = dFdy( uv.st );\\n\t\tvec3 N = surf_norm;\\n\t\tvec3 q1perp = cross( q1, N );\\n\t\tvec3 q0perp = cross( N, q0 );\\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\\n\t\treturn mat3( T * scale, B * scale, N );\\n\t}\\n#endif\";\nvar clearcoat_normal_fragment_begin = \"#ifdef USE_CLEARCOAT\\n\tvec3 clearcoatNormal = nonPerturbedNormal;\\n#endif\";\nvar clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\\n\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\\n#endif\";\nvar clearcoat_pars_fragment = \"#ifdef USE_CLEARCOATMAP\\n\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\tuniform sampler2D clearcoatNormalMap;\\n\tuniform vec2 clearcoatNormalScale;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\";\nvar iridescence_pars_fragment = \"#ifdef USE_IRIDESCENCEMAP\\n\tuniform sampler2D iridescenceMap;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\tuniform sampler2D iridescenceThicknessMap;\\n#endif\";\nvar opaque_fragment = \"#ifdef OPAQUE\\ndiffuseColor.a = 1.0;\\n#endif\\n#ifdef USE_TRANSMISSION\\ndiffuseColor.a *= material.transmissionAlpha;\\n#endif\\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\";\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\\nconst float Inv255 = 1. / 255.;\\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\\nvec4 packDepthToRGBA( const in float v ) {\\n\tif( v <= 0.0 )\\n\t\treturn vec4( 0., 0., 0., 0. );\\n\tif( v >= 1.0 )\\n\t\treturn vec4( 1., 1., 1., 1. );\\n\tfloat vuf;\\n\tfloat af = modf( v * PackFactors.a, vuf );\\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\\n}\\nvec3 packDepthToRGB( const in float v ) {\\n\tif( v <= 0.0 )\\n\t\treturn vec3( 0., 0., 0. );\\n\tif( v >= 1.0 )\\n\t\treturn vec3( 1., 1., 1. );\\n\tfloat vuf;\\n\tfloat bf = modf( v * PackFactors.b, vuf );\\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\\n}\\nvec2 packDepthToRG( const in float v ) {\\n\tif( v <= 0.0 )\\n\t\treturn vec2( 0., 0. );\\n\tif( v >= 1.0 )\\n\t\treturn vec2( 1., 1. );\\n\tfloat vuf;\\n\tfloat gf = modf( v * 256., vuf );\\n\treturn vec2( vuf * Inv255, gf );\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\treturn dot( v, UnpackFactors4 );\\n}\\nfloat unpackRGBToDepth( const in vec3 v ) {\\n\treturn dot( v, UnpackFactors3 );\\n}\\nfloat unpackRGToDepth( const in vec2 v ) {\\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\\n}\\nvec4 pack2HalfToRGBA( const in vec2 v ) {\\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\\n}\\nvec2 unpackRGBATo2Half( const in vec4 v ) {\\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\\n\treturn depth * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\\n}\";\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\nvar project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_BATCHING\\n\tmvPosition = batchingMatrix * mvPosition;\\n#endif\\n#ifdef USE_INSTANCING\\n\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\nvar dithering_fragment = \"#ifdef DITHERING\\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\nvar dithering_pars_fragment = \"#ifdef DITHERING\\n\tvec3 dithering( vec3 color ) {\\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\t\treturn color + dither_shift_RGB;\\n\t}\\n#endif\";\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\\n\troughnessFactor *= texelRoughness.g;\\n#endif\";\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\nvar shadowmap_pars_fragment = \"#if NUM_SPOT_LIGHT_COORDS > 0\\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\\n#endif\\n#if NUM_SPOT_LIGHT_MAPS > 0\\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\\n#endif\\n#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\t\tstruct DirectionalLightShadow {\\n\t\t\tfloat shadowIntensity;\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t};\\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\t\tstruct SpotLightShadow {\\n\t\t\tfloat shadowIntensity;\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t};\\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\t\tstruct PointLightShadow {\\n\t\t\tfloat shadowIntensity;\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t\tfloat shadowCameraNear;\\n\t\t\tfloat shadowCameraFar;\\n\t\t};\\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\t}\\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\t\tfloat occlusion = 1.0;\\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\t\tfloat hard_shadow = step( compare , distribution.x );\\n\t\tif (hard_shadow != 1.0 ) {\\n\t\t\tfloat distance = compare - distribution.x ;\\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\t\t}\\n\t\treturn occlusion;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tfloat shadow = 1.0;\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\tfloat dx2 = dx0 / 2.0;\\n\t\t\tfloat dy2 = dy0 / 2.0;\\n\t\t\tfloat dx3 = dx1 / 2.0;\\n\t\t\tfloat dy3 = dy1 / 2.0;\\n\t\t\tshadow = (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 17.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx = texelSize.x;\\n\t\t\tfloat dy = texelSize.y;\\n\t\t\tvec2 uv = shadowCoord.xy;\\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\t\t\tuv -= f * texelSize;\\n\t\t\tshadow = (\\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\t\t\t\t\t f.x ) +\\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\t\t\t\t\t f.x ) +\\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\t\t\t\t\t f.y ) +\\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\t\t\t\t\t f.y ) +\\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\t\t\t\t\t\t  f.x ),\\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\t\t\t\t\t\t  f.x ),\\n\t\t\t\t\t f.y )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#else\\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn mix( 1.0, shadow, shadowIntensity );\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\t\tfloat shadow = 1.0;\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\t\\n\t\tfloat lightToPositionLength = length( lightToPosition );\\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\\n\t\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\t\tshadow = (\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t\t) * ( 1.0 / 9.0 );\\n\t\t\t#else\\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t\t#endif\\n\t\t}\\n\t\treturn mix( 1.0, shadow, shadowIntensity );\\n\t}\\n#endif\";\nvar shadowmap_pars_vertex = \"#if NUM_SPOT_LIGHT_COORDS > 0\\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\\n#endif\\n#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\t\tstruct DirectionalLightShadow {\\n\t\t\tfloat shadowIntensity;\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t};\\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\t\tstruct SpotLightShadow {\\n\t\t\tfloat shadowIntensity;\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t};\\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\t\tstruct PointLightShadow {\\n\t\t\tfloat shadowIntensity;\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t\tfloat shadowCameraNear;\\n\t\t\tfloat shadowCameraFar;\\n\t\t};\\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\t#endif\\n#endif\";\nvar shadowmap_vertex = \"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\tvec4 shadowWorldPosition;\\n#endif\\n#if defined( USE_SHADOWMAP )\\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\t\t#pragma unroll_loop_start\\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\t\t}\\n\t\t#pragma unroll_loop_end\\n\t#endif\\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\t\t#pragma unroll_loop_start\\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\t\t}\\n\t\t#pragma unroll_loop_end\\n\t#endif\\n#endif\\n#if NUM_SPOT_LIGHT_COORDS > 0\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\\n\t\tshadowWorldPosition = worldPosition;\\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\\n\t\t#endif\\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\";\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\tDirectionalLightShadow directionalLight;\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\t\tdirectionalLight = directionalLightShadows[ i ];\\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#endif\\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\tSpotLightShadow spotLight;\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\t\tspotLight = spotLightShadows[ i ];\\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#endif\\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\tPointLightShadow pointLight;\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\t\tpointLight = pointLightShadows[ i ];\\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\";\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\tuniform highp sampler2D boneTexture;\\n\tmat4 getBoneMatrix( const in float i ) {\\n\t\tint size = textureSize( boneTexture, 0 ).x;\\n\t\tint j = int( i ) * 4;\\n\t\tint x = j % size;\\n\t\tint y = j / size;\\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\\n\t\treturn mat4( v1, v2, v3, v4 );\\n\t}\\n#endif\";\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\t#ifdef USE_TANGENT\\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\t#endif\\n#endif\";\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\treturn saturate( toneMappingExposure * color );\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\tcolor *= toneMappingExposure;\\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 CineonToneMapping( vec3 color ) {\\n\tcolor *= toneMappingExposure;\\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\tconst mat3 ACESInputMat = mat3(\\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\\n\t);\\n\tconst mat3 ACESOutputMat = mat3(\\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\\n\t);\\n\tcolor *= toneMappingExposure / 0.6;\\n\tcolor = ACESInputMat * color;\\n\tcolor = RRTAndODTFit( color );\\n\tcolor = ACESOutputMat * color;\\n\treturn saturate( color );\\n}\\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\\n);\\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\\n\tvec3( 0.6274, 0.0691, 0.0164 ),\\n\tvec3( 0.3293, 0.9195, 0.0880 ),\\n\tvec3( 0.0433, 0.0113, 0.8956 )\\n);\\nvec3 agxDefaultContrastApprox( vec3 x ) {\\n\tvec3 x2 = x * x;\\n\tvec3 x4 = x2 * x2;\\n\treturn + 15.5 * x4 * x2\\n\t\t- 40.14 * x4 * x\\n\t\t+ 31.96 * x4\\n\t\t- 6.868 * x2 * x\\n\t\t+ 0.4298 * x2\\n\t\t+ 0.1191 * x\\n\t\t- 0.00232;\\n}\\nvec3 AgXToneMapping( vec3 color ) {\\n\tconst mat3 AgXInsetMatrix = mat3(\\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\\n\t);\\n\tconst mat3 AgXOutsetMatrix = mat3(\\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\\n\t);\\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\\n\tcolor *= toneMappingExposure;\\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\\n\tcolor = AgXInsetMatrix * color;\\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\\n\tcolor = clamp( color, 0.0, 1.0 );\\n\tcolor = agxDefaultContrastApprox( color );\\n\tcolor = AgXOutsetMatrix * color;\\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\\n\tcolor = clamp( color, 0.0, 1.0 );\\n\treturn color;\\n}\\nvec3 NeutralToneMapping( vec3 color ) {\\n\tconst float StartCompression = 0.8 - 0.04;\\n\tconst float Desaturation = 0.15;\\n\tcolor *= toneMappingExposure;\\n\tfloat x = min( color.r, min( color.g, color.b ) );\\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\\n\tcolor -= offset;\\n\tfloat peak = max( color.r, max( color.g, color.b ) );\\n\tif ( peak < StartCompression ) return color;\\n\tfloat d = 1. - StartCompression;\\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\\n\tcolor *= newPeak / peak;\\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\\n\treturn mix( color, vec3( newPeak ), g );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\";\nvar transmission_fragment = \"#ifdef USE_TRANSMISSION\\n\tmaterial.transmission = transmission;\\n\tmaterial.transmissionAlpha = 1.0;\\n\tmaterial.thickness = thickness;\\n\tmaterial.attenuationDistance = attenuationDistance;\\n\tmaterial.attenuationColor = attenuationColor;\\n\t#ifdef USE_TRANSMISSIONMAP\\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\\n\t#endif\\n\t#ifdef USE_THICKNESSMAP\\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\\n\t#endif\\n\tvec3 pos = vWorldPosition;\\n\tvec3 v = normalize( cameraPosition - pos );\\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\\n\tvec4 transmitted = getIBLVolumeRefraction(\\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\\n\t\tmaterial.attenuationColor, material.attenuationDistance );\\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\\n#endif\";\nvar transmission_pars_fragment = \"#ifdef USE_TRANSMISSION\\n\tuniform float transmission;\\n\tuniform float thickness;\\n\tuniform float attenuationDistance;\\n\tuniform vec3 attenuationColor;\\n\t#ifdef USE_TRANSMISSIONMAP\\n\t\tuniform sampler2D transmissionMap;\\n\t#endif\\n\t#ifdef USE_THICKNESSMAP\\n\t\tuniform sampler2D thicknessMap;\\n\t#endif\\n\tuniform vec2 transmissionSamplerSize;\\n\tuniform sampler2D transmissionSamplerMap;\\n\tuniform mat4 modelMatrix;\\n\tuniform mat4 projectionMatrix;\\n\tvarying vec3 vWorldPosition;\\n\tfloat w0( float a ) {\\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\\n\t}\\n\tfloat w1( float a ) {\\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\\n\t}\\n\tfloat w2( float a ){\\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\\n\t}\\n\tfloat w3( float a ) {\\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\\n\t}\\n\tfloat g0( float a ) {\\n\t\treturn w0( a ) + w1( a );\\n\t}\\n\tfloat g1( float a ) {\\n\t\treturn w2( a ) + w3( a );\\n\t}\\n\tfloat h0( float a ) {\\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\\n\t}\\n\tfloat h1( float a ) {\\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\\n\t}\\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\\n\t\tuv = uv * texelSize.zw + 0.5;\\n\t\tvec2 iuv = floor( uv );\\n\t\tvec2 fuv = fract( uv );\\n\t\tfloat g0x = g0( fuv.x );\\n\t\tfloat g1x = g1( fuv.x );\\n\t\tfloat h0x = h0( fuv.x );\\n\t\tfloat h1x = h1( fuv.x );\\n\t\tfloat h0y = h0( fuv.y );\\n\t\tfloat h1y = h1( fuv.y );\\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\\n\t}\\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\\n\t\treturn mix( fSample, cSample, fract( lod ) );\\n\t}\\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\\n\t\tvec3 modelScale;\\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\\n\t}\\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\\n\t}\\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\\n\t}\\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\\n\t\tif ( isinf( attenuationDistance ) ) {\\n\t\t\treturn vec3( 1.0 );\\n\t\t} else {\\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\\n\t\t}\\n\t}\\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\\n\t\tvec4 transmittedLight;\\n\t\tvec3 transmittance;\\n\t\t#ifdef USE_DISPERSION\\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\\n\t\t\\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\t\t\t\trefractionCoords += 1.0;\\n\t\t\t\trefractionCoords /= 2.0;\\n\t\t\\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\\n\t\t\t}\\n\t\t\ttransmittedLight.a /= 3.0;\\n\t\t\\n\t\t#else\\n\t\t\\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\t\t\trefractionCoords += 1.0;\\n\t\t\trefractionCoords /= 2.0;\\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\\n\t\t\\n\t\t#endif\\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\\n\t}\\n#endif\";\nvar uv_pars_fragment = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\tvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\n\tvarying vec2 vMapUv;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\tvarying vec2 vAlphaMapUv;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\tvarying vec2 vLightMapUv;\\n#endif\\n#ifdef USE_AOMAP\\n\tvarying vec2 vAoMapUv;\\n#endif\\n#ifdef USE_BUMPMAP\\n\tvarying vec2 vBumpMapUv;\\n#endif\\n#ifdef USE_NORMALMAP\\n\tvarying vec2 vNormalMapUv;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\tvarying vec2 vEmissiveMapUv;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\tvarying vec2 vMetalnessMapUv;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\tvarying vec2 vRoughnessMapUv;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\tvarying vec2 vAnisotropyMapUv;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\tvarying vec2 vClearcoatMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\tvarying vec2 vClearcoatNormalMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\tvarying vec2 vClearcoatRoughnessMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\tvarying vec2 vIridescenceMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\tvarying vec2 vIridescenceThicknessMapUv;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\tvarying vec2 vSheenColorMapUv;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\tvarying vec2 vSheenRoughnessMapUv;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\tvarying vec2 vSpecularMapUv;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\tvarying vec2 vSpecularColorMapUv;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\tvarying vec2 vSpecularIntensityMapUv;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\tuniform mat3 transmissionMapTransform;\\n\tvarying vec2 vTransmissionMapUv;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\tuniform mat3 thicknessMapTransform;\\n\tvarying vec2 vThicknessMapUv;\\n#endif\";\nvar uv_pars_vertex = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\tvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\n\tuniform mat3 mapTransform;\\n\tvarying vec2 vMapUv;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\tuniform mat3 alphaMapTransform;\\n\tvarying vec2 vAlphaMapUv;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\tuniform mat3 lightMapTransform;\\n\tvarying vec2 vLightMapUv;\\n#endif\\n#ifdef USE_AOMAP\\n\tuniform mat3 aoMapTransform;\\n\tvarying vec2 vAoMapUv;\\n#endif\\n#ifdef USE_BUMPMAP\\n\tuniform mat3 bumpMapTransform;\\n\tvarying vec2 vBumpMapUv;\\n#endif\\n#ifdef USE_NORMALMAP\\n\tuniform mat3 normalMapTransform;\\n\tvarying vec2 vNormalMapUv;\\n#endif\\n#ifdef USE_DISPLACEMENTMAP\\n\tuniform mat3 displacementMapTransform;\\n\tvarying vec2 vDisplacementMapUv;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\tuniform mat3 emissiveMapTransform;\\n\tvarying vec2 vEmissiveMapUv;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\tuniform mat3 metalnessMapTransform;\\n\tvarying vec2 vMetalnessMapUv;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\tuniform mat3 roughnessMapTransform;\\n\tvarying vec2 vRoughnessMapUv;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\tuniform mat3 anisotropyMapTransform;\\n\tvarying vec2 vAnisotropyMapUv;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\tuniform mat3 clearcoatMapTransform;\\n\tvarying vec2 vClearcoatMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\tuniform mat3 clearcoatNormalMapTransform;\\n\tvarying vec2 vClearcoatNormalMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\tuniform mat3 clearcoatRoughnessMapTransform;\\n\tvarying vec2 vClearcoatRoughnessMapUv;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\tuniform mat3 sheenColorMapTransform;\\n\tvarying vec2 vSheenColorMapUv;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\tuniform mat3 sheenRoughnessMapTransform;\\n\tvarying vec2 vSheenRoughnessMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\tuniform mat3 iridescenceMapTransform;\\n\tvarying vec2 vIridescenceMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\tuniform mat3 iridescenceThicknessMapTransform;\\n\tvarying vec2 vIridescenceThicknessMapUv;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\tuniform mat3 specularMapTransform;\\n\tvarying vec2 vSpecularMapUv;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\tuniform mat3 specularColorMapTransform;\\n\tvarying vec2 vSpecularColorMapUv;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\tuniform mat3 specularIntensityMapTransform;\\n\tvarying vec2 vSpecularIntensityMapUv;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\tuniform mat3 transmissionMapTransform;\\n\tvarying vec2 vTransmissionMapUv;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\tuniform mat3 thicknessMapTransform;\\n\tvarying vec2 vThicknessMapUv;\\n#endif\";\nvar uv_vertex = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\tvUv = vec3( uv, 1 ).xy;\\n#endif\\n#ifdef USE_MAP\\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_AOMAP\\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_BUMPMAP\\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_NORMALMAP\\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_DISPLACEMENTMAP\\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\\n#endif\";\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\\n\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\t#ifdef USE_BATCHING\\n\t\tworldPosition = batchingMatrix * worldPosition;\\n\t#endif\\n\t#ifdef USE_INSTANCING\\n\t\tworldPosition = instanceMatrix * worldPosition;\\n\t#endif\\n\tworldPosition = modelMatrix * worldPosition;\\n#endif\";\nconst vertex$h = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\nconst fragment$h = \"uniform sampler2D t2D;\\nuniform float backgroundIntensity;\\nvarying vec2 vUv;\\nvoid main() {\\n\tvec4 texColor = texture2D( t2D, vUv );\\n\t#ifdef DECODE_VIDEO_TEXTURE\\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\\n\t#endif\\n\ttexColor.rgb *= backgroundIntensity;\\n\tgl_FragColor = texColor;\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n}\";\nconst vertex$g = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\tvWorldDirection = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\tgl_Position.z = gl_Position.w;\\n}\";\nconst fragment$g = \"#ifdef ENVMAP_TYPE_CUBE\\n\tuniform samplerCube envMap;\\n#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\tuniform sampler2D envMap;\\n#endif\\nuniform float flipEnvMap;\\nuniform float backgroundBlurriness;\\nuniform float backgroundIntensity;\\nuniform mat3 backgroundRotation;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\\n\t#else\\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\t#endif\\n\ttexColor.rgb *= backgroundIntensity;\\n\tgl_FragColor = texColor;\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n}\";\nconst vertex$f = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\tvWorldDirection = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\tgl_Position.z = gl_Position.w;\\n}\";\nconst fragment$f = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\nvoid main() {\\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\\n\tgl_FragColor = texColor;\\n\tgl_FragColor.a *= opacity;\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n}\";\nconst vertex$e = \"#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <batching_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <morphinstance_vertex>\\n\t#ifdef USE_DISPLACEMENTMAP\\n\t\t#include <beginnormal_vertex>\\n\t\t#include <morphnormal_vertex>\\n\t\t#include <skinnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvHighPrecisionZW = gl_Position.zw;\\n}\";\nconst fragment$e = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#include <clipping_planes_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\t#include <logdepthbuf_fragment>\\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\t#elif DEPTH_PACKING == 3202\\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\\n\t#elif DEPTH_PACKING == 3203\\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\\n\t#endif\\n}\";\nconst vertex$d = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <batching_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <morphinstance_vertex>\\n\t#ifdef USE_DISPLACEMENTMAP\\n\t\t#include <beginnormal_vertex>\\n\t\t#include <morphnormal_vertex>\\n\t\t#include <skinnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition.xyz;\\n}\";\nconst fragment$d = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#include <clipping_planes_fragment>\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\tfloat dist = length( vWorldPosition - referencePosition );\\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\tdist = saturate( dist );\\n\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\nconst vertex$c = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\tvWorldDirection = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n}\";\nconst fragment$c = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\tvec3 direction = normalize( vWorldDirection );\\n\tvec2 sampleUV = equirectUv( direction );\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n}\";\nconst vertex$b = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvLineDistance = scale * lineDistance;\\n\t#include <uv_vertex>\\n\t#include <color_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <fog_vertex>\\n}\";\nconst fragment$b = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\t#include <opaque_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n}\";\nconst vertex$a = \"#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <color_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include <batching_vertex>\\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\\n\t\t#include <beginnormal_vertex>\\n\t\t#include <morphnormal_vertex>\\n\t\t#include <skinbase_vertex>\\n\t\t#include <skinnormal_vertex>\\n\t\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nconst fragment$a = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <clipping_planes_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\\n\t#else\\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\t#endif\\n\t#include <aomap_fragment>\\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <envmap_fragment>\\n\t#include <opaque_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nconst vertex$9 = \"#define LAMBERT\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <color_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include <batching_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <normal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nconst fragment$9 = \"#define LAMBERT\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_lambert_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <clipping_planes_fragment>\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_lambert_fragment>\\n\t#include <lights_fragment_begin>\\n\t#include <lights_fragment_maps>\\n\t#include <lights_fragment_end>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\t#include <opaque_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nconst vertex$8 = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <color_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include <batching_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <normal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <fog_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n}\";\nconst fragment$8 = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <clipping_planes_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\tvec3 viewDir = normalize( vViewPosition );\\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\tvec3 y = cross( viewDir, x );\\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\t#ifdef USE_MATCAP\\n\t\tvec4 matcapColor = texture2D( matcap, uv );\\n\t#else\\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\\n\t#endif\\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\t#include <opaque_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nconst vertex$7 = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\tvarying vec3 vViewPosition;\\n#endif\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <batching_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <normal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\nconst fragment$7 = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\tvarying vec3 vViewPosition;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\\n\t#include <clipping_planes_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\\n\t#ifdef OPAQUE\\n\t\tgl_FragColor.a = 1.0;\\n\t#endif\\n}\";\nconst vertex$6 = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <color_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include <batching_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <normal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nconst fragment$6 = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <clipping_planes_fragment>\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_fragment_begin>\\n\t#include <lights_fragment_maps>\\n\t#include <lights_fragment_end>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\t#include <opaque_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nconst vertex$5 = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifdef USE_TRANSMISSION\\n\tvarying vec3 vWorldPosition;\\n#endif\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <color_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include <batching_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <normal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\tvWorldPosition = worldPosition.xyz;\\n#endif\\n}\";\nconst fragment$5 = \"#define STANDARD\\n#ifdef PHYSICAL\\n\t#define IOR\\n\t#define USE_SPECULAR\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef IOR\\n\tuniform float ior;\\n#endif\\n#ifdef USE_SPECULAR\\n\tuniform float specularIntensity;\\n\tuniform vec3 specularColor;\\n\t#ifdef USE_SPECULAR_COLORMAP\\n\t\tuniform sampler2D specularColorMap;\\n\t#endif\\n\t#ifdef USE_SPECULAR_INTENSITYMAP\\n\t\tuniform sampler2D specularIntensityMap;\\n\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT\\n\tuniform float clearcoat;\\n\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_DISPERSION\\n\tuniform float dispersion;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\tuniform float iridescence;\\n\tuniform float iridescenceIOR;\\n\tuniform float iridescenceThicknessMinimum;\\n\tuniform float iridescenceThicknessMaximum;\\n#endif\\n#ifdef USE_SHEEN\\n\tuniform vec3 sheenColor;\\n\tuniform float sheenRoughness;\\n\t#ifdef USE_SHEEN_COLORMAP\\n\t\tuniform sampler2D sheenColorMap;\\n\t#endif\\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\\n\t\tuniform sampler2D sheenRoughnessMap;\\n\t#endif\\n#endif\\n#ifdef USE_ANISOTROPY\\n\tuniform vec2 anisotropyVector;\\n\t#ifdef USE_ANISOTROPYMAP\\n\t\tuniform sampler2D anisotropyMap;\\n\t#endif\\n#endif\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <iridescence_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_physical_pars_fragment>\\n#include <transmission_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <iridescence_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <clipping_planes_fragment>\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\t#include <clearcoat_normal_fragment_begin>\\n\t#include <clearcoat_normal_fragment_maps>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_fragment_begin>\\n\t#include <lights_fragment_maps>\\n\t#include <lights_fragment_end>\\n\t#include <aomap_fragment>\\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\\n\t#include <transmission_fragment>\\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\\n\t#ifdef USE_SHEEN\\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\\n\t#endif\\n\t#ifdef USE_CLEARCOAT\\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\\n\t#endif\\n\t#include <opaque_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nconst vertex$4 = \"#define TOON\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <batching_pars_vertex>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <color_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include <batching_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <normal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nconst fragment$4 = \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <clipping_planes_fragment>\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_toon_fragment>\\n\t#include <lights_fragment_begin>\\n\t#include <lights_fragment_maps>\\n\t#include <lights_fragment_end>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <opaque_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nconst vertex$3 = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n#ifdef USE_POINTS_UV\\n\tvarying vec2 vUv;\\n\tuniform mat3 uvTransform;\\n#endif\\nvoid main() {\\n\t#ifdef USE_POINTS_UV\\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\t#endif\\n\t#include <color_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include <morphcolor_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\tgl_PointSize = size;\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <fog_vertex>\\n}\";\nconst fragment$3 = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\t#include <opaque_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n}\";\nconst vertex$2 = \"#include <common>\\n#include <batching_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\t#include <batching_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphinstance_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nconst fragment$2 = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <logdepthbuf_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\t#include <logdepthbuf_fragment>\\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include <fog_fragment>\\n}\";\nconst vertex$1 = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\\n\t#ifndef USE_SIZEATTENUATION\\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\\n\t#endif\\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\tvec2 rotatedPosition;\\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\tmvPosition.xy += rotatedPosition;\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <fog_vertex>\\n}\";\nconst fragment$1 = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <alphahash_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\t#include <opaque_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <colorspace_fragment>\\n\t#include <fog_fragment>\\n}\";\nconst ShaderChunk = {\n  alphahash_fragment,\n  alphahash_pars_fragment,\n  alphamap_fragment,\n  alphamap_pars_fragment,\n  alphatest_fragment,\n  alphatest_pars_fragment,\n  aomap_fragment,\n  aomap_pars_fragment,\n  batching_pars_vertex,\n  batching_vertex,\n  begin_vertex,\n  beginnormal_vertex,\n  bsdfs,\n  iridescence_fragment,\n  bumpmap_pars_fragment,\n  clipping_planes_fragment,\n  clipping_planes_pars_fragment,\n  clipping_planes_pars_vertex,\n  clipping_planes_vertex,\n  color_fragment,\n  color_pars_fragment,\n  color_pars_vertex,\n  color_vertex,\n  common,\n  cube_uv_reflection_fragment,\n  defaultnormal_vertex,\n  displacementmap_pars_vertex,\n  displacementmap_vertex,\n  emissivemap_fragment,\n  emissivemap_pars_fragment,\n  colorspace_fragment,\n  colorspace_pars_fragment,\n  envmap_fragment,\n  envmap_common_pars_fragment,\n  envmap_pars_fragment,\n  envmap_pars_vertex,\n  envmap_physical_pars_fragment,\n  envmap_vertex,\n  fog_vertex,\n  fog_pars_vertex,\n  fog_fragment,\n  fog_pars_fragment,\n  gradientmap_pars_fragment,\n  lightmap_pars_fragment,\n  lights_lambert_fragment,\n  lights_lambert_pars_fragment,\n  lights_pars_begin,\n  lights_toon_fragment,\n  lights_toon_pars_fragment,\n  lights_phong_fragment,\n  lights_phong_pars_fragment,\n  lights_physical_fragment,\n  lights_physical_pars_fragment,\n  lights_fragment_begin,\n  lights_fragment_maps,\n  lights_fragment_end,\n  logdepthbuf_fragment,\n  logdepthbuf_pars_fragment,\n  logdepthbuf_pars_vertex,\n  logdepthbuf_vertex,\n  map_fragment,\n  map_pars_fragment,\n  map_particle_fragment,\n  map_particle_pars_fragment,\n  metalnessmap_fragment,\n  metalnessmap_pars_fragment,\n  morphinstance_vertex,\n  morphcolor_vertex,\n  morphnormal_vertex,\n  morphtarget_pars_vertex,\n  morphtarget_vertex,\n  normal_fragment_begin,\n  normal_fragment_maps,\n  normal_pars_fragment,\n  normal_pars_vertex,\n  normal_vertex,\n  normalmap_pars_fragment,\n  clearcoat_normal_fragment_begin,\n  clearcoat_normal_fragment_maps,\n  clearcoat_pars_fragment,\n  iridescence_pars_fragment,\n  opaque_fragment,\n  packing,\n  premultiplied_alpha_fragment,\n  project_vertex,\n  dithering_fragment,\n  dithering_pars_fragment,\n  roughnessmap_fragment,\n  roughnessmap_pars_fragment,\n  shadowmap_pars_fragment,\n  shadowmap_pars_vertex,\n  shadowmap_vertex,\n  shadowmask_pars_fragment,\n  skinbase_vertex,\n  skinning_pars_vertex,\n  skinning_vertex,\n  skinnormal_vertex,\n  specularmap_fragment,\n  specularmap_pars_fragment,\n  tonemapping_fragment,\n  tonemapping_pars_fragment,\n  transmission_fragment,\n  transmission_pars_fragment,\n  uv_pars_fragment,\n  uv_pars_vertex,\n  uv_vertex,\n  worldpos_vertex,\n  background_vert: vertex$h,\n  background_frag: fragment$h,\n  backgroundCube_vert: vertex$g,\n  backgroundCube_frag: fragment$g,\n  cube_vert: vertex$f,\n  cube_frag: fragment$f,\n  depth_vert: vertex$e,\n  depth_frag: fragment$e,\n  distanceRGBA_vert: vertex$d,\n  distanceRGBA_frag: fragment$d,\n  equirect_vert: vertex$c,\n  equirect_frag: fragment$c,\n  linedashed_vert: vertex$b,\n  linedashed_frag: fragment$b,\n  meshbasic_vert: vertex$a,\n  meshbasic_frag: fragment$a,\n  meshlambert_vert: vertex$9,\n  meshlambert_frag: fragment$9,\n  meshmatcap_vert: vertex$8,\n  meshmatcap_frag: fragment$8,\n  meshnormal_vert: vertex$7,\n  meshnormal_frag: fragment$7,\n  meshphong_vert: vertex$6,\n  meshphong_frag: fragment$6,\n  meshphysical_vert: vertex$5,\n  meshphysical_frag: fragment$5,\n  meshtoon_vert: vertex$4,\n  meshtoon_frag: fragment$4,\n  points_vert: vertex$3,\n  points_frag: fragment$3,\n  shadow_vert: vertex$2,\n  shadow_frag: fragment$2,\n  sprite_vert: vertex$1,\n  sprite_frag: fragment$1\n};\nconst UniformsLib = {\n  common: {\n    diffuse: { value: /* @__PURE__ */ new Color(16777215) },\n    opacity: { value: 1 },\n    map: { value: null },\n    mapTransform: { value: /* @__PURE__ */ new Matrix3() },\n    alphaMap: { value: null },\n    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n    alphaTest: { value: 0 }\n  },\n  specularmap: {\n    specularMap: { value: null },\n    specularMapTransform: { value: /* @__PURE__ */ new Matrix3() }\n  },\n  envmap: {\n    envMap: { value: null },\n    envMapRotation: { value: /* @__PURE__ */ new Matrix3() },\n    flipEnvMap: { value: -1 },\n    reflectivity: { value: 1 },\n    // basic, lambert, phong\n    ior: { value: 1.5 },\n    // physical\n    refractionRatio: { value: 0.98 }\n    // basic, lambert, phong\n  },\n  aomap: {\n    aoMap: { value: null },\n    aoMapIntensity: { value: 1 },\n    aoMapTransform: { value: /* @__PURE__ */ new Matrix3() }\n  },\n  lightmap: {\n    lightMap: { value: null },\n    lightMapIntensity: { value: 1 },\n    lightMapTransform: { value: /* @__PURE__ */ new Matrix3() }\n  },\n  bumpmap: {\n    bumpMap: { value: null },\n    bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n    bumpScale: { value: 1 }\n  },\n  normalmap: {\n    normalMap: { value: null },\n    normalMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n    normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }\n  },\n  displacementmap: {\n    displacementMap: { value: null },\n    displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n    displacementScale: { value: 1 },\n    displacementBias: { value: 0 }\n  },\n  emissivemap: {\n    emissiveMap: { value: null },\n    emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() }\n  },\n  metalnessmap: {\n    metalnessMap: { value: null },\n    metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }\n  },\n  roughnessmap: {\n    roughnessMap: { value: null },\n    roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }\n  },\n  gradientmap: {\n    gradientMap: { value: null }\n  },\n  fog: {\n    fogDensity: { value: 25e-5 },\n    fogNear: { value: 1 },\n    fogFar: { value: 2e3 },\n    fogColor: { value: /* @__PURE__ */ new Color(16777215) }\n  },\n  lights: {\n    ambientLightColor: { value: [] },\n    lightProbe: { value: [] },\n    directionalLights: { value: [], properties: {\n      direction: {},\n      color: {}\n    } },\n    directionalLightShadows: { value: [], properties: {\n      shadowIntensity: 1,\n      shadowBias: {},\n      shadowNormalBias: {},\n      shadowRadius: {},\n      shadowMapSize: {}\n    } },\n    directionalShadowMap: { value: [] },\n    directionalShadowMatrix: { value: [] },\n    spotLights: { value: [], properties: {\n      color: {},\n      position: {},\n      direction: {},\n      distance: {},\n      coneCos: {},\n      penumbraCos: {},\n      decay: {}\n    } },\n    spotLightShadows: { value: [], properties: {\n      shadowIntensity: 1,\n      shadowBias: {},\n      shadowNormalBias: {},\n      shadowRadius: {},\n      shadowMapSize: {}\n    } },\n    spotLightMap: { value: [] },\n    spotShadowMap: { value: [] },\n    spotLightMatrix: { value: [] },\n    pointLights: { value: [], properties: {\n      color: {},\n      position: {},\n      decay: {},\n      distance: {}\n    } },\n    pointLightShadows: { value: [], properties: {\n      shadowIntensity: 1,\n      shadowBias: {},\n      shadowNormalBias: {},\n      shadowRadius: {},\n      shadowMapSize: {},\n      shadowCameraNear: {},\n      shadowCameraFar: {}\n    } },\n    pointShadowMap: { value: [] },\n    pointShadowMatrix: { value: [] },\n    hemisphereLights: { value: [], properties: {\n      direction: {},\n      skyColor: {},\n      groundColor: {}\n    } },\n    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n    rectAreaLights: { value: [], properties: {\n      color: {},\n      position: {},\n      width: {},\n      height: {}\n    } },\n    ltc_1: { value: null },\n    ltc_2: { value: null }\n  },\n  points: {\n    diffuse: { value: /* @__PURE__ */ new Color(16777215) },\n    opacity: { value: 1 },\n    size: { value: 1 },\n    scale: { value: 1 },\n    map: { value: null },\n    alphaMap: { value: null },\n    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n    alphaTest: { value: 0 },\n    uvTransform: { value: /* @__PURE__ */ new Matrix3() }\n  },\n  sprite: {\n    diffuse: { value: /* @__PURE__ */ new Color(16777215) },\n    opacity: { value: 1 },\n    center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },\n    rotation: { value: 0 },\n    map: { value: null },\n    mapTransform: { value: /* @__PURE__ */ new Matrix3() },\n    alphaMap: { value: null },\n    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n    alphaTest: { value: 0 }\n  }\n};\nconst ShaderLib = {\n  basic: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.specularmap,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.fog\n    ]),\n    vertexShader: ShaderChunk.meshbasic_vert,\n    fragmentShader: ShaderChunk.meshbasic_frag\n  },\n  lambert: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.specularmap,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: { value: /* @__PURE__ */ new Color(0) }\n      }\n    ]),\n    vertexShader: ShaderChunk.meshlambert_vert,\n    fragmentShader: ShaderChunk.meshlambert_frag\n  },\n  phong: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.specularmap,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: { value: /* @__PURE__ */ new Color(0) },\n        specular: { value: /* @__PURE__ */ new Color(1118481) },\n        shininess: { value: 30 }\n      }\n    ]),\n    vertexShader: ShaderChunk.meshphong_vert,\n    fragmentShader: ShaderChunk.meshphong_frag\n  },\n  standard: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.roughnessmap,\n      UniformsLib.metalnessmap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: { value: /* @__PURE__ */ new Color(0) },\n        roughness: { value: 1 },\n        metalness: { value: 0 },\n        envMapIntensity: { value: 1 }\n      }\n    ]),\n    vertexShader: ShaderChunk.meshphysical_vert,\n    fragmentShader: ShaderChunk.meshphysical_frag\n  },\n  toon: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.gradientmap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: { value: /* @__PURE__ */ new Color(0) }\n      }\n    ]),\n    vertexShader: ShaderChunk.meshtoon_vert,\n    fragmentShader: ShaderChunk.meshtoon_frag\n  },\n  matcap: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.fog,\n      {\n        matcap: { value: null }\n      }\n    ]),\n    vertexShader: ShaderChunk.meshmatcap_vert,\n    fragmentShader: ShaderChunk.meshmatcap_frag\n  },\n  points: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.points,\n      UniformsLib.fog\n    ]),\n    vertexShader: ShaderChunk.points_vert,\n    fragmentShader: ShaderChunk.points_frag\n  },\n  dashed: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.fog,\n      {\n        scale: { value: 1 },\n        dashSize: { value: 1 },\n        totalSize: { value: 2 }\n      }\n    ]),\n    vertexShader: ShaderChunk.linedashed_vert,\n    fragmentShader: ShaderChunk.linedashed_frag\n  },\n  depth: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.displacementmap\n    ]),\n    vertexShader: ShaderChunk.depth_vert,\n    fragmentShader: ShaderChunk.depth_frag\n  },\n  normal: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      {\n        opacity: { value: 1 }\n      }\n    ]),\n    vertexShader: ShaderChunk.meshnormal_vert,\n    fragmentShader: ShaderChunk.meshnormal_frag\n  },\n  sprite: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.sprite,\n      UniformsLib.fog\n    ]),\n    vertexShader: ShaderChunk.sprite_vert,\n    fragmentShader: ShaderChunk.sprite_frag\n  },\n  background: {\n    uniforms: {\n      uvTransform: { value: /* @__PURE__ */ new Matrix3() },\n      t2D: { value: null },\n      backgroundIntensity: { value: 1 }\n    },\n    vertexShader: ShaderChunk.background_vert,\n    fragmentShader: ShaderChunk.background_frag\n  },\n  backgroundCube: {\n    uniforms: {\n      envMap: { value: null },\n      flipEnvMap: { value: -1 },\n      backgroundBlurriness: { value: 0 },\n      backgroundIntensity: { value: 1 },\n      backgroundRotation: { value: /* @__PURE__ */ new Matrix3() }\n    },\n    vertexShader: ShaderChunk.backgroundCube_vert,\n    fragmentShader: ShaderChunk.backgroundCube_frag\n  },\n  cube: {\n    uniforms: {\n      tCube: { value: null },\n      tFlip: { value: -1 },\n      opacity: { value: 1 }\n    },\n    vertexShader: ShaderChunk.cube_vert,\n    fragmentShader: ShaderChunk.cube_frag\n  },\n  equirect: {\n    uniforms: {\n      tEquirect: { value: null }\n    },\n    vertexShader: ShaderChunk.equirect_vert,\n    fragmentShader: ShaderChunk.equirect_frag\n  },\n  distanceRGBA: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.displacementmap,\n      {\n        referencePosition: { value: /* @__PURE__ */ new Vector3() },\n        nearDistance: { value: 1 },\n        farDistance: { value: 1e3 }\n      }\n    ]),\n    vertexShader: ShaderChunk.distanceRGBA_vert,\n    fragmentShader: ShaderChunk.distanceRGBA_frag\n  },\n  shadow: {\n    uniforms: /* @__PURE__ */ mergeUniforms([\n      UniformsLib.lights,\n      UniformsLib.fog,\n      {\n        color: { value: /* @__PURE__ */ new Color(0) },\n        opacity: { value: 1 }\n      }\n    ]),\n    vertexShader: ShaderChunk.shadow_vert,\n    fragmentShader: ShaderChunk.shadow_frag\n  }\n};\nShaderLib.physical = {\n  uniforms: /* @__PURE__ */ mergeUniforms([\n    ShaderLib.standard.uniforms,\n    {\n      clearcoat: { value: 0 },\n      clearcoatMap: { value: null },\n      clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n      clearcoatNormalMap: { value: null },\n      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n      clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },\n      clearcoatRoughness: { value: 0 },\n      clearcoatRoughnessMap: { value: null },\n      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n      dispersion: { value: 0 },\n      iridescence: { value: 0 },\n      iridescenceMap: { value: null },\n      iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n      iridescenceIOR: { value: 1.3 },\n      iridescenceThicknessMinimum: { value: 100 },\n      iridescenceThicknessMaximum: { value: 400 },\n      iridescenceThicknessMap: { value: null },\n      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n      sheen: { value: 0 },\n      sheenColor: { value: /* @__PURE__ */ new Color(0) },\n      sheenColorMap: { value: null },\n      sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n      sheenRoughness: { value: 1 },\n      sheenRoughnessMap: { value: null },\n      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n      transmission: { value: 0 },\n      transmissionMap: { value: null },\n      transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n      transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },\n      transmissionSamplerMap: { value: null },\n      thickness: { value: 0 },\n      thicknessMap: { value: null },\n      thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n      attenuationDistance: { value: 0 },\n      attenuationColor: { value: /* @__PURE__ */ new Color(0) },\n      specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },\n      specularColorMap: { value: null },\n      specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n      specularIntensity: { value: 1 },\n      specularIntensityMap: { value: null },\n      specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },\n      anisotropyVector: { value: /* @__PURE__ */ new Vector2() },\n      anisotropyMap: { value: null },\n      anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() }\n    }\n  ]),\n  vertexShader: ShaderChunk.meshphysical_vert,\n  fragmentShader: ShaderChunk.meshphysical_frag\n};\nconst _rgb = { r: 0, b: 0, g: 0 };\nconst _e1$1 = /* @__PURE__ */ new Euler();\nconst _m1$1 = /* @__PURE__ */ new Matrix4();\nfunction WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {\n  const clearColor = new Color(0);\n  let clearAlpha = alpha === true ? 0 : 1;\n  let planeMesh;\n  let boxMesh;\n  let currentBackground = null;\n  let currentBackgroundVersion = 0;\n  let currentTonemapping = null;\n  function getBackground(scene) {\n    let background = scene.isScene === true ? scene.background : null;\n    if (background && background.isTexture) {\n      const usePMREM = scene.backgroundBlurriness > 0;\n      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);\n    }\n    return background;\n  }\n  function render(scene) {\n    let forceClear = false;\n    const background = getBackground(scene);\n    if (background === null) {\n      setClear(clearColor, clearAlpha);\n    } else if (background && background.isColor) {\n      setClear(background, 1);\n      forceClear = true;\n    }\n    const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();\n    if (environmentBlendMode === \"additive\") {\n      state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);\n    } else if (environmentBlendMode === \"alpha-blend\") {\n      state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);\n    }\n    if (renderer.autoClear || forceClear) {\n      state.buffers.depth.setTest(true);\n      state.buffers.depth.setMask(true);\n      state.buffers.color.setMask(true);\n      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n    }\n  }\n  function addToRenderList(renderList2, scene) {\n    const background = getBackground(scene);\n    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {\n      if (boxMesh === void 0) {\n        boxMesh = new Mesh(\n          new BoxGeometry(1, 1, 1),\n          new ShaderMaterial({\n            name: \"BackgroundCubeMaterial\",\n            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),\n            vertexShader: ShaderLib.backgroundCube.vertexShader,\n            fragmentShader: ShaderLib.backgroundCube.fragmentShader,\n            side: BackSide,\n            depthTest: false,\n            depthWrite: false,\n            fog: false\n          })\n        );\n        boxMesh.geometry.deleteAttribute(\"normal\");\n        boxMesh.geometry.deleteAttribute(\"uv\");\n        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {\n          this.matrixWorld.copyPosition(camera.matrixWorld);\n        };\n        Object.defineProperty(boxMesh.material, \"envMap\", {\n          get: function() {\n            return this.uniforms.envMap.value;\n          }\n        });\n        objects.update(boxMesh);\n      }\n      _e1$1.copy(scene.backgroundRotation);\n      _e1$1.x *= -1;\n      _e1$1.y *= -1;\n      _e1$1.z *= -1;\n      if (background.isCubeTexture && background.isRenderTargetTexture === false) {\n        _e1$1.y *= -1;\n        _e1$1.z *= -1;\n      }\n      boxMesh.material.uniforms.envMap.value = background;\n      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;\n      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;\n      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n      boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1));\n      boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;\n      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n        boxMesh.material.needsUpdate = true;\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      }\n      boxMesh.layers.enableAll();\n      renderList2.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);\n    } else if (background && background.isTexture) {\n      if (planeMesh === void 0) {\n        planeMesh = new Mesh(\n          new PlaneGeometry(2, 2),\n          new ShaderMaterial({\n            name: \"BackgroundMaterial\",\n            uniforms: cloneUniforms(ShaderLib.background.uniforms),\n            vertexShader: ShaderLib.background.vertexShader,\n            fragmentShader: ShaderLib.background.fragmentShader,\n            side: FrontSide,\n            depthTest: false,\n            depthWrite: false,\n            fog: false\n          })\n        );\n        planeMesh.geometry.deleteAttribute(\"normal\");\n        Object.defineProperty(planeMesh.material, \"map\", {\n          get: function() {\n            return this.uniforms.t2D.value;\n          }\n        });\n        objects.update(planeMesh);\n      }\n      planeMesh.material.uniforms.t2D.value = background;\n      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n      planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;\n      if (background.matrixAutoUpdate === true) {\n        background.updateMatrix();\n      }\n      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);\n      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n        planeMesh.material.needsUpdate = true;\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      }\n      planeMesh.layers.enableAll();\n      renderList2.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);\n    }\n  }\n  function setClear(color, alpha2) {\n    color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));\n    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);\n  }\n  return {\n    getClearColor: function() {\n      return clearColor;\n    },\n    setClearColor: function(color, alpha2 = 1) {\n      clearColor.set(color);\n      clearAlpha = alpha2;\n      setClear(clearColor, clearAlpha);\n    },\n    getClearAlpha: function() {\n      return clearAlpha;\n    },\n    setClearAlpha: function(alpha2) {\n      clearAlpha = alpha2;\n      setClear(clearColor, clearAlpha);\n    },\n    render,\n    addToRenderList\n  };\n}\nfunction WebGLBindingStates(gl, attributes) {\n  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n  const bindingStates = {};\n  const defaultState = createBindingState(null);\n  let currentState = defaultState;\n  let forceUpdate = false;\n  function setup(object, material, program, geometry, index) {\n    let updateBuffers = false;\n    const state = getBindingState(geometry, program, material);\n    if (currentState !== state) {\n      currentState = state;\n      bindVertexArrayObject(currentState.object);\n    }\n    updateBuffers = needsUpdate(object, geometry, program, index);\n    if (updateBuffers) saveCache(object, geometry, program, index);\n    if (index !== null) {\n      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);\n    }\n    if (updateBuffers || forceUpdate) {\n      forceUpdate = false;\n      setupVertexAttributes(object, material, program, geometry);\n      if (index !== null) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);\n      }\n    }\n  }\n  function createVertexArrayObject() {\n    return gl.createVertexArray();\n  }\n  function bindVertexArrayObject(vao) {\n    return gl.bindVertexArray(vao);\n  }\n  function deleteVertexArrayObject(vao) {\n    return gl.deleteVertexArray(vao);\n  }\n  function getBindingState(geometry, program, material) {\n    const wireframe = material.wireframe === true;\n    let programMap = bindingStates[geometry.id];\n    if (programMap === void 0) {\n      programMap = {};\n      bindingStates[geometry.id] = programMap;\n    }\n    let stateMap = programMap[program.id];\n    if (stateMap === void 0) {\n      stateMap = {};\n      programMap[program.id] = stateMap;\n    }\n    let state = stateMap[wireframe];\n    if (state === void 0) {\n      state = createBindingState(createVertexArrayObject());\n      stateMap[wireframe] = state;\n    }\n    return state;\n  }\n  function createBindingState(vao) {\n    const newAttributes = [];\n    const enabledAttributes = [];\n    const attributeDivisors = [];\n    for (let i = 0; i < maxVertexAttributes; i++) {\n      newAttributes[i] = 0;\n      enabledAttributes[i] = 0;\n      attributeDivisors[i] = 0;\n    }\n    return {\n      // for backward compatibility on non-VAO support browser\n      geometry: null,\n      program: null,\n      wireframe: false,\n      newAttributes,\n      enabledAttributes,\n      attributeDivisors,\n      object: vao,\n      attributes: {},\n      index: null\n    };\n  }\n  function needsUpdate(object, geometry, program, index) {\n    const cachedAttributes = currentState.attributes;\n    const geometryAttributes = geometry.attributes;\n    let attributesNum = 0;\n    const programAttributes = program.getAttributes();\n    for (const name in programAttributes) {\n      const programAttribute = programAttributes[name];\n      if (programAttribute.location >= 0) {\n        const cachedAttribute = cachedAttributes[name];\n        let geometryAttribute = geometryAttributes[name];\n        if (geometryAttribute === void 0) {\n          if (name === \"instanceMatrix\" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;\n          if (name === \"instanceColor\" && object.instanceColor) geometryAttribute = object.instanceColor;\n        }\n        if (cachedAttribute === void 0) return true;\n        if (cachedAttribute.attribute !== geometryAttribute) return true;\n        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;\n        attributesNum++;\n      }\n    }\n    if (currentState.attributesNum !== attributesNum) return true;\n    if (currentState.index !== index) return true;\n    return false;\n  }\n  function saveCache(object, geometry, program, index) {\n    const cache2 = {};\n    const attributes2 = geometry.attributes;\n    let attributesNum = 0;\n    const programAttributes = program.getAttributes();\n    for (const name in programAttributes) {\n      const programAttribute = programAttributes[name];\n      if (programAttribute.location >= 0) {\n        let attribute = attributes2[name];\n        if (attribute === void 0) {\n          if (name === \"instanceMatrix\" && object.instanceMatrix) attribute = object.instanceMatrix;\n          if (name === \"instanceColor\" && object.instanceColor) attribute = object.instanceColor;\n        }\n        const data = {};\n        data.attribute = attribute;\n        if (attribute && attribute.data) {\n          data.data = attribute.data;\n        }\n        cache2[name] = data;\n        attributesNum++;\n      }\n    }\n    currentState.attributes = cache2;\n    currentState.attributesNum = attributesNum;\n    currentState.index = index;\n  }\n  function initAttributes() {\n    const newAttributes = currentState.newAttributes;\n    for (let i = 0, il = newAttributes.length; i < il; i++) {\n      newAttributes[i] = 0;\n    }\n  }\n  function enableAttribute(attribute) {\n    enableAttributeAndDivisor(attribute, 0);\n  }\n  function enableAttributeAndDivisor(attribute, meshPerAttribute) {\n    const newAttributes = currentState.newAttributes;\n    const enabledAttributes = currentState.enabledAttributes;\n    const attributeDivisors = currentState.attributeDivisors;\n    newAttributes[attribute] = 1;\n    if (enabledAttributes[attribute] === 0) {\n      gl.enableVertexAttribArray(attribute);\n      enabledAttributes[attribute] = 1;\n    }\n    if (attributeDivisors[attribute] !== meshPerAttribute) {\n      gl.vertexAttribDivisor(attribute, meshPerAttribute);\n      attributeDivisors[attribute] = meshPerAttribute;\n    }\n  }\n  function disableUnusedAttributes() {\n    const newAttributes = currentState.newAttributes;\n    const enabledAttributes = currentState.enabledAttributes;\n    for (let i = 0, il = enabledAttributes.length; i < il; i++) {\n      if (enabledAttributes[i] !== newAttributes[i]) {\n        gl.disableVertexAttribArray(i);\n        enabledAttributes[i] = 0;\n      }\n    }\n  }\n  function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {\n    if (integer === true) {\n      gl.vertexAttribIPointer(index, size, type, stride, offset);\n    } else {\n      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);\n    }\n  }\n  function setupVertexAttributes(object, material, program, geometry) {\n    initAttributes();\n    const geometryAttributes = geometry.attributes;\n    const programAttributes = program.getAttributes();\n    const materialDefaultAttributeValues = material.defaultAttributeValues;\n    for (const name in programAttributes) {\n      const programAttribute = programAttributes[name];\n      if (programAttribute.location >= 0) {\n        let geometryAttribute = geometryAttributes[name];\n        if (geometryAttribute === void 0) {\n          if (name === \"instanceMatrix\" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;\n          if (name === \"instanceColor\" && object.instanceColor) geometryAttribute = object.instanceColor;\n        }\n        if (geometryAttribute !== void 0) {\n          const normalized = geometryAttribute.normalized;\n          const size = geometryAttribute.itemSize;\n          const attribute = attributes.get(geometryAttribute);\n          if (attribute === void 0) continue;\n          const buffer = attribute.buffer;\n          const type = attribute.type;\n          const bytesPerElement = attribute.bytesPerElement;\n          const integer = type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType;\n          if (geometryAttribute.isInterleavedBufferAttribute) {\n            const data = geometryAttribute.data;\n            const stride = data.stride;\n            const offset = geometryAttribute.offset;\n            if (data.isInstancedInterleavedBuffer) {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);\n              }\n              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {\n                geometry._maxInstanceCount = data.meshPerAttribute * data.count;\n              }\n            } else {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttribute(programAttribute.location + i);\n              }\n            }\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            for (let i = 0; i < programAttribute.locationSize; i++) {\n              vertexAttribPointer(\n                programAttribute.location + i,\n                size / programAttribute.locationSize,\n                type,\n                normalized,\n                stride * bytesPerElement,\n                (offset + size / programAttribute.locationSize * i) * bytesPerElement,\n                integer\n              );\n            }\n          } else {\n            if (geometryAttribute.isInstancedBufferAttribute) {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);\n              }\n              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {\n                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n              }\n            } else {\n              for (let i = 0; i < programAttribute.locationSize; i++) {\n                enableAttribute(programAttribute.location + i);\n              }\n            }\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            for (let i = 0; i < programAttribute.locationSize; i++) {\n              vertexAttribPointer(\n                programAttribute.location + i,\n                size / programAttribute.locationSize,\n                type,\n                normalized,\n                size * bytesPerElement,\n                size / programAttribute.locationSize * i * bytesPerElement,\n                integer\n              );\n            }\n          }\n        } else if (materialDefaultAttributeValues !== void 0) {\n          const value = materialDefaultAttributeValues[name];\n          if (value !== void 0) {\n            switch (value.length) {\n              case 2:\n                gl.vertexAttrib2fv(programAttribute.location, value);\n                break;\n              case 3:\n                gl.vertexAttrib3fv(programAttribute.location, value);\n                break;\n              case 4:\n                gl.vertexAttrib4fv(programAttribute.location, value);\n                break;\n              default:\n                gl.vertexAttrib1fv(programAttribute.location, value);\n            }\n          }\n        }\n      }\n    }\n    disableUnusedAttributes();\n  }\n  function dispose() {\n    reset();\n    for (const geometryId in bindingStates) {\n      const programMap = bindingStates[geometryId];\n      for (const programId in programMap) {\n        const stateMap = programMap[programId];\n        for (const wireframe in stateMap) {\n          deleteVertexArrayObject(stateMap[wireframe].object);\n          delete stateMap[wireframe];\n        }\n        delete programMap[programId];\n      }\n      delete bindingStates[geometryId];\n    }\n  }\n  function releaseStatesOfGeometry(geometry) {\n    if (bindingStates[geometry.id] === void 0) return;\n    const programMap = bindingStates[geometry.id];\n    for (const programId in programMap) {\n      const stateMap = programMap[programId];\n      for (const wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n      delete programMap[programId];\n    }\n    delete bindingStates[geometry.id];\n  }\n  function releaseStatesOfProgram(program) {\n    for (const geometryId in bindingStates) {\n      const programMap = bindingStates[geometryId];\n      if (programMap[program.id] === void 0) continue;\n      const stateMap = programMap[program.id];\n      for (const wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n      delete programMap[program.id];\n    }\n  }\n  function reset() {\n    resetDefaultState();\n    forceUpdate = true;\n    if (currentState === defaultState) return;\n    currentState = defaultState;\n    bindVertexArrayObject(currentState.object);\n  }\n  function resetDefaultState() {\n    defaultState.geometry = null;\n    defaultState.program = null;\n    defaultState.wireframe = false;\n  }\n  return {\n    setup,\n    reset,\n    resetDefaultState,\n    dispose,\n    releaseStatesOfGeometry,\n    releaseStatesOfProgram,\n    initAttributes,\n    enableAttribute,\n    disableUnusedAttributes\n  };\n}\nfunction WebGLBufferRenderer(gl, extensions, info) {\n  let mode;\n  function setMode(value) {\n    mode = value;\n  }\n  function render(start, count) {\n    gl.drawArrays(mode, start, count);\n    info.update(count, mode, 1);\n  }\n  function renderInstances(start, count, primcount) {\n    if (primcount === 0) return;\n    gl.drawArraysInstanced(mode, start, count, primcount);\n    info.update(count, mode, primcount);\n  }\n  function renderMultiDraw(starts, counts, drawCount) {\n    if (drawCount === 0) return;\n    const extension = extensions.get(\"WEBGL_multi_draw\");\n    extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);\n    let elementCount = 0;\n    for (let i = 0; i < drawCount; i++) {\n      elementCount += counts[i];\n    }\n    info.update(elementCount, mode, 1);\n  }\n  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {\n    if (drawCount === 0) return;\n    const extension = extensions.get(\"WEBGL_multi_draw\");\n    if (extension === null) {\n      for (let i = 0; i < starts.length; i++) {\n        renderInstances(starts[i], counts[i], primcount[i]);\n      }\n    } else {\n      extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);\n      let elementCount = 0;\n      for (let i = 0; i < drawCount; i++) {\n        elementCount += counts[i] * primcount[i];\n      }\n      info.update(elementCount, mode, 1);\n    }\n  }\n  this.setMode = setMode;\n  this.render = render;\n  this.renderInstances = renderInstances;\n  this.renderMultiDraw = renderMultiDraw;\n  this.renderMultiDrawInstances = renderMultiDrawInstances;\n}\nfunction WebGLCapabilities(gl, extensions, parameters, utils) {\n  let maxAnisotropy;\n  function getMaxAnisotropy() {\n    if (maxAnisotropy !== void 0) return maxAnisotropy;\n    if (extensions.has(\"EXT_texture_filter_anisotropic\") === true) {\n      const extension = extensions.get(\"EXT_texture_filter_anisotropic\");\n      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n    } else {\n      maxAnisotropy = 0;\n    }\n    return maxAnisotropy;\n  }\n  function textureFormatReadable(textureFormat) {\n    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {\n      return false;\n    }\n    return true;\n  }\n  function textureTypeReadable(textureType) {\n    const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has(\"EXT_color_buffer_half_float\") || extensions.has(\"EXT_color_buffer_float\"));\n    if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)\n    textureType !== FloatType && !halfFloatSupportedByExt) {\n      return false;\n    }\n    return true;\n  }\n  function getMaxPrecision(precision2) {\n    if (precision2 === \"highp\") {\n      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {\n        return \"highp\";\n      }\n      precision2 = \"mediump\";\n    }\n    if (precision2 === \"mediump\") {\n      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {\n        return \"mediump\";\n      }\n    }\n    return \"lowp\";\n  }\n  let precision = parameters.precision !== void 0 ? parameters.precision : \"highp\";\n  const maxPrecision = getMaxPrecision(precision);\n  if (maxPrecision !== precision) {\n    console.warn(\"THREE.WebGLRenderer:\", precision, \"not supported, using\", maxPrecision, \"instead.\");\n    precision = maxPrecision;\n  }\n  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n  const reverseDepthBuffer = parameters.reverseDepthBuffer === true && extensions.has(\"EXT_clip_control\");\n  const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n  const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n  const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n  const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n  const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);\n  const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n  const vertexTextures = maxVertexTextures > 0;\n  const maxSamples = gl.getParameter(gl.MAX_SAMPLES);\n  return {\n    isWebGL2: true,\n    // keeping this for backwards compatibility\n    getMaxAnisotropy,\n    getMaxPrecision,\n    textureFormatReadable,\n    textureTypeReadable,\n    precision,\n    logarithmicDepthBuffer,\n    reverseDepthBuffer,\n    maxTextures,\n    maxVertexTextures,\n    maxTextureSize,\n    maxCubemapSize,\n    maxAttributes,\n    maxVertexUniforms,\n    maxVaryings,\n    maxFragmentUniforms,\n    vertexTextures,\n    maxSamples\n  };\n}\nfunction WebGLClipping(properties) {\n  const scope = this;\n  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;\n  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };\n  this.uniform = uniform;\n  this.numPlanes = 0;\n  this.numIntersection = 0;\n  this.init = function(planes, enableLocalClipping) {\n    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to\n    // run another frame in order to reset the state:\n    numGlobalPlanes !== 0 || localClippingEnabled;\n    localClippingEnabled = enableLocalClipping;\n    numGlobalPlanes = planes.length;\n    return enabled;\n  };\n  this.beginShadows = function() {\n    renderingShadows = true;\n    projectPlanes(null);\n  };\n  this.endShadows = function() {\n    renderingShadows = false;\n  };\n  this.setGlobalState = function(planes, camera) {\n    globalState = projectPlanes(planes, camera, 0);\n  };\n  this.setState = function(material, camera, useCache) {\n    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;\n    const materialProperties = properties.get(material);\n    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {\n      if (renderingShadows) {\n        projectPlanes(null);\n      } else {\n        resetGlobalState();\n      }\n    } else {\n      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;\n      let dstArray = materialProperties.clippingState || null;\n      uniform.value = dstArray;\n      dstArray = projectPlanes(planes, camera, lGlobal, useCache);\n      for (let i = 0; i !== lGlobal; ++i) {\n        dstArray[i] = globalState[i];\n      }\n      materialProperties.clippingState = dstArray;\n      this.numIntersection = clipIntersection ? this.numPlanes : 0;\n      this.numPlanes += nGlobal;\n    }\n  };\n  function resetGlobalState() {\n    if (uniform.value !== globalState) {\n      uniform.value = globalState;\n      uniform.needsUpdate = numGlobalPlanes > 0;\n    }\n    scope.numPlanes = numGlobalPlanes;\n    scope.numIntersection = 0;\n  }\n  function projectPlanes(planes, camera, dstOffset, skipTransform) {\n    const nPlanes = planes !== null ? planes.length : 0;\n    let dstArray = null;\n    if (nPlanes !== 0) {\n      dstArray = uniform.value;\n      if (skipTransform !== true || dstArray === null) {\n        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;\n        viewNormalMatrix.getNormalMatrix(viewMatrix);\n        if (dstArray === null || dstArray.length < flatSize) {\n          dstArray = new Float32Array(flatSize);\n        }\n        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {\n          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);\n          plane.normal.toArray(dstArray, i4);\n          dstArray[i4 + 3] = plane.constant;\n        }\n      }\n      uniform.value = dstArray;\n      uniform.needsUpdate = true;\n    }\n    scope.numPlanes = nPlanes;\n    scope.numIntersection = 0;\n    return dstArray;\n  }\n}\nfunction WebGLCubeMaps(renderer) {\n  let cubemaps = /* @__PURE__ */ new WeakMap();\n  function mapTextureMapping(texture, mapping) {\n    if (mapping === EquirectangularReflectionMapping) {\n      texture.mapping = CubeReflectionMapping;\n    } else if (mapping === EquirectangularRefractionMapping) {\n      texture.mapping = CubeRefractionMapping;\n    }\n    return texture;\n  }\n  function get(texture) {\n    if (texture && texture.isTexture) {\n      const mapping = texture.mapping;\n      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {\n        if (cubemaps.has(texture)) {\n          const cubemap = cubemaps.get(texture).texture;\n          return mapTextureMapping(cubemap, texture.mapping);\n        } else {\n          const image = texture.image;\n          if (image && image.height > 0) {\n            const renderTarget = new WebGLCubeRenderTarget(image.height);\n            renderTarget.fromEquirectangularTexture(renderer, texture);\n            cubemaps.set(texture, renderTarget);\n            texture.addEventListener(\"dispose\", onTextureDispose);\n            return mapTextureMapping(renderTarget.texture, texture.mapping);\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n    return texture;\n  }\n  function onTextureDispose(event) {\n    const texture = event.target;\n    texture.removeEventListener(\"dispose\", onTextureDispose);\n    const cubemap = cubemaps.get(texture);\n    if (cubemap !== void 0) {\n      cubemaps.delete(texture);\n      cubemap.dispose();\n    }\n  }\n  function dispose() {\n    cubemaps = /* @__PURE__ */ new WeakMap();\n  }\n  return {\n    get,\n    dispose\n  };\n}\nclass OrthographicCamera extends Camera {\n  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {\n    super();\n    this.isOrthographicCamera = true;\n    this.type = \"OrthographicCamera\";\n    this.zoom = 1;\n    this.view = null;\n    this.left = left;\n    this.right = right;\n    this.top = top;\n    this.bottom = bottom;\n    this.near = near;\n    this.far = far;\n    this.updateProjectionMatrix();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.left = source.left;\n    this.right = source.right;\n    this.top = source.top;\n    this.bottom = source.bottom;\n    this.near = source.near;\n    this.far = source.far;\n    this.zoom = source.zoom;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n    return this;\n  }\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  }\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n    this.updateProjectionMatrix();\n  }\n  updateProjectionMatrix() {\n    const dx = (this.right - this.left) / (2 * this.zoom);\n    const dy = (this.top - this.bottom) / (2 * this.zoom);\n    const cx = (this.right + this.left) / 2;\n    const cy = (this.top + this.bottom) / 2;\n    let left = cx - dx;\n    let right = cx + dx;\n    let top = cy + dy;\n    let bottom = cy - dy;\n    if (this.view !== null && this.view.enabled) {\n      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;\n      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n      left += scaleW * this.view.offsetX;\n      right = left + scaleW * this.view.width;\n      top -= scaleH * this.view.offsetY;\n      bottom = top - scaleH * this.view.height;\n    }\n    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.zoom = this.zoom;\n    data.object.left = this.left;\n    data.object.right = this.right;\n    data.object.top = this.top;\n    data.object.bottom = this.bottom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n    if (this.view !== null) data.object.view = Object.assign({}, this.view);\n    return data;\n  }\n}\nconst LOD_MIN = 4;\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\nconst MAX_SAMPLES = 20;\nconst _flatCamera = /* @__PURE__ */ new OrthographicCamera();\nconst _clearColor = /* @__PURE__ */ new Color();\nlet _oldTarget = null;\nlet _oldActiveCubeFace = 0;\nlet _oldActiveMipmapLevel = 0;\nlet _oldXrEnabled = false;\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI;\nconst _axisDirections = [\n  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0),\n  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),\n  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),\n  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),\n  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),\n  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),\n  /* @__PURE__ */ new Vector3(-1, 1, -1),\n  /* @__PURE__ */ new Vector3(1, 1, -1),\n  /* @__PURE__ */ new Vector3(-1, 1, 1),\n  /* @__PURE__ */ new Vector3(1, 1, 1)\n];\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._lodMax = 0;\n    this._cubeSize = 0;\n    this._lodPlanes = [];\n    this._sizeLods = [];\n    this._sigmas = [];\n    this._blurMaterial = null;\n    this._cubemapMaterial = null;\n    this._equirectMaterial = null;\n    this._compileMaterial(this._blurMaterial);\n  }\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n  fromScene(scene, sigma = 0, near = 0.1, far = 100) {\n    _oldTarget = this._renderer.getRenderTarget();\n    _oldActiveCubeFace = this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n    _oldXrEnabled = this._renderer.xr.enabled;\n    this._renderer.xr.enabled = false;\n    this._setSize(256);\n    const cubeUVRenderTarget = this._allocateTargets();\n    cubeUVRenderTarget.depthBuffer = true;\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * or HDR. The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   * The smallest supported equirectangular image size is 64 x 32.\n   */\n  fromEquirectangular(equirectangular, renderTarget = null) {\n    return this._fromTexture(equirectangular, renderTarget);\n  }\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * or HDR. The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   * The smallest supported cube size is 16 x 16.\n   */\n  fromCubemap(cubemap, renderTarget = null) {\n    return this._fromTexture(cubemap, renderTarget);\n  }\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  compileCubemapShader() {\n    if (this._cubemapMaterial === null) {\n      this._cubemapMaterial = _getCubemapMaterial();\n      this._compileMaterial(this._cubemapMaterial);\n    }\n  }\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n  compileEquirectangularShader() {\n    if (this._equirectMaterial === null) {\n      this._equirectMaterial = _getEquirectMaterial();\n      this._compileMaterial(this._equirectMaterial);\n    }\n  }\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n  dispose() {\n    this._dispose();\n    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();\n    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();\n  }\n  // private interface\n  _setSize(cubeSize) {\n    this._lodMax = Math.floor(Math.log2(cubeSize));\n    this._cubeSize = Math.pow(2, this._lodMax);\n  }\n  _dispose() {\n    if (this._blurMaterial !== null) this._blurMaterial.dispose();\n    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();\n    for (let i = 0; i < this._lodPlanes.length; i++) {\n      this._lodPlanes[i].dispose();\n    }\n  }\n  _cleanup(outputTarget) {\n    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);\n    this._renderer.xr.enabled = _oldXrEnabled;\n    outputTarget.scissorTest = false;\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n  _fromTexture(texture, renderTarget) {\n    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {\n      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);\n    } else {\n      this._setSize(texture.image.width / 4);\n    }\n    _oldTarget = this._renderer.getRenderTarget();\n    _oldActiveCubeFace = this._renderer.getActiveCubeFace();\n    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();\n    _oldXrEnabled = this._renderer.xr.enabled;\n    this._renderer.xr.enabled = false;\n    const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  _allocateTargets() {\n    const width = 3 * Math.max(this._cubeSize, 16 * 7);\n    const height = 4 * this._cubeSize;\n    const params = {\n      magFilter: LinearFilter,\n      minFilter: LinearFilter,\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      colorSpace: LinearSRGBColorSpace,\n      depthBuffer: false\n    };\n    const cubeUVRenderTarget = _createRenderTarget(width, height, params);\n    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {\n      if (this._pingPongRenderTarget !== null) {\n        this._dispose();\n      }\n      this._pingPongRenderTarget = _createRenderTarget(width, height, params);\n      const { _lodMax } = this;\n      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));\n      this._blurMaterial = _getBlurShader(_lodMax, width, height);\n    }\n    return cubeUVRenderTarget;\n  }\n  _compileMaterial(material) {\n    const tmpMesh = new Mesh(this._lodPlanes[0], material);\n    this._renderer.compile(tmpMesh, _flatCamera);\n  }\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const fov2 = 90;\n    const aspect2 = 1;\n    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);\n    const upSign = [1, -1, 1, 1, 1, 1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const renderer = this._renderer;\n    const originalAutoClear = renderer.autoClear;\n    const toneMapping = renderer.toneMapping;\n    renderer.getClearColor(_clearColor);\n    renderer.toneMapping = NoToneMapping;\n    renderer.autoClear = false;\n    const backgroundMaterial = new MeshBasicMaterial({\n      name: \"PMREM.Background\",\n      side: BackSide,\n      depthWrite: false,\n      depthTest: false\n    });\n    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\n    let useSolidColor = false;\n    const background = scene.background;\n    if (background) {\n      if (background.isColor) {\n        backgroundMaterial.color.copy(background);\n        scene.background = null;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundMaterial.color.copy(_clearColor);\n      useSolidColor = true;\n    }\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n      if (col === 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col === 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n      const size = this._cubeSize;\n      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);\n      renderer.setRenderTarget(cubeUVRenderTarget);\n      if (useSolidColor) {\n        renderer.render(backgroundBox, cubeCamera);\n      }\n      renderer.render(scene, cubeCamera);\n    }\n    backgroundBox.geometry.dispose();\n    backgroundBox.material.dispose();\n    renderer.toneMapping = toneMapping;\n    renderer.autoClear = originalAutoClear;\n    scene.background = background;\n  }\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;\n    if (isCubeTexture) {\n      if (this._cubemapMaterial === null) {\n        this._cubemapMaterial = _getCubemapMaterial();\n      }\n      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;\n    } else {\n      if (this._equirectMaterial === null) {\n        this._equirectMaterial = _getEquirectMaterial();\n      }\n    }\n    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n    const mesh = new Mesh(this._lodPlanes[0], material);\n    const uniforms2 = material.uniforms;\n    uniforms2[\"envMap\"].value = texture;\n    const size = this._cubeSize;\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera);\n  }\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    const n = this._lodPlanes.length;\n    for (let i = 1; i < n; i++) {\n      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);\n      const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n    renderer.autoClear = autoClear;\n  }\n  /**\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\n   * the blur latitudinally (around the poles), and then longitudinally (towards\n   * the poles) to approximate the orthogonally-separable blur. It is least\n   * accurate at the poles, but still does a decent job.\n   */\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n    this._halfBlur(\n      cubeUVRenderTarget,\n      pingPongRenderTarget,\n      lodIn,\n      lodOut,\n      sigma,\n      \"latitudinal\",\n      poleAxis\n    );\n    this._halfBlur(\n      pingPongRenderTarget,\n      cubeUVRenderTarget,\n      lodOut,\n      lodOut,\n      sigma,\n      \"longitudinal\",\n      poleAxis\n    );\n  }\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n    if (direction !== \"latitudinal\" && direction !== \"longitudinal\") {\n      console.error(\n        \"blur direction must be either latitudinal or longitudinal!\"\n      );\n    }\n    const STANDARD_DEVIATIONS = 3;\n    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);\n    const blurUniforms = blurMaterial.uniforms;\n    const pixels = this._sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n    const weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x2 = i / sigmaPixels;\n      const weight = Math.exp(-x2 * x2 / 2);\n      weights.push(weight);\n      if (i === 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n    blurUniforms[\"envMap\"].value = targetIn.texture;\n    blurUniforms[\"samples\"].value = samples;\n    blurUniforms[\"weights\"].value = weights;\n    blurUniforms[\"latitudinal\"].value = direction === \"latitudinal\";\n    if (poleAxis) {\n      blurUniforms[\"poleAxis\"].value = poleAxis;\n    }\n    const { _lodMax } = this;\n    blurUniforms[\"dTheta\"].value = radiansPerPixel;\n    blurUniforms[\"mipInt\"].value = _lodMax - lodIn;\n    const outputSize = this._sizeLods[lodOut];\n    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);\n    const y = 4 * (this._cubeSize - outputSize);\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera);\n  }\n}\nfunction _createPlanes(lodMax) {\n  const lodPlanes = [];\n  const sizeLods = [];\n  const sigmas = [];\n  let lod = lodMax;\n  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n  for (let i = 0; i < totalLods; i++) {\n    const sizeLod = Math.pow(2, lod);\n    sizeLods.push(sizeLod);\n    let sigma = 1 / sizeLod;\n    if (i > lodMax - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];\n    } else if (i === 0) {\n      sigma = 0;\n    }\n    sigmas.push(sigma);\n    const texelSize = 1 / (sizeLod - 2);\n    const min = -texelSize;\n    const max2 = 1 + texelSize;\n    const uv1 = [min, min, max2, min, max2, max2, min, min, max2, max2, min, max2];\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = face % 3 * 2 / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [\n        x,\n        y,\n        0,\n        x + 2 / 3,\n        y,\n        0,\n        x + 2 / 3,\n        y + 1,\n        0,\n        x,\n        y,\n        0,\n        x + 2 / 3,\n        y + 1,\n        0,\n        x,\n        y + 1,\n        0\n      ];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      const fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n    const planes = new BufferGeometry();\n    planes.setAttribute(\"position\", new BufferAttribute(position, positionSize));\n    planes.setAttribute(\"uv\", new BufferAttribute(uv, uvSize));\n    planes.setAttribute(\"faceIndex\", new BufferAttribute(faceIndex, faceIndexSize));\n    lodPlanes.push(planes);\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n  return { lodPlanes, sizeLods, sigmas };\n}\nfunction _createRenderTarget(width, height, params) {\n  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = \"PMREM.cubeUv\";\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\nfunction _getBlurShader(lodMax, width, height) {\n  const weights = new Float32Array(MAX_SAMPLES);\n  const poleAxis = new Vector3(0, 1, 0);\n  const shaderMaterial = new ShaderMaterial({\n    name: \"SphericalGaussianBlur\",\n    defines: {\n      \"n\": MAX_SAMPLES,\n      \"CUBEUV_TEXEL_WIDTH\": 1 / width,\n      \"CUBEUV_TEXEL_HEIGHT\": 1 / height,\n      \"CUBEUV_MAX_MIP\": `${lodMax}.0`\n    },\n    uniforms: {\n      \"envMap\": { value: null },\n      \"samples\": { value: 1 },\n      \"weights\": { value: weights },\n      \"latitudinal\": { value: false },\n      \"dTheta\": { value: 0 },\n      \"mipInt\": { value: 0 },\n      \"poleAxis\": { value: poleAxis }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: (\n      /* glsl */\n      `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`\n    ),\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\nfunction _getEquirectMaterial() {\n  return new ShaderMaterial({\n    name: \"EquirectangularToCubeUV\",\n    uniforms: {\n      \"envMap\": { value: null }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: (\n      /* glsl */\n      `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t`\n    ),\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n}\nfunction _getCubemapMaterial() {\n  return new ShaderMaterial({\n    name: \"CubemapToCubeUV\",\n    uniforms: {\n      \"envMap\": { value: null },\n      \"flipEnvMap\": { value: -1 }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: (\n      /* glsl */\n      `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t`\n    ),\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n}\nfunction _getCommonVertexShader() {\n  return (\n    /* glsl */\n    `\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`\n  );\n}\nfunction WebGLCubeUVMaps(renderer) {\n  let cubeUVmaps = /* @__PURE__ */ new WeakMap();\n  let pmremGenerator = null;\n  function get(texture) {\n    if (texture && texture.isTexture) {\n      const mapping = texture.mapping;\n      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;\n      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;\n      if (isEquirectMap || isCubeMap) {\n        let renderTarget = cubeUVmaps.get(texture);\n        const currentPMREMVersion = renderTarget !== void 0 ? renderTarget.texture.pmremVersion : 0;\n        if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion) {\n          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);\n          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);\n          renderTarget.texture.pmremVersion = texture.pmremVersion;\n          cubeUVmaps.set(texture, renderTarget);\n          return renderTarget.texture;\n        } else {\n          if (renderTarget !== void 0) {\n            return renderTarget.texture;\n          } else {\n            const image = texture.image;\n            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {\n              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);\n              renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);\n              renderTarget.texture.pmremVersion = texture.pmremVersion;\n              cubeUVmaps.set(texture, renderTarget);\n              texture.addEventListener(\"dispose\", onTextureDispose);\n              return renderTarget.texture;\n            } else {\n              return null;\n            }\n          }\n        }\n      }\n    }\n    return texture;\n  }\n  function isCubeTextureComplete(image) {\n    let count = 0;\n    const length = 6;\n    for (let i = 0; i < length; i++) {\n      if (image[i] !== void 0) count++;\n    }\n    return count === length;\n  }\n  function onTextureDispose(event) {\n    const texture = event.target;\n    texture.removeEventListener(\"dispose\", onTextureDispose);\n    const cubemapUV = cubeUVmaps.get(texture);\n    if (cubemapUV !== void 0) {\n      cubeUVmaps.delete(texture);\n      cubemapUV.dispose();\n    }\n  }\n  function dispose() {\n    cubeUVmaps = /* @__PURE__ */ new WeakMap();\n    if (pmremGenerator !== null) {\n      pmremGenerator.dispose();\n      pmremGenerator = null;\n    }\n  }\n  return {\n    get,\n    dispose\n  };\n}\nfunction WebGLExtensions(gl) {\n  const extensions = {};\n  function getExtension(name) {\n    if (extensions[name] !== void 0) {\n      return extensions[name];\n    }\n    let extension;\n    switch (name) {\n      case \"WEBGL_depth_texture\":\n        extension = gl.getExtension(\"WEBGL_depth_texture\") || gl.getExtension(\"MOZ_WEBGL_depth_texture\") || gl.getExtension(\"WEBKIT_WEBGL_depth_texture\");\n        break;\n      case \"EXT_texture_filter_anisotropic\":\n        extension = gl.getExtension(\"EXT_texture_filter_anisotropic\") || gl.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || gl.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\");\n        break;\n      case \"WEBGL_compressed_texture_s3tc\":\n        extension = gl.getExtension(\"WEBGL_compressed_texture_s3tc\") || gl.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\") || gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\");\n        break;\n      case \"WEBGL_compressed_texture_pvrtc\":\n        extension = gl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\");\n        break;\n      default:\n        extension = gl.getExtension(name);\n    }\n    extensions[name] = extension;\n    return extension;\n  }\n  return {\n    has: function(name) {\n      return getExtension(name) !== null;\n    },\n    init: function() {\n      getExtension(\"EXT_color_buffer_float\");\n      getExtension(\"WEBGL_clip_cull_distance\");\n      getExtension(\"OES_texture_float_linear\");\n      getExtension(\"EXT_color_buffer_half_float\");\n      getExtension(\"WEBGL_multisampled_render_to_texture\");\n      getExtension(\"WEBGL_render_shared_exponent\");\n    },\n    get: function(name) {\n      const extension = getExtension(name);\n      if (extension === null) {\n        warnOnce(\"THREE.WebGLRenderer: \" + name + \" extension not supported.\");\n      }\n      return extension;\n    }\n  };\n}\nfunction WebGLGeometries(gl, attributes, info, bindingStates) {\n  const geometries = {};\n  const wireframeAttributes = /* @__PURE__ */ new WeakMap();\n  function onGeometryDispose(event) {\n    const geometry = event.target;\n    if (geometry.index !== null) {\n      attributes.remove(geometry.index);\n    }\n    for (const name in geometry.attributes) {\n      attributes.remove(geometry.attributes[name]);\n    }\n    for (const name in geometry.morphAttributes) {\n      const array = geometry.morphAttributes[name];\n      for (let i = 0, l = array.length; i < l; i++) {\n        attributes.remove(array[i]);\n      }\n    }\n    geometry.removeEventListener(\"dispose\", onGeometryDispose);\n    delete geometries[geometry.id];\n    const attribute = wireframeAttributes.get(geometry);\n    if (attribute) {\n      attributes.remove(attribute);\n      wireframeAttributes.delete(geometry);\n    }\n    bindingStates.releaseStatesOfGeometry(geometry);\n    if (geometry.isInstancedBufferGeometry === true) {\n      delete geometry._maxInstanceCount;\n    }\n    info.memory.geometries--;\n  }\n  function get(object, geometry) {\n    if (geometries[geometry.id] === true) return geometry;\n    geometry.addEventListener(\"dispose\", onGeometryDispose);\n    geometries[geometry.id] = true;\n    info.memory.geometries++;\n    return geometry;\n  }\n  function update(geometry) {\n    const geometryAttributes = geometry.attributes;\n    for (const name in geometryAttributes) {\n      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);\n    }\n    const morphAttributes = geometry.morphAttributes;\n    for (const name in morphAttributes) {\n      const array = morphAttributes[name];\n      for (let i = 0, l = array.length; i < l; i++) {\n        attributes.update(array[i], gl.ARRAY_BUFFER);\n      }\n    }\n  }\n  function updateWireframeAttribute(geometry) {\n    const indices = [];\n    const geometryIndex = geometry.index;\n    const geometryPosition = geometry.attributes.position;\n    let version = 0;\n    if (geometryIndex !== null) {\n      const array = geometryIndex.array;\n      version = geometryIndex.version;\n      for (let i = 0, l = array.length; i < l; i += 3) {\n        const a = array[i + 0];\n        const b = array[i + 1];\n        const c = array[i + 2];\n        indices.push(a, b, b, c, c, a);\n      }\n    } else if (geometryPosition !== void 0) {\n      const array = geometryPosition.array;\n      version = geometryPosition.version;\n      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {\n        const a = i + 0;\n        const b = i + 1;\n        const c = i + 2;\n        indices.push(a, b, b, c, c, a);\n      }\n    } else {\n      return;\n    }\n    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\n    attribute.version = version;\n    const previousAttribute = wireframeAttributes.get(geometry);\n    if (previousAttribute) attributes.remove(previousAttribute);\n    wireframeAttributes.set(geometry, attribute);\n  }\n  function getWireframeAttribute(geometry) {\n    const currentAttribute = wireframeAttributes.get(geometry);\n    if (currentAttribute) {\n      const geometryIndex = geometry.index;\n      if (geometryIndex !== null) {\n        if (currentAttribute.version < geometryIndex.version) {\n          updateWireframeAttribute(geometry);\n        }\n      }\n    } else {\n      updateWireframeAttribute(geometry);\n    }\n    return wireframeAttributes.get(geometry);\n  }\n  return {\n    get,\n    update,\n    getWireframeAttribute\n  };\n}\nfunction WebGLIndexedBufferRenderer(gl, extensions, info) {\n  let mode;\n  function setMode(value) {\n    mode = value;\n  }\n  let type, bytesPerElement;\n  function setIndex(value) {\n    type = value.type;\n    bytesPerElement = value.bytesPerElement;\n  }\n  function render(start, count) {\n    gl.drawElements(mode, count, type, start * bytesPerElement);\n    info.update(count, mode, 1);\n  }\n  function renderInstances(start, count, primcount) {\n    if (primcount === 0) return;\n    gl.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount);\n    info.update(count, mode, primcount);\n  }\n  function renderMultiDraw(starts, counts, drawCount) {\n    if (drawCount === 0) return;\n    const extension = extensions.get(\"WEBGL_multi_draw\");\n    extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);\n    let elementCount = 0;\n    for (let i = 0; i < drawCount; i++) {\n      elementCount += counts[i];\n    }\n    info.update(elementCount, mode, 1);\n  }\n  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {\n    if (drawCount === 0) return;\n    const extension = extensions.get(\"WEBGL_multi_draw\");\n    if (extension === null) {\n      for (let i = 0; i < starts.length; i++) {\n        renderInstances(starts[i] / bytesPerElement, counts[i], primcount[i]);\n      }\n    } else {\n      extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);\n      let elementCount = 0;\n      for (let i = 0; i < drawCount; i++) {\n        elementCount += counts[i] * primcount[i];\n      }\n      info.update(elementCount, mode, 1);\n    }\n  }\n  this.setMode = setMode;\n  this.setIndex = setIndex;\n  this.render = render;\n  this.renderInstances = renderInstances;\n  this.renderMultiDraw = renderMultiDraw;\n  this.renderMultiDrawInstances = renderMultiDrawInstances;\n}\nfunction WebGLInfo(gl) {\n  const memory = {\n    geometries: 0,\n    textures: 0\n  };\n  const render = {\n    frame: 0,\n    calls: 0,\n    triangles: 0,\n    points: 0,\n    lines: 0\n  };\n  function update(count, mode, instanceCount) {\n    render.calls++;\n    switch (mode) {\n      case gl.TRIANGLES:\n        render.triangles += instanceCount * (count / 3);\n        break;\n      case gl.LINES:\n        render.lines += instanceCount * (count / 2);\n        break;\n      case gl.LINE_STRIP:\n        render.lines += instanceCount * (count - 1);\n        break;\n      case gl.LINE_LOOP:\n        render.lines += instanceCount * count;\n        break;\n      case gl.POINTS:\n        render.points += instanceCount * count;\n        break;\n      default:\n        console.error(\"THREE.WebGLInfo: Unknown draw mode:\", mode);\n        break;\n    }\n  }\n  function reset() {\n    render.calls = 0;\n    render.triangles = 0;\n    render.points = 0;\n    render.lines = 0;\n  }\n  return {\n    memory,\n    render,\n    programs: null,\n    autoReset: true,\n    reset,\n    update\n  };\n}\nfunction WebGLMorphtargets(gl, capabilities, textures) {\n  const morphTextures = /* @__PURE__ */ new WeakMap();\n  const morph = new Vector4();\n  function update(object, geometry, program) {\n    const objectInfluences = object.morphTargetInfluences;\n    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;\n    let entry = morphTextures.get(geometry);\n    if (entry === void 0 || entry.count !== morphTargetsCount) {\n      let disposeTexture = function() {\n        texture.dispose();\n        morphTextures.delete(geometry);\n        geometry.removeEventListener(\"dispose\", disposeTexture);\n      };\n      if (entry !== void 0) entry.texture.dispose();\n      const hasMorphPosition = geometry.morphAttributes.position !== void 0;\n      const hasMorphNormals = geometry.morphAttributes.normal !== void 0;\n      const hasMorphColors = geometry.morphAttributes.color !== void 0;\n      const morphTargets = geometry.morphAttributes.position || [];\n      const morphNormals = geometry.morphAttributes.normal || [];\n      const morphColors = geometry.morphAttributes.color || [];\n      let vertexDataCount = 0;\n      if (hasMorphPosition === true) vertexDataCount = 1;\n      if (hasMorphNormals === true) vertexDataCount = 2;\n      if (hasMorphColors === true) vertexDataCount = 3;\n      let width = geometry.attributes.position.count * vertexDataCount;\n      let height = 1;\n      if (width > capabilities.maxTextureSize) {\n        height = Math.ceil(width / capabilities.maxTextureSize);\n        width = capabilities.maxTextureSize;\n      }\n      const buffer = new Float32Array(width * height * 4 * morphTargetsCount);\n      const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);\n      texture.type = FloatType;\n      texture.needsUpdate = true;\n      const vertexDataStride = vertexDataCount * 4;\n      for (let i = 0; i < morphTargetsCount; i++) {\n        const morphTarget = morphTargets[i];\n        const morphNormal = morphNormals[i];\n        const morphColor = morphColors[i];\n        const offset = width * height * 4 * i;\n        for (let j = 0; j < morphTarget.count; j++) {\n          const stride = j * vertexDataStride;\n          if (hasMorphPosition === true) {\n            morph.fromBufferAttribute(morphTarget, j);\n            buffer[offset + stride + 0] = morph.x;\n            buffer[offset + stride + 1] = morph.y;\n            buffer[offset + stride + 2] = morph.z;\n            buffer[offset + stride + 3] = 0;\n          }\n          if (hasMorphNormals === true) {\n            morph.fromBufferAttribute(morphNormal, j);\n            buffer[offset + stride + 4] = morph.x;\n            buffer[offset + stride + 5] = morph.y;\n            buffer[offset + stride + 6] = morph.z;\n            buffer[offset + stride + 7] = 0;\n          }\n          if (hasMorphColors === true) {\n            morph.fromBufferAttribute(morphColor, j);\n            buffer[offset + stride + 8] = morph.x;\n            buffer[offset + stride + 9] = morph.y;\n            buffer[offset + stride + 10] = morph.z;\n            buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;\n          }\n        }\n      }\n      entry = {\n        count: morphTargetsCount,\n        texture,\n        size: new Vector2(width, height)\n      };\n      morphTextures.set(geometry, entry);\n      geometry.addEventListener(\"dispose\", disposeTexture);\n    }\n    if (object.isInstancedMesh === true && object.morphTexture !== null) {\n      program.getUniforms().setValue(gl, \"morphTexture\", object.morphTexture, textures);\n    } else {\n      let morphInfluencesSum = 0;\n      for (let i = 0; i < objectInfluences.length; i++) {\n        morphInfluencesSum += objectInfluences[i];\n      }\n      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, \"morphTargetBaseInfluence\", morphBaseInfluence);\n      program.getUniforms().setValue(gl, \"morphTargetInfluences\", objectInfluences);\n    }\n    program.getUniforms().setValue(gl, \"morphTargetsTexture\", entry.texture, textures);\n    program.getUniforms().setValue(gl, \"morphTargetsTextureSize\", entry.size);\n  }\n  return {\n    update\n  };\n}\nfunction WebGLObjects(gl, geometries, attributes, info) {\n  let updateMap = /* @__PURE__ */ new WeakMap();\n  function update(object) {\n    const frame = info.render.frame;\n    const geometry = object.geometry;\n    const buffergeometry = geometries.get(object, geometry);\n    if (updateMap.get(buffergeometry) !== frame) {\n      geometries.update(buffergeometry);\n      updateMap.set(buffergeometry, frame);\n    }\n    if (object.isInstancedMesh) {\n      if (object.hasEventListener(\"dispose\", onInstancedMeshDispose) === false) {\n        object.addEventListener(\"dispose\", onInstancedMeshDispose);\n      }\n      if (updateMap.get(object) !== frame) {\n        attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);\n        if (object.instanceColor !== null) {\n          attributes.update(object.instanceColor, gl.ARRAY_BUFFER);\n        }\n        updateMap.set(object, frame);\n      }\n    }\n    if (object.isSkinnedMesh) {\n      const skeleton = object.skeleton;\n      if (updateMap.get(skeleton) !== frame) {\n        skeleton.update();\n        updateMap.set(skeleton, frame);\n      }\n    }\n    return buffergeometry;\n  }\n  function dispose() {\n    updateMap = /* @__PURE__ */ new WeakMap();\n  }\n  function onInstancedMeshDispose(event) {\n    const instancedMesh = event.target;\n    instancedMesh.removeEventListener(\"dispose\", onInstancedMeshDispose);\n    attributes.remove(instancedMesh.instanceMatrix);\n    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);\n  }\n  return {\n    update,\n    dispose\n  };\n}\nclass DepthTexture extends Texture {\n  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat) {\n    if (format !== DepthFormat && format !== DepthStencilFormat) {\n      throw new Error(\"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat\");\n    }\n    if (type === void 0 && format === DepthFormat) type = UnsignedIntType;\n    if (type === void 0 && format === DepthStencilFormat) type = UnsignedInt248Type;\n    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.isDepthTexture = true;\n    this.image = { width, height };\n    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;\n    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;\n    this.flipY = false;\n    this.generateMipmaps = false;\n    this.compareFunction = null;\n  }\n  copy(source) {\n    super.copy(source);\n    this.compareFunction = source.compareFunction;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    if (this.compareFunction !== null) data.compareFunction = this.compareFunction;\n    return data;\n  }\n}\nconst emptyTexture = /* @__PURE__ */ new Texture();\nconst emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);\nconst emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();\nconst empty3dTexture = /* @__PURE__ */ new Data3DTexture();\nconst emptyCubeTexture = /* @__PURE__ */ new CubeTexture();\nconst arrayCacheF32 = [];\nconst arrayCacheI32 = [];\nconst mat4array = new Float32Array(16);\nconst mat3array = new Float32Array(9);\nconst mat2array = new Float32Array(4);\nfunction flatten(array, nBlocks, blockSize) {\n  const firstElem = array[0];\n  if (firstElem <= 0 || firstElem > 0) return array;\n  const n = nBlocks * blockSize;\n  let r = arrayCacheF32[n];\n  if (r === void 0) {\n    r = new Float32Array(n);\n    arrayCacheF32[n] = r;\n  }\n  if (nBlocks !== 0) {\n    firstElem.toArray(r, 0);\n    for (let i = 1, offset = 0; i !== nBlocks; ++i) {\n      offset += blockSize;\n      array[i].toArray(r, offset);\n    }\n  }\n  return r;\n}\nfunction arraysEqual(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n  return true;\n}\nfunction copyArray(a, b) {\n  for (let i = 0, l = b.length; i < l; i++) {\n    a[i] = b[i];\n  }\n}\nfunction allocTexUnits(textures, n) {\n  let r = arrayCacheI32[n];\n  if (r === void 0) {\n    r = new Int32Array(n);\n    arrayCacheI32[n] = r;\n  }\n  for (let i = 0; i !== n; ++i) {\n    r[i] = textures.allocateTextureUnit();\n  }\n  return r;\n}\nfunction setValueV1f(gl, v) {\n  const cache2 = this.cache;\n  if (cache2[0] === v) return;\n  gl.uniform1f(this.addr, v);\n  cache2[0] = v;\n}\nfunction setValueV2f(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== v.x || cache2[1] !== v.y) {\n      gl.uniform2f(this.addr, v.x, v.y);\n      cache2[0] = v.x;\n      cache2[1] = v.y;\n    }\n  } else {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniform2fv(this.addr, v);\n    copyArray(cache2, v);\n  }\n}\nfunction setValueV3f(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z) {\n      gl.uniform3f(this.addr, v.x, v.y, v.z);\n      cache2[0] = v.x;\n      cache2[1] = v.y;\n      cache2[2] = v.z;\n    }\n  } else if (v.r !== void 0) {\n    if (cache2[0] !== v.r || cache2[1] !== v.g || cache2[2] !== v.b) {\n      gl.uniform3f(this.addr, v.r, v.g, v.b);\n      cache2[0] = v.r;\n      cache2[1] = v.g;\n      cache2[2] = v.b;\n    }\n  } else {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniform3fv(this.addr, v);\n    copyArray(cache2, v);\n  }\n}\nfunction setValueV4f(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z || cache2[3] !== v.w) {\n      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);\n      cache2[0] = v.x;\n      cache2[1] = v.y;\n      cache2[2] = v.z;\n      cache2[3] = v.w;\n    }\n  } else {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniform4fv(this.addr, v);\n    copyArray(cache2, v);\n  }\n}\nfunction setValueM2(gl, v) {\n  const cache2 = this.cache;\n  const elements = v.elements;\n  if (elements === void 0) {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniformMatrix2fv(this.addr, false, v);\n    copyArray(cache2, v);\n  } else {\n    if (arraysEqual(cache2, elements)) return;\n    mat2array.set(elements);\n    gl.uniformMatrix2fv(this.addr, false, mat2array);\n    copyArray(cache2, elements);\n  }\n}\nfunction setValueM3(gl, v) {\n  const cache2 = this.cache;\n  const elements = v.elements;\n  if (elements === void 0) {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniformMatrix3fv(this.addr, false, v);\n    copyArray(cache2, v);\n  } else {\n    if (arraysEqual(cache2, elements)) return;\n    mat3array.set(elements);\n    gl.uniformMatrix3fv(this.addr, false, mat3array);\n    copyArray(cache2, elements);\n  }\n}\nfunction setValueM4(gl, v) {\n  const cache2 = this.cache;\n  const elements = v.elements;\n  if (elements === void 0) {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniformMatrix4fv(this.addr, false, v);\n    copyArray(cache2, v);\n  } else {\n    if (arraysEqual(cache2, elements)) return;\n    mat4array.set(elements);\n    gl.uniformMatrix4fv(this.addr, false, mat4array);\n    copyArray(cache2, elements);\n  }\n}\nfunction setValueV1i(gl, v) {\n  const cache2 = this.cache;\n  if (cache2[0] === v) return;\n  gl.uniform1i(this.addr, v);\n  cache2[0] = v;\n}\nfunction setValueV2i(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== v.x || cache2[1] !== v.y) {\n      gl.uniform2i(this.addr, v.x, v.y);\n      cache2[0] = v.x;\n      cache2[1] = v.y;\n    }\n  } else {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniform2iv(this.addr, v);\n    copyArray(cache2, v);\n  }\n}\nfunction setValueV3i(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z) {\n      gl.uniform3i(this.addr, v.x, v.y, v.z);\n      cache2[0] = v.x;\n      cache2[1] = v.y;\n      cache2[2] = v.z;\n    }\n  } else {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniform3iv(this.addr, v);\n    copyArray(cache2, v);\n  }\n}\nfunction setValueV4i(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z || cache2[3] !== v.w) {\n      gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);\n      cache2[0] = v.x;\n      cache2[1] = v.y;\n      cache2[2] = v.z;\n      cache2[3] = v.w;\n    }\n  } else {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniform4iv(this.addr, v);\n    copyArray(cache2, v);\n  }\n}\nfunction setValueV1ui(gl, v) {\n  const cache2 = this.cache;\n  if (cache2[0] === v) return;\n  gl.uniform1ui(this.addr, v);\n  cache2[0] = v;\n}\nfunction setValueV2ui(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== v.x || cache2[1] !== v.y) {\n      gl.uniform2ui(this.addr, v.x, v.y);\n      cache2[0] = v.x;\n      cache2[1] = v.y;\n    }\n  } else {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniform2uiv(this.addr, v);\n    copyArray(cache2, v);\n  }\n}\nfunction setValueV3ui(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z) {\n      gl.uniform3ui(this.addr, v.x, v.y, v.z);\n      cache2[0] = v.x;\n      cache2[1] = v.y;\n      cache2[2] = v.z;\n    }\n  } else {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniform3uiv(this.addr, v);\n    copyArray(cache2, v);\n  }\n}\nfunction setValueV4ui(gl, v) {\n  const cache2 = this.cache;\n  if (v.x !== void 0) {\n    if (cache2[0] !== v.x || cache2[1] !== v.y || cache2[2] !== v.z || cache2[3] !== v.w) {\n      gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);\n      cache2[0] = v.x;\n      cache2[1] = v.y;\n      cache2[2] = v.z;\n      cache2[3] = v.w;\n    }\n  } else {\n    if (arraysEqual(cache2, v)) return;\n    gl.uniform4uiv(this.addr, v);\n    copyArray(cache2, v);\n  }\n}\nfunction setValueT1(gl, v, textures) {\n  const cache2 = this.cache;\n  const unit = textures.allocateTextureUnit();\n  if (cache2[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache2[0] = unit;\n  }\n  let emptyTexture2D;\n  if (this.type === gl.SAMPLER_2D_SHADOW) {\n    emptyShadowTexture.compareFunction = LessEqualCompare;\n    emptyTexture2D = emptyShadowTexture;\n  } else {\n    emptyTexture2D = emptyTexture;\n  }\n  textures.setTexture2D(v || emptyTexture2D, unit);\n}\nfunction setValueT3D1(gl, v, textures) {\n  const cache2 = this.cache;\n  const unit = textures.allocateTextureUnit();\n  if (cache2[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache2[0] = unit;\n  }\n  textures.setTexture3D(v || empty3dTexture, unit);\n}\nfunction setValueT6(gl, v, textures) {\n  const cache2 = this.cache;\n  const unit = textures.allocateTextureUnit();\n  if (cache2[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache2[0] = unit;\n  }\n  textures.setTextureCube(v || emptyCubeTexture, unit);\n}\nfunction setValueT2DArray1(gl, v, textures) {\n  const cache2 = this.cache;\n  const unit = textures.allocateTextureUnit();\n  if (cache2[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache2[0] = unit;\n  }\n  textures.setTexture2DArray(v || emptyArrayTexture, unit);\n}\nfunction getSingularSetter(type) {\n  switch (type) {\n    case 5126:\n      return setValueV1f;\n    case 35664:\n      return setValueV2f;\n    case 35665:\n      return setValueV3f;\n    case 35666:\n      return setValueV4f;\n    case 35674:\n      return setValueM2;\n    case 35675:\n      return setValueM3;\n    case 35676:\n      return setValueM4;\n    case 5124:\n    case 35670:\n      return setValueV1i;\n    case 35667:\n    case 35671:\n      return setValueV2i;\n    case 35668:\n    case 35672:\n      return setValueV3i;\n    case 35669:\n    case 35673:\n      return setValueV4i;\n    case 5125:\n      return setValueV1ui;\n    case 36294:\n      return setValueV2ui;\n    case 36295:\n      return setValueV3ui;\n    case 36296:\n      return setValueV4ui;\n    case 35678:\n    case 36198:\n    case 36298:\n    case 36306:\n    case 35682:\n      return setValueT1;\n    case 35679:\n    case 36299:\n    case 36307:\n      return setValueT3D1;\n    case 35680:\n    case 36300:\n    case 36308:\n    case 36293:\n      return setValueT6;\n    case 36289:\n    case 36303:\n    case 36311:\n    case 36292:\n      return setValueT2DArray1;\n  }\n}\nfunction setValueV1fArray(gl, v) {\n  gl.uniform1fv(this.addr, v);\n}\nfunction setValueV2fArray(gl, v) {\n  const data = flatten(v, this.size, 2);\n  gl.uniform2fv(this.addr, data);\n}\nfunction setValueV3fArray(gl, v) {\n  const data = flatten(v, this.size, 3);\n  gl.uniform3fv(this.addr, data);\n}\nfunction setValueV4fArray(gl, v) {\n  const data = flatten(v, this.size, 4);\n  gl.uniform4fv(this.addr, data);\n}\nfunction setValueM2Array(gl, v) {\n  const data = flatten(v, this.size, 4);\n  gl.uniformMatrix2fv(this.addr, false, data);\n}\nfunction setValueM3Array(gl, v) {\n  const data = flatten(v, this.size, 9);\n  gl.uniformMatrix3fv(this.addr, false, data);\n}\nfunction setValueM4Array(gl, v) {\n  const data = flatten(v, this.size, 16);\n  gl.uniformMatrix4fv(this.addr, false, data);\n}\nfunction setValueV1iArray(gl, v) {\n  gl.uniform1iv(this.addr, v);\n}\nfunction setValueV2iArray(gl, v) {\n  gl.uniform2iv(this.addr, v);\n}\nfunction setValueV3iArray(gl, v) {\n  gl.uniform3iv(this.addr, v);\n}\nfunction setValueV4iArray(gl, v) {\n  gl.uniform4iv(this.addr, v);\n}\nfunction setValueV1uiArray(gl, v) {\n  gl.uniform1uiv(this.addr, v);\n}\nfunction setValueV2uiArray(gl, v) {\n  gl.uniform2uiv(this.addr, v);\n}\nfunction setValueV3uiArray(gl, v) {\n  gl.uniform3uiv(this.addr, v);\n}\nfunction setValueV4uiArray(gl, v) {\n  gl.uniform4uiv(this.addr, v);\n}\nfunction setValueT1Array(gl, v, textures) {\n  const cache2 = this.cache;\n  const n = v.length;\n  const units = allocTexUnits(textures, n);\n  if (!arraysEqual(cache2, units)) {\n    gl.uniform1iv(this.addr, units);\n    copyArray(cache2, units);\n  }\n  for (let i = 0; i !== n; ++i) {\n    textures.setTexture2D(v[i] || emptyTexture, units[i]);\n  }\n}\nfunction setValueT3DArray(gl, v, textures) {\n  const cache2 = this.cache;\n  const n = v.length;\n  const units = allocTexUnits(textures, n);\n  if (!arraysEqual(cache2, units)) {\n    gl.uniform1iv(this.addr, units);\n    copyArray(cache2, units);\n  }\n  for (let i = 0; i !== n; ++i) {\n    textures.setTexture3D(v[i] || empty3dTexture, units[i]);\n  }\n}\nfunction setValueT6Array(gl, v, textures) {\n  const cache2 = this.cache;\n  const n = v.length;\n  const units = allocTexUnits(textures, n);\n  if (!arraysEqual(cache2, units)) {\n    gl.uniform1iv(this.addr, units);\n    copyArray(cache2, units);\n  }\n  for (let i = 0; i !== n; ++i) {\n    textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);\n  }\n}\nfunction setValueT2DArrayArray(gl, v, textures) {\n  const cache2 = this.cache;\n  const n = v.length;\n  const units = allocTexUnits(textures, n);\n  if (!arraysEqual(cache2, units)) {\n    gl.uniform1iv(this.addr, units);\n    copyArray(cache2, units);\n  }\n  for (let i = 0; i !== n; ++i) {\n    textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);\n  }\n}\nfunction getPureArraySetter(type) {\n  switch (type) {\n    case 5126:\n      return setValueV1fArray;\n    case 35664:\n      return setValueV2fArray;\n    case 35665:\n      return setValueV3fArray;\n    case 35666:\n      return setValueV4fArray;\n    case 35674:\n      return setValueM2Array;\n    case 35675:\n      return setValueM3Array;\n    case 35676:\n      return setValueM4Array;\n    case 5124:\n    case 35670:\n      return setValueV1iArray;\n    case 35667:\n    case 35671:\n      return setValueV2iArray;\n    case 35668:\n    case 35672:\n      return setValueV3iArray;\n    case 35669:\n    case 35673:\n      return setValueV4iArray;\n    case 5125:\n      return setValueV1uiArray;\n    case 36294:\n      return setValueV2uiArray;\n    case 36295:\n      return setValueV3uiArray;\n    case 36296:\n      return setValueV4uiArray;\n    case 35678:\n    case 36198:\n    case 36298:\n    case 36306:\n    case 35682:\n      return setValueT1Array;\n    case 35679:\n    case 36299:\n    case 36307:\n      return setValueT3DArray;\n    case 35680:\n    case 36300:\n    case 36308:\n    case 36293:\n      return setValueT6Array;\n    case 36289:\n    case 36303:\n    case 36311:\n    case 36292:\n      return setValueT2DArrayArray;\n  }\n}\nclass SingleUniform {\n  constructor(id2, activeInfo, addr) {\n    this.id = id2;\n    this.addr = addr;\n    this.cache = [];\n    this.type = activeInfo.type;\n    this.setValue = getSingularSetter(activeInfo.type);\n  }\n}\nclass PureArrayUniform {\n  constructor(id2, activeInfo, addr) {\n    this.id = id2;\n    this.addr = addr;\n    this.cache = [];\n    this.type = activeInfo.type;\n    this.size = activeInfo.size;\n    this.setValue = getPureArraySetter(activeInfo.type);\n  }\n}\nclass StructuredUniform {\n  constructor(id2) {\n    this.id = id2;\n    this.seq = [];\n    this.map = {};\n  }\n  setValue(gl, value, textures) {\n    const seq = this.seq;\n    for (let i = 0, n = seq.length; i !== n; ++i) {\n      const u = seq[i];\n      u.setValue(gl, value[u.id], textures);\n    }\n  }\n}\nconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g;\nfunction addUniform(container, uniformObject) {\n  container.seq.push(uniformObject);\n  container.map[uniformObject.id] = uniformObject;\n}\nfunction parseUniform(activeInfo, addr, container) {\n  const path = activeInfo.name, pathLength = path.length;\n  RePathPart.lastIndex = 0;\n  while (true) {\n    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;\n    let id2 = match[1];\n    const idIsIndex = match[2] === \"]\", subscript = match[3];\n    if (idIsIndex) id2 = id2 | 0;\n    if (subscript === void 0 || subscript === \"[\" && matchEnd + 2 === pathLength) {\n      addUniform(container, subscript === void 0 ? new SingleUniform(id2, activeInfo, addr) : new PureArrayUniform(id2, activeInfo, addr));\n      break;\n    } else {\n      const map = container.map;\n      let next = map[id2];\n      if (next === void 0) {\n        next = new StructuredUniform(id2);\n        addUniform(container, next);\n      }\n      container = next;\n    }\n  }\n}\nclass WebGLUniforms {\n  constructor(gl, program) {\n    this.seq = [];\n    this.map = {};\n    const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n    for (let i = 0; i < n; ++i) {\n      const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);\n      parseUniform(info, addr, this);\n    }\n  }\n  setValue(gl, name, value, textures) {\n    const u = this.map[name];\n    if (u !== void 0) u.setValue(gl, value, textures);\n  }\n  setOptional(gl, object, name) {\n    const v = object[name];\n    if (v !== void 0) this.setValue(gl, name, v);\n  }\n  static upload(gl, seq, values, textures) {\n    for (let i = 0, n = seq.length; i !== n; ++i) {\n      const u = seq[i], v = values[u.id];\n      if (v.needsUpdate !== false) {\n        u.setValue(gl, v.value, textures);\n      }\n    }\n  }\n  static seqWithValue(seq, values) {\n    const r = [];\n    for (let i = 0, n = seq.length; i !== n; ++i) {\n      const u = seq[i];\n      if (u.id in values) r.push(u);\n    }\n    return r;\n  }\n}\nfunction WebGLShader(gl, type, string) {\n  const shader2 = gl.createShader(type);\n  gl.shaderSource(shader2, string);\n  gl.compileShader(shader2);\n  return shader2;\n}\nconst COMPLETION_STATUS_KHR = 37297;\nlet programIdCount = 0;\nfunction handleSource(string, errorLine) {\n  const lines = string.split(\"\\n\");\n  const lines2 = [];\n  const from = Math.max(errorLine - 6, 0);\n  const to = Math.min(errorLine + 6, lines.length);\n  for (let i = from; i < to; i++) {\n    const line = i + 1;\n    lines2.push(`${line === errorLine ? \">\" : \" \"} ${line}: ${lines[i]}`);\n  }\n  return lines2.join(\"\\n\");\n}\nconst _m0 = /* @__PURE__ */ new Matrix3();\nfunction getEncodingComponents(colorSpace) {\n  ColorManagement._getMatrix(_m0, ColorManagement.workingColorSpace, colorSpace);\n  const encodingMatrix = `mat3( ${_m0.elements.map((v) => v.toFixed(4))} )`;\n  switch (ColorManagement.getTransfer(colorSpace)) {\n    case LinearTransfer:\n      return [encodingMatrix, \"LinearTransferOETF\"];\n    case SRGBTransfer:\n      return [encodingMatrix, \"sRGBTransferOETF\"];\n    default:\n      console.warn(\"THREE.WebGLProgram: Unsupported color space: \", colorSpace);\n      return [encodingMatrix, \"LinearTransferOETF\"];\n  }\n}\nfunction getShaderErrors(gl, shader2, type) {\n  const status = gl.getShaderParameter(shader2, gl.COMPILE_STATUS);\n  const errors = gl.getShaderInfoLog(shader2).trim();\n  if (status && errors === \"\") return \"\";\n  const errorMatches = /ERROR: 0:(\\d+)/.exec(errors);\n  if (errorMatches) {\n    const errorLine = parseInt(errorMatches[1]);\n    return type.toUpperCase() + \"\\n\\n\" + errors + \"\\n\\n\" + handleSource(gl.getShaderSource(shader2), errorLine);\n  } else {\n    return errors;\n  }\n}\nfunction getTexelEncodingFunction(functionName, colorSpace) {\n  const components = getEncodingComponents(colorSpace);\n  return [\n    `vec4 ${functionName}( vec4 value ) {`,\n    `\treturn ${components[1]}( vec4( value.rgb * ${components[0]}, value.a ) );`,\n    \"}\"\n  ].join(\"\\n\");\n}\nfunction getToneMappingFunction(functionName, toneMapping) {\n  let toneMappingName;\n  switch (toneMapping) {\n    case LinearToneMapping:\n      toneMappingName = \"Linear\";\n      break;\n    case ReinhardToneMapping:\n      toneMappingName = \"Reinhard\";\n      break;\n    case CineonToneMapping:\n      toneMappingName = \"Cineon\";\n      break;\n    case ACESFilmicToneMapping:\n      toneMappingName = \"ACESFilmic\";\n      break;\n    case AgXToneMapping:\n      toneMappingName = \"AgX\";\n      break;\n    case NeutralToneMapping:\n      toneMappingName = \"Neutral\";\n      break;\n    case CustomToneMapping:\n      toneMappingName = \"Custom\";\n      break;\n    default:\n      console.warn(\"THREE.WebGLProgram: Unsupported toneMapping:\", toneMapping);\n      toneMappingName = \"Linear\";\n  }\n  return \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n}\nconst _v0$1 = /* @__PURE__ */ new Vector3();\nfunction getLuminanceFunction() {\n  ColorManagement.getLuminanceCoefficients(_v0$1);\n  const r = _v0$1.x.toFixed(4);\n  const g = _v0$1.y.toFixed(4);\n  const b = _v0$1.z.toFixed(4);\n  return [\n    \"float luminance( const in vec3 rgb ) {\",\n    `\tconst vec3 weights = vec3( ${r}, ${g}, ${b} );`,\n    \"\treturn dot( weights, rgb );\",\n    \"}\"\n  ].join(\"\\n\");\n}\nfunction generateVertexExtensions(parameters) {\n  const chunks = [\n    parameters.extensionClipCullDistance ? \"#extension GL_ANGLE_clip_cull_distance : require\" : \"\",\n    parameters.extensionMultiDraw ? \"#extension GL_ANGLE_multi_draw : require\" : \"\"\n  ];\n  return chunks.filter(filterEmptyLine).join(\"\\n\");\n}\nfunction generateDefines(defines) {\n  const chunks = [];\n  for (const name in defines) {\n    const value = defines[name];\n    if (value === false) continue;\n    chunks.push(\"#define \" + name + \" \" + value);\n  }\n  return chunks.join(\"\\n\");\n}\nfunction fetchAttributeLocations(gl, program) {\n  const attributes = {};\n  const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n  for (let i = 0; i < n; i++) {\n    const info = gl.getActiveAttrib(program, i);\n    const name = info.name;\n    let locationSize = 1;\n    if (info.type === gl.FLOAT_MAT2) locationSize = 2;\n    if (info.type === gl.FLOAT_MAT3) locationSize = 3;\n    if (info.type === gl.FLOAT_MAT4) locationSize = 4;\n    attributes[name] = {\n      type: info.type,\n      location: gl.getAttribLocation(program, name),\n      locationSize\n    };\n  }\n  return attributes;\n}\nfunction filterEmptyLine(string) {\n  return string !== \"\";\n}\nfunction replaceLightNums(string, parameters) {\n  const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;\n  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);\n}\nfunction replaceClippingPlaneNums(string, parameters) {\n  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);\n}\nconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\nfunction resolveIncludes(string) {\n  return string.replace(includePattern, includeReplacer);\n}\nconst shaderChunkMap = /* @__PURE__ */ new Map();\nfunction includeReplacer(match, include) {\n  let string = ShaderChunk[include];\n  if (string === void 0) {\n    const newInclude = shaderChunkMap.get(include);\n    if (newInclude !== void 0) {\n      string = ShaderChunk[newInclude];\n      console.warn('THREE.WebGLRenderer: Shader chunk \"%s\" has been deprecated. Use \"%s\" instead.', include, newInclude);\n    } else {\n      throw new Error(\"Can not resolve #include <\" + include + \">\");\n    }\n  }\n  return resolveIncludes(string);\n}\nconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\nfunction unrollLoops(string) {\n  return string.replace(unrollLoopPattern, loopReplacer);\n}\nfunction loopReplacer(match, start, end, snippet) {\n  let string = \"\";\n  for (let i = parseInt(start); i < parseInt(end); i++) {\n    string += snippet.replace(/\\[\\s*i\\s*\\]/g, \"[ \" + i + \" ]\").replace(/UNROLLED_LOOP_INDEX/g, i);\n  }\n  return string;\n}\nfunction generatePrecision(parameters) {\n  let precisionstring = `precision ${parameters.precision} float;\n\tprecision ${parameters.precision} int;\n\tprecision ${parameters.precision} sampler2D;\n\tprecision ${parameters.precision} samplerCube;\n\tprecision ${parameters.precision} sampler3D;\n\tprecision ${parameters.precision} sampler2DArray;\n\tprecision ${parameters.precision} sampler2DShadow;\n\tprecision ${parameters.precision} samplerCubeShadow;\n\tprecision ${parameters.precision} sampler2DArrayShadow;\n\tprecision ${parameters.precision} isampler2D;\n\tprecision ${parameters.precision} isampler3D;\n\tprecision ${parameters.precision} isamplerCube;\n\tprecision ${parameters.precision} isampler2DArray;\n\tprecision ${parameters.precision} usampler2D;\n\tprecision ${parameters.precision} usampler3D;\n\tprecision ${parameters.precision} usamplerCube;\n\tprecision ${parameters.precision} usampler2DArray;\n\t`;\n  if (parameters.precision === \"highp\") {\n    precisionstring += \"\\n#define HIGH_PRECISION\";\n  } else if (parameters.precision === \"mediump\") {\n    precisionstring += \"\\n#define MEDIUM_PRECISION\";\n  } else if (parameters.precision === \"lowp\") {\n    precisionstring += \"\\n#define LOW_PRECISION\";\n  }\n  return precisionstring;\n}\nfunction generateShadowMapTypeDefine(parameters) {\n  let shadowMapTypeDefine = \"SHADOWMAP_TYPE_BASIC\";\n  if (parameters.shadowMapType === PCFShadowMap) {\n    shadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF\";\n  } else if (parameters.shadowMapType === PCFSoftShadowMap) {\n    shadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF_SOFT\";\n  } else if (parameters.shadowMapType === VSMShadowMap) {\n    shadowMapTypeDefine = \"SHADOWMAP_TYPE_VSM\";\n  }\n  return shadowMapTypeDefine;\n}\nfunction generateEnvMapTypeDefine(parameters) {\n  let envMapTypeDefine = \"ENVMAP_TYPE_CUBE\";\n  if (parameters.envMap) {\n    switch (parameters.envMapMode) {\n      case CubeReflectionMapping:\n      case CubeRefractionMapping:\n        envMapTypeDefine = \"ENVMAP_TYPE_CUBE\";\n        break;\n      case CubeUVReflectionMapping:\n        envMapTypeDefine = \"ENVMAP_TYPE_CUBE_UV\";\n        break;\n    }\n  }\n  return envMapTypeDefine;\n}\nfunction generateEnvMapModeDefine(parameters) {\n  let envMapModeDefine = \"ENVMAP_MODE_REFLECTION\";\n  if (parameters.envMap) {\n    switch (parameters.envMapMode) {\n      case CubeRefractionMapping:\n        envMapModeDefine = \"ENVMAP_MODE_REFRACTION\";\n        break;\n    }\n  }\n  return envMapModeDefine;\n}\nfunction generateEnvMapBlendingDefine(parameters) {\n  let envMapBlendingDefine = \"ENVMAP_BLENDING_NONE\";\n  if (parameters.envMap) {\n    switch (parameters.combine) {\n      case MultiplyOperation:\n        envMapBlendingDefine = \"ENVMAP_BLENDING_MULTIPLY\";\n        break;\n      case MixOperation:\n        envMapBlendingDefine = \"ENVMAP_BLENDING_MIX\";\n        break;\n      case AddOperation:\n        envMapBlendingDefine = \"ENVMAP_BLENDING_ADD\";\n        break;\n    }\n  }\n  return envMapBlendingDefine;\n}\nfunction generateCubeUVSize(parameters) {\n  const imageHeight = parameters.envMapCubeUVHeight;\n  if (imageHeight === null) return null;\n  const maxMip = Math.log2(imageHeight) - 2;\n  const texelHeight = 1 / imageHeight;\n  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));\n  return { texelWidth, texelHeight, maxMip };\n}\nfunction WebGLProgram(renderer, cacheKey, parameters, bindingStates) {\n  const gl = renderer.getContext();\n  const defines = parameters.defines;\n  let vertexShader = parameters.vertexShader;\n  let fragmentShader = parameters.fragmentShader;\n  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);\n  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);\n  const envMapModeDefine = generateEnvMapModeDefine(parameters);\n  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);\n  const envMapCubeUVSize = generateCubeUVSize(parameters);\n  const customVertexExtensions = generateVertexExtensions(parameters);\n  const customDefines = generateDefines(defines);\n  const program = gl.createProgram();\n  let prefixVertex, prefixFragment;\n  let versionString = parameters.glslVersion ? \"#version \" + parameters.glslVersion + \"\\n\" : \"\";\n  if (parameters.isRawShaderMaterial) {\n    prefixVertex = [\n      \"#define SHADER_TYPE \" + parameters.shaderType,\n      \"#define SHADER_NAME \" + parameters.shaderName,\n      customDefines\n    ].filter(filterEmptyLine).join(\"\\n\");\n    if (prefixVertex.length > 0) {\n      prefixVertex += \"\\n\";\n    }\n    prefixFragment = [\n      \"#define SHADER_TYPE \" + parameters.shaderType,\n      \"#define SHADER_NAME \" + parameters.shaderName,\n      customDefines\n    ].filter(filterEmptyLine).join(\"\\n\");\n    if (prefixFragment.length > 0) {\n      prefixFragment += \"\\n\";\n    }\n  } else {\n    prefixVertex = [\n      generatePrecision(parameters),\n      \"#define SHADER_TYPE \" + parameters.shaderType,\n      \"#define SHADER_NAME \" + parameters.shaderName,\n      customDefines,\n      parameters.extensionClipCullDistance ? \"#define USE_CLIP_DISTANCE\" : \"\",\n      parameters.batching ? \"#define USE_BATCHING\" : \"\",\n      parameters.batchingColor ? \"#define USE_BATCHING_COLOR\" : \"\",\n      parameters.instancing ? \"#define USE_INSTANCING\" : \"\",\n      parameters.instancingColor ? \"#define USE_INSTANCING_COLOR\" : \"\",\n      parameters.instancingMorph ? \"#define USE_INSTANCING_MORPH\" : \"\",\n      parameters.useFog && parameters.fog ? \"#define USE_FOG\" : \"\",\n      parameters.useFog && parameters.fogExp2 ? \"#define FOG_EXP2\" : \"\",\n      parameters.map ? \"#define USE_MAP\" : \"\",\n      parameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n      parameters.envMap ? \"#define \" + envMapModeDefine : \"\",\n      parameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n      parameters.aoMap ? \"#define USE_AOMAP\" : \"\",\n      parameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n      parameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n      parameters.normalMapObjectSpace ? \"#define USE_NORMALMAP_OBJECTSPACE\" : \"\",\n      parameters.normalMapTangentSpace ? \"#define USE_NORMALMAP_TANGENTSPACE\" : \"\",\n      parameters.displacementMap ? \"#define USE_DISPLACEMENTMAP\" : \"\",\n      parameters.emissiveMap ? \"#define USE_EMISSIVEMAP\" : \"\",\n      parameters.anisotropy ? \"#define USE_ANISOTROPY\" : \"\",\n      parameters.anisotropyMap ? \"#define USE_ANISOTROPYMAP\" : \"\",\n      parameters.clearcoatMap ? \"#define USE_CLEARCOATMAP\" : \"\",\n      parameters.clearcoatRoughnessMap ? \"#define USE_CLEARCOAT_ROUGHNESSMAP\" : \"\",\n      parameters.clearcoatNormalMap ? \"#define USE_CLEARCOAT_NORMALMAP\" : \"\",\n      parameters.iridescenceMap ? \"#define USE_IRIDESCENCEMAP\" : \"\",\n      parameters.iridescenceThicknessMap ? \"#define USE_IRIDESCENCE_THICKNESSMAP\" : \"\",\n      parameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n      parameters.specularColorMap ? \"#define USE_SPECULAR_COLORMAP\" : \"\",\n      parameters.specularIntensityMap ? \"#define USE_SPECULAR_INTENSITYMAP\" : \"\",\n      parameters.roughnessMap ? \"#define USE_ROUGHNESSMAP\" : \"\",\n      parameters.metalnessMap ? \"#define USE_METALNESSMAP\" : \"\",\n      parameters.alphaMap ? \"#define USE_ALPHAMAP\" : \"\",\n      parameters.alphaHash ? \"#define USE_ALPHAHASH\" : \"\",\n      parameters.transmission ? \"#define USE_TRANSMISSION\" : \"\",\n      parameters.transmissionMap ? \"#define USE_TRANSMISSIONMAP\" : \"\",\n      parameters.thicknessMap ? \"#define USE_THICKNESSMAP\" : \"\",\n      parameters.sheenColorMap ? \"#define USE_SHEEN_COLORMAP\" : \"\",\n      parameters.sheenRoughnessMap ? \"#define USE_SHEEN_ROUGHNESSMAP\" : \"\",\n      //\n      parameters.mapUv ? \"#define MAP_UV \" + parameters.mapUv : \"\",\n      parameters.alphaMapUv ? \"#define ALPHAMAP_UV \" + parameters.alphaMapUv : \"\",\n      parameters.lightMapUv ? \"#define LIGHTMAP_UV \" + parameters.lightMapUv : \"\",\n      parameters.aoMapUv ? \"#define AOMAP_UV \" + parameters.aoMapUv : \"\",\n      parameters.emissiveMapUv ? \"#define EMISSIVEMAP_UV \" + parameters.emissiveMapUv : \"\",\n      parameters.bumpMapUv ? \"#define BUMPMAP_UV \" + parameters.bumpMapUv : \"\",\n      parameters.normalMapUv ? \"#define NORMALMAP_UV \" + parameters.normalMapUv : \"\",\n      parameters.displacementMapUv ? \"#define DISPLACEMENTMAP_UV \" + parameters.displacementMapUv : \"\",\n      parameters.metalnessMapUv ? \"#define METALNESSMAP_UV \" + parameters.metalnessMapUv : \"\",\n      parameters.roughnessMapUv ? \"#define ROUGHNESSMAP_UV \" + parameters.roughnessMapUv : \"\",\n      parameters.anisotropyMapUv ? \"#define ANISOTROPYMAP_UV \" + parameters.anisotropyMapUv : \"\",\n      parameters.clearcoatMapUv ? \"#define CLEARCOATMAP_UV \" + parameters.clearcoatMapUv : \"\",\n      parameters.clearcoatNormalMapUv ? \"#define CLEARCOAT_NORMALMAP_UV \" + parameters.clearcoatNormalMapUv : \"\",\n      parameters.clearcoatRoughnessMapUv ? \"#define CLEARCOAT_ROUGHNESSMAP_UV \" + parameters.clearcoatRoughnessMapUv : \"\",\n      parameters.iridescenceMapUv ? \"#define IRIDESCENCEMAP_UV \" + parameters.iridescenceMapUv : \"\",\n      parameters.iridescenceThicknessMapUv ? \"#define IRIDESCENCE_THICKNESSMAP_UV \" + parameters.iridescenceThicknessMapUv : \"\",\n      parameters.sheenColorMapUv ? \"#define SHEEN_COLORMAP_UV \" + parameters.sheenColorMapUv : \"\",\n      parameters.sheenRoughnessMapUv ? \"#define SHEEN_ROUGHNESSMAP_UV \" + parameters.sheenRoughnessMapUv : \"\",\n      parameters.specularMapUv ? \"#define SPECULARMAP_UV \" + parameters.specularMapUv : \"\",\n      parameters.specularColorMapUv ? \"#define SPECULAR_COLORMAP_UV \" + parameters.specularColorMapUv : \"\",\n      parameters.specularIntensityMapUv ? \"#define SPECULAR_INTENSITYMAP_UV \" + parameters.specularIntensityMapUv : \"\",\n      parameters.transmissionMapUv ? \"#define TRANSMISSIONMAP_UV \" + parameters.transmissionMapUv : \"\",\n      parameters.thicknessMapUv ? \"#define THICKNESSMAP_UV \" + parameters.thicknessMapUv : \"\",\n      //\n      parameters.vertexTangents && parameters.flatShading === false ? \"#define USE_TANGENT\" : \"\",\n      parameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n      parameters.vertexAlphas ? \"#define USE_COLOR_ALPHA\" : \"\",\n      parameters.vertexUv1s ? \"#define USE_UV1\" : \"\",\n      parameters.vertexUv2s ? \"#define USE_UV2\" : \"\",\n      parameters.vertexUv3s ? \"#define USE_UV3\" : \"\",\n      parameters.pointsUvs ? \"#define USE_POINTS_UV\" : \"\",\n      parameters.flatShading ? \"#define FLAT_SHADED\" : \"\",\n      parameters.skinning ? \"#define USE_SKINNING\" : \"\",\n      parameters.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\n      parameters.morphNormals && parameters.flatShading === false ? \"#define USE_MORPHNORMALS\" : \"\",\n      parameters.morphColors ? \"#define USE_MORPHCOLORS\" : \"\",\n      parameters.morphTargetsCount > 0 ? \"#define MORPHTARGETS_TEXTURE_STRIDE \" + parameters.morphTextureStride : \"\",\n      parameters.morphTargetsCount > 0 ? \"#define MORPHTARGETS_COUNT \" + parameters.morphTargetsCount : \"\",\n      parameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n      parameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n      parameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n      parameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n      parameters.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\",\n      parameters.numLightProbes > 0 ? \"#define USE_LIGHT_PROBES\" : \"\",\n      parameters.logarithmicDepthBuffer ? \"#define USE_LOGDEPTHBUF\" : \"\",\n      parameters.reverseDepthBuffer ? \"#define USE_REVERSEDEPTHBUF\" : \"\",\n      \"uniform mat4 modelMatrix;\",\n      \"uniform mat4 modelViewMatrix;\",\n      \"uniform mat4 projectionMatrix;\",\n      \"uniform mat4 viewMatrix;\",\n      \"uniform mat3 normalMatrix;\",\n      \"uniform vec3 cameraPosition;\",\n      \"uniform bool isOrthographic;\",\n      \"#ifdef USE_INSTANCING\",\n      \"\tattribute mat4 instanceMatrix;\",\n      \"#endif\",\n      \"#ifdef USE_INSTANCING_COLOR\",\n      \"\tattribute vec3 instanceColor;\",\n      \"#endif\",\n      \"#ifdef USE_INSTANCING_MORPH\",\n      \"\tuniform sampler2D morphTexture;\",\n      \"#endif\",\n      \"attribute vec3 position;\",\n      \"attribute vec3 normal;\",\n      \"attribute vec2 uv;\",\n      \"#ifdef USE_UV1\",\n      \"\tattribute vec2 uv1;\",\n      \"#endif\",\n      \"#ifdef USE_UV2\",\n      \"\tattribute vec2 uv2;\",\n      \"#endif\",\n      \"#ifdef USE_UV3\",\n      \"\tattribute vec2 uv3;\",\n      \"#endif\",\n      \"#ifdef USE_TANGENT\",\n      \"\tattribute vec4 tangent;\",\n      \"#endif\",\n      \"#if defined( USE_COLOR_ALPHA )\",\n      \"\tattribute vec4 color;\",\n      \"#elif defined( USE_COLOR )\",\n      \"\tattribute vec3 color;\",\n      \"#endif\",\n      \"#ifdef USE_SKINNING\",\n      \"\tattribute vec4 skinIndex;\",\n      \"\tattribute vec4 skinWeight;\",\n      \"#endif\",\n      \"\\n\"\n    ].filter(filterEmptyLine).join(\"\\n\");\n    prefixFragment = [\n      generatePrecision(parameters),\n      \"#define SHADER_TYPE \" + parameters.shaderType,\n      \"#define SHADER_NAME \" + parameters.shaderName,\n      customDefines,\n      parameters.useFog && parameters.fog ? \"#define USE_FOG\" : \"\",\n      parameters.useFog && parameters.fogExp2 ? \"#define FOG_EXP2\" : \"\",\n      parameters.alphaToCoverage ? \"#define ALPHA_TO_COVERAGE\" : \"\",\n      parameters.map ? \"#define USE_MAP\" : \"\",\n      parameters.matcap ? \"#define USE_MATCAP\" : \"\",\n      parameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n      parameters.envMap ? \"#define \" + envMapTypeDefine : \"\",\n      parameters.envMap ? \"#define \" + envMapModeDefine : \"\",\n      parameters.envMap ? \"#define \" + envMapBlendingDefine : \"\",\n      envMapCubeUVSize ? \"#define CUBEUV_TEXEL_WIDTH \" + envMapCubeUVSize.texelWidth : \"\",\n      envMapCubeUVSize ? \"#define CUBEUV_TEXEL_HEIGHT \" + envMapCubeUVSize.texelHeight : \"\",\n      envMapCubeUVSize ? \"#define CUBEUV_MAX_MIP \" + envMapCubeUVSize.maxMip + \".0\" : \"\",\n      parameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n      parameters.aoMap ? \"#define USE_AOMAP\" : \"\",\n      parameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n      parameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n      parameters.normalMapObjectSpace ? \"#define USE_NORMALMAP_OBJECTSPACE\" : \"\",\n      parameters.normalMapTangentSpace ? \"#define USE_NORMALMAP_TANGENTSPACE\" : \"\",\n      parameters.emissiveMap ? \"#define USE_EMISSIVEMAP\" : \"\",\n      parameters.anisotropy ? \"#define USE_ANISOTROPY\" : \"\",\n      parameters.anisotropyMap ? \"#define USE_ANISOTROPYMAP\" : \"\",\n      parameters.clearcoat ? \"#define USE_CLEARCOAT\" : \"\",\n      parameters.clearcoatMap ? \"#define USE_CLEARCOATMAP\" : \"\",\n      parameters.clearcoatRoughnessMap ? \"#define USE_CLEARCOAT_ROUGHNESSMAP\" : \"\",\n      parameters.clearcoatNormalMap ? \"#define USE_CLEARCOAT_NORMALMAP\" : \"\",\n      parameters.dispersion ? \"#define USE_DISPERSION\" : \"\",\n      parameters.iridescence ? \"#define USE_IRIDESCENCE\" : \"\",\n      parameters.iridescenceMap ? \"#define USE_IRIDESCENCEMAP\" : \"\",\n      parameters.iridescenceThicknessMap ? \"#define USE_IRIDESCENCE_THICKNESSMAP\" : \"\",\n      parameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n      parameters.specularColorMap ? \"#define USE_SPECULAR_COLORMAP\" : \"\",\n      parameters.specularIntensityMap ? \"#define USE_SPECULAR_INTENSITYMAP\" : \"\",\n      parameters.roughnessMap ? \"#define USE_ROUGHNESSMAP\" : \"\",\n      parameters.metalnessMap ? \"#define USE_METALNESSMAP\" : \"\",\n      parameters.alphaMap ? \"#define USE_ALPHAMAP\" : \"\",\n      parameters.alphaTest ? \"#define USE_ALPHATEST\" : \"\",\n      parameters.alphaHash ? \"#define USE_ALPHAHASH\" : \"\",\n      parameters.sheen ? \"#define USE_SHEEN\" : \"\",\n      parameters.sheenColorMap ? \"#define USE_SHEEN_COLORMAP\" : \"\",\n      parameters.sheenRoughnessMap ? \"#define USE_SHEEN_ROUGHNESSMAP\" : \"\",\n      parameters.transmission ? \"#define USE_TRANSMISSION\" : \"\",\n      parameters.transmissionMap ? \"#define USE_TRANSMISSIONMAP\" : \"\",\n      parameters.thicknessMap ? \"#define USE_THICKNESSMAP\" : \"\",\n      parameters.vertexTangents && parameters.flatShading === false ? \"#define USE_TANGENT\" : \"\",\n      parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? \"#define USE_COLOR\" : \"\",\n      parameters.vertexAlphas ? \"#define USE_COLOR_ALPHA\" : \"\",\n      parameters.vertexUv1s ? \"#define USE_UV1\" : \"\",\n      parameters.vertexUv2s ? \"#define USE_UV2\" : \"\",\n      parameters.vertexUv3s ? \"#define USE_UV3\" : \"\",\n      parameters.pointsUvs ? \"#define USE_POINTS_UV\" : \"\",\n      parameters.gradientMap ? \"#define USE_GRADIENTMAP\" : \"\",\n      parameters.flatShading ? \"#define FLAT_SHADED\" : \"\",\n      parameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n      parameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n      parameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n      parameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n      parameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : \"\",\n      parameters.numLightProbes > 0 ? \"#define USE_LIGHT_PROBES\" : \"\",\n      parameters.decodeVideoTexture ? \"#define DECODE_VIDEO_TEXTURE\" : \"\",\n      parameters.decodeVideoTextureEmissive ? \"#define DECODE_VIDEO_TEXTURE_EMISSIVE\" : \"\",\n      parameters.logarithmicDepthBuffer ? \"#define USE_LOGDEPTHBUF\" : \"\",\n      parameters.reverseDepthBuffer ? \"#define USE_REVERSEDEPTHBUF\" : \"\",\n      \"uniform mat4 viewMatrix;\",\n      \"uniform vec3 cameraPosition;\",\n      \"uniform bool isOrthographic;\",\n      parameters.toneMapping !== NoToneMapping ? \"#define TONE_MAPPING\" : \"\",\n      parameters.toneMapping !== NoToneMapping ? ShaderChunk[\"tonemapping_pars_fragment\"] : \"\",\n      // this code is required here because it is used by the toneMapping() function defined below\n      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction(\"toneMapping\", parameters.toneMapping) : \"\",\n      parameters.dithering ? \"#define DITHERING\" : \"\",\n      parameters.opaque ? \"#define OPAQUE\" : \"\",\n      ShaderChunk[\"colorspace_pars_fragment\"],\n      // this code is required here because it is used by the various encoding/decoding function defined below\n      getTexelEncodingFunction(\"linearToOutputTexel\", parameters.outputColorSpace),\n      getLuminanceFunction(),\n      parameters.useDepthPacking ? \"#define DEPTH_PACKING \" + parameters.depthPacking : \"\",\n      \"\\n\"\n    ].filter(filterEmptyLine).join(\"\\n\");\n  }\n  vertexShader = resolveIncludes(vertexShader);\n  vertexShader = replaceLightNums(vertexShader, parameters);\n  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);\n  fragmentShader = resolveIncludes(fragmentShader);\n  fragmentShader = replaceLightNums(fragmentShader, parameters);\n  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);\n  vertexShader = unrollLoops(vertexShader);\n  fragmentShader = unrollLoops(fragmentShader);\n  if (parameters.isRawShaderMaterial !== true) {\n    versionString = \"#version 300 es\\n\";\n    prefixVertex = [\n      customVertexExtensions,\n      \"#define attribute in\",\n      \"#define varying out\",\n      \"#define texture2D texture\"\n    ].join(\"\\n\") + \"\\n\" + prefixVertex;\n    prefixFragment = [\n      \"#define varying in\",\n      parameters.glslVersion === GLSL3 ? \"\" : \"layout(location = 0) out highp vec4 pc_fragColor;\",\n      parameters.glslVersion === GLSL3 ? \"\" : \"#define gl_FragColor pc_fragColor\",\n      \"#define gl_FragDepthEXT gl_FragDepth\",\n      \"#define texture2D texture\",\n      \"#define textureCube texture\",\n      \"#define texture2DProj textureProj\",\n      \"#define texture2DLodEXT textureLod\",\n      \"#define texture2DProjLodEXT textureProjLod\",\n      \"#define textureCubeLodEXT textureLod\",\n      \"#define texture2DGradEXT textureGrad\",\n      \"#define texture2DProjGradEXT textureProjGrad\",\n      \"#define textureCubeGradEXT textureGrad\"\n    ].join(\"\\n\") + \"\\n\" + prefixFragment;\n  }\n  const vertexGlsl = versionString + prefixVertex + vertexShader;\n  const fragmentGlsl = versionString + prefixFragment + fragmentShader;\n  const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);\n  const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);\n  gl.attachShader(program, glVertexShader);\n  gl.attachShader(program, glFragmentShader);\n  if (parameters.index0AttributeName !== void 0) {\n    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);\n  } else if (parameters.morphTargets === true) {\n    gl.bindAttribLocation(program, 0, \"position\");\n  }\n  gl.linkProgram(program);\n  function onFirstUse(self2) {\n    if (renderer.debug.checkShaderErrors) {\n      const programLog = gl.getProgramInfoLog(program).trim();\n      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();\n      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();\n      let runnable = true;\n      let haveDiagnostics = true;\n      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n        runnable = false;\n        if (typeof renderer.debug.onShaderError === \"function\") {\n          renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);\n        } else {\n          const vertexErrors = getShaderErrors(gl, glVertexShader, \"vertex\");\n          const fragmentErrors = getShaderErrors(gl, glFragmentShader, \"fragment\");\n          console.error(\n            \"THREE.WebGLProgram: Shader Error \" + gl.getError() + \" - VALIDATE_STATUS \" + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + \"\\n\\nMaterial Name: \" + self2.name + \"\\nMaterial Type: \" + self2.type + \"\\n\\nProgram Info Log: \" + programLog + \"\\n\" + vertexErrors + \"\\n\" + fragmentErrors\n          );\n        }\n      } else if (programLog !== \"\") {\n        console.warn(\"THREE.WebGLProgram: Program Info Log:\", programLog);\n      } else if (vertexLog === \"\" || fragmentLog === \"\") {\n        haveDiagnostics = false;\n      }\n      if (haveDiagnostics) {\n        self2.diagnostics = {\n          runnable,\n          programLog,\n          vertexShader: {\n            log: vertexLog,\n            prefix: prefixVertex\n          },\n          fragmentShader: {\n            log: fragmentLog,\n            prefix: prefixFragment\n          }\n        };\n      }\n    }\n    gl.deleteShader(glVertexShader);\n    gl.deleteShader(glFragmentShader);\n    cachedUniforms = new WebGLUniforms(gl, program);\n    cachedAttributes = fetchAttributeLocations(gl, program);\n  }\n  let cachedUniforms;\n  this.getUniforms = function() {\n    if (cachedUniforms === void 0) {\n      onFirstUse(this);\n    }\n    return cachedUniforms;\n  };\n  let cachedAttributes;\n  this.getAttributes = function() {\n    if (cachedAttributes === void 0) {\n      onFirstUse(this);\n    }\n    return cachedAttributes;\n  };\n  let programReady = parameters.rendererExtensionParallelShaderCompile === false;\n  this.isReady = function() {\n    if (programReady === false) {\n      programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR);\n    }\n    return programReady;\n  };\n  this.destroy = function() {\n    bindingStates.releaseStatesOfProgram(this);\n    gl.deleteProgram(program);\n    this.program = void 0;\n  };\n  this.type = parameters.shaderType;\n  this.name = parameters.shaderName;\n  this.id = programIdCount++;\n  this.cacheKey = cacheKey;\n  this.usedTimes = 1;\n  this.program = program;\n  this.vertexShader = glVertexShader;\n  this.fragmentShader = glFragmentShader;\n  return this;\n}\nlet _id$1 = 0;\nclass WebGLShaderCache {\n  constructor() {\n    this.shaderCache = /* @__PURE__ */ new Map();\n    this.materialCache = /* @__PURE__ */ new Map();\n  }\n  update(material) {\n    const vertexShader = material.vertexShader;\n    const fragmentShader = material.fragmentShader;\n    const vertexShaderStage = this._getShaderStage(vertexShader);\n    const fragmentShaderStage = this._getShaderStage(fragmentShader);\n    const materialShaders = this._getShaderCacheForMaterial(material);\n    if (materialShaders.has(vertexShaderStage) === false) {\n      materialShaders.add(vertexShaderStage);\n      vertexShaderStage.usedTimes++;\n    }\n    if (materialShaders.has(fragmentShaderStage) === false) {\n      materialShaders.add(fragmentShaderStage);\n      fragmentShaderStage.usedTimes++;\n    }\n    return this;\n  }\n  remove(material) {\n    const materialShaders = this.materialCache.get(material);\n    for (const shaderStage of materialShaders) {\n      shaderStage.usedTimes--;\n      if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);\n    }\n    this.materialCache.delete(material);\n    return this;\n  }\n  getVertexShaderID(material) {\n    return this._getShaderStage(material.vertexShader).id;\n  }\n  getFragmentShaderID(material) {\n    return this._getShaderStage(material.fragmentShader).id;\n  }\n  dispose() {\n    this.shaderCache.clear();\n    this.materialCache.clear();\n  }\n  _getShaderCacheForMaterial(material) {\n    const cache2 = this.materialCache;\n    let set = cache2.get(material);\n    if (set === void 0) {\n      set = /* @__PURE__ */ new Set();\n      cache2.set(material, set);\n    }\n    return set;\n  }\n  _getShaderStage(code) {\n    const cache2 = this.shaderCache;\n    let stage = cache2.get(code);\n    if (stage === void 0) {\n      stage = new WebGLShaderStage(code);\n      cache2.set(code, stage);\n    }\n    return stage;\n  }\n}\nclass WebGLShaderStage {\n  constructor(code) {\n    this.id = _id$1++;\n    this.code = code;\n    this.usedTimes = 0;\n  }\n}\nfunction WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {\n  const _programLayers = new Layers();\n  const _customShaders = new WebGLShaderCache();\n  const _activeChannels = /* @__PURE__ */ new Set();\n  const programs = [];\n  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n  const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;\n  let precision = capabilities.precision;\n  const shaderIDs = {\n    MeshDepthMaterial: \"depth\",\n    MeshDistanceMaterial: \"distanceRGBA\",\n    MeshNormalMaterial: \"normal\",\n    MeshBasicMaterial: \"basic\",\n    MeshLambertMaterial: \"lambert\",\n    MeshPhongMaterial: \"phong\",\n    MeshToonMaterial: \"toon\",\n    MeshStandardMaterial: \"physical\",\n    MeshPhysicalMaterial: \"physical\",\n    MeshMatcapMaterial: \"matcap\",\n    LineBasicMaterial: \"basic\",\n    LineDashedMaterial: \"dashed\",\n    PointsMaterial: \"points\",\n    ShadowMaterial: \"shadow\",\n    SpriteMaterial: \"sprite\"\n  };\n  function getChannel(value) {\n    _activeChannels.add(value);\n    if (value === 0) return \"uv\";\n    return `uv${value}`;\n  }\n  function getParameters(material, lights, shadows, scene, object) {\n    const fog = scene.fog;\n    const geometry = object.geometry;\n    const environment = material.isMeshStandardMaterial ? scene.environment : null;\n    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);\n    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;\n    const shaderID = shaderIDs[material.type];\n    if (material.precision !== null) {\n      precision = capabilities.getMaxPrecision(material.precision);\n      if (precision !== material.precision) {\n        console.warn(\"THREE.WebGLProgram.getParameters:\", material.precision, \"not supported, using\", precision, \"instead.\");\n      }\n    }\n    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;\n    let morphTextureStride = 0;\n    if (geometry.morphAttributes.position !== void 0) morphTextureStride = 1;\n    if (geometry.morphAttributes.normal !== void 0) morphTextureStride = 2;\n    if (geometry.morphAttributes.color !== void 0) morphTextureStride = 3;\n    let vertexShader, fragmentShader;\n    let customVertexShaderID, customFragmentShaderID;\n    if (shaderID) {\n      const shader2 = ShaderLib[shaderID];\n      vertexShader = shader2.vertexShader;\n      fragmentShader = shader2.fragmentShader;\n    } else {\n      vertexShader = material.vertexShader;\n      fragmentShader = material.fragmentShader;\n      _customShaders.update(material);\n      customVertexShaderID = _customShaders.getVertexShaderID(material);\n      customFragmentShaderID = _customShaders.getFragmentShaderID(material);\n    }\n    const currentRenderTarget = renderer.getRenderTarget();\n    const reverseDepthBuffer = renderer.state.buffers.depth.getReversed();\n    const IS_INSTANCEDMESH = object.isInstancedMesh === true;\n    const IS_BATCHEDMESH = object.isBatchedMesh === true;\n    const HAS_MAP = !!material.map;\n    const HAS_MATCAP = !!material.matcap;\n    const HAS_ENVMAP = !!envMap;\n    const HAS_AOMAP = !!material.aoMap;\n    const HAS_LIGHTMAP = !!material.lightMap;\n    const HAS_BUMPMAP = !!material.bumpMap;\n    const HAS_NORMALMAP = !!material.normalMap;\n    const HAS_DISPLACEMENTMAP = !!material.displacementMap;\n    const HAS_EMISSIVEMAP = !!material.emissiveMap;\n    const HAS_METALNESSMAP = !!material.metalnessMap;\n    const HAS_ROUGHNESSMAP = !!material.roughnessMap;\n    const HAS_ANISOTROPY = material.anisotropy > 0;\n    const HAS_CLEARCOAT = material.clearcoat > 0;\n    const HAS_DISPERSION = material.dispersion > 0;\n    const HAS_IRIDESCENCE = material.iridescence > 0;\n    const HAS_SHEEN = material.sheen > 0;\n    const HAS_TRANSMISSION = material.transmission > 0;\n    const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;\n    const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;\n    const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;\n    const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;\n    const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;\n    const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;\n    const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;\n    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;\n    const HAS_SPECULARMAP = !!material.specularMap;\n    const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;\n    const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;\n    const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;\n    const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;\n    const HAS_GRADIENTMAP = !!material.gradientMap;\n    const HAS_ALPHAMAP = !!material.alphaMap;\n    const HAS_ALPHATEST = material.alphaTest > 0;\n    const HAS_ALPHAHASH = !!material.alphaHash;\n    const HAS_EXTENSIONS = !!material.extensions;\n    let toneMapping = NoToneMapping;\n    if (material.toneMapped) {\n      if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {\n        toneMapping = renderer.toneMapping;\n      }\n    }\n    const parameters = {\n      shaderID,\n      shaderType: material.type,\n      shaderName: material.name,\n      vertexShader,\n      fragmentShader,\n      defines: material.defines,\n      customVertexShaderID,\n      customFragmentShaderID,\n      isRawShaderMaterial: material.isRawShaderMaterial === true,\n      glslVersion: material.glslVersion,\n      precision,\n      batching: IS_BATCHEDMESH,\n      batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,\n      instancing: IS_INSTANCEDMESH,\n      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,\n      instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,\n      supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,\n      outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,\n      alphaToCoverage: !!material.alphaToCoverage,\n      map: HAS_MAP,\n      matcap: HAS_MATCAP,\n      envMap: HAS_ENVMAP,\n      envMapMode: HAS_ENVMAP && envMap.mapping,\n      envMapCubeUVHeight,\n      aoMap: HAS_AOMAP,\n      lightMap: HAS_LIGHTMAP,\n      bumpMap: HAS_BUMPMAP,\n      normalMap: HAS_NORMALMAP,\n      displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,\n      emissiveMap: HAS_EMISSIVEMAP,\n      normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,\n      normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,\n      metalnessMap: HAS_METALNESSMAP,\n      roughnessMap: HAS_ROUGHNESSMAP,\n      anisotropy: HAS_ANISOTROPY,\n      anisotropyMap: HAS_ANISOTROPYMAP,\n      clearcoat: HAS_CLEARCOAT,\n      clearcoatMap: HAS_CLEARCOATMAP,\n      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,\n      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,\n      dispersion: HAS_DISPERSION,\n      iridescence: HAS_IRIDESCENCE,\n      iridescenceMap: HAS_IRIDESCENCEMAP,\n      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,\n      sheen: HAS_SHEEN,\n      sheenColorMap: HAS_SHEEN_COLORMAP,\n      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,\n      specularMap: HAS_SPECULARMAP,\n      specularColorMap: HAS_SPECULAR_COLORMAP,\n      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,\n      transmission: HAS_TRANSMISSION,\n      transmissionMap: HAS_TRANSMISSIONMAP,\n      thicknessMap: HAS_THICKNESSMAP,\n      gradientMap: HAS_GRADIENTMAP,\n      opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,\n      alphaMap: HAS_ALPHAMAP,\n      alphaTest: HAS_ALPHATEST,\n      alphaHash: HAS_ALPHAHASH,\n      combine: material.combine,\n      //\n      mapUv: HAS_MAP && getChannel(material.map.channel),\n      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),\n      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),\n      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),\n      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),\n      displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),\n      emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),\n      metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),\n      roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),\n      anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),\n      clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),\n      clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),\n      clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),\n      iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),\n      iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),\n      sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),\n      sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),\n      specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),\n      specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),\n      specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),\n      transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),\n      thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),\n      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),\n      //\n      vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),\n      vertexColors: material.vertexColors,\n      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,\n      pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),\n      fog: !!fog,\n      useFog: material.fog === true,\n      fogExp2: !!fog && fog.isFogExp2,\n      flatShading: material.flatShading === true,\n      sizeAttenuation: material.sizeAttenuation === true,\n      logarithmicDepthBuffer,\n      reverseDepthBuffer,\n      skinning: object.isSkinnedMesh === true,\n      morphTargets: geometry.morphAttributes.position !== void 0,\n      morphNormals: geometry.morphAttributes.normal !== void 0,\n      morphColors: geometry.morphAttributes.color !== void 0,\n      morphTargetsCount,\n      morphTextureStride,\n      numDirLights: lights.directional.length,\n      numPointLights: lights.point.length,\n      numSpotLights: lights.spot.length,\n      numSpotLightMaps: lights.spotLightMap.length,\n      numRectAreaLights: lights.rectArea.length,\n      numHemiLights: lights.hemi.length,\n      numDirLightShadows: lights.directionalShadowMap.length,\n      numPointLightShadows: lights.pointShadowMap.length,\n      numSpotLightShadows: lights.spotShadowMap.length,\n      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,\n      numLightProbes: lights.numLightProbes,\n      numClippingPlanes: clipping.numPlanes,\n      numClipIntersection: clipping.numIntersection,\n      dithering: material.dithering,\n      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n      shadowMapType: renderer.shadowMap.type,\n      toneMapping,\n      decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,\n      decodeVideoTextureEmissive: HAS_EMISSIVEMAP && material.emissiveMap.isVideoTexture === true && ColorManagement.getTransfer(material.emissiveMap.colorSpace) === SRGBTransfer,\n      premultipliedAlpha: material.premultipliedAlpha,\n      doubleSided: material.side === DoubleSide,\n      flipSided: material.side === BackSide,\n      useDepthPacking: material.depthPacking >= 0,\n      depthPacking: material.depthPacking || 0,\n      index0AttributeName: material.index0AttributeName,\n      extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has(\"WEBGL_clip_cull_distance\"),\n      extensionMultiDraw: (HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH) && extensions.has(\"WEBGL_multi_draw\"),\n      rendererExtensionParallelShaderCompile: extensions.has(\"KHR_parallel_shader_compile\"),\n      customProgramCacheKey: material.customProgramCacheKey()\n    };\n    parameters.vertexUv1s = _activeChannels.has(1);\n    parameters.vertexUv2s = _activeChannels.has(2);\n    parameters.vertexUv3s = _activeChannels.has(3);\n    _activeChannels.clear();\n    return parameters;\n  }\n  function getProgramCacheKey(parameters) {\n    const array = [];\n    if (parameters.shaderID) {\n      array.push(parameters.shaderID);\n    } else {\n      array.push(parameters.customVertexShaderID);\n      array.push(parameters.customFragmentShaderID);\n    }\n    if (parameters.defines !== void 0) {\n      for (const name in parameters.defines) {\n        array.push(name);\n        array.push(parameters.defines[name]);\n      }\n    }\n    if (parameters.isRawShaderMaterial === false) {\n      getProgramCacheKeyParameters(array, parameters);\n      getProgramCacheKeyBooleans(array, parameters);\n      array.push(renderer.outputColorSpace);\n    }\n    array.push(parameters.customProgramCacheKey);\n    return array.join();\n  }\n  function getProgramCacheKeyParameters(array, parameters) {\n    array.push(parameters.precision);\n    array.push(parameters.outputColorSpace);\n    array.push(parameters.envMapMode);\n    array.push(parameters.envMapCubeUVHeight);\n    array.push(parameters.mapUv);\n    array.push(parameters.alphaMapUv);\n    array.push(parameters.lightMapUv);\n    array.push(parameters.aoMapUv);\n    array.push(parameters.bumpMapUv);\n    array.push(parameters.normalMapUv);\n    array.push(parameters.displacementMapUv);\n    array.push(parameters.emissiveMapUv);\n    array.push(parameters.metalnessMapUv);\n    array.push(parameters.roughnessMapUv);\n    array.push(parameters.anisotropyMapUv);\n    array.push(parameters.clearcoatMapUv);\n    array.push(parameters.clearcoatNormalMapUv);\n    array.push(parameters.clearcoatRoughnessMapUv);\n    array.push(parameters.iridescenceMapUv);\n    array.push(parameters.iridescenceThicknessMapUv);\n    array.push(parameters.sheenColorMapUv);\n    array.push(parameters.sheenRoughnessMapUv);\n    array.push(parameters.specularMapUv);\n    array.push(parameters.specularColorMapUv);\n    array.push(parameters.specularIntensityMapUv);\n    array.push(parameters.transmissionMapUv);\n    array.push(parameters.thicknessMapUv);\n    array.push(parameters.combine);\n    array.push(parameters.fogExp2);\n    array.push(parameters.sizeAttenuation);\n    array.push(parameters.morphTargetsCount);\n    array.push(parameters.morphAttributeCount);\n    array.push(parameters.numDirLights);\n    array.push(parameters.numPointLights);\n    array.push(parameters.numSpotLights);\n    array.push(parameters.numSpotLightMaps);\n    array.push(parameters.numHemiLights);\n    array.push(parameters.numRectAreaLights);\n    array.push(parameters.numDirLightShadows);\n    array.push(parameters.numPointLightShadows);\n    array.push(parameters.numSpotLightShadows);\n    array.push(parameters.numSpotLightShadowsWithMaps);\n    array.push(parameters.numLightProbes);\n    array.push(parameters.shadowMapType);\n    array.push(parameters.toneMapping);\n    array.push(parameters.numClippingPlanes);\n    array.push(parameters.numClipIntersection);\n    array.push(parameters.depthPacking);\n  }\n  function getProgramCacheKeyBooleans(array, parameters) {\n    _programLayers.disableAll();\n    if (parameters.supportsVertexTextures)\n      _programLayers.enable(0);\n    if (parameters.instancing)\n      _programLayers.enable(1);\n    if (parameters.instancingColor)\n      _programLayers.enable(2);\n    if (parameters.instancingMorph)\n      _programLayers.enable(3);\n    if (parameters.matcap)\n      _programLayers.enable(4);\n    if (parameters.envMap)\n      _programLayers.enable(5);\n    if (parameters.normalMapObjectSpace)\n      _programLayers.enable(6);\n    if (parameters.normalMapTangentSpace)\n      _programLayers.enable(7);\n    if (parameters.clearcoat)\n      _programLayers.enable(8);\n    if (parameters.iridescence)\n      _programLayers.enable(9);\n    if (parameters.alphaTest)\n      _programLayers.enable(10);\n    if (parameters.vertexColors)\n      _programLayers.enable(11);\n    if (parameters.vertexAlphas)\n      _programLayers.enable(12);\n    if (parameters.vertexUv1s)\n      _programLayers.enable(13);\n    if (parameters.vertexUv2s)\n      _programLayers.enable(14);\n    if (parameters.vertexUv3s)\n      _programLayers.enable(15);\n    if (parameters.vertexTangents)\n      _programLayers.enable(16);\n    if (parameters.anisotropy)\n      _programLayers.enable(17);\n    if (parameters.alphaHash)\n      _programLayers.enable(18);\n    if (parameters.batching)\n      _programLayers.enable(19);\n    if (parameters.dispersion)\n      _programLayers.enable(20);\n    if (parameters.batchingColor)\n      _programLayers.enable(21);\n    array.push(_programLayers.mask);\n    _programLayers.disableAll();\n    if (parameters.fog)\n      _programLayers.enable(0);\n    if (parameters.useFog)\n      _programLayers.enable(1);\n    if (parameters.flatShading)\n      _programLayers.enable(2);\n    if (parameters.logarithmicDepthBuffer)\n      _programLayers.enable(3);\n    if (parameters.reverseDepthBuffer)\n      _programLayers.enable(4);\n    if (parameters.skinning)\n      _programLayers.enable(5);\n    if (parameters.morphTargets)\n      _programLayers.enable(6);\n    if (parameters.morphNormals)\n      _programLayers.enable(7);\n    if (parameters.morphColors)\n      _programLayers.enable(8);\n    if (parameters.premultipliedAlpha)\n      _programLayers.enable(9);\n    if (parameters.shadowMapEnabled)\n      _programLayers.enable(10);\n    if (parameters.doubleSided)\n      _programLayers.enable(11);\n    if (parameters.flipSided)\n      _programLayers.enable(12);\n    if (parameters.useDepthPacking)\n      _programLayers.enable(13);\n    if (parameters.dithering)\n      _programLayers.enable(14);\n    if (parameters.transmission)\n      _programLayers.enable(15);\n    if (parameters.sheen)\n      _programLayers.enable(16);\n    if (parameters.opaque)\n      _programLayers.enable(17);\n    if (parameters.pointsUvs)\n      _programLayers.enable(18);\n    if (parameters.decodeVideoTexture)\n      _programLayers.enable(19);\n    if (parameters.decodeVideoTextureEmissive)\n      _programLayers.enable(20);\n    if (parameters.alphaToCoverage)\n      _programLayers.enable(21);\n    array.push(_programLayers.mask);\n  }\n  function getUniforms(material) {\n    const shaderID = shaderIDs[material.type];\n    let uniforms2;\n    if (shaderID) {\n      const shader2 = ShaderLib[shaderID];\n      uniforms2 = UniformsUtils.clone(shader2.uniforms);\n    } else {\n      uniforms2 = material.uniforms;\n    }\n    return uniforms2;\n  }\n  function acquireProgram(parameters, cacheKey) {\n    let program;\n    for (let p = 0, pl = programs.length; p < pl; p++) {\n      const preexistingProgram = programs[p];\n      if (preexistingProgram.cacheKey === cacheKey) {\n        program = preexistingProgram;\n        ++program.usedTimes;\n        break;\n      }\n    }\n    if (program === void 0) {\n      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);\n      programs.push(program);\n    }\n    return program;\n  }\n  function releaseProgram(program) {\n    if (--program.usedTimes === 0) {\n      const i = programs.indexOf(program);\n      programs[i] = programs[programs.length - 1];\n      programs.pop();\n      program.destroy();\n    }\n  }\n  function releaseShaderCache(material) {\n    _customShaders.remove(material);\n  }\n  function dispose() {\n    _customShaders.dispose();\n  }\n  return {\n    getParameters,\n    getProgramCacheKey,\n    getUniforms,\n    acquireProgram,\n    releaseProgram,\n    releaseShaderCache,\n    // Exposed for resource monitoring & error feedback via renderer.info:\n    programs,\n    dispose\n  };\n}\nfunction WebGLProperties() {\n  let properties = /* @__PURE__ */ new WeakMap();\n  function has(object) {\n    return properties.has(object);\n  }\n  function get(object) {\n    let map = properties.get(object);\n    if (map === void 0) {\n      map = {};\n      properties.set(object, map);\n    }\n    return map;\n  }\n  function remove(object) {\n    properties.delete(object);\n  }\n  function update(object, key, value) {\n    properties.get(object)[key] = value;\n  }\n  function dispose() {\n    properties = /* @__PURE__ */ new WeakMap();\n  }\n  return {\n    has,\n    get,\n    remove,\n    update,\n    dispose\n  };\n}\nfunction painterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.material.id !== b.material.id) {\n    return a.material.id - b.material.id;\n  } else if (a.z !== b.z) {\n    return a.z - b.z;\n  } else {\n    return a.id - b.id;\n  }\n}\nfunction reversePainterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.z !== b.z) {\n    return b.z - a.z;\n  } else {\n    return a.id - b.id;\n  }\n}\nfunction WebGLRenderList() {\n  const renderItems = [];\n  let renderItemsIndex = 0;\n  const opaque = [];\n  const transmissive = [];\n  const transparent = [];\n  function init() {\n    renderItemsIndex = 0;\n    opaque.length = 0;\n    transmissive.length = 0;\n    transparent.length = 0;\n  }\n  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {\n    let renderItem = renderItems[renderItemsIndex];\n    if (renderItem === void 0) {\n      renderItem = {\n        id: object.id,\n        object,\n        geometry,\n        material,\n        groupOrder,\n        renderOrder: object.renderOrder,\n        z,\n        group\n      };\n      renderItems[renderItemsIndex] = renderItem;\n    } else {\n      renderItem.id = object.id;\n      renderItem.object = object;\n      renderItem.geometry = geometry;\n      renderItem.material = material;\n      renderItem.groupOrder = groupOrder;\n      renderItem.renderOrder = object.renderOrder;\n      renderItem.z = z;\n      renderItem.group = group;\n    }\n    renderItemsIndex++;\n    return renderItem;\n  }\n  function push(object, geometry, material, groupOrder, z, group) {\n    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n    if (material.transmission > 0) {\n      transmissive.push(renderItem);\n    } else if (material.transparent === true) {\n      transparent.push(renderItem);\n    } else {\n      opaque.push(renderItem);\n    }\n  }\n  function unshift(object, geometry, material, groupOrder, z, group) {\n    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n    if (material.transmission > 0) {\n      transmissive.unshift(renderItem);\n    } else if (material.transparent === true) {\n      transparent.unshift(renderItem);\n    } else {\n      opaque.unshift(renderItem);\n    }\n  }\n  function sort(customOpaqueSort, customTransparentSort) {\n    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);\n    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);\n    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);\n  }\n  function finish() {\n    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {\n      const renderItem = renderItems[i];\n      if (renderItem.id === null) break;\n      renderItem.id = null;\n      renderItem.object = null;\n      renderItem.geometry = null;\n      renderItem.material = null;\n      renderItem.group = null;\n    }\n  }\n  return {\n    opaque,\n    transmissive,\n    transparent,\n    init,\n    push,\n    unshift,\n    finish,\n    sort\n  };\n}\nfunction WebGLRenderLists() {\n  let lists = /* @__PURE__ */ new WeakMap();\n  function get(scene, renderCallDepth) {\n    const listArray = lists.get(scene);\n    let list;\n    if (listArray === void 0) {\n      list = new WebGLRenderList();\n      lists.set(scene, [list]);\n    } else {\n      if (renderCallDepth >= listArray.length) {\n        list = new WebGLRenderList();\n        listArray.push(list);\n      } else {\n        list = listArray[renderCallDepth];\n      }\n    }\n    return list;\n  }\n  function dispose() {\n    lists = /* @__PURE__ */ new WeakMap();\n  }\n  return {\n    get,\n    dispose\n  };\n}\nfunction UniformsCache() {\n  const lights = {};\n  return {\n    get: function(light) {\n      if (lights[light.id] !== void 0) {\n        return lights[light.id];\n      }\n      let uniforms2;\n      switch (light.type) {\n        case \"DirectionalLight\":\n          uniforms2 = {\n            direction: new Vector3(),\n            color: new Color()\n          };\n          break;\n        case \"SpotLight\":\n          uniforms2 = {\n            position: new Vector3(),\n            direction: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            coneCos: 0,\n            penumbraCos: 0,\n            decay: 0\n          };\n          break;\n        case \"PointLight\":\n          uniforms2 = {\n            position: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            decay: 0\n          };\n          break;\n        case \"HemisphereLight\":\n          uniforms2 = {\n            direction: new Vector3(),\n            skyColor: new Color(),\n            groundColor: new Color()\n          };\n          break;\n        case \"RectAreaLight\":\n          uniforms2 = {\n            color: new Color(),\n            position: new Vector3(),\n            halfWidth: new Vector3(),\n            halfHeight: new Vector3()\n          };\n          break;\n      }\n      lights[light.id] = uniforms2;\n      return uniforms2;\n    }\n  };\n}\nfunction ShadowUniformsCache() {\n  const lights = {};\n  return {\n    get: function(light) {\n      if (lights[light.id] !== void 0) {\n        return lights[light.id];\n      }\n      let uniforms2;\n      switch (light.type) {\n        case \"DirectionalLight\":\n          uniforms2 = {\n            shadowIntensity: 1,\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n        case \"SpotLight\":\n          uniforms2 = {\n            shadowIntensity: 1,\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n        case \"PointLight\":\n          uniforms2 = {\n            shadowIntensity: 1,\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2(),\n            shadowCameraNear: 1,\n            shadowCameraFar: 1e3\n          };\n          break;\n      }\n      lights[light.id] = uniforms2;\n      return uniforms2;\n    }\n  };\n}\nlet nextVersion = 0;\nfunction shadowCastingAndTexturingLightsFirst(lightA, lightB) {\n  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);\n}\nfunction WebGLLights(extensions) {\n  const cache2 = new UniformsCache();\n  const shadowCache = ShadowUniformsCache();\n  const state = {\n    version: 0,\n    hash: {\n      directionalLength: -1,\n      pointLength: -1,\n      spotLength: -1,\n      rectAreaLength: -1,\n      hemiLength: -1,\n      numDirectionalShadows: -1,\n      numPointShadows: -1,\n      numSpotShadows: -1,\n      numSpotMaps: -1,\n      numLightProbes: -1\n    },\n    ambient: [0, 0, 0],\n    probe: [],\n    directional: [],\n    directionalShadow: [],\n    directionalShadowMap: [],\n    directionalShadowMatrix: [],\n    spot: [],\n    spotLightMap: [],\n    spotShadow: [],\n    spotShadowMap: [],\n    spotLightMatrix: [],\n    rectArea: [],\n    rectAreaLTC1: null,\n    rectAreaLTC2: null,\n    point: [],\n    pointShadow: [],\n    pointShadowMap: [],\n    pointShadowMatrix: [],\n    hemi: [],\n    numSpotLightShadowsWithMaps: 0,\n    numLightProbes: 0\n  };\n  for (let i = 0; i < 9; i++) state.probe.push(new Vector3());\n  const vector3 = new Vector3();\n  const matrix4 = new Matrix4();\n  const matrix42 = new Matrix4();\n  function setup(lights) {\n    let r = 0, g = 0, b = 0;\n    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);\n    let directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let rectAreaLength = 0;\n    let hemiLength = 0;\n    let numDirectionalShadows = 0;\n    let numPointShadows = 0;\n    let numSpotShadows = 0;\n    let numSpotMaps = 0;\n    let numSpotShadowsWithMaps = 0;\n    let numLightProbes = 0;\n    lights.sort(shadowCastingAndTexturingLightsFirst);\n    for (let i = 0, l = lights.length; i < l; i++) {\n      const light = lights[i];\n      const color = light.color;\n      const intensity = light.intensity;\n      const distance = light.distance;\n      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;\n      if (light.isAmbientLight) {\n        r += color.r * intensity;\n        g += color.g * intensity;\n        b += color.b * intensity;\n      } else if (light.isLightProbe) {\n        for (let j = 0; j < 9; j++) {\n          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n        }\n        numLightProbes++;\n      } else if (light.isDirectionalLight) {\n        const uniforms2 = cache2.get(light);\n        uniforms2.color.copy(light.color).multiplyScalar(light.intensity);\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowIntensity = shadow.intensity;\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          state.directionalShadow[directionalLength] = shadowUniforms;\n          state.directionalShadowMap[directionalLength] = shadowMap;\n          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\n          numDirectionalShadows++;\n        }\n        state.directional[directionalLength] = uniforms2;\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        const uniforms2 = cache2.get(light);\n        uniforms2.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms2.color.copy(color).multiplyScalar(intensity);\n        uniforms2.distance = distance;\n        uniforms2.coneCos = Math.cos(light.angle);\n        uniforms2.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\n        uniforms2.decay = light.decay;\n        state.spot[spotLength] = uniforms2;\n        const shadow = light.shadow;\n        if (light.map) {\n          state.spotLightMap[numSpotMaps] = light.map;\n          numSpotMaps++;\n          shadow.updateMatrices(light);\n          if (light.castShadow) numSpotShadowsWithMaps++;\n        }\n        state.spotLightMatrix[spotLength] = shadow.matrix;\n        if (light.castShadow) {\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowIntensity = shadow.intensity;\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          state.spotShadow[spotLength] = shadowUniforms;\n          state.spotShadowMap[spotLength] = shadowMap;\n          numSpotShadows++;\n        }\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        const uniforms2 = cache2.get(light);\n        uniforms2.color.copy(color).multiplyScalar(intensity);\n        uniforms2.halfWidth.set(light.width * 0.5, 0, 0);\n        uniforms2.halfHeight.set(0, light.height * 0.5, 0);\n        state.rectArea[rectAreaLength] = uniforms2;\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        const uniforms2 = cache2.get(light);\n        uniforms2.color.copy(light.color).multiplyScalar(light.intensity);\n        uniforms2.distance = light.distance;\n        uniforms2.decay = light.decay;\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowIntensity = shadow.intensity;\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          shadowUniforms.shadowCameraNear = shadow.camera.near;\n          shadowUniforms.shadowCameraFar = shadow.camera.far;\n          state.pointShadow[pointLength] = shadowUniforms;\n          state.pointShadowMap[pointLength] = shadowMap;\n          state.pointShadowMatrix[pointLength] = light.shadow.matrix;\n          numPointShadows++;\n        }\n        state.point[pointLength] = uniforms2;\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        const uniforms2 = cache2.get(light);\n        uniforms2.skyColor.copy(light.color).multiplyScalar(intensity);\n        uniforms2.groundColor.copy(light.groundColor).multiplyScalar(intensity);\n        state.hemi[hemiLength] = uniforms2;\n        hemiLength++;\n      }\n    }\n    if (rectAreaLength > 0) {\n      if (extensions.has(\"OES_texture_float_linear\") === true) {\n        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n      } else {\n        state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n        state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n      }\n    }\n    state.ambient[0] = r;\n    state.ambient[1] = g;\n    state.ambient[2] = b;\n    const hash = state.hash;\n    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {\n      state.directional.length = directionalLength;\n      state.spot.length = spotLength;\n      state.rectArea.length = rectAreaLength;\n      state.point.length = pointLength;\n      state.hemi.length = hemiLength;\n      state.directionalShadow.length = numDirectionalShadows;\n      state.directionalShadowMap.length = numDirectionalShadows;\n      state.pointShadow.length = numPointShadows;\n      state.pointShadowMap.length = numPointShadows;\n      state.spotShadow.length = numSpotShadows;\n      state.spotShadowMap.length = numSpotShadows;\n      state.directionalShadowMatrix.length = numDirectionalShadows;\n      state.pointShadowMatrix.length = numPointShadows;\n      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;\n      state.spotLightMap.length = numSpotMaps;\n      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;\n      state.numLightProbes = numLightProbes;\n      hash.directionalLength = directionalLength;\n      hash.pointLength = pointLength;\n      hash.spotLength = spotLength;\n      hash.rectAreaLength = rectAreaLength;\n      hash.hemiLength = hemiLength;\n      hash.numDirectionalShadows = numDirectionalShadows;\n      hash.numPointShadows = numPointShadows;\n      hash.numSpotShadows = numSpotShadows;\n      hash.numSpotMaps = numSpotMaps;\n      hash.numLightProbes = numLightProbes;\n      state.version = nextVersion++;\n    }\n  }\n  function setupView(lights, camera) {\n    let directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let rectAreaLength = 0;\n    let hemiLength = 0;\n    const viewMatrix = camera.matrixWorldInverse;\n    for (let i = 0, l = lights.length; i < l; i++) {\n      const light = lights[i];\n      if (light.isDirectionalLight) {\n        const uniforms2 = state.directional[directionalLength];\n        uniforms2.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms2.direction.sub(vector3);\n        uniforms2.direction.transformDirection(viewMatrix);\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        const uniforms2 = state.spot[spotLength];\n        uniforms2.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms2.position.applyMatrix4(viewMatrix);\n        uniforms2.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms2.direction.sub(vector3);\n        uniforms2.direction.transformDirection(viewMatrix);\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        const uniforms2 = state.rectArea[rectAreaLength];\n        uniforms2.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms2.position.applyMatrix4(viewMatrix);\n        matrix42.identity();\n        matrix4.copy(light.matrixWorld);\n        matrix4.premultiply(viewMatrix);\n        matrix42.extractRotation(matrix4);\n        uniforms2.halfWidth.set(light.width * 0.5, 0, 0);\n        uniforms2.halfHeight.set(0, light.height * 0.5, 0);\n        uniforms2.halfWidth.applyMatrix4(matrix42);\n        uniforms2.halfHeight.applyMatrix4(matrix42);\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        const uniforms2 = state.point[pointLength];\n        uniforms2.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms2.position.applyMatrix4(viewMatrix);\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        const uniforms2 = state.hemi[hemiLength];\n        uniforms2.direction.setFromMatrixPosition(light.matrixWorld);\n        uniforms2.direction.transformDirection(viewMatrix);\n        hemiLength++;\n      }\n    }\n  }\n  return {\n    setup,\n    setupView,\n    state\n  };\n}\nfunction WebGLRenderState(extensions) {\n  const lights = new WebGLLights(extensions);\n  const lightsArray = [];\n  const shadowsArray = [];\n  function init(camera) {\n    state.camera = camera;\n    lightsArray.length = 0;\n    shadowsArray.length = 0;\n  }\n  function pushLight(light) {\n    lightsArray.push(light);\n  }\n  function pushShadow(shadowLight) {\n    shadowsArray.push(shadowLight);\n  }\n  function setupLights() {\n    lights.setup(lightsArray);\n  }\n  function setupLightsView(camera) {\n    lights.setupView(lightsArray, camera);\n  }\n  const state = {\n    lightsArray,\n    shadowsArray,\n    camera: null,\n    lights,\n    transmissionRenderTarget: {}\n  };\n  return {\n    init,\n    state,\n    setupLights,\n    setupLightsView,\n    pushLight,\n    pushShadow\n  };\n}\nfunction WebGLRenderStates(extensions) {\n  let renderStates = /* @__PURE__ */ new WeakMap();\n  function get(scene, renderCallDepth = 0) {\n    const renderStateArray = renderStates.get(scene);\n    let renderState;\n    if (renderStateArray === void 0) {\n      renderState = new WebGLRenderState(extensions);\n      renderStates.set(scene, [renderState]);\n    } else {\n      if (renderCallDepth >= renderStateArray.length) {\n        renderState = new WebGLRenderState(extensions);\n        renderStateArray.push(renderState);\n      } else {\n        renderState = renderStateArray[renderCallDepth];\n      }\n    }\n    return renderState;\n  }\n  function dispose() {\n    renderStates = /* @__PURE__ */ new WeakMap();\n  }\n  return {\n    get,\n    dispose\n  };\n}\nclass MeshDepthMaterial extends Material {\n  static get type() {\n    return \"MeshDepthMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshDepthMaterial = true;\n    this.depthPacking = BasicDepthPacking;\n    this.map = null;\n    this.alphaMap = null;\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.depthPacking = source.depthPacking;\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    return this;\n  }\n}\nclass MeshDistanceMaterial extends Material {\n  static get type() {\n    return \"MeshDistanceMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshDistanceMaterial = true;\n    this.map = null;\n    this.alphaMap = null;\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    return this;\n  }\n}\nconst vertex = \"void main() {\\n\tgl_Position = vec4( position, 1.0 );\\n}\";\nconst fragment = \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\tconst float samples = float( VSM_SAMPLES );\\n\tfloat mean = 0.0;\\n\tfloat squared_mean = 0.0;\\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\\n\tfor ( float i = 0.0; i < samples; i ++ ) {\\n\t\tfloat uvOffset = uvStart + i * uvStride;\\n\t\t#ifdef HORIZONTAL_PASS\\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\\n\t\t\tmean += distribution.x;\\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\t\t#else\\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\\n\t\t\tmean += depth;\\n\t\t\tsquared_mean += depth * depth;\\n\t\t#endif\\n\t}\\n\tmean = mean / samples;\\n\tsquared_mean = squared_mean / samples;\\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\";\nfunction WebGLShadowMap(renderer, objects, capabilities) {\n  let _frustum = new Frustum();\n  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport2 = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = capabilities.maxTextureSize;\n  const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };\n  const shadowMaterialVertical = new ShaderMaterial({\n    defines: {\n      VSM_SAMPLES: 8\n    },\n    uniforms: {\n      shadow_pass: { value: null },\n      resolution: { value: new Vector2() },\n      radius: { value: 4 }\n    },\n    vertexShader: vertex,\n    fragmentShader: fragment\n  });\n  const shadowMaterialHorizontal = shadowMaterialVertical.clone();\n  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n  const fullScreenTri = new BufferGeometry();\n  fullScreenTri.setAttribute(\n    \"position\",\n    new BufferAttribute(\n      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),\n      3\n    )\n  );\n  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);\n  const scope = this;\n  this.enabled = false;\n  this.autoUpdate = true;\n  this.needsUpdate = false;\n  this.type = PCFShadowMap;\n  let _previousType = this.type;\n  this.render = function(lights, scene, camera) {\n    if (scope.enabled === false) return;\n    if (scope.autoUpdate === false && scope.needsUpdate === false) return;\n    if (lights.length === 0) return;\n    const currentRenderTarget = renderer.getRenderTarget();\n    const activeCubeFace = renderer.getActiveCubeFace();\n    const activeMipmapLevel = renderer.getActiveMipmapLevel();\n    const _state = renderer.state;\n    _state.setBlending(NoBlending);\n    _state.buffers.color.setClear(1, 1, 1, 1);\n    _state.buffers.depth.setTest(true);\n    _state.setScissorTest(false);\n    const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;\n    const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;\n    for (let i = 0, il = lights.length; i < il; i++) {\n      const light = lights[i];\n      const shadow = light.shadow;\n      if (shadow === void 0) {\n        console.warn(\"THREE.WebGLShadowMap:\", light, \"has no shadow.\");\n        continue;\n      }\n      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;\n      _shadowMapSize.copy(shadow.mapSize);\n      const shadowFrameExtents = shadow.getFrameExtents();\n      _shadowMapSize.multiply(shadowFrameExtents);\n      _viewportSize.copy(shadow.mapSize);\n      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {\n        if (_shadowMapSize.x > _maxTextureSize) {\n          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);\n          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n          shadow.mapSize.x = _viewportSize.x;\n        }\n        if (_shadowMapSize.y > _maxTextureSize) {\n          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);\n          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n          shadow.mapSize.y = _viewportSize.y;\n        }\n      }\n      if (shadow.map === null || toVSM === true || fromVSM === true) {\n        const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};\n        if (shadow.map !== null) {\n          shadow.map.dispose();\n        }\n        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.map.texture.name = light.name + \".shadowMap\";\n        shadow.camera.updateProjectionMatrix();\n      }\n      renderer.setRenderTarget(shadow.map);\n      renderer.clear();\n      const viewportCount = shadow.getViewportCount();\n      for (let vp = 0; vp < viewportCount; vp++) {\n        const viewport = shadow.getViewport(vp);\n        _viewport2.set(\n          _viewportSize.x * viewport.x,\n          _viewportSize.y * viewport.y,\n          _viewportSize.x * viewport.z,\n          _viewportSize.y * viewport.w\n        );\n        _state.viewport(_viewport2);\n        shadow.updateMatrices(light, vp);\n        _frustum = shadow.getFrustum();\n        renderObject(scene, camera, shadow.camera, light, this.type);\n      }\n      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {\n        VSMPass(shadow, camera);\n      }\n      shadow.needsUpdate = false;\n    }\n    _previousType = this.type;\n    scope.needsUpdate = false;\n    renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);\n  };\n  function VSMPass(shadow, camera) {\n    const geometry = objects.update(fullScreenMesh);\n    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {\n      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;\n      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;\n      shadowMaterialVertical.needsUpdate = true;\n      shadowMaterialHorizontal.needsUpdate = true;\n    }\n    if (shadow.mapPass === null) {\n      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);\n    }\n    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialVertical.uniforms.radius.value = shadow.radius;\n    renderer.setRenderTarget(shadow.mapPass);\n    renderer.clear();\n    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);\n    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n    renderer.setRenderTarget(shadow.map);\n    renderer.clear();\n    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);\n  }\n  function getDepthMaterial(object, material, light, type) {\n    let result = null;\n    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;\n    if (customMaterial !== void 0) {\n      result = customMaterial;\n    } else {\n      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;\n      if (renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {\n        const keyA = result.uuid, keyB = material.uuid;\n        let materialsForVariant = _materialCache[keyA];\n        if (materialsForVariant === void 0) {\n          materialsForVariant = {};\n          _materialCache[keyA] = materialsForVariant;\n        }\n        let cachedMaterial = materialsForVariant[keyB];\n        if (cachedMaterial === void 0) {\n          cachedMaterial = result.clone();\n          materialsForVariant[keyB] = cachedMaterial;\n          material.addEventListener(\"dispose\", onMaterialDispose);\n        }\n        result = cachedMaterial;\n      }\n    }\n    result.visible = material.visible;\n    result.wireframe = material.wireframe;\n    if (type === VSMShadowMap) {\n      result.side = material.shadowSide !== null ? material.shadowSide : material.side;\n    } else {\n      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];\n    }\n    result.alphaMap = material.alphaMap;\n    result.alphaTest = material.alphaTest;\n    result.map = material.map;\n    result.clipShadows = material.clipShadows;\n    result.clippingPlanes = material.clippingPlanes;\n    result.clipIntersection = material.clipIntersection;\n    result.displacementMap = material.displacementMap;\n    result.displacementScale = material.displacementScale;\n    result.displacementBias = material.displacementBias;\n    result.wireframeLinewidth = material.wireframeLinewidth;\n    result.linewidth = material.linewidth;\n    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {\n      const materialProperties = renderer.properties.get(result);\n      materialProperties.light = light;\n    }\n    return result;\n  }\n  function renderObject(object, camera, shadowCamera, light, type) {\n    if (object.visible === false) return;\n    const visible = object.layers.test(camera.layers);\n    if (visible && (object.isMesh || object.isLine || object.isPoints)) {\n      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {\n        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\n        const geometry = objects.update(object);\n        const material = object.material;\n        if (Array.isArray(material)) {\n          const groups = geometry.groups;\n          for (let k = 0, kl = groups.length; k < kl; k++) {\n            const group = groups[k];\n            const groupMaterial = material[group.materialIndex];\n            if (groupMaterial && groupMaterial.visible) {\n              const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);\n              object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);\n              renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);\n              object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);\n            }\n          }\n        } else if (material.visible) {\n          const depthMaterial = getDepthMaterial(object, material, light, type);\n          object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);\n          renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);\n          object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);\n        }\n      }\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      renderObject(children[i], camera, shadowCamera, light, type);\n    }\n  }\n  function onMaterialDispose(event) {\n    const material = event.target;\n    material.removeEventListener(\"dispose\", onMaterialDispose);\n    for (const id2 in _materialCache) {\n      const cache2 = _materialCache[id2];\n      const uuid = event.target.uuid;\n      if (uuid in cache2) {\n        const shadowMaterial = cache2[uuid];\n        shadowMaterial.dispose();\n        delete cache2[uuid];\n      }\n    }\n  }\n}\nconst reversedFuncs = {\n  [NeverDepth]: AlwaysDepth,\n  [LessDepth]: GreaterDepth,\n  [EqualDepth]: NotEqualDepth,\n  [LessEqualDepth]: GreaterEqualDepth,\n  [AlwaysDepth]: NeverDepth,\n  [GreaterDepth]: LessDepth,\n  [NotEqualDepth]: EqualDepth,\n  [GreaterEqualDepth]: LessEqualDepth\n};\nfunction WebGLState(gl, extensions) {\n  function ColorBuffer() {\n    let locked = false;\n    const color = new Vector4();\n    let currentColorMask = null;\n    const currentColorClear = new Vector4(0, 0, 0, 0);\n    return {\n      setMask: function(colorMask) {\n        if (currentColorMask !== colorMask && !locked) {\n          gl.colorMask(colorMask, colorMask, colorMask, colorMask);\n          currentColorMask = colorMask;\n        }\n      },\n      setLocked: function(lock) {\n        locked = lock;\n      },\n      setClear: function(r, g, b, a, premultipliedAlpha) {\n        if (premultipliedAlpha === true) {\n          r *= a;\n          g *= a;\n          b *= a;\n        }\n        color.set(r, g, b, a);\n        if (currentColorClear.equals(color) === false) {\n          gl.clearColor(r, g, b, a);\n          currentColorClear.copy(color);\n        }\n      },\n      reset: function() {\n        locked = false;\n        currentColorMask = null;\n        currentColorClear.set(-1, 0, 0, 0);\n      }\n    };\n  }\n  function DepthBuffer() {\n    let locked = false;\n    let reversed = false;\n    let currentDepthMask = null;\n    let currentDepthFunc = null;\n    let currentDepthClear = null;\n    return {\n      setReversed: function(value) {\n        if (reversed !== value) {\n          const ext2 = extensions.get(\"EXT_clip_control\");\n          if (reversed) {\n            ext2.clipControlEXT(ext2.LOWER_LEFT_EXT, ext2.ZERO_TO_ONE_EXT);\n          } else {\n            ext2.clipControlEXT(ext2.LOWER_LEFT_EXT, ext2.NEGATIVE_ONE_TO_ONE_EXT);\n          }\n          const oldDepth = currentDepthClear;\n          currentDepthClear = null;\n          this.setClear(oldDepth);\n        }\n        reversed = value;\n      },\n      getReversed: function() {\n        return reversed;\n      },\n      setTest: function(depthTest) {\n        if (depthTest) {\n          enable(gl.DEPTH_TEST);\n        } else {\n          disable(gl.DEPTH_TEST);\n        }\n      },\n      setMask: function(depthMask) {\n        if (currentDepthMask !== depthMask && !locked) {\n          gl.depthMask(depthMask);\n          currentDepthMask = depthMask;\n        }\n      },\n      setFunc: function(depthFunc) {\n        if (reversed) depthFunc = reversedFuncs[depthFunc];\n        if (currentDepthFunc !== depthFunc) {\n          switch (depthFunc) {\n            case NeverDepth:\n              gl.depthFunc(gl.NEVER);\n              break;\n            case AlwaysDepth:\n              gl.depthFunc(gl.ALWAYS);\n              break;\n            case LessDepth:\n              gl.depthFunc(gl.LESS);\n              break;\n            case LessEqualDepth:\n              gl.depthFunc(gl.LEQUAL);\n              break;\n            case EqualDepth:\n              gl.depthFunc(gl.EQUAL);\n              break;\n            case GreaterEqualDepth:\n              gl.depthFunc(gl.GEQUAL);\n              break;\n            case GreaterDepth:\n              gl.depthFunc(gl.GREATER);\n              break;\n            case NotEqualDepth:\n              gl.depthFunc(gl.NOTEQUAL);\n              break;\n            default:\n              gl.depthFunc(gl.LEQUAL);\n          }\n          currentDepthFunc = depthFunc;\n        }\n      },\n      setLocked: function(lock) {\n        locked = lock;\n      },\n      setClear: function(depth) {\n        if (currentDepthClear !== depth) {\n          if (reversed) {\n            depth = 1 - depth;\n          }\n          gl.clearDepth(depth);\n          currentDepthClear = depth;\n        }\n      },\n      reset: function() {\n        locked = false;\n        currentDepthMask = null;\n        currentDepthFunc = null;\n        currentDepthClear = null;\n        reversed = false;\n      }\n    };\n  }\n  function StencilBuffer() {\n    let locked = false;\n    let currentStencilMask = null;\n    let currentStencilFunc = null;\n    let currentStencilRef = null;\n    let currentStencilFuncMask = null;\n    let currentStencilFail = null;\n    let currentStencilZFail = null;\n    let currentStencilZPass = null;\n    let currentStencilClear = null;\n    return {\n      setTest: function(stencilTest) {\n        if (!locked) {\n          if (stencilTest) {\n            enable(gl.STENCIL_TEST);\n          } else {\n            disable(gl.STENCIL_TEST);\n          }\n        }\n      },\n      setMask: function(stencilMask) {\n        if (currentStencilMask !== stencilMask && !locked) {\n          gl.stencilMask(stencilMask);\n          currentStencilMask = stencilMask;\n        }\n      },\n      setFunc: function(stencilFunc, stencilRef, stencilMask) {\n        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {\n          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);\n          currentStencilFunc = stencilFunc;\n          currentStencilRef = stencilRef;\n          currentStencilFuncMask = stencilMask;\n        }\n      },\n      setOp: function(stencilFail, stencilZFail, stencilZPass) {\n        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {\n          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);\n          currentStencilFail = stencilFail;\n          currentStencilZFail = stencilZFail;\n          currentStencilZPass = stencilZPass;\n        }\n      },\n      setLocked: function(lock) {\n        locked = lock;\n      },\n      setClear: function(stencil) {\n        if (currentStencilClear !== stencil) {\n          gl.clearStencil(stencil);\n          currentStencilClear = stencil;\n        }\n      },\n      reset: function() {\n        locked = false;\n        currentStencilMask = null;\n        currentStencilFunc = null;\n        currentStencilRef = null;\n        currentStencilFuncMask = null;\n        currentStencilFail = null;\n        currentStencilZFail = null;\n        currentStencilZPass = null;\n        currentStencilClear = null;\n      }\n    };\n  }\n  const colorBuffer = new ColorBuffer();\n  const depthBuffer = new DepthBuffer();\n  const stencilBuffer = new StencilBuffer();\n  const uboBindings = /* @__PURE__ */ new WeakMap();\n  const uboProgramMap = /* @__PURE__ */ new WeakMap();\n  let enabledCapabilities = {};\n  let currentBoundFramebuffers = {};\n  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();\n  let defaultDrawbuffers = [];\n  let currentProgram = null;\n  let currentBlendingEnabled = false;\n  let currentBlending = null;\n  let currentBlendEquation = null;\n  let currentBlendSrc = null;\n  let currentBlendDst = null;\n  let currentBlendEquationAlpha = null;\n  let currentBlendSrcAlpha = null;\n  let currentBlendDstAlpha = null;\n  let currentBlendColor = new Color(0, 0, 0);\n  let currentBlendAlpha = 0;\n  let currentPremultipledAlpha = false;\n  let currentFlipSided = null;\n  let currentCullFace = null;\n  let currentLineWidth = null;\n  let currentPolygonOffsetFactor = null;\n  let currentPolygonOffsetUnits = null;\n  const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n  let lineWidthAvailable = false;\n  let version = 0;\n  const glVersion = gl.getParameter(gl.VERSION);\n  if (glVersion.indexOf(\"WebGL\") !== -1) {\n    version = parseFloat(/^WebGL (\\d)/.exec(glVersion)[1]);\n    lineWidthAvailable = version >= 1;\n  } else if (glVersion.indexOf(\"OpenGL ES\") !== -1) {\n    version = parseFloat(/^OpenGL ES (\\d)/.exec(glVersion)[1]);\n    lineWidthAvailable = version >= 2;\n  }\n  let currentTextureSlot = null;\n  let currentBoundTextures = {};\n  const scissorParam = gl.getParameter(gl.SCISSOR_BOX);\n  const viewportParam = gl.getParameter(gl.VIEWPORT);\n  const currentScissor = new Vector4().fromArray(scissorParam);\n  const currentViewport = new Vector4().fromArray(viewportParam);\n  function createTexture(type, target, count, dimensions) {\n    const data = new Uint8Array(4);\n    const texture = gl.createTexture();\n    gl.bindTexture(type, texture);\n    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    for (let i = 0; i < count; i++) {\n      if (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY) {\n        gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      } else {\n        gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      }\n    }\n    return texture;\n  }\n  const emptyTextures = {};\n  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);\n  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);\n  emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);\n  emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);\n  colorBuffer.setClear(0, 0, 0, 1);\n  depthBuffer.setClear(1);\n  stencilBuffer.setClear(0);\n  enable(gl.DEPTH_TEST);\n  depthBuffer.setFunc(LessEqualDepth);\n  setFlipSided(false);\n  setCullFace(CullFaceBack);\n  enable(gl.CULL_FACE);\n  setBlending(NoBlending);\n  function enable(id2) {\n    if (enabledCapabilities[id2] !== true) {\n      gl.enable(id2);\n      enabledCapabilities[id2] = true;\n    }\n  }\n  function disable(id2) {\n    if (enabledCapabilities[id2] !== false) {\n      gl.disable(id2);\n      enabledCapabilities[id2] = false;\n    }\n  }\n  function bindFramebuffer(target, framebuffer) {\n    if (currentBoundFramebuffers[target] !== framebuffer) {\n      gl.bindFramebuffer(target, framebuffer);\n      currentBoundFramebuffers[target] = framebuffer;\n      if (target === gl.DRAW_FRAMEBUFFER) {\n        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;\n      }\n      if (target === gl.FRAMEBUFFER) {\n        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;\n      }\n      return true;\n    }\n    return false;\n  }\n  function drawBuffers(renderTarget, framebuffer) {\n    let drawBuffers2 = defaultDrawbuffers;\n    let needsUpdate = false;\n    if (renderTarget) {\n      drawBuffers2 = currentDrawbuffers.get(framebuffer);\n      if (drawBuffers2 === void 0) {\n        drawBuffers2 = [];\n        currentDrawbuffers.set(framebuffer, drawBuffers2);\n      }\n      const textures = renderTarget.textures;\n      if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {\n        for (let i = 0, il = textures.length; i < il; i++) {\n          drawBuffers2[i] = gl.COLOR_ATTACHMENT0 + i;\n        }\n        drawBuffers2.length = textures.length;\n        needsUpdate = true;\n      }\n    } else {\n      if (drawBuffers2[0] !== gl.BACK) {\n        drawBuffers2[0] = gl.BACK;\n        needsUpdate = true;\n      }\n    }\n    if (needsUpdate) {\n      gl.drawBuffers(drawBuffers2);\n    }\n  }\n  function useProgram(program) {\n    if (currentProgram !== program) {\n      gl.useProgram(program);\n      currentProgram = program;\n      return true;\n    }\n    return false;\n  }\n  const equationToGL = {\n    [AddEquation]: gl.FUNC_ADD,\n    [SubtractEquation]: gl.FUNC_SUBTRACT,\n    [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT\n  };\n  equationToGL[MinEquation] = gl.MIN;\n  equationToGL[MaxEquation] = gl.MAX;\n  const factorToGL = {\n    [ZeroFactor]: gl.ZERO,\n    [OneFactor]: gl.ONE,\n    [SrcColorFactor]: gl.SRC_COLOR,\n    [SrcAlphaFactor]: gl.SRC_ALPHA,\n    [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,\n    [DstColorFactor]: gl.DST_COLOR,\n    [DstAlphaFactor]: gl.DST_ALPHA,\n    [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,\n    [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,\n    [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,\n    [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,\n    [ConstantColorFactor]: gl.CONSTANT_COLOR,\n    [OneMinusConstantColorFactor]: gl.ONE_MINUS_CONSTANT_COLOR,\n    [ConstantAlphaFactor]: gl.CONSTANT_ALPHA,\n    [OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA\n  };\n  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {\n    if (blending === NoBlending) {\n      if (currentBlendingEnabled === true) {\n        disable(gl.BLEND);\n        currentBlendingEnabled = false;\n      }\n      return;\n    }\n    if (currentBlendingEnabled === false) {\n      enable(gl.BLEND);\n      currentBlendingEnabled = true;\n    }\n    if (blending !== CustomBlending) {\n      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {\n        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {\n          gl.blendEquation(gl.FUNC_ADD);\n          currentBlendEquation = AddEquation;\n          currentBlendEquationAlpha = AddEquation;\n        }\n        if (premultipliedAlpha) {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n              break;\n            case AdditiveBlending:\n              gl.blendFunc(gl.ONE, gl.ONE);\n              break;\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);\n              break;\n            case MultiplyBlending:\n              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);\n              break;\n            default:\n              console.error(\"THREE.WebGLState: Invalid blending: \", blending);\n              break;\n          }\n        } else {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n              break;\n            case AdditiveBlending:\n              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n              break;\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);\n              break;\n            case MultiplyBlending:\n              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n              break;\n            default:\n              console.error(\"THREE.WebGLState: Invalid blending: \", blending);\n              break;\n          }\n        }\n        currentBlendSrc = null;\n        currentBlendDst = null;\n        currentBlendSrcAlpha = null;\n        currentBlendDstAlpha = null;\n        currentBlendColor.set(0, 0, 0);\n        currentBlendAlpha = 0;\n        currentBlending = blending;\n        currentPremultipledAlpha = premultipliedAlpha;\n      }\n      return;\n    }\n    blendEquationAlpha = blendEquationAlpha || blendEquation;\n    blendSrcAlpha = blendSrcAlpha || blendSrc;\n    blendDstAlpha = blendDstAlpha || blendDst;\n    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {\n      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);\n      currentBlendEquation = blendEquation;\n      currentBlendEquationAlpha = blendEquationAlpha;\n    }\n    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {\n      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);\n      currentBlendSrc = blendSrc;\n      currentBlendDst = blendDst;\n      currentBlendSrcAlpha = blendSrcAlpha;\n      currentBlendDstAlpha = blendDstAlpha;\n    }\n    if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {\n      gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);\n      currentBlendColor.copy(blendColor);\n      currentBlendAlpha = blendAlpha;\n    }\n    currentBlending = blending;\n    currentPremultipledAlpha = false;\n  }\n  function setMaterial(material, frontFaceCW) {\n    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);\n    let flipSided = material.side === BackSide;\n    if (frontFaceCW) flipSided = !flipSided;\n    setFlipSided(flipSided);\n    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);\n    depthBuffer.setFunc(material.depthFunc);\n    depthBuffer.setTest(material.depthTest);\n    depthBuffer.setMask(material.depthWrite);\n    colorBuffer.setMask(material.colorWrite);\n    const stencilWrite = material.stencilWrite;\n    stencilBuffer.setTest(stencilWrite);\n    if (stencilWrite) {\n      stencilBuffer.setMask(material.stencilWriteMask);\n      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);\n      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);\n    }\n    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n    material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n  }\n  function setFlipSided(flipSided) {\n    if (currentFlipSided !== flipSided) {\n      if (flipSided) {\n        gl.frontFace(gl.CW);\n      } else {\n        gl.frontFace(gl.CCW);\n      }\n      currentFlipSided = flipSided;\n    }\n  }\n  function setCullFace(cullFace) {\n    if (cullFace !== CullFaceNone) {\n      enable(gl.CULL_FACE);\n      if (cullFace !== currentCullFace) {\n        if (cullFace === CullFaceBack) {\n          gl.cullFace(gl.BACK);\n        } else if (cullFace === CullFaceFront) {\n          gl.cullFace(gl.FRONT);\n        } else {\n          gl.cullFace(gl.FRONT_AND_BACK);\n        }\n      }\n    } else {\n      disable(gl.CULL_FACE);\n    }\n    currentCullFace = cullFace;\n  }\n  function setLineWidth(width) {\n    if (width !== currentLineWidth) {\n      if (lineWidthAvailable) gl.lineWidth(width);\n      currentLineWidth = width;\n    }\n  }\n  function setPolygonOffset(polygonOffset, factor, units) {\n    if (polygonOffset) {\n      enable(gl.POLYGON_OFFSET_FILL);\n      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {\n        gl.polygonOffset(factor, units);\n        currentPolygonOffsetFactor = factor;\n        currentPolygonOffsetUnits = units;\n      }\n    } else {\n      disable(gl.POLYGON_OFFSET_FILL);\n    }\n  }\n  function setScissorTest(scissorTest) {\n    if (scissorTest) {\n      enable(gl.SCISSOR_TEST);\n    } else {\n      disable(gl.SCISSOR_TEST);\n    }\n  }\n  function activeTexture(webglSlot) {\n    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n    if (currentTextureSlot !== webglSlot) {\n      gl.activeTexture(webglSlot);\n      currentTextureSlot = webglSlot;\n    }\n  }\n  function bindTexture(webglType, webglTexture, webglSlot) {\n    if (webglSlot === void 0) {\n      if (currentTextureSlot === null) {\n        webglSlot = gl.TEXTURE0 + maxTextures - 1;\n      } else {\n        webglSlot = currentTextureSlot;\n      }\n    }\n    let boundTexture = currentBoundTextures[webglSlot];\n    if (boundTexture === void 0) {\n      boundTexture = { type: void 0, texture: void 0 };\n      currentBoundTextures[webglSlot] = boundTexture;\n    }\n    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {\n      if (currentTextureSlot !== webglSlot) {\n        gl.activeTexture(webglSlot);\n        currentTextureSlot = webglSlot;\n      }\n      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);\n      boundTexture.type = webglType;\n      boundTexture.texture = webglTexture;\n    }\n  }\n  function unbindTexture() {\n    const boundTexture = currentBoundTextures[currentTextureSlot];\n    if (boundTexture !== void 0 && boundTexture.type !== void 0) {\n      gl.bindTexture(boundTexture.type, null);\n      boundTexture.type = void 0;\n      boundTexture.texture = void 0;\n    }\n  }\n  function compressedTexImage2D() {\n    try {\n      gl.compressedTexImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function compressedTexImage3D() {\n    try {\n      gl.compressedTexImage3D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function texSubImage2D() {\n    try {\n      gl.texSubImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function texSubImage3D() {\n    try {\n      gl.texSubImage3D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function compressedTexSubImage2D() {\n    try {\n      gl.compressedTexSubImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function compressedTexSubImage3D() {\n    try {\n      gl.compressedTexSubImage3D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function texStorage2D() {\n    try {\n      gl.texStorage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function texStorage3D() {\n    try {\n      gl.texStorage3D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function texImage2D() {\n    try {\n      gl.texImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function texImage3D() {\n    try {\n      gl.texImage3D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function scissor(scissor2) {\n    if (currentScissor.equals(scissor2) === false) {\n      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);\n      currentScissor.copy(scissor2);\n    }\n  }\n  function viewport(viewport2) {\n    if (currentViewport.equals(viewport2) === false) {\n      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);\n      currentViewport.copy(viewport2);\n    }\n  }\n  function updateUBOMapping(uniformsGroup, program) {\n    let mapping = uboProgramMap.get(program);\n    if (mapping === void 0) {\n      mapping = /* @__PURE__ */ new WeakMap();\n      uboProgramMap.set(program, mapping);\n    }\n    let blockIndex = mapping.get(uniformsGroup);\n    if (blockIndex === void 0) {\n      blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);\n      mapping.set(uniformsGroup, blockIndex);\n    }\n  }\n  function uniformBlockBinding(uniformsGroup, program) {\n    const mapping = uboProgramMap.get(program);\n    const blockIndex = mapping.get(uniformsGroup);\n    if (uboBindings.get(program) !== blockIndex) {\n      gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);\n      uboBindings.set(program, blockIndex);\n    }\n  }\n  function reset() {\n    gl.disable(gl.BLEND);\n    gl.disable(gl.CULL_FACE);\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.POLYGON_OFFSET_FILL);\n    gl.disable(gl.SCISSOR_TEST);\n    gl.disable(gl.STENCIL_TEST);\n    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n    gl.blendEquation(gl.FUNC_ADD);\n    gl.blendFunc(gl.ONE, gl.ZERO);\n    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);\n    gl.blendColor(0, 0, 0, 0);\n    gl.colorMask(true, true, true, true);\n    gl.clearColor(0, 0, 0, 0);\n    gl.depthMask(true);\n    gl.depthFunc(gl.LESS);\n    depthBuffer.setReversed(false);\n    gl.clearDepth(1);\n    gl.stencilMask(4294967295);\n    gl.stencilFunc(gl.ALWAYS, 0, 4294967295);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n    gl.clearStencil(0);\n    gl.cullFace(gl.BACK);\n    gl.frontFace(gl.CCW);\n    gl.polygonOffset(0, 0);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);\n    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);\n    gl.useProgram(null);\n    gl.lineWidth(1);\n    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    enabledCapabilities = {};\n    currentTextureSlot = null;\n    currentBoundTextures = {};\n    currentBoundFramebuffers = {};\n    currentDrawbuffers = /* @__PURE__ */ new WeakMap();\n    defaultDrawbuffers = [];\n    currentProgram = null;\n    currentBlendingEnabled = false;\n    currentBlending = null;\n    currentBlendEquation = null;\n    currentBlendSrc = null;\n    currentBlendDst = null;\n    currentBlendEquationAlpha = null;\n    currentBlendSrcAlpha = null;\n    currentBlendDstAlpha = null;\n    currentBlendColor = new Color(0, 0, 0);\n    currentBlendAlpha = 0;\n    currentPremultipledAlpha = false;\n    currentFlipSided = null;\n    currentCullFace = null;\n    currentLineWidth = null;\n    currentPolygonOffsetFactor = null;\n    currentPolygonOffsetUnits = null;\n    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);\n    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);\n    colorBuffer.reset();\n    depthBuffer.reset();\n    stencilBuffer.reset();\n  }\n  return {\n    buffers: {\n      color: colorBuffer,\n      depth: depthBuffer,\n      stencil: stencilBuffer\n    },\n    enable,\n    disable,\n    bindFramebuffer,\n    drawBuffers,\n    useProgram,\n    setBlending,\n    setMaterial,\n    setFlipSided,\n    setCullFace,\n    setLineWidth,\n    setPolygonOffset,\n    setScissorTest,\n    activeTexture,\n    bindTexture,\n    unbindTexture,\n    compressedTexImage2D,\n    compressedTexImage3D,\n    texImage2D,\n    texImage3D,\n    updateUBOMapping,\n    uniformBlockBinding,\n    texStorage2D,\n    texStorage3D,\n    texSubImage2D,\n    texSubImage3D,\n    compressedTexSubImage2D,\n    compressedTexSubImage3D,\n    scissor,\n    viewport,\n    reset\n  };\n}\nfunction getByteLength(width, height, format, type) {\n  const typeByteLength = getTextureTypeByteLength(type);\n  switch (format) {\n    case AlphaFormat:\n      return width * height;\n    case LuminanceFormat:\n      return width * height;\n    case LuminanceAlphaFormat:\n      return width * height * 2;\n    case RedFormat:\n      return width * height / typeByteLength.components * typeByteLength.byteLength;\n    case RedIntegerFormat:\n      return width * height / typeByteLength.components * typeByteLength.byteLength;\n    case RGFormat:\n      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;\n    case RGIntegerFormat:\n      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;\n    case RGBFormat:\n      return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;\n    case RGBAFormat:\n      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;\n    case RGBAIntegerFormat:\n      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;\n    case RGB_S3TC_DXT1_Format:\n    case RGBA_S3TC_DXT1_Format:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n    case RGBA_S3TC_DXT3_Format:\n    case RGBA_S3TC_DXT5_Format:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n    case RGB_PVRTC_2BPPV1_Format:\n    case RGBA_PVRTC_2BPPV1_Format:\n      return Math.max(width, 16) * Math.max(height, 8) / 4;\n    case RGB_PVRTC_4BPPV1_Format:\n    case RGBA_PVRTC_4BPPV1_Format:\n      return Math.max(width, 8) * Math.max(height, 8) / 2;\n    case RGB_ETC1_Format:\n    case RGB_ETC2_Format:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n    case RGBA_ETC2_EAC_Format:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n    case RGBA_ASTC_4x4_Format:\n      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n    case RGBA_ASTC_5x4_Format:\n      return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;\n    case RGBA_ASTC_5x5_Format:\n      return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;\n    case RGBA_ASTC_6x5_Format:\n      return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;\n    case RGBA_ASTC_6x6_Format:\n      return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;\n    case RGBA_ASTC_8x5_Format:\n      return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;\n    case RGBA_ASTC_8x6_Format:\n      return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;\n    case RGBA_ASTC_8x8_Format:\n      return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;\n    case RGBA_ASTC_10x5_Format:\n      return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;\n    case RGBA_ASTC_10x6_Format:\n      return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;\n    case RGBA_ASTC_10x8_Format:\n      return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;\n    case RGBA_ASTC_10x10_Format:\n      return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;\n    case RGBA_ASTC_12x10_Format:\n      return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;\n    case RGBA_ASTC_12x12_Format:\n      return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;\n    case RGBA_BPTC_Format:\n    case RGB_BPTC_SIGNED_Format:\n    case RGB_BPTC_UNSIGNED_Format:\n      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;\n    case RED_RGTC1_Format:\n    case SIGNED_RED_RGTC1_Format:\n      return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;\n    case RED_GREEN_RGTC2_Format:\n    case SIGNED_RED_GREEN_RGTC2_Format:\n      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;\n  }\n  throw new Error(\n    `Unable to determine texture byte length for ${format} format.`\n  );\n}\nfunction getTextureTypeByteLength(type) {\n  switch (type) {\n    case UnsignedByteType:\n    case ByteType:\n      return { byteLength: 1, components: 1 };\n    case UnsignedShortType:\n    case ShortType:\n    case HalfFloatType:\n      return { byteLength: 2, components: 1 };\n    case UnsignedShort4444Type:\n    case UnsignedShort5551Type:\n      return { byteLength: 2, components: 4 };\n    case UnsignedIntType:\n    case IntType:\n    case FloatType:\n      return { byteLength: 4, components: 1 };\n    case UnsignedInt5999Type:\n      return { byteLength: 4, components: 3 };\n  }\n  throw new Error(`Unknown texture type ${type}.`);\n}\nfunction WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {\n  const multisampledRTTExt = extensions.has(\"WEBGL_multisampled_render_to_texture\") ? extensions.get(\"WEBGL_multisampled_render_to_texture\") : null;\n  const supportsInvalidateFramebuffer = typeof navigator === \"undefined\" ? false : /OculusBrowser/g.test(navigator.userAgent);\n  const _imageDimensions = new Vector2();\n  const _videoTextures = /* @__PURE__ */ new WeakMap();\n  let _canvas2;\n  const _sources = /* @__PURE__ */ new WeakMap();\n  let useOffscreenCanvas = false;\n  try {\n    useOffscreenCanvas = typeof OffscreenCanvas !== \"undefined\" && new OffscreenCanvas(1, 1).getContext(\"2d\") !== null;\n  } catch (err2) {\n  }\n  function createCanvas(width, height) {\n    return useOffscreenCanvas ? (\n      // eslint-disable-next-line compat/compat\n      new OffscreenCanvas(width, height)\n    ) : createElementNS(\"canvas\");\n  }\n  function resizeImage(image, needsNewCanvas, maxSize) {\n    let scale = 1;\n    const dimensions = getDimensions(image);\n    if (dimensions.width > maxSize || dimensions.height > maxSize) {\n      scale = maxSize / Math.max(dimensions.width, dimensions.height);\n    }\n    if (scale < 1) {\n      if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap || typeof VideoFrame !== \"undefined\" && image instanceof VideoFrame) {\n        const width = Math.floor(scale * dimensions.width);\n        const height = Math.floor(scale * dimensions.height);\n        if (_canvas2 === void 0) _canvas2 = createCanvas(width, height);\n        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;\n        canvas.width = width;\n        canvas.height = height;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(image, 0, 0, width, height);\n        console.warn(\"THREE.WebGLRenderer: Texture has been resized from (\" + dimensions.width + \"x\" + dimensions.height + \") to (\" + width + \"x\" + height + \").\");\n        return canvas;\n      } else {\n        if (\"data\" in image) {\n          console.warn(\"THREE.WebGLRenderer: Image in DataTexture is too big (\" + dimensions.width + \"x\" + dimensions.height + \").\");\n        }\n        return image;\n      }\n    }\n    return image;\n  }\n  function textureNeedsGenerateMipmaps(texture) {\n    return texture.generateMipmaps;\n  }\n  function generateMipmap(target) {\n    _gl.generateMipmap(target);\n  }\n  function getTargetType(texture) {\n    if (texture.isWebGLCubeRenderTarget) return _gl.TEXTURE_CUBE_MAP;\n    if (texture.isWebGL3DRenderTarget) return _gl.TEXTURE_3D;\n    if (texture.isWebGLArrayRenderTarget || texture.isCompressedArrayTexture) return _gl.TEXTURE_2D_ARRAY;\n    return _gl.TEXTURE_2D;\n  }\n  function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {\n    if (internalFormatName !== null) {\n      if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];\n      console.warn(\"THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '\" + internalFormatName + \"'\");\n    }\n    let internalFormat = glFormat;\n    if (glFormat === _gl.RED) {\n      if (glType === _gl.FLOAT) internalFormat = _gl.R32F;\n      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;\n    }\n    if (glFormat === _gl.RED_INTEGER) {\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;\n      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;\n      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;\n      if (glType === _gl.BYTE) internalFormat = _gl.R8I;\n      if (glType === _gl.SHORT) internalFormat = _gl.R16I;\n      if (glType === _gl.INT) internalFormat = _gl.R32I;\n    }\n    if (glFormat === _gl.RG) {\n      if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;\n      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;\n    }\n    if (glFormat === _gl.RG_INTEGER) {\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;\n      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;\n      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;\n      if (glType === _gl.BYTE) internalFormat = _gl.RG8I;\n      if (glType === _gl.SHORT) internalFormat = _gl.RG16I;\n      if (glType === _gl.INT) internalFormat = _gl.RG32I;\n    }\n    if (glFormat === _gl.RGB_INTEGER) {\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8UI;\n      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGB16UI;\n      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGB32UI;\n      if (glType === _gl.BYTE) internalFormat = _gl.RGB8I;\n      if (glType === _gl.SHORT) internalFormat = _gl.RGB16I;\n      if (glType === _gl.INT) internalFormat = _gl.RGB32I;\n    }\n    if (glFormat === _gl.RGBA_INTEGER) {\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8UI;\n      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGBA16UI;\n      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGBA32UI;\n      if (glType === _gl.BYTE) internalFormat = _gl.RGBA8I;\n      if (glType === _gl.SHORT) internalFormat = _gl.RGBA16I;\n      if (glType === _gl.INT) internalFormat = _gl.RGBA32I;\n    }\n    if (glFormat === _gl.RGB) {\n      if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = _gl.RGB9_E5;\n    }\n    if (glFormat === _gl.RGBA) {\n      const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);\n      if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;\n      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;\n      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;\n      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;\n    }\n    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {\n      extensions.get(\"EXT_color_buffer_float\");\n    }\n    return internalFormat;\n  }\n  function getInternalDepthFormat(useStencil, depthType) {\n    let glInternalFormat;\n    if (useStencil) {\n      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {\n        glInternalFormat = _gl.DEPTH24_STENCIL8;\n      } else if (depthType === FloatType) {\n        glInternalFormat = _gl.DEPTH32F_STENCIL8;\n      } else if (depthType === UnsignedShortType) {\n        glInternalFormat = _gl.DEPTH24_STENCIL8;\n        console.warn(\"DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.\");\n      }\n    } else {\n      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {\n        glInternalFormat = _gl.DEPTH_COMPONENT24;\n      } else if (depthType === FloatType) {\n        glInternalFormat = _gl.DEPTH_COMPONENT32F;\n      } else if (depthType === UnsignedShortType) {\n        glInternalFormat = _gl.DEPTH_COMPONENT16;\n      }\n    }\n    return glInternalFormat;\n  }\n  function getMipLevels(texture, image) {\n    if (textureNeedsGenerateMipmaps(texture) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {\n      return Math.log2(Math.max(image.width, image.height)) + 1;\n    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {\n      return texture.mipmaps.length;\n    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {\n      return image.mipmaps.length;\n    } else {\n      return 1;\n    }\n  }\n  function onTextureDispose(event) {\n    const texture = event.target;\n    texture.removeEventListener(\"dispose\", onTextureDispose);\n    deallocateTexture(texture);\n    if (texture.isVideoTexture) {\n      _videoTextures.delete(texture);\n    }\n  }\n  function onRenderTargetDispose(event) {\n    const renderTarget = event.target;\n    renderTarget.removeEventListener(\"dispose\", onRenderTargetDispose);\n    deallocateRenderTarget(renderTarget);\n  }\n  function deallocateTexture(texture) {\n    const textureProperties = properties.get(texture);\n    if (textureProperties.__webglInit === void 0) return;\n    const source = texture.source;\n    const webglTextures = _sources.get(source);\n    if (webglTextures) {\n      const webglTexture = webglTextures[textureProperties.__cacheKey];\n      webglTexture.usedTimes--;\n      if (webglTexture.usedTimes === 0) {\n        deleteTexture(texture);\n      }\n      if (Object.keys(webglTextures).length === 0) {\n        _sources.delete(source);\n      }\n    }\n    properties.remove(texture);\n  }\n  function deleteTexture(texture) {\n    const textureProperties = properties.get(texture);\n    _gl.deleteTexture(textureProperties.__webglTexture);\n    const source = texture.source;\n    const webglTextures = _sources.get(source);\n    delete webglTextures[textureProperties.__cacheKey];\n    info.memory.textures--;\n  }\n  function deallocateRenderTarget(renderTarget) {\n    const renderTargetProperties = properties.get(renderTarget);\n    if (renderTarget.depthTexture) {\n      renderTarget.depthTexture.dispose();\n      properties.remove(renderTarget.depthTexture);\n    }\n    if (renderTarget.isWebGLCubeRenderTarget) {\n      for (let i = 0; i < 6; i++) {\n        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) {\n          for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);\n        } else {\n          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);\n        }\n        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);\n      }\n    } else {\n      if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {\n        for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);\n      } else {\n        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\n      }\n      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);\n      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);\n      if (renderTargetProperties.__webglColorRenderbuffer) {\n        for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {\n          if (renderTargetProperties.__webglColorRenderbuffer[i]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);\n        }\n      }\n      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);\n    }\n    const textures = renderTarget.textures;\n    for (let i = 0, il = textures.length; i < il; i++) {\n      const attachmentProperties = properties.get(textures[i]);\n      if (attachmentProperties.__webglTexture) {\n        _gl.deleteTexture(attachmentProperties.__webglTexture);\n        info.memory.textures--;\n      }\n      properties.remove(textures[i]);\n    }\n    properties.remove(renderTarget);\n  }\n  let textureUnits = 0;\n  function resetTextureUnits() {\n    textureUnits = 0;\n  }\n  function allocateTextureUnit() {\n    const textureUnit = textureUnits;\n    if (textureUnit >= capabilities.maxTextures) {\n      console.warn(\"THREE.WebGLTextures: Trying to use \" + textureUnit + \" texture units while this GPU supports only \" + capabilities.maxTextures);\n    }\n    textureUnits += 1;\n    return textureUnit;\n  }\n  function getTextureCacheKey(texture) {\n    const array = [];\n    array.push(texture.wrapS);\n    array.push(texture.wrapT);\n    array.push(texture.wrapR || 0);\n    array.push(texture.magFilter);\n    array.push(texture.minFilter);\n    array.push(texture.anisotropy);\n    array.push(texture.internalFormat);\n    array.push(texture.format);\n    array.push(texture.type);\n    array.push(texture.generateMipmaps);\n    array.push(texture.premultiplyAlpha);\n    array.push(texture.flipY);\n    array.push(texture.unpackAlignment);\n    array.push(texture.colorSpace);\n    return array.join();\n  }\n  function setTexture2D(texture, slot) {\n    const textureProperties = properties.get(texture);\n    if (texture.isVideoTexture) updateVideoTexture(texture);\n    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {\n      const image = texture.image;\n      if (image === null) {\n        console.warn(\"THREE.WebGLRenderer: Texture marked for update but no image data found.\");\n      } else if (image.complete === false) {\n        console.warn(\"THREE.WebGLRenderer: Texture marked for update but image is incomplete\");\n      } else {\n        uploadTexture(textureProperties, texture, slot);\n        return;\n      }\n    }\n    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);\n  }\n  function setTexture2DArray(texture, slot) {\n    const textureProperties = properties.get(texture);\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);\n  }\n  function setTexture3D(texture, slot) {\n    const textureProperties = properties.get(texture);\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);\n  }\n  function setTextureCube(texture, slot) {\n    const textureProperties = properties.get(texture);\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadCubeTexture(textureProperties, texture, slot);\n      return;\n    }\n    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);\n  }\n  const wrappingToGL = {\n    [RepeatWrapping]: _gl.REPEAT,\n    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,\n    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT\n  };\n  const filterToGL = {\n    [NearestFilter]: _gl.NEAREST,\n    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,\n    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,\n    [LinearFilter]: _gl.LINEAR,\n    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,\n    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR\n  };\n  const compareToGL = {\n    [NeverCompare]: _gl.NEVER,\n    [AlwaysCompare]: _gl.ALWAYS,\n    [LessCompare]: _gl.LESS,\n    [LessEqualCompare]: _gl.LEQUAL,\n    [EqualCompare]: _gl.EQUAL,\n    [GreaterEqualCompare]: _gl.GEQUAL,\n    [GreaterCompare]: _gl.GREATER,\n    [NotEqualCompare]: _gl.NOTEQUAL\n  };\n  function setTextureParameters(textureType, texture) {\n    if (texture.type === FloatType && extensions.has(\"OES_texture_float_linear\") === false && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter)) {\n      console.warn(\"THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.\");\n    }\n    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);\n    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);\n    if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {\n      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);\n    }\n    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);\n    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);\n    if (texture.compareFunction) {\n      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);\n      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);\n    }\n    if (extensions.has(\"EXT_texture_filter_anisotropic\") === true) {\n      if (texture.magFilter === NearestFilter) return;\n      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;\n      if (texture.type === FloatType && extensions.has(\"OES_texture_float_linear\") === false) return;\n      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {\n        const extension = extensions.get(\"EXT_texture_filter_anisotropic\");\n        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));\n        properties.get(texture).__currentAnisotropy = texture.anisotropy;\n      }\n    }\n  }\n  function initTexture(textureProperties, texture) {\n    let forceUpload = false;\n    if (textureProperties.__webglInit === void 0) {\n      textureProperties.__webglInit = true;\n      texture.addEventListener(\"dispose\", onTextureDispose);\n    }\n    const source = texture.source;\n    let webglTextures = _sources.get(source);\n    if (webglTextures === void 0) {\n      webglTextures = {};\n      _sources.set(source, webglTextures);\n    }\n    const textureCacheKey = getTextureCacheKey(texture);\n    if (textureCacheKey !== textureProperties.__cacheKey) {\n      if (webglTextures[textureCacheKey] === void 0) {\n        webglTextures[textureCacheKey] = {\n          texture: _gl.createTexture(),\n          usedTimes: 0\n        };\n        info.memory.textures++;\n        forceUpload = true;\n      }\n      webglTextures[textureCacheKey].usedTimes++;\n      const webglTexture = webglTextures[textureProperties.__cacheKey];\n      if (webglTexture !== void 0) {\n        webglTextures[textureProperties.__cacheKey].usedTimes--;\n        if (webglTexture.usedTimes === 0) {\n          deleteTexture(texture);\n        }\n      }\n      textureProperties.__cacheKey = textureCacheKey;\n      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;\n    }\n    return forceUpload;\n  }\n  function uploadTexture(textureProperties, texture, slot) {\n    let textureType = _gl.TEXTURE_2D;\n    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;\n    if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;\n    const forceUpload = initTexture(textureProperties, texture);\n    const source = texture.source;\n    state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);\n    const sourceProperties = properties.get(source);\n    if (source.version !== sourceProperties.__version || forceUpload === true) {\n      state.activeTexture(_gl.TEXTURE0 + slot);\n      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);\n      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);\n      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;\n      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);\n      let image = resizeImage(texture.image, false, capabilities.maxTextureSize);\n      image = verifyColorSpace(texture, image);\n      const glFormat = utils.convert(texture.format, texture.colorSpace);\n      const glType = utils.convert(texture.type);\n      let glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);\n      setTextureParameters(textureType, texture);\n      let mipmap;\n      const mipmaps = texture.mipmaps;\n      const useTexStorage = texture.isVideoTexture !== true;\n      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;\n      const dataReady = source.dataReady;\n      const levels = getMipLevels(texture, image);\n      if (texture.isDepthTexture) {\n        glInternalFormat = getInternalDepthFormat(texture.format === DepthStencilFormat, texture.type);\n        if (allocateMemory) {\n          if (useTexStorage) {\n            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);\n          } else {\n            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);\n          }\n        }\n      } else if (texture.isDataTexture) {\n        if (mipmaps.length > 0) {\n          if (useTexStorage && allocateMemory) {\n            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);\n          }\n          for (let i = 0, il = mipmaps.length; i < il; i++) {\n            mipmap = mipmaps[i];\n            if (useTexStorage) {\n              if (dataReady) {\n                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);\n              }\n            } else {\n              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n            }\n          }\n          texture.generateMipmaps = false;\n        } else {\n          if (useTexStorage) {\n            if (allocateMemory) {\n              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);\n            }\n            if (dataReady) {\n              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);\n            }\n          } else {\n            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);\n          }\n        }\n      } else if (texture.isCompressedTexture) {\n        if (texture.isCompressedArrayTexture) {\n          if (useTexStorage && allocateMemory) {\n            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);\n          }\n          for (let i = 0, il = mipmaps.length; i < il; i++) {\n            mipmap = mipmaps[i];\n            if (texture.format !== RGBAFormat) {\n              if (glFormat !== null) {\n                if (useTexStorage) {\n                  if (dataReady) {\n                    if (texture.layerUpdates.size > 0) {\n                      const layerByteLength = getByteLength(mipmap.width, mipmap.height, texture.format, texture.type);\n                      for (const layerIndex of texture.layerUpdates) {\n                        const layerData = mipmap.data.subarray(\n                          layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,\n                          (layerIndex + 1) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT\n                        );\n                        state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData);\n                      }\n                      texture.clearLayerUpdates();\n                    } else {\n                      state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);\n                    }\n                  }\n                } else {\n                  state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);\n                }\n              } else {\n                console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\");\n              }\n            } else {\n              if (useTexStorage) {\n                if (dataReady) {\n                  state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);\n                }\n              } else {\n                state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);\n              }\n            }\n          }\n        } else {\n          if (useTexStorage && allocateMemory) {\n            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);\n          }\n          for (let i = 0, il = mipmaps.length; i < il; i++) {\n            mipmap = mipmaps[i];\n            if (texture.format !== RGBAFormat) {\n              if (glFormat !== null) {\n                if (useTexStorage) {\n                  if (dataReady) {\n                    state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);\n                  }\n                } else {\n                  state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n                }\n              } else {\n                console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\");\n              }\n            } else {\n              if (useTexStorage) {\n                if (dataReady) {\n                  state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);\n                }\n              } else {\n                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n              }\n            }\n          }\n        }\n      } else if (texture.isDataArrayTexture) {\n        if (useTexStorage) {\n          if (allocateMemory) {\n            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);\n          }\n          if (dataReady) {\n            if (texture.layerUpdates.size > 0) {\n              const layerByteLength = getByteLength(image.width, image.height, texture.format, texture.type);\n              for (const layerIndex of texture.layerUpdates) {\n                const layerData = image.data.subarray(\n                  layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,\n                  (layerIndex + 1) * layerByteLength / image.data.BYTES_PER_ELEMENT\n                );\n                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData);\n              }\n              texture.clearLayerUpdates();\n            } else {\n              state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);\n            }\n          }\n        } else {\n          state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n        }\n      } else if (texture.isData3DTexture) {\n        if (useTexStorage) {\n          if (allocateMemory) {\n            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);\n          }\n          if (dataReady) {\n            state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);\n          }\n        } else {\n          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n        }\n      } else if (texture.isFramebufferTexture) {\n        if (allocateMemory) {\n          if (useTexStorage) {\n            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);\n          } else {\n            let width = image.width, height = image.height;\n            for (let i = 0; i < levels; i++) {\n              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null);\n              width >>= 1;\n              height >>= 1;\n            }\n          }\n        }\n      } else {\n        if (mipmaps.length > 0) {\n          if (useTexStorage && allocateMemory) {\n            const dimensions = getDimensions(mipmaps[0]);\n            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);\n          }\n          for (let i = 0, il = mipmaps.length; i < il; i++) {\n            mipmap = mipmaps[i];\n            if (useTexStorage) {\n              if (dataReady) {\n                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);\n              }\n            } else {\n              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);\n            }\n          }\n          texture.generateMipmaps = false;\n        } else {\n          if (useTexStorage) {\n            if (allocateMemory) {\n              const dimensions = getDimensions(image);\n              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);\n            }\n            if (dataReady) {\n              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);\n            }\n          } else {\n            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);\n          }\n        }\n      }\n      if (textureNeedsGenerateMipmaps(texture)) {\n        generateMipmap(textureType);\n      }\n      sourceProperties.__version = source.version;\n      if (texture.onUpdate) texture.onUpdate(texture);\n    }\n    textureProperties.__version = texture.version;\n  }\n  function uploadCubeTexture(textureProperties, texture, slot) {\n    if (texture.image.length !== 6) return;\n    const forceUpload = initTexture(textureProperties, texture);\n    const source = texture.source;\n    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);\n    const sourceProperties = properties.get(source);\n    if (source.version !== sourceProperties.__version || forceUpload === true) {\n      state.activeTexture(_gl.TEXTURE0 + slot);\n      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);\n      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);\n      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;\n      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);\n      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;\n      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;\n      const cubeImage = [];\n      for (let i = 0; i < 6; i++) {\n        if (!isCompressed && !isDataTexture) {\n          cubeImage[i] = resizeImage(texture.image[i], true, capabilities.maxCubemapSize);\n        } else {\n          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];\n        }\n        cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);\n      }\n      const image = cubeImage[0], glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);\n      const useTexStorage = texture.isVideoTexture !== true;\n      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;\n      const dataReady = source.dataReady;\n      let levels = getMipLevels(texture, image);\n      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);\n      let mipmaps;\n      if (isCompressed) {\n        if (useTexStorage && allocateMemory) {\n          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);\n        }\n        for (let i = 0; i < 6; i++) {\n          mipmaps = cubeImage[i].mipmaps;\n          for (let j = 0; j < mipmaps.length; j++) {\n            const mipmap = mipmaps[j];\n            if (texture.format !== RGBAFormat) {\n              if (glFormat !== null) {\n                if (useTexStorage) {\n                  if (dataReady) {\n                    state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);\n                  }\n                } else {\n                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n                }\n              } else {\n                console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\");\n              }\n            } else {\n              if (useTexStorage) {\n                if (dataReady) {\n                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);\n                }\n              } else {\n                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n              }\n            }\n          }\n        }\n      } else {\n        mipmaps = texture.mipmaps;\n        if (useTexStorage && allocateMemory) {\n          if (mipmaps.length > 0) levels++;\n          const dimensions = getDimensions(cubeImage[0]);\n          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);\n        }\n        for (let i = 0; i < 6; i++) {\n          if (isDataTexture) {\n            if (useTexStorage) {\n              if (dataReady) {\n                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);\n              }\n            } else {\n              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);\n            }\n            for (let j = 0; j < mipmaps.length; j++) {\n              const mipmap = mipmaps[j];\n              const mipmapImage = mipmap.image[i].image;\n              if (useTexStorage) {\n                if (dataReady) {\n                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);\n                }\n              } else {\n                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);\n              }\n            }\n          } else {\n            if (useTexStorage) {\n              if (dataReady) {\n                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]);\n              }\n            } else {\n              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);\n            }\n            for (let j = 0; j < mipmaps.length; j++) {\n              const mipmap = mipmaps[j];\n              if (useTexStorage) {\n                if (dataReady) {\n                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);\n                }\n              } else {\n                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);\n              }\n            }\n          }\n        }\n      }\n      if (textureNeedsGenerateMipmaps(texture)) {\n        generateMipmap(_gl.TEXTURE_CUBE_MAP);\n      }\n      sourceProperties.__version = source.version;\n      if (texture.onUpdate) texture.onUpdate(texture);\n    }\n    textureProperties.__version = texture.version;\n  }\n  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {\n    const glFormat = utils.convert(texture.format, texture.colorSpace);\n    const glType = utils.convert(texture.type);\n    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);\n    const renderTargetProperties = properties.get(renderTarget);\n    const textureProperties = properties.get(texture);\n    textureProperties.__renderTarget = renderTarget;\n    if (!renderTargetProperties.__hasExternalTextures) {\n      const width = Math.max(1, renderTarget.width >> level);\n      const height = Math.max(1, renderTarget.height >> level);\n      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {\n        state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);\n      } else {\n        state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);\n      }\n    }\n    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n    if (useMultisampledRTT(renderTarget)) {\n      multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, 0, getRenderTargetSamples(renderTarget));\n    } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {\n      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, level);\n    }\n    state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n  }\n  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {\n    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);\n    if (renderTarget.depthBuffer) {\n      const depthTexture = renderTarget.depthTexture;\n      const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;\n      const glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);\n      const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n      const samples = getRenderTargetSamples(renderTarget);\n      const isUseMultisampledRTT = useMultisampledRTT(renderTarget);\n      if (isUseMultisampledRTT) {\n        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n      } else if (isMultisample) {\n        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n      } else {\n        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);\n      }\n      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);\n    } else {\n      const textures = renderTarget.textures;\n      for (let i = 0; i < textures.length; i++) {\n        const texture = textures[i];\n        const glFormat = utils.convert(texture.format, texture.colorSpace);\n        const glType = utils.convert(texture.type);\n        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);\n        const samples = getRenderTargetSamples(renderTarget);\n        if (isMultisample && useMultisampledRTT(renderTarget) === false) {\n          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n        } else if (useMultisampledRTT(renderTarget)) {\n          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n        } else {\n          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);\n        }\n      }\n    }\n    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n  }\n  function setupDepthTexture(framebuffer, renderTarget) {\n    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;\n    if (isCube) throw new Error(\"Depth Texture with cube render targets is not supported\");\n    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {\n      throw new Error(\"renderTarget.depthTexture must be an instance of THREE.DepthTexture\");\n    }\n    const textureProperties = properties.get(renderTarget.depthTexture);\n    textureProperties.__renderTarget = renderTarget;\n    if (!textureProperties.__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {\n      renderTarget.depthTexture.image.width = renderTarget.width;\n      renderTarget.depthTexture.image.height = renderTarget.height;\n      renderTarget.depthTexture.needsUpdate = true;\n    }\n    setTexture2D(renderTarget.depthTexture, 0);\n    const webglDepthTexture = textureProperties.__webglTexture;\n    const samples = getRenderTargetSamples(renderTarget);\n    if (renderTarget.depthTexture.format === DepthFormat) {\n      if (useMultisampledRTT(renderTarget)) {\n        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);\n      } else {\n        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);\n      }\n    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {\n      if (useMultisampledRTT(renderTarget)) {\n        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);\n      } else {\n        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);\n      }\n    } else {\n      throw new Error(\"Unknown depthTexture format\");\n    }\n  }\n  function setupDepthRenderbuffer(renderTarget) {\n    const renderTargetProperties = properties.get(renderTarget);\n    const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n    if (renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture) {\n      const depthTexture = renderTarget.depthTexture;\n      if (renderTargetProperties.__depthDisposeCallback) {\n        renderTargetProperties.__depthDisposeCallback();\n      }\n      if (depthTexture) {\n        const disposeEvent = () => {\n          delete renderTargetProperties.__boundDepthTexture;\n          delete renderTargetProperties.__depthDisposeCallback;\n          depthTexture.removeEventListener(\"dispose\", disposeEvent);\n        };\n        depthTexture.addEventListener(\"dispose\", disposeEvent);\n        renderTargetProperties.__depthDisposeCallback = disposeEvent;\n      }\n      renderTargetProperties.__boundDepthTexture = depthTexture;\n    }\n    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {\n      if (isCube) throw new Error(\"target.depthTexture not supported in Cube render targets\");\n      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);\n    } else {\n      if (isCube) {\n        renderTargetProperties.__webglDepthbuffer = [];\n        for (let i = 0; i < 6; i++) {\n          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);\n          if (renderTargetProperties.__webglDepthbuffer[i] === void 0) {\n            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();\n            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);\n          } else {\n            const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n            const renderbuffer = renderTargetProperties.__webglDepthbuffer[i];\n            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);\n            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);\n          }\n        }\n      } else {\n        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);\n        if (renderTargetProperties.__webglDepthbuffer === void 0) {\n          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);\n        } else {\n          const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n          const renderbuffer = renderTargetProperties.__webglDepthbuffer;\n          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);\n          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);\n        }\n      }\n    }\n    state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n  }\n  function rebindTextures(renderTarget, colorTexture, depthTexture) {\n    const renderTargetProperties = properties.get(renderTarget);\n    if (colorTexture !== void 0) {\n      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);\n    }\n    if (depthTexture !== void 0) {\n      setupDepthRenderbuffer(renderTarget);\n    }\n  }\n  function setupRenderTarget(renderTarget) {\n    const texture = renderTarget.texture;\n    const renderTargetProperties = properties.get(renderTarget);\n    const textureProperties = properties.get(texture);\n    renderTarget.addEventListener(\"dispose\", onRenderTargetDispose);\n    const textures = renderTarget.textures;\n    const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n    const isMultipleRenderTargets = textures.length > 1;\n    if (!isMultipleRenderTargets) {\n      if (textureProperties.__webglTexture === void 0) {\n        textureProperties.__webglTexture = _gl.createTexture();\n      }\n      textureProperties.__version = texture.version;\n      info.memory.textures++;\n    }\n    if (isCube) {\n      renderTargetProperties.__webglFramebuffer = [];\n      for (let i = 0; i < 6; i++) {\n        if (texture.mipmaps && texture.mipmaps.length > 0) {\n          renderTargetProperties.__webglFramebuffer[i] = [];\n          for (let level = 0; level < texture.mipmaps.length; level++) {\n            renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer();\n          }\n        } else {\n          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();\n        }\n      }\n    } else {\n      if (texture.mipmaps && texture.mipmaps.length > 0) {\n        renderTargetProperties.__webglFramebuffer = [];\n        for (let level = 0; level < texture.mipmaps.length; level++) {\n          renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();\n        }\n      } else {\n        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n      }\n      if (isMultipleRenderTargets) {\n        for (let i = 0, il = textures.length; i < il; i++) {\n          const attachmentProperties = properties.get(textures[i]);\n          if (attachmentProperties.__webglTexture === void 0) {\n            attachmentProperties.__webglTexture = _gl.createTexture();\n            info.memory.textures++;\n          }\n        }\n      }\n      if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {\n        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n        renderTargetProperties.__webglColorRenderbuffer = [];\n        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n        for (let i = 0; i < textures.length; i++) {\n          const texture2 = textures[i];\n          renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();\n          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);\n          const glFormat = utils.convert(texture2.format, texture2.colorSpace);\n          const glType = utils.convert(texture2.type);\n          const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);\n          const samples = getRenderTargetSamples(renderTarget);\n          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);\n        }\n        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n        if (renderTarget.depthBuffer) {\n          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);\n        }\n        state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n      }\n    }\n    if (isCube) {\n      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);\n      for (let i = 0; i < 6; i++) {\n        if (texture.mipmaps && texture.mipmaps.length > 0) {\n          for (let level = 0; level < texture.mipmaps.length; level++) {\n            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level);\n          }\n        } else {\n          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);\n        }\n      }\n      if (textureNeedsGenerateMipmaps(texture)) {\n        generateMipmap(_gl.TEXTURE_CUBE_MAP);\n      }\n      state.unbindTexture();\n    } else if (isMultipleRenderTargets) {\n      for (let i = 0, il = textures.length; i < il; i++) {\n        const attachment = textures[i];\n        const attachmentProperties = properties.get(attachment);\n        state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);\n        setTextureParameters(_gl.TEXTURE_2D, attachment);\n        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0);\n        if (textureNeedsGenerateMipmaps(attachment)) {\n          generateMipmap(_gl.TEXTURE_2D);\n        }\n      }\n      state.unbindTexture();\n    } else {\n      let glTextureType = _gl.TEXTURE_2D;\n      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {\n        glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;\n      }\n      state.bindTexture(glTextureType, textureProperties.__webglTexture);\n      setTextureParameters(glTextureType, texture);\n      if (texture.mipmaps && texture.mipmaps.length > 0) {\n        for (let level = 0; level < texture.mipmaps.length; level++) {\n          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);\n        }\n      } else {\n        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);\n      }\n      if (textureNeedsGenerateMipmaps(texture)) {\n        generateMipmap(glTextureType);\n      }\n      state.unbindTexture();\n    }\n    if (renderTarget.depthBuffer) {\n      setupDepthRenderbuffer(renderTarget);\n    }\n  }\n  function updateRenderTargetMipmap(renderTarget) {\n    const textures = renderTarget.textures;\n    for (let i = 0, il = textures.length; i < il; i++) {\n      const texture = textures[i];\n      if (textureNeedsGenerateMipmaps(texture)) {\n        const targetType = getTargetType(renderTarget);\n        const webglTexture = properties.get(texture).__webglTexture;\n        state.bindTexture(targetType, webglTexture);\n        generateMipmap(targetType);\n        state.unbindTexture();\n      }\n    }\n  }\n  const invalidationArrayRead = [];\n  const invalidationArrayDraw = [];\n  function updateMultisampleRenderTarget(renderTarget) {\n    if (renderTarget.samples > 0) {\n      if (useMultisampledRTT(renderTarget) === false) {\n        const textures = renderTarget.textures;\n        const width = renderTarget.width;\n        const height = renderTarget.height;\n        let mask = _gl.COLOR_BUFFER_BIT;\n        const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n        const renderTargetProperties = properties.get(renderTarget);\n        const isMultipleRenderTargets = textures.length > 1;\n        if (isMultipleRenderTargets) {\n          for (let i = 0; i < textures.length; i++) {\n            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);\n            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);\n            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);\n          }\n        }\n        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);\n        for (let i = 0; i < textures.length; i++) {\n          if (renderTarget.resolveDepthBuffer) {\n            if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;\n            if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;\n          }\n          if (isMultipleRenderTargets) {\n            _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);\n            const webglTexture = properties.get(textures[i]).__webglTexture;\n            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);\n          }\n          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);\n          if (supportsInvalidateFramebuffer === true) {\n            invalidationArrayRead.length = 0;\n            invalidationArrayDraw.length = 0;\n            invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i);\n            if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {\n              invalidationArrayRead.push(depthStyle);\n              invalidationArrayDraw.push(depthStyle);\n              _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);\n            }\n            _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead);\n          }\n        }\n        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);\n        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);\n        if (isMultipleRenderTargets) {\n          for (let i = 0; i < textures.length; i++) {\n            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);\n            const webglTexture = properties.get(textures[i]).__webglTexture;\n            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);\n            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0);\n          }\n        }\n        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n      } else {\n        if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer) {\n          const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);\n        }\n      }\n    }\n  }\n  function getRenderTargetSamples(renderTarget) {\n    return Math.min(capabilities.maxSamples, renderTarget.samples);\n  }\n  function useMultisampledRTT(renderTarget) {\n    const renderTargetProperties = properties.get(renderTarget);\n    return renderTarget.samples > 0 && extensions.has(\"WEBGL_multisampled_render_to_texture\") === true && renderTargetProperties.__useRenderToTexture !== false;\n  }\n  function updateVideoTexture(texture) {\n    const frame = info.render.frame;\n    if (_videoTextures.get(texture) !== frame) {\n      _videoTextures.set(texture, frame);\n      texture.update();\n    }\n  }\n  function verifyColorSpace(texture, image) {\n    const colorSpace = texture.colorSpace;\n    const format = texture.format;\n    const type = texture.type;\n    if (texture.isCompressedTexture === true || texture.isVideoTexture === true) return image;\n    if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {\n      if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {\n        if (format !== RGBAFormat || type !== UnsignedByteType) {\n          console.warn(\"THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.\");\n        }\n      } else {\n        console.error(\"THREE.WebGLTextures: Unsupported texture color space:\", colorSpace);\n      }\n    }\n    return image;\n  }\n  function getDimensions(image) {\n    if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement) {\n      _imageDimensions.width = image.naturalWidth || image.width;\n      _imageDimensions.height = image.naturalHeight || image.height;\n    } else if (typeof VideoFrame !== \"undefined\" && image instanceof VideoFrame) {\n      _imageDimensions.width = image.displayWidth;\n      _imageDimensions.height = image.displayHeight;\n    } else {\n      _imageDimensions.width = image.width;\n      _imageDimensions.height = image.height;\n    }\n    return _imageDimensions;\n  }\n  this.allocateTextureUnit = allocateTextureUnit;\n  this.resetTextureUnits = resetTextureUnits;\n  this.setTexture2D = setTexture2D;\n  this.setTexture2DArray = setTexture2DArray;\n  this.setTexture3D = setTexture3D;\n  this.setTextureCube = setTextureCube;\n  this.rebindTextures = rebindTextures;\n  this.setupRenderTarget = setupRenderTarget;\n  this.updateRenderTargetMipmap = updateRenderTargetMipmap;\n  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n  this.setupDepthRenderbuffer = setupDepthRenderbuffer;\n  this.setupFrameBufferTexture = setupFrameBufferTexture;\n  this.useMultisampledRTT = useMultisampledRTT;\n}\nfunction WebGLUtils(gl, extensions) {\n  function convert(p, colorSpace = NoColorSpace) {\n    let extension;\n    const transfer = ColorManagement.getTransfer(colorSpace);\n    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;\n    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;\n    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;\n    if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;\n    if (p === ByteType) return gl.BYTE;\n    if (p === ShortType) return gl.SHORT;\n    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;\n    if (p === IntType) return gl.INT;\n    if (p === UnsignedIntType) return gl.UNSIGNED_INT;\n    if (p === FloatType) return gl.FLOAT;\n    if (p === HalfFloatType) return gl.HALF_FLOAT;\n    if (p === AlphaFormat) return gl.ALPHA;\n    if (p === RGBFormat) return gl.RGB;\n    if (p === RGBAFormat) return gl.RGBA;\n    if (p === LuminanceFormat) return gl.LUMINANCE;\n    if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;\n    if (p === DepthFormat) return gl.DEPTH_COMPONENT;\n    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;\n    if (p === RedFormat) return gl.RED;\n    if (p === RedIntegerFormat) return gl.RED_INTEGER;\n    if (p === RGFormat) return gl.RG;\n    if (p === RGIntegerFormat) return gl.RG_INTEGER;\n    if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;\n    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {\n      if (transfer === SRGBTransfer) {\n        extension = extensions.get(\"WEBGL_compressed_texture_s3tc_srgb\");\n        if (extension !== null) {\n          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n        } else {\n          return null;\n        }\n      } else {\n        extension = extensions.get(\"WEBGL_compressed_texture_s3tc\");\n        if (extension !== null) {\n          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n        } else {\n          return null;\n        }\n      }\n    }\n    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {\n      extension = extensions.get(\"WEBGL_compressed_texture_pvrtc\");\n      if (extension !== null) {\n        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n      } else {\n        return null;\n      }\n    }\n    if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {\n      extension = extensions.get(\"WEBGL_compressed_texture_etc\");\n      if (extension !== null) {\n        if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n        if (p === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n      } else {\n        return null;\n      }\n    }\n    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {\n      extension = extensions.get(\"WEBGL_compressed_texture_astc\");\n      if (extension !== null) {\n        if (p === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n        if (p === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n        if (p === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n        if (p === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n        if (p === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n        if (p === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n        if (p === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n        if (p === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n        if (p === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n        if (p === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n        if (p === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n        if (p === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n        if (p === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n        if (p === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n      } else {\n        return null;\n      }\n    }\n    if (p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format) {\n      extension = extensions.get(\"EXT_texture_compression_bptc\");\n      if (extension !== null) {\n        if (p === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n        if (p === RGB_BPTC_SIGNED_Format) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;\n        if (p === RGB_BPTC_UNSIGNED_Format) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;\n      } else {\n        return null;\n      }\n    }\n    if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {\n      extension = extensions.get(\"EXT_texture_compression_rgtc\");\n      if (extension !== null) {\n        if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;\n        if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n        if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n        if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n      } else {\n        return null;\n      }\n    }\n    if (p === UnsignedInt248Type) return gl.UNSIGNED_INT_24_8;\n    return gl[p] !== void 0 ? gl[p] : null;\n  }\n  return { convert };\n}\nclass ArrayCamera extends PerspectiveCamera {\n  constructor(array = []) {\n    super();\n    this.isArrayCamera = true;\n    this.cameras = array;\n  }\n}\nclass Group extends Object3D {\n  constructor() {\n    super();\n    this.isGroup = true;\n    this.type = \"Group\";\n  }\n}\nconst _moveEvent = { type: \"move\" };\nclass WebXRController {\n  constructor() {\n    this._targetRay = null;\n    this._grip = null;\n    this._hand = null;\n  }\n  getHandSpace() {\n    if (this._hand === null) {\n      this._hand = new Group();\n      this._hand.matrixAutoUpdate = false;\n      this._hand.visible = false;\n      this._hand.joints = {};\n      this._hand.inputState = { pinching: false };\n    }\n    return this._hand;\n  }\n  getTargetRaySpace() {\n    if (this._targetRay === null) {\n      this._targetRay = new Group();\n      this._targetRay.matrixAutoUpdate = false;\n      this._targetRay.visible = false;\n      this._targetRay.hasLinearVelocity = false;\n      this._targetRay.linearVelocity = new Vector3();\n      this._targetRay.hasAngularVelocity = false;\n      this._targetRay.angularVelocity = new Vector3();\n    }\n    return this._targetRay;\n  }\n  getGripSpace() {\n    if (this._grip === null) {\n      this._grip = new Group();\n      this._grip.matrixAutoUpdate = false;\n      this._grip.visible = false;\n      this._grip.hasLinearVelocity = false;\n      this._grip.linearVelocity = new Vector3();\n      this._grip.hasAngularVelocity = false;\n      this._grip.angularVelocity = new Vector3();\n    }\n    return this._grip;\n  }\n  dispatchEvent(event) {\n    if (this._targetRay !== null) {\n      this._targetRay.dispatchEvent(event);\n    }\n    if (this._grip !== null) {\n      this._grip.dispatchEvent(event);\n    }\n    if (this._hand !== null) {\n      this._hand.dispatchEvent(event);\n    }\n    return this;\n  }\n  connect(inputSource) {\n    if (inputSource && inputSource.hand) {\n      const hand = this._hand;\n      if (hand) {\n        for (const inputjoint of inputSource.hand.values()) {\n          this._getHandJoint(hand, inputjoint);\n        }\n      }\n    }\n    this.dispatchEvent({ type: \"connected\", data: inputSource });\n    return this;\n  }\n  disconnect(inputSource) {\n    this.dispatchEvent({ type: \"disconnected\", data: inputSource });\n    if (this._targetRay !== null) {\n      this._targetRay.visible = false;\n    }\n    if (this._grip !== null) {\n      this._grip.visible = false;\n    }\n    if (this._hand !== null) {\n      this._hand.visible = false;\n    }\n    return this;\n  }\n  update(inputSource, frame, referenceSpace) {\n    let inputPose = null;\n    let gripPose = null;\n    let handPose = null;\n    const targetRay = this._targetRay;\n    const grip = this._grip;\n    const hand = this._hand;\n    if (inputSource && frame.session.visibilityState !== \"visible-blurred\") {\n      if (hand && inputSource.hand) {\n        handPose = true;\n        for (const inputjoint of inputSource.hand.values()) {\n          const jointPose = frame.getJointPose(inputjoint, referenceSpace);\n          const joint = this._getHandJoint(hand, inputjoint);\n          if (jointPose !== null) {\n            joint.matrix.fromArray(jointPose.transform.matrix);\n            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);\n            joint.matrixWorldNeedsUpdate = true;\n            joint.jointRadius = jointPose.radius;\n          }\n          joint.visible = jointPose !== null;\n        }\n        const indexTip = hand.joints[\"index-finger-tip\"];\n        const thumbTip = hand.joints[\"thumb-tip\"];\n        const distance = indexTip.position.distanceTo(thumbTip.position);\n        const distanceToPinch = 0.02;\n        const threshold = 5e-3;\n        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {\n          hand.inputState.pinching = false;\n          this.dispatchEvent({\n            type: \"pinchend\",\n            handedness: inputSource.handedness,\n            target: this\n          });\n        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {\n          hand.inputState.pinching = true;\n          this.dispatchEvent({\n            type: \"pinchstart\",\n            handedness: inputSource.handedness,\n            target: this\n          });\n        }\n      } else {\n        if (grip !== null && inputSource.gripSpace) {\n          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);\n          if (gripPose !== null) {\n            grip.matrix.fromArray(gripPose.transform.matrix);\n            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);\n            grip.matrixWorldNeedsUpdate = true;\n            if (gripPose.linearVelocity) {\n              grip.hasLinearVelocity = true;\n              grip.linearVelocity.copy(gripPose.linearVelocity);\n            } else {\n              grip.hasLinearVelocity = false;\n            }\n            if (gripPose.angularVelocity) {\n              grip.hasAngularVelocity = true;\n              grip.angularVelocity.copy(gripPose.angularVelocity);\n            } else {\n              grip.hasAngularVelocity = false;\n            }\n          }\n        }\n      }\n      if (targetRay !== null) {\n        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\n        if (inputPose === null && gripPose !== null) {\n          inputPose = gripPose;\n        }\n        if (inputPose !== null) {\n          targetRay.matrix.fromArray(inputPose.transform.matrix);\n          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);\n          targetRay.matrixWorldNeedsUpdate = true;\n          if (inputPose.linearVelocity) {\n            targetRay.hasLinearVelocity = true;\n            targetRay.linearVelocity.copy(inputPose.linearVelocity);\n          } else {\n            targetRay.hasLinearVelocity = false;\n          }\n          if (inputPose.angularVelocity) {\n            targetRay.hasAngularVelocity = true;\n            targetRay.angularVelocity.copy(inputPose.angularVelocity);\n          } else {\n            targetRay.hasAngularVelocity = false;\n          }\n          this.dispatchEvent(_moveEvent);\n        }\n      }\n    }\n    if (targetRay !== null) {\n      targetRay.visible = inputPose !== null;\n    }\n    if (grip !== null) {\n      grip.visible = gripPose !== null;\n    }\n    if (hand !== null) {\n      hand.visible = handPose !== null;\n    }\n    return this;\n  }\n  // private method\n  _getHandJoint(hand, inputjoint) {\n    if (hand.joints[inputjoint.jointName] === void 0) {\n      const joint = new Group();\n      joint.matrixAutoUpdate = false;\n      joint.visible = false;\n      hand.joints[inputjoint.jointName] = joint;\n      hand.add(joint);\n    }\n    return hand.joints[inputjoint.jointName];\n  }\n}\nconst _occlusion_vertex = `\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}`;\nconst _occlusion_fragment = `\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}`;\nclass WebXRDepthSensing {\n  constructor() {\n    this.texture = null;\n    this.mesh = null;\n    this.depthNear = 0;\n    this.depthFar = 0;\n  }\n  init(renderer, depthData, renderState) {\n    if (this.texture === null) {\n      const texture = new Texture();\n      const texProps = renderer.properties.get(texture);\n      texProps.__webglTexture = depthData.texture;\n      if (depthData.depthNear != renderState.depthNear || depthData.depthFar != renderState.depthFar) {\n        this.depthNear = depthData.depthNear;\n        this.depthFar = depthData.depthFar;\n      }\n      this.texture = texture;\n    }\n  }\n  getMesh(cameraXR) {\n    if (this.texture !== null) {\n      if (this.mesh === null) {\n        const viewport = cameraXR.cameras[0].viewport;\n        const material = new ShaderMaterial({\n          vertexShader: _occlusion_vertex,\n          fragmentShader: _occlusion_fragment,\n          uniforms: {\n            depthColor: { value: this.texture },\n            depthWidth: { value: viewport.z },\n            depthHeight: { value: viewport.w }\n          }\n        });\n        this.mesh = new Mesh(new PlaneGeometry(20, 20), material);\n      }\n    }\n    return this.mesh;\n  }\n  reset() {\n    this.texture = null;\n    this.mesh = null;\n  }\n  getDepthTexture() {\n    return this.texture;\n  }\n}\nclass WebXRManager extends EventDispatcher {\n  constructor(renderer, gl) {\n    super();\n    const scope = this;\n    let session = null;\n    let framebufferScaleFactor = 1;\n    let referenceSpace = null;\n    let referenceSpaceType = \"local-floor\";\n    let foveation = 1;\n    let customReferenceSpace = null;\n    let pose = null;\n    let glBinding = null;\n    let glProjLayer = null;\n    let glBaseLayer = null;\n    let xrFrame = null;\n    const depthSensing = new WebXRDepthSensing();\n    const attributes = gl.getContextAttributes();\n    let initialRenderTarget = null;\n    let newRenderTarget = null;\n    const controllers = [];\n    const controllerInputSources = [];\n    const currentSize = new Vector2();\n    let currentPixelRatio = null;\n    const cameraL = new PerspectiveCamera();\n    cameraL.viewport = new Vector4();\n    const cameraR = new PerspectiveCamera();\n    cameraR.viewport = new Vector4();\n    const cameras = [cameraL, cameraR];\n    const cameraXR = new ArrayCamera();\n    let _currentDepthNear = null;\n    let _currentDepthFar = null;\n    this.cameraAutoUpdate = true;\n    this.enabled = false;\n    this.isPresenting = false;\n    this.getController = function(index) {\n      let controller = controllers[index];\n      if (controller === void 0) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n      return controller.getTargetRaySpace();\n    };\n    this.getControllerGrip = function(index) {\n      let controller = controllers[index];\n      if (controller === void 0) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n      return controller.getGripSpace();\n    };\n    this.getHand = function(index) {\n      let controller = controllers[index];\n      if (controller === void 0) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n      return controller.getHandSpace();\n    };\n    function onSessionEvent(event) {\n      const controllerIndex = controllerInputSources.indexOf(event.inputSource);\n      if (controllerIndex === -1) {\n        return;\n      }\n      const controller = controllers[controllerIndex];\n      if (controller !== void 0) {\n        controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);\n        controller.dispatchEvent({ type: event.type, data: event.inputSource });\n      }\n    }\n    function onSessionEnd() {\n      session.removeEventListener(\"select\", onSessionEvent);\n      session.removeEventListener(\"selectstart\", onSessionEvent);\n      session.removeEventListener(\"selectend\", onSessionEvent);\n      session.removeEventListener(\"squeeze\", onSessionEvent);\n      session.removeEventListener(\"squeezestart\", onSessionEvent);\n      session.removeEventListener(\"squeezeend\", onSessionEvent);\n      session.removeEventListener(\"end\", onSessionEnd);\n      session.removeEventListener(\"inputsourceschange\", onInputSourcesChange);\n      for (let i = 0; i < controllers.length; i++) {\n        const inputSource = controllerInputSources[i];\n        if (inputSource === null) continue;\n        controllerInputSources[i] = null;\n        controllers[i].disconnect(inputSource);\n      }\n      _currentDepthNear = null;\n      _currentDepthFar = null;\n      depthSensing.reset();\n      renderer.setRenderTarget(initialRenderTarget);\n      glBaseLayer = null;\n      glProjLayer = null;\n      glBinding = null;\n      session = null;\n      newRenderTarget = null;\n      animation.stop();\n      scope.isPresenting = false;\n      renderer.setPixelRatio(currentPixelRatio);\n      renderer.setSize(currentSize.width, currentSize.height, false);\n      scope.dispatchEvent({ type: \"sessionend\" });\n    }\n    this.setFramebufferScaleFactor = function(value) {\n      framebufferScaleFactor = value;\n      if (scope.isPresenting === true) {\n        console.warn(\"THREE.WebXRManager: Cannot change framebuffer scale while presenting.\");\n      }\n    };\n    this.setReferenceSpaceType = function(value) {\n      referenceSpaceType = value;\n      if (scope.isPresenting === true) {\n        console.warn(\"THREE.WebXRManager: Cannot change reference space type while presenting.\");\n      }\n    };\n    this.getReferenceSpace = function() {\n      return customReferenceSpace || referenceSpace;\n    };\n    this.setReferenceSpace = function(space) {\n      customReferenceSpace = space;\n    };\n    this.getBaseLayer = function() {\n      return glProjLayer !== null ? glProjLayer : glBaseLayer;\n    };\n    this.getBinding = function() {\n      return glBinding;\n    };\n    this.getFrame = function() {\n      return xrFrame;\n    };\n    this.getSession = function() {\n      return session;\n    };\n    this.setSession = async function(value) {\n      session = value;\n      if (session !== null) {\n        initialRenderTarget = renderer.getRenderTarget();\n        session.addEventListener(\"select\", onSessionEvent);\n        session.addEventListener(\"selectstart\", onSessionEvent);\n        session.addEventListener(\"selectend\", onSessionEvent);\n        session.addEventListener(\"squeeze\", onSessionEvent);\n        session.addEventListener(\"squeezestart\", onSessionEvent);\n        session.addEventListener(\"squeezeend\", onSessionEvent);\n        session.addEventListener(\"end\", onSessionEnd);\n        session.addEventListener(\"inputsourceschange\", onInputSourcesChange);\n        if (attributes.xrCompatible !== true) {\n          await gl.makeXRCompatible();\n        }\n        currentPixelRatio = renderer.getPixelRatio();\n        renderer.getSize(currentSize);\n        if (session.renderState.layers === void 0) {\n          const layerInit = {\n            antialias: attributes.antialias,\n            alpha: true,\n            depth: attributes.depth,\n            stencil: attributes.stencil,\n            framebufferScaleFactor\n          };\n          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);\n          session.updateRenderState({ baseLayer: glBaseLayer });\n          renderer.setPixelRatio(1);\n          renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false);\n          newRenderTarget = new WebGLRenderTarget(\n            glBaseLayer.framebufferWidth,\n            glBaseLayer.framebufferHeight,\n            {\n              format: RGBAFormat,\n              type: UnsignedByteType,\n              colorSpace: renderer.outputColorSpace,\n              stencilBuffer: attributes.stencil\n            }\n          );\n        } else {\n          let depthFormat = null;\n          let depthType = null;\n          let glDepthFormat = null;\n          if (attributes.depth) {\n            glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;\n            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;\n          }\n          const projectionlayerInit = {\n            colorFormat: gl.RGBA8,\n            depthFormat: glDepthFormat,\n            scaleFactor: framebufferScaleFactor\n          };\n          glBinding = new XRWebGLBinding(session, gl);\n          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);\n          session.updateRenderState({ layers: [glProjLayer] });\n          renderer.setPixelRatio(1);\n          renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, false);\n          newRenderTarget = new WebGLRenderTarget(\n            glProjLayer.textureWidth,\n            glProjLayer.textureHeight,\n            {\n              format: RGBAFormat,\n              type: UnsignedByteType,\n              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),\n              stencilBuffer: attributes.stencil,\n              colorSpace: renderer.outputColorSpace,\n              samples: attributes.antialias ? 4 : 0,\n              resolveDepthBuffer: glProjLayer.ignoreDepthValues === false\n            }\n          );\n        }\n        newRenderTarget.isXRRenderTarget = true;\n        this.setFoveation(foveation);\n        customReferenceSpace = null;\n        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);\n        animation.setContext(session);\n        animation.start();\n        scope.isPresenting = true;\n        scope.dispatchEvent({ type: \"sessionstart\" });\n      }\n    };\n    this.getEnvironmentBlendMode = function() {\n      if (session !== null) {\n        return session.environmentBlendMode;\n      }\n    };\n    this.getDepthTexture = function() {\n      return depthSensing.getDepthTexture();\n    };\n    function onInputSourcesChange(event) {\n      for (let i = 0; i < event.removed.length; i++) {\n        const inputSource = event.removed[i];\n        const index = controllerInputSources.indexOf(inputSource);\n        if (index >= 0) {\n          controllerInputSources[index] = null;\n          controllers[index].disconnect(inputSource);\n        }\n      }\n      for (let i = 0; i < event.added.length; i++) {\n        const inputSource = event.added[i];\n        let controllerIndex = controllerInputSources.indexOf(inputSource);\n        if (controllerIndex === -1) {\n          for (let i2 = 0; i2 < controllers.length; i2++) {\n            if (i2 >= controllerInputSources.length) {\n              controllerInputSources.push(inputSource);\n              controllerIndex = i2;\n              break;\n            } else if (controllerInputSources[i2] === null) {\n              controllerInputSources[i2] = inputSource;\n              controllerIndex = i2;\n              break;\n            }\n          }\n          if (controllerIndex === -1) break;\n        }\n        const controller = controllers[controllerIndex];\n        if (controller) {\n          controller.connect(inputSource);\n        }\n      }\n    }\n    const cameraLPos = new Vector3();\n    const cameraRPos = new Vector3();\n    function setProjectionFromUnion(camera, cameraL2, cameraR2) {\n      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);\n      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);\n      const ipd = cameraLPos.distanceTo(cameraRPos);\n      const projL = cameraL2.projectionMatrix.elements;\n      const projR = cameraR2.projectionMatrix.elements;\n      const near = projL[14] / (projL[10] - 1);\n      const far = projL[14] / (projL[10] + 1);\n      const topFov = (projL[9] + 1) / projL[5];\n      const bottomFov = (projL[9] - 1) / projL[5];\n      const leftFov = (projL[8] - 1) / projL[0];\n      const rightFov = (projR[8] + 1) / projR[0];\n      const left = near * leftFov;\n      const right = near * rightFov;\n      const zOffset = ipd / (-leftFov + rightFov);\n      const xOffset = zOffset * -leftFov;\n      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\n      camera.translateX(xOffset);\n      camera.translateZ(zOffset);\n      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n      if (projL[10] === -1) {\n        camera.projectionMatrix.copy(cameraL2.projectionMatrix);\n        camera.projectionMatrixInverse.copy(cameraL2.projectionMatrixInverse);\n      } else {\n        const near2 = near + zOffset;\n        const far2 = far + zOffset;\n        const left2 = left - xOffset;\n        const right2 = right + (ipd - xOffset);\n        const top2 = topFov * far / far2 * near2;\n        const bottom2 = bottomFov * far / far2 * near2;\n        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);\n        camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();\n      }\n    }\n    function updateCamera(camera, parent) {\n      if (parent === null) {\n        camera.matrixWorld.copy(camera.matrix);\n      } else {\n        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);\n      }\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n    }\n    this.updateCamera = function(camera) {\n      if (session === null) return;\n      let depthNear = camera.near;\n      let depthFar = camera.far;\n      if (depthSensing.texture !== null) {\n        if (depthSensing.depthNear > 0) depthNear = depthSensing.depthNear;\n        if (depthSensing.depthFar > 0) depthFar = depthSensing.depthFar;\n      }\n      cameraXR.near = cameraR.near = cameraL.near = depthNear;\n      cameraXR.far = cameraR.far = cameraL.far = depthFar;\n      if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {\n        session.updateRenderState({\n          depthNear: cameraXR.near,\n          depthFar: cameraXR.far\n        });\n        _currentDepthNear = cameraXR.near;\n        _currentDepthFar = cameraXR.far;\n      }\n      cameraL.layers.mask = camera.layers.mask | 2;\n      cameraR.layers.mask = camera.layers.mask | 4;\n      cameraXR.layers.mask = cameraL.layers.mask | cameraR.layers.mask;\n      const parent = camera.parent;\n      const cameras2 = cameraXR.cameras;\n      updateCamera(cameraXR, parent);\n      for (let i = 0; i < cameras2.length; i++) {\n        updateCamera(cameras2[i], parent);\n      }\n      if (cameras2.length === 2) {\n        setProjectionFromUnion(cameraXR, cameraL, cameraR);\n      } else {\n        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);\n      }\n      updateUserCamera(camera, cameraXR, parent);\n    };\n    function updateUserCamera(camera, cameraXR2, parent) {\n      if (parent === null) {\n        camera.matrix.copy(cameraXR2.matrixWorld);\n      } else {\n        camera.matrix.copy(parent.matrixWorld);\n        camera.matrix.invert();\n        camera.matrix.multiply(cameraXR2.matrixWorld);\n      }\n      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);\n      camera.updateMatrixWorld(true);\n      camera.projectionMatrix.copy(cameraXR2.projectionMatrix);\n      camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);\n      if (camera.isPerspectiveCamera) {\n        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);\n        camera.zoom = 1;\n      }\n    }\n    this.getCamera = function() {\n      return cameraXR;\n    };\n    this.getFoveation = function() {\n      if (glProjLayer === null && glBaseLayer === null) {\n        return void 0;\n      }\n      return foveation;\n    };\n    this.setFoveation = function(value) {\n      foveation = value;\n      if (glProjLayer !== null) {\n        glProjLayer.fixedFoveation = value;\n      }\n      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {\n        glBaseLayer.fixedFoveation = value;\n      }\n    };\n    this.hasDepthSensing = function() {\n      return depthSensing.texture !== null;\n    };\n    this.getDepthSensingMesh = function() {\n      return depthSensing.getMesh(cameraXR);\n    };\n    let onAnimationFrameCallback = null;\n    function onAnimationFrame(time, frame) {\n      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);\n      xrFrame = frame;\n      if (pose !== null) {\n        const views = pose.views;\n        if (glBaseLayer !== null) {\n          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);\n          renderer.setRenderTarget(newRenderTarget);\n        }\n        let cameraXRNeedsUpdate = false;\n        if (views.length !== cameraXR.cameras.length) {\n          cameraXR.cameras.length = 0;\n          cameraXRNeedsUpdate = true;\n        }\n        for (let i = 0; i < views.length; i++) {\n          const view = views[i];\n          let viewport = null;\n          if (glBaseLayer !== null) {\n            viewport = glBaseLayer.getViewport(view);\n          } else {\n            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);\n            viewport = glSubImage.viewport;\n            if (i === 0) {\n              renderer.setRenderTargetTextures(\n                newRenderTarget,\n                glSubImage.colorTexture,\n                glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture\n              );\n              renderer.setRenderTarget(newRenderTarget);\n            }\n          }\n          let camera = cameras[i];\n          if (camera === void 0) {\n            camera = new PerspectiveCamera();\n            camera.layers.enable(i);\n            camera.viewport = new Vector4();\n            cameras[i] = camera;\n          }\n          camera.matrix.fromArray(view.transform.matrix);\n          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);\n          camera.projectionMatrix.fromArray(view.projectionMatrix);\n          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();\n          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\n          if (i === 0) {\n            cameraXR.matrix.copy(camera.matrix);\n            cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);\n          }\n          if (cameraXRNeedsUpdate === true) {\n            cameraXR.cameras.push(camera);\n          }\n        }\n        const enabledFeatures = session.enabledFeatures;\n        if (enabledFeatures && enabledFeatures.includes(\"depth-sensing\")) {\n          const depthData = glBinding.getDepthInformation(views[0]);\n          if (depthData && depthData.isValid && depthData.texture) {\n            depthSensing.init(renderer, depthData, session.renderState);\n          }\n        }\n      }\n      for (let i = 0; i < controllers.length; i++) {\n        const inputSource = controllerInputSources[i];\n        const controller = controllers[i];\n        if (inputSource !== null && controller !== void 0) {\n          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);\n        }\n      }\n      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);\n      if (frame.detectedPlanes) {\n        scope.dispatchEvent({ type: \"planesdetected\", data: frame });\n      }\n      xrFrame = null;\n    }\n    const animation = new WebGLAnimation();\n    animation.setAnimationLoop(onAnimationFrame);\n    this.setAnimationLoop = function(callback) {\n      onAnimationFrameCallback = callback;\n    };\n    this.dispose = function() {\n    };\n  }\n}\nconst _e1 = /* @__PURE__ */ new Euler();\nconst _m1 = /* @__PURE__ */ new Matrix4();\nfunction WebGLMaterials(renderer, properties) {\n  function refreshTransformUniform(map, uniform) {\n    if (map.matrixAutoUpdate === true) {\n      map.updateMatrix();\n    }\n    uniform.value.copy(map.matrix);\n  }\n  function refreshFogUniforms(uniforms2, fog) {\n    fog.color.getRGB(uniforms2.fogColor.value, getUnlitUniformColorSpace(renderer));\n    if (fog.isFog) {\n      uniforms2.fogNear.value = fog.near;\n      uniforms2.fogFar.value = fog.far;\n    } else if (fog.isFogExp2) {\n      uniforms2.fogDensity.value = fog.density;\n    }\n  }\n  function refreshMaterialUniforms(uniforms2, material, pixelRatio, height, transmissionRenderTarget) {\n    if (material.isMeshBasicMaterial) {\n      refreshUniformsCommon(uniforms2, material);\n    } else if (material.isMeshLambertMaterial) {\n      refreshUniformsCommon(uniforms2, material);\n    } else if (material.isMeshToonMaterial) {\n      refreshUniformsCommon(uniforms2, material);\n      refreshUniformsToon(uniforms2, material);\n    } else if (material.isMeshPhongMaterial) {\n      refreshUniformsCommon(uniforms2, material);\n      refreshUniformsPhong(uniforms2, material);\n    } else if (material.isMeshStandardMaterial) {\n      refreshUniformsCommon(uniforms2, material);\n      refreshUniformsStandard(uniforms2, material);\n      if (material.isMeshPhysicalMaterial) {\n        refreshUniformsPhysical(uniforms2, material, transmissionRenderTarget);\n      }\n    } else if (material.isMeshMatcapMaterial) {\n      refreshUniformsCommon(uniforms2, material);\n      refreshUniformsMatcap(uniforms2, material);\n    } else if (material.isMeshDepthMaterial) {\n      refreshUniformsCommon(uniforms2, material);\n    } else if (material.isMeshDistanceMaterial) {\n      refreshUniformsCommon(uniforms2, material);\n      refreshUniformsDistance(uniforms2, material);\n    } else if (material.isMeshNormalMaterial) {\n      refreshUniformsCommon(uniforms2, material);\n    } else if (material.isLineBasicMaterial) {\n      refreshUniformsLine(uniforms2, material);\n      if (material.isLineDashedMaterial) {\n        refreshUniformsDash(uniforms2, material);\n      }\n    } else if (material.isPointsMaterial) {\n      refreshUniformsPoints(uniforms2, material, pixelRatio, height);\n    } else if (material.isSpriteMaterial) {\n      refreshUniformsSprites(uniforms2, material);\n    } else if (material.isShadowMaterial) {\n      uniforms2.color.value.copy(material.color);\n      uniforms2.opacity.value = material.opacity;\n    } else if (material.isShaderMaterial) {\n      material.uniformsNeedUpdate = false;\n    }\n  }\n  function refreshUniformsCommon(uniforms2, material) {\n    uniforms2.opacity.value = material.opacity;\n    if (material.color) {\n      uniforms2.diffuse.value.copy(material.color);\n    }\n    if (material.emissive) {\n      uniforms2.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n    }\n    if (material.map) {\n      uniforms2.map.value = material.map;\n      refreshTransformUniform(material.map, uniforms2.mapTransform);\n    }\n    if (material.alphaMap) {\n      uniforms2.alphaMap.value = material.alphaMap;\n      refreshTransformUniform(material.alphaMap, uniforms2.alphaMapTransform);\n    }\n    if (material.bumpMap) {\n      uniforms2.bumpMap.value = material.bumpMap;\n      refreshTransformUniform(material.bumpMap, uniforms2.bumpMapTransform);\n      uniforms2.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide) {\n        uniforms2.bumpScale.value *= -1;\n      }\n    }\n    if (material.normalMap) {\n      uniforms2.normalMap.value = material.normalMap;\n      refreshTransformUniform(material.normalMap, uniforms2.normalMapTransform);\n      uniforms2.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide) {\n        uniforms2.normalScale.value.negate();\n      }\n    }\n    if (material.displacementMap) {\n      uniforms2.displacementMap.value = material.displacementMap;\n      refreshTransformUniform(material.displacementMap, uniforms2.displacementMapTransform);\n      uniforms2.displacementScale.value = material.displacementScale;\n      uniforms2.displacementBias.value = material.displacementBias;\n    }\n    if (material.emissiveMap) {\n      uniforms2.emissiveMap.value = material.emissiveMap;\n      refreshTransformUniform(material.emissiveMap, uniforms2.emissiveMapTransform);\n    }\n    if (material.specularMap) {\n      uniforms2.specularMap.value = material.specularMap;\n      refreshTransformUniform(material.specularMap, uniforms2.specularMapTransform);\n    }\n    if (material.alphaTest > 0) {\n      uniforms2.alphaTest.value = material.alphaTest;\n    }\n    const materialProperties = properties.get(material);\n    const envMap = materialProperties.envMap;\n    const envMapRotation = materialProperties.envMapRotation;\n    if (envMap) {\n      uniforms2.envMap.value = envMap;\n      _e1.copy(envMapRotation);\n      _e1.x *= -1;\n      _e1.y *= -1;\n      _e1.z *= -1;\n      if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {\n        _e1.y *= -1;\n        _e1.z *= -1;\n      }\n      uniforms2.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1));\n      uniforms2.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;\n      uniforms2.reflectivity.value = material.reflectivity;\n      uniforms2.ior.value = material.ior;\n      uniforms2.refractionRatio.value = material.refractionRatio;\n    }\n    if (material.lightMap) {\n      uniforms2.lightMap.value = material.lightMap;\n      uniforms2.lightMapIntensity.value = material.lightMapIntensity;\n      refreshTransformUniform(material.lightMap, uniforms2.lightMapTransform);\n    }\n    if (material.aoMap) {\n      uniforms2.aoMap.value = material.aoMap;\n      uniforms2.aoMapIntensity.value = material.aoMapIntensity;\n      refreshTransformUniform(material.aoMap, uniforms2.aoMapTransform);\n    }\n  }\n  function refreshUniformsLine(uniforms2, material) {\n    uniforms2.diffuse.value.copy(material.color);\n    uniforms2.opacity.value = material.opacity;\n    if (material.map) {\n      uniforms2.map.value = material.map;\n      refreshTransformUniform(material.map, uniforms2.mapTransform);\n    }\n  }\n  function refreshUniformsDash(uniforms2, material) {\n    uniforms2.dashSize.value = material.dashSize;\n    uniforms2.totalSize.value = material.dashSize + material.gapSize;\n    uniforms2.scale.value = material.scale;\n  }\n  function refreshUniformsPoints(uniforms2, material, pixelRatio, height) {\n    uniforms2.diffuse.value.copy(material.color);\n    uniforms2.opacity.value = material.opacity;\n    uniforms2.size.value = material.size * pixelRatio;\n    uniforms2.scale.value = height * 0.5;\n    if (material.map) {\n      uniforms2.map.value = material.map;\n      refreshTransformUniform(material.map, uniforms2.uvTransform);\n    }\n    if (material.alphaMap) {\n      uniforms2.alphaMap.value = material.alphaMap;\n      refreshTransformUniform(material.alphaMap, uniforms2.alphaMapTransform);\n    }\n    if (material.alphaTest > 0) {\n      uniforms2.alphaTest.value = material.alphaTest;\n    }\n  }\n  function refreshUniformsSprites(uniforms2, material) {\n    uniforms2.diffuse.value.copy(material.color);\n    uniforms2.opacity.value = material.opacity;\n    uniforms2.rotation.value = material.rotation;\n    if (material.map) {\n      uniforms2.map.value = material.map;\n      refreshTransformUniform(material.map, uniforms2.mapTransform);\n    }\n    if (material.alphaMap) {\n      uniforms2.alphaMap.value = material.alphaMap;\n      refreshTransformUniform(material.alphaMap, uniforms2.alphaMapTransform);\n    }\n    if (material.alphaTest > 0) {\n      uniforms2.alphaTest.value = material.alphaTest;\n    }\n  }\n  function refreshUniformsPhong(uniforms2, material) {\n    uniforms2.specular.value.copy(material.specular);\n    uniforms2.shininess.value = Math.max(material.shininess, 1e-4);\n  }\n  function refreshUniformsToon(uniforms2, material) {\n    if (material.gradientMap) {\n      uniforms2.gradientMap.value = material.gradientMap;\n    }\n  }\n  function refreshUniformsStandard(uniforms2, material) {\n    uniforms2.metalness.value = material.metalness;\n    if (material.metalnessMap) {\n      uniforms2.metalnessMap.value = material.metalnessMap;\n      refreshTransformUniform(material.metalnessMap, uniforms2.metalnessMapTransform);\n    }\n    uniforms2.roughness.value = material.roughness;\n    if (material.roughnessMap) {\n      uniforms2.roughnessMap.value = material.roughnessMap;\n      refreshTransformUniform(material.roughnessMap, uniforms2.roughnessMapTransform);\n    }\n    if (material.envMap) {\n      uniforms2.envMapIntensity.value = material.envMapIntensity;\n    }\n  }\n  function refreshUniformsPhysical(uniforms2, material, transmissionRenderTarget) {\n    uniforms2.ior.value = material.ior;\n    if (material.sheen > 0) {\n      uniforms2.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);\n      uniforms2.sheenRoughness.value = material.sheenRoughness;\n      if (material.sheenColorMap) {\n        uniforms2.sheenColorMap.value = material.sheenColorMap;\n        refreshTransformUniform(material.sheenColorMap, uniforms2.sheenColorMapTransform);\n      }\n      if (material.sheenRoughnessMap) {\n        uniforms2.sheenRoughnessMap.value = material.sheenRoughnessMap;\n        refreshTransformUniform(material.sheenRoughnessMap, uniforms2.sheenRoughnessMapTransform);\n      }\n    }\n    if (material.clearcoat > 0) {\n      uniforms2.clearcoat.value = material.clearcoat;\n      uniforms2.clearcoatRoughness.value = material.clearcoatRoughness;\n      if (material.clearcoatMap) {\n        uniforms2.clearcoatMap.value = material.clearcoatMap;\n        refreshTransformUniform(material.clearcoatMap, uniforms2.clearcoatMapTransform);\n      }\n      if (material.clearcoatRoughnessMap) {\n        uniforms2.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n        refreshTransformUniform(material.clearcoatRoughnessMap, uniforms2.clearcoatRoughnessMapTransform);\n      }\n      if (material.clearcoatNormalMap) {\n        uniforms2.clearcoatNormalMap.value = material.clearcoatNormalMap;\n        refreshTransformUniform(material.clearcoatNormalMap, uniforms2.clearcoatNormalMapTransform);\n        uniforms2.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);\n        if (material.side === BackSide) {\n          uniforms2.clearcoatNormalScale.value.negate();\n        }\n      }\n    }\n    if (material.dispersion > 0) {\n      uniforms2.dispersion.value = material.dispersion;\n    }\n    if (material.iridescence > 0) {\n      uniforms2.iridescence.value = material.iridescence;\n      uniforms2.iridescenceIOR.value = material.iridescenceIOR;\n      uniforms2.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];\n      uniforms2.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];\n      if (material.iridescenceMap) {\n        uniforms2.iridescenceMap.value = material.iridescenceMap;\n        refreshTransformUniform(material.iridescenceMap, uniforms2.iridescenceMapTransform);\n      }\n      if (material.iridescenceThicknessMap) {\n        uniforms2.iridescenceThicknessMap.value = material.iridescenceThicknessMap;\n        refreshTransformUniform(material.iridescenceThicknessMap, uniforms2.iridescenceThicknessMapTransform);\n      }\n    }\n    if (material.transmission > 0) {\n      uniforms2.transmission.value = material.transmission;\n      uniforms2.transmissionSamplerMap.value = transmissionRenderTarget.texture;\n      uniforms2.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);\n      if (material.transmissionMap) {\n        uniforms2.transmissionMap.value = material.transmissionMap;\n        refreshTransformUniform(material.transmissionMap, uniforms2.transmissionMapTransform);\n      }\n      uniforms2.thickness.value = material.thickness;\n      if (material.thicknessMap) {\n        uniforms2.thicknessMap.value = material.thicknessMap;\n        refreshTransformUniform(material.thicknessMap, uniforms2.thicknessMapTransform);\n      }\n      uniforms2.attenuationDistance.value = material.attenuationDistance;\n      uniforms2.attenuationColor.value.copy(material.attenuationColor);\n    }\n    if (material.anisotropy > 0) {\n      uniforms2.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));\n      if (material.anisotropyMap) {\n        uniforms2.anisotropyMap.value = material.anisotropyMap;\n        refreshTransformUniform(material.anisotropyMap, uniforms2.anisotropyMapTransform);\n      }\n    }\n    uniforms2.specularIntensity.value = material.specularIntensity;\n    uniforms2.specularColor.value.copy(material.specularColor);\n    if (material.specularColorMap) {\n      uniforms2.specularColorMap.value = material.specularColorMap;\n      refreshTransformUniform(material.specularColorMap, uniforms2.specularColorMapTransform);\n    }\n    if (material.specularIntensityMap) {\n      uniforms2.specularIntensityMap.value = material.specularIntensityMap;\n      refreshTransformUniform(material.specularIntensityMap, uniforms2.specularIntensityMapTransform);\n    }\n  }\n  function refreshUniformsMatcap(uniforms2, material) {\n    if (material.matcap) {\n      uniforms2.matcap.value = material.matcap;\n    }\n  }\n  function refreshUniformsDistance(uniforms2, material) {\n    const light = properties.get(material).light;\n    uniforms2.referencePosition.value.setFromMatrixPosition(light.matrixWorld);\n    uniforms2.nearDistance.value = light.shadow.camera.near;\n    uniforms2.farDistance.value = light.shadow.camera.far;\n  }\n  return {\n    refreshFogUniforms,\n    refreshMaterialUniforms\n  };\n}\nfunction WebGLUniformsGroups(gl, info, capabilities, state) {\n  let buffers = {};\n  let updateList = {};\n  let allocatedBindingPoints = [];\n  const maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);\n  function bind(uniformsGroup, program) {\n    const webglProgram = program.program;\n    state.uniformBlockBinding(uniformsGroup, webglProgram);\n  }\n  function update(uniformsGroup, program) {\n    let buffer = buffers[uniformsGroup.id];\n    if (buffer === void 0) {\n      prepareUniformsGroup(uniformsGroup);\n      buffer = createBuffer(uniformsGroup);\n      buffers[uniformsGroup.id] = buffer;\n      uniformsGroup.addEventListener(\"dispose\", onUniformsGroupsDispose);\n    }\n    const webglProgram = program.program;\n    state.updateUBOMapping(uniformsGroup, webglProgram);\n    const frame = info.render.frame;\n    if (updateList[uniformsGroup.id] !== frame) {\n      updateBufferData(uniformsGroup);\n      updateList[uniformsGroup.id] = frame;\n    }\n  }\n  function createBuffer(uniformsGroup) {\n    const bindingPointIndex = allocateBindingPointIndex();\n    uniformsGroup.__bindingPointIndex = bindingPointIndex;\n    const buffer = gl.createBuffer();\n    const size = uniformsGroup.__size;\n    const usage = uniformsGroup.usage;\n    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n    gl.bufferData(gl.UNIFORM_BUFFER, size, usage);\n    gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);\n    return buffer;\n  }\n  function allocateBindingPointIndex() {\n    for (let i = 0; i < maxBindingPoints; i++) {\n      if (allocatedBindingPoints.indexOf(i) === -1) {\n        allocatedBindingPoints.push(i);\n        return i;\n      }\n    }\n    console.error(\"THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.\");\n    return 0;\n  }\n  function updateBufferData(uniformsGroup) {\n    const buffer = buffers[uniformsGroup.id];\n    const uniforms2 = uniformsGroup.uniforms;\n    const cache2 = uniformsGroup.__cache;\n    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);\n    for (let i = 0, il = uniforms2.length; i < il; i++) {\n      const uniformArray = Array.isArray(uniforms2[i]) ? uniforms2[i] : [uniforms2[i]];\n      for (let j = 0, jl = uniformArray.length; j < jl; j++) {\n        const uniform = uniformArray[j];\n        if (hasUniformChanged(uniform, i, j, cache2) === true) {\n          const offset = uniform.__offset;\n          const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];\n          let arrayOffset = 0;\n          for (let k = 0; k < values.length; k++) {\n            const value = values[k];\n            const info2 = getUniformSize(value);\n            if (typeof value === \"number\" || typeof value === \"boolean\") {\n              uniform.__data[0] = value;\n              gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);\n            } else if (value.isMatrix3) {\n              uniform.__data[0] = value.elements[0];\n              uniform.__data[1] = value.elements[1];\n              uniform.__data[2] = value.elements[2];\n              uniform.__data[3] = 0;\n              uniform.__data[4] = value.elements[3];\n              uniform.__data[5] = value.elements[4];\n              uniform.__data[6] = value.elements[5];\n              uniform.__data[7] = 0;\n              uniform.__data[8] = value.elements[6];\n              uniform.__data[9] = value.elements[7];\n              uniform.__data[10] = value.elements[8];\n              uniform.__data[11] = 0;\n            } else {\n              value.toArray(uniform.__data, arrayOffset);\n              arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;\n            }\n          }\n          gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);\n        }\n      }\n    }\n    gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n  }\n  function hasUniformChanged(uniform, index, indexArray, cache2) {\n    const value = uniform.value;\n    const indexString = index + \"_\" + indexArray;\n    if (cache2[indexString] === void 0) {\n      if (typeof value === \"number\" || typeof value === \"boolean\") {\n        cache2[indexString] = value;\n      } else {\n        cache2[indexString] = value.clone();\n      }\n      return true;\n    } else {\n      const cachedObject = cache2[indexString];\n      if (typeof value === \"number\" || typeof value === \"boolean\") {\n        if (cachedObject !== value) {\n          cache2[indexString] = value;\n          return true;\n        }\n      } else {\n        if (cachedObject.equals(value) === false) {\n          cachedObject.copy(value);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  function prepareUniformsGroup(uniformsGroup) {\n    const uniforms2 = uniformsGroup.uniforms;\n    let offset = 0;\n    const chunkSize = 16;\n    for (let i = 0, l = uniforms2.length; i < l; i++) {\n      const uniformArray = Array.isArray(uniforms2[i]) ? uniforms2[i] : [uniforms2[i]];\n      for (let j = 0, jl = uniformArray.length; j < jl; j++) {\n        const uniform = uniformArray[j];\n        const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];\n        for (let k = 0, kl = values.length; k < kl; k++) {\n          const value = values[k];\n          const info2 = getUniformSize(value);\n          const chunkOffset2 = offset % chunkSize;\n          const chunkPadding = chunkOffset2 % info2.boundary;\n          const chunkStart = chunkOffset2 + chunkPadding;\n          offset += chunkPadding;\n          if (chunkStart !== 0 && chunkSize - chunkStart < info2.storage) {\n            offset += chunkSize - chunkStart;\n          }\n          uniform.__data = new Float32Array(info2.storage / Float32Array.BYTES_PER_ELEMENT);\n          uniform.__offset = offset;\n          offset += info2.storage;\n        }\n      }\n    }\n    const chunkOffset = offset % chunkSize;\n    if (chunkOffset > 0) offset += chunkSize - chunkOffset;\n    uniformsGroup.__size = offset;\n    uniformsGroup.__cache = {};\n    return this;\n  }\n  function getUniformSize(value) {\n    const info2 = {\n      boundary: 0,\n      // bytes\n      storage: 0\n      // bytes\n    };\n    if (typeof value === \"number\" || typeof value === \"boolean\") {\n      info2.boundary = 4;\n      info2.storage = 4;\n    } else if (value.isVector2) {\n      info2.boundary = 8;\n      info2.storage = 8;\n    } else if (value.isVector3 || value.isColor) {\n      info2.boundary = 16;\n      info2.storage = 12;\n    } else if (value.isVector4) {\n      info2.boundary = 16;\n      info2.storage = 16;\n    } else if (value.isMatrix3) {\n      info2.boundary = 48;\n      info2.storage = 48;\n    } else if (value.isMatrix4) {\n      info2.boundary = 64;\n      info2.storage = 64;\n    } else if (value.isTexture) {\n      console.warn(\"THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.\");\n    } else {\n      console.warn(\"THREE.WebGLRenderer: Unsupported uniform value type.\", value);\n    }\n    return info2;\n  }\n  function onUniformsGroupsDispose(event) {\n    const uniformsGroup = event.target;\n    uniformsGroup.removeEventListener(\"dispose\", onUniformsGroupsDispose);\n    const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);\n    allocatedBindingPoints.splice(index, 1);\n    gl.deleteBuffer(buffers[uniformsGroup.id]);\n    delete buffers[uniformsGroup.id];\n    delete updateList[uniformsGroup.id];\n  }\n  function dispose() {\n    for (const id2 in buffers) {\n      gl.deleteBuffer(buffers[id2]);\n    }\n    allocatedBindingPoints = [];\n    buffers = {};\n    updateList = {};\n  }\n  return {\n    bind,\n    update,\n    dispose\n  };\n}\nclass WebGLRenderer {\n  constructor(parameters = {}) {\n    const {\n      canvas = createCanvasElement(),\n      context = null,\n      depth = true,\n      stencil = false,\n      alpha = false,\n      antialias = false,\n      premultipliedAlpha = true,\n      preserveDrawingBuffer = false,\n      powerPreference = \"default\",\n      failIfMajorPerformanceCaveat = false,\n      reverseDepthBuffer = false\n    } = parameters;\n    this.isWebGLRenderer = true;\n    let _alpha;\n    if (context !== null) {\n      if (typeof WebGLRenderingContext !== \"undefined\" && context instanceof WebGLRenderingContext) {\n        throw new Error(\"THREE.WebGLRenderer: WebGL 1 is not supported since r163.\");\n      }\n      _alpha = context.getContextAttributes().alpha;\n    } else {\n      _alpha = alpha;\n    }\n    const uintClearColor = new Uint32Array(4);\n    const intClearColor = new Int32Array(4);\n    let currentRenderList = null;\n    let currentRenderState = null;\n    const renderListStack = [];\n    const renderStateStack = [];\n    this.domElement = canvas;\n    this.debug = {\n      /**\n       * Enables error checking and reporting when shader programs are being compiled\n       * @type {boolean}\n       */\n      checkShaderErrors: true,\n      /**\n       * Callback for custom error reporting.\n       * @type {?Function}\n       */\n      onShaderError: null\n    };\n    this.autoClear = true;\n    this.autoClearColor = true;\n    this.autoClearDepth = true;\n    this.autoClearStencil = true;\n    this.sortObjects = true;\n    this.clippingPlanes = [];\n    this.localClippingEnabled = false;\n    this._outputColorSpace = SRGBColorSpace;\n    this.toneMapping = NoToneMapping;\n    this.toneMappingExposure = 1;\n    const _this = this;\n    let _isContextLost = false;\n    let _currentActiveCubeFace = 0;\n    let _currentActiveMipmapLevel = 0;\n    let _currentRenderTarget = null;\n    let _currentMaterialId = -1;\n    let _currentCamera = null;\n    const _currentViewport = new Vector4();\n    const _currentScissor = new Vector4();\n    let _currentScissorTest = null;\n    const _currentClearColor = new Color(0);\n    let _currentClearAlpha = 0;\n    let _width = canvas.width;\n    let _height = canvas.height;\n    let _pixelRatio = 1;\n    let _opaqueSort = null;\n    let _transparentSort = null;\n    const _viewport2 = new Vector4(0, 0, _width, _height);\n    const _scissor = new Vector4(0, 0, _width, _height);\n    let _scissorTest = false;\n    const _frustum = new Frustum();\n    let _clippingEnabled = false;\n    let _localClippingEnabled = false;\n    const _currentProjectionMatrix = new Matrix4();\n    const _projScreenMatrix2 = new Matrix4();\n    const _vector32 = new Vector3();\n    const _vector4 = new Vector4();\n    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };\n    let _renderBackground = false;\n    function getTargetPixelRatio() {\n      return _currentRenderTarget === null ? _pixelRatio : 1;\n    }\n    let _gl = context;\n    function getContext(contextName, contextAttributes) {\n      return canvas.getContext(contextName, contextAttributes);\n    }\n    try {\n      const contextAttributes = {\n        alpha: true,\n        depth,\n        stencil,\n        antialias,\n        premultipliedAlpha,\n        preserveDrawingBuffer,\n        powerPreference,\n        failIfMajorPerformanceCaveat\n      };\n      if (\"setAttribute\" in canvas) canvas.setAttribute(\"data-engine\", `three.js r${REVISION}`);\n      canvas.addEventListener(\"webglcontextlost\", onContextLost, false);\n      canvas.addEventListener(\"webglcontextrestored\", onContextRestore, false);\n      canvas.addEventListener(\"webglcontextcreationerror\", onContextCreationError, false);\n      if (_gl === null) {\n        const contextName = \"webgl2\";\n        _gl = getContext(contextName, contextAttributes);\n        if (_gl === null) {\n          if (getContext(contextName)) {\n            throw new Error(\"Error creating WebGL context with your selected attributes.\");\n          } else {\n            throw new Error(\"Error creating WebGL context.\");\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"THREE.WebGLRenderer: \" + error.message);\n      throw error;\n    }\n    let extensions, capabilities, state, info;\n    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;\n    let programCache, materials, renderLists, renderStates, clipping, shadowMap;\n    let background, morphtargets, bufferRenderer, indexedBufferRenderer;\n    let utils, bindingStates, uniformsGroups;\n    function initGLContext() {\n      extensions = new WebGLExtensions(_gl);\n      extensions.init();\n      utils = new WebGLUtils(_gl, extensions);\n      capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);\n      state = new WebGLState(_gl, extensions);\n      if (capabilities.reverseDepthBuffer && reverseDepthBuffer) {\n        state.buffers.depth.setReversed(true);\n      }\n      info = new WebGLInfo(_gl);\n      properties = new WebGLProperties();\n      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);\n      cubemaps = new WebGLCubeMaps(_this);\n      cubeuvmaps = new WebGLCubeUVMaps(_this);\n      attributes = new WebGLAttributes(_gl);\n      bindingStates = new WebGLBindingStates(_gl, attributes);\n      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);\n      objects = new WebGLObjects(_gl, geometries, attributes, info);\n      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);\n      clipping = new WebGLClipping(properties);\n      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);\n      materials = new WebGLMaterials(_this, properties);\n      renderLists = new WebGLRenderLists();\n      renderStates = new WebGLRenderStates(extensions);\n      background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);\n      shadowMap = new WebGLShadowMap(_this, objects, capabilities);\n      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);\n      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);\n      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);\n      info.programs = programCache.programs;\n      _this.capabilities = capabilities;\n      _this.extensions = extensions;\n      _this.properties = properties;\n      _this.renderLists = renderLists;\n      _this.shadowMap = shadowMap;\n      _this.state = state;\n      _this.info = info;\n    }\n    initGLContext();\n    const xr = new WebXRManager(_this, _gl);\n    this.xr = xr;\n    this.getContext = function() {\n      return _gl;\n    };\n    this.getContextAttributes = function() {\n      return _gl.getContextAttributes();\n    };\n    this.forceContextLoss = function() {\n      const extension = extensions.get(\"WEBGL_lose_context\");\n      if (extension) extension.loseContext();\n    };\n    this.forceContextRestore = function() {\n      const extension = extensions.get(\"WEBGL_lose_context\");\n      if (extension) extension.restoreContext();\n    };\n    this.getPixelRatio = function() {\n      return _pixelRatio;\n    };\n    this.setPixelRatio = function(value) {\n      if (value === void 0) return;\n      _pixelRatio = value;\n      this.setSize(_width, _height, false);\n    };\n    this.getSize = function(target) {\n      return target.set(_width, _height);\n    };\n    this.setSize = function(width, height, updateStyle = true) {\n      if (xr.isPresenting) {\n        console.warn(\"THREE.WebGLRenderer: Can't change size while VR device is presenting.\");\n        return;\n      }\n      _width = width;\n      _height = height;\n      canvas.width = Math.floor(width * _pixelRatio);\n      canvas.height = Math.floor(height * _pixelRatio);\n      if (updateStyle === true) {\n        canvas.style.width = width + \"px\";\n        canvas.style.height = height + \"px\";\n      }\n      this.setViewport(0, 0, width, height);\n    };\n    this.getDrawingBufferSize = function(target) {\n      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();\n    };\n    this.setDrawingBufferSize = function(width, height, pixelRatio) {\n      _width = width;\n      _height = height;\n      _pixelRatio = pixelRatio;\n      canvas.width = Math.floor(width * pixelRatio);\n      canvas.height = Math.floor(height * pixelRatio);\n      this.setViewport(0, 0, width, height);\n    };\n    this.getCurrentViewport = function(target) {\n      return target.copy(_currentViewport);\n    };\n    this.getViewport = function(target) {\n      return target.copy(_viewport2);\n    };\n    this.setViewport = function(x, y, width, height) {\n      if (x.isVector4) {\n        _viewport2.set(x.x, x.y, x.z, x.w);\n      } else {\n        _viewport2.set(x, y, width, height);\n      }\n      state.viewport(_currentViewport.copy(_viewport2).multiplyScalar(_pixelRatio).round());\n    };\n    this.getScissor = function(target) {\n      return target.copy(_scissor);\n    };\n    this.setScissor = function(x, y, width, height) {\n      if (x.isVector4) {\n        _scissor.set(x.x, x.y, x.z, x.w);\n      } else {\n        _scissor.set(x, y, width, height);\n      }\n      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());\n    };\n    this.getScissorTest = function() {\n      return _scissorTest;\n    };\n    this.setScissorTest = function(boolean) {\n      state.setScissorTest(_scissorTest = boolean);\n    };\n    this.setOpaqueSort = function(method) {\n      _opaqueSort = method;\n    };\n    this.setTransparentSort = function(method) {\n      _transparentSort = method;\n    };\n    this.getClearColor = function(target) {\n      return target.copy(background.getClearColor());\n    };\n    this.setClearColor = function() {\n      background.setClearColor.apply(background, arguments);\n    };\n    this.getClearAlpha = function() {\n      return background.getClearAlpha();\n    };\n    this.setClearAlpha = function() {\n      background.setClearAlpha.apply(background, arguments);\n    };\n    this.clear = function(color = true, depth2 = true, stencil2 = true) {\n      let bits2 = 0;\n      if (color) {\n        let isIntegerFormat = false;\n        if (_currentRenderTarget !== null) {\n          const targetFormat = _currentRenderTarget.texture.format;\n          isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;\n        }\n        if (isIntegerFormat) {\n          const targetType = _currentRenderTarget.texture.type;\n          const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;\n          const clearColor = background.getClearColor();\n          const a = background.getClearAlpha();\n          const r = clearColor.r;\n          const g = clearColor.g;\n          const b = clearColor.b;\n          if (isUnsignedType) {\n            uintClearColor[0] = r;\n            uintClearColor[1] = g;\n            uintClearColor[2] = b;\n            uintClearColor[3] = a;\n            _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);\n          } else {\n            intClearColor[0] = r;\n            intClearColor[1] = g;\n            intClearColor[2] = b;\n            intClearColor[3] = a;\n            _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);\n          }\n        } else {\n          bits2 |= _gl.COLOR_BUFFER_BIT;\n        }\n      }\n      if (depth2) {\n        bits2 |= _gl.DEPTH_BUFFER_BIT;\n      }\n      if (stencil2) {\n        bits2 |= _gl.STENCIL_BUFFER_BIT;\n        this.state.buffers.stencil.setMask(4294967295);\n      }\n      _gl.clear(bits2);\n    };\n    this.clearColor = function() {\n      this.clear(true, false, false);\n    };\n    this.clearDepth = function() {\n      this.clear(false, true, false);\n    };\n    this.clearStencil = function() {\n      this.clear(false, false, true);\n    };\n    this.dispose = function() {\n      canvas.removeEventListener(\"webglcontextlost\", onContextLost, false);\n      canvas.removeEventListener(\"webglcontextrestored\", onContextRestore, false);\n      canvas.removeEventListener(\"webglcontextcreationerror\", onContextCreationError, false);\n      renderLists.dispose();\n      renderStates.dispose();\n      properties.dispose();\n      cubemaps.dispose();\n      cubeuvmaps.dispose();\n      objects.dispose();\n      bindingStates.dispose();\n      uniformsGroups.dispose();\n      programCache.dispose();\n      xr.dispose();\n      xr.removeEventListener(\"sessionstart\", onXRSessionStart);\n      xr.removeEventListener(\"sessionend\", onXRSessionEnd);\n      animation.stop();\n    };\n    function onContextLost(event) {\n      event.preventDefault();\n      console.log(\"THREE.WebGLRenderer: Context Lost.\");\n      _isContextLost = true;\n    }\n    function onContextRestore() {\n      console.log(\"THREE.WebGLRenderer: Context Restored.\");\n      _isContextLost = false;\n      const infoAutoReset = info.autoReset;\n      const shadowMapEnabled = shadowMap.enabled;\n      const shadowMapAutoUpdate = shadowMap.autoUpdate;\n      const shadowMapNeedsUpdate = shadowMap.needsUpdate;\n      const shadowMapType = shadowMap.type;\n      initGLContext();\n      info.autoReset = infoAutoReset;\n      shadowMap.enabled = shadowMapEnabled;\n      shadowMap.autoUpdate = shadowMapAutoUpdate;\n      shadowMap.needsUpdate = shadowMapNeedsUpdate;\n      shadowMap.type = shadowMapType;\n    }\n    function onContextCreationError(event) {\n      console.error(\"THREE.WebGLRenderer: A WebGL context could not be created. Reason: \", event.statusMessage);\n    }\n    function onMaterialDispose(event) {\n      const material = event.target;\n      material.removeEventListener(\"dispose\", onMaterialDispose);\n      deallocateMaterial(material);\n    }\n    function deallocateMaterial(material) {\n      releaseMaterialProgramReferences(material);\n      properties.remove(material);\n    }\n    function releaseMaterialProgramReferences(material) {\n      const programs = properties.get(material).programs;\n      if (programs !== void 0) {\n        programs.forEach(function(program) {\n          programCache.releaseProgram(program);\n        });\n        if (material.isShaderMaterial) {\n          programCache.releaseShaderCache(material);\n        }\n      }\n    }\n    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {\n      if (scene === null) scene = _emptyScene;\n      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n      const program = setProgram(camera, scene, geometry, material, object);\n      state.setMaterial(material, frontFaceCW);\n      let index = geometry.index;\n      let rangeFactor = 1;\n      if (material.wireframe === true) {\n        index = geometries.getWireframeAttribute(geometry);\n        if (index === void 0) return;\n        rangeFactor = 2;\n      }\n      const drawRange = geometry.drawRange;\n      const position = geometry.attributes.position;\n      let drawStart = drawRange.start * rangeFactor;\n      let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;\n      if (group !== null) {\n        drawStart = Math.max(drawStart, group.start * rangeFactor);\n        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);\n      }\n      if (index !== null) {\n        drawStart = Math.max(drawStart, 0);\n        drawEnd = Math.min(drawEnd, index.count);\n      } else if (position !== void 0 && position !== null) {\n        drawStart = Math.max(drawStart, 0);\n        drawEnd = Math.min(drawEnd, position.count);\n      }\n      const drawCount = drawEnd - drawStart;\n      if (drawCount < 0 || drawCount === Infinity) return;\n      bindingStates.setup(object, material, program, geometry, index);\n      let attribute;\n      let renderer = bufferRenderer;\n      if (index !== null) {\n        attribute = attributes.get(index);\n        renderer = indexedBufferRenderer;\n        renderer.setIndex(attribute);\n      }\n      if (object.isMesh) {\n        if (material.wireframe === true) {\n          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());\n          renderer.setMode(_gl.LINES);\n        } else {\n          renderer.setMode(_gl.TRIANGLES);\n        }\n      } else if (object.isLine) {\n        let lineWidth = material.linewidth;\n        if (lineWidth === void 0) lineWidth = 1;\n        state.setLineWidth(lineWidth * getTargetPixelRatio());\n        if (object.isLineSegments) {\n          renderer.setMode(_gl.LINES);\n        } else if (object.isLineLoop) {\n          renderer.setMode(_gl.LINE_LOOP);\n        } else {\n          renderer.setMode(_gl.LINE_STRIP);\n        }\n      } else if (object.isPoints) {\n        renderer.setMode(_gl.POINTS);\n      } else if (object.isSprite) {\n        renderer.setMode(_gl.TRIANGLES);\n      }\n      if (object.isBatchedMesh) {\n        if (object._multiDrawInstances !== null) {\n          renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);\n        } else {\n          if (!extensions.get(\"WEBGL_multi_draw\")) {\n            const starts = object._multiDrawStarts;\n            const counts = object._multiDrawCounts;\n            const drawCount2 = object._multiDrawCount;\n            const bytesPerElement = index ? attributes.get(index).bytesPerElement : 1;\n            const uniforms2 = properties.get(material).currentProgram.getUniforms();\n            for (let i = 0; i < drawCount2; i++) {\n              uniforms2.setValue(_gl, \"_gl_DrawID\", i);\n              renderer.render(starts[i] / bytesPerElement, counts[i]);\n            }\n          } else {\n            renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);\n          }\n        }\n      } else if (object.isInstancedMesh) {\n        renderer.renderInstances(drawStart, drawCount, object.count);\n      } else if (geometry.isInstancedBufferGeometry) {\n        const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;\n        const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);\n        renderer.renderInstances(drawStart, drawCount, instanceCount);\n      } else {\n        renderer.render(drawStart, drawCount);\n      }\n    };\n    function prepareMaterial(material, scene, object) {\n      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {\n        material.side = BackSide;\n        material.needsUpdate = true;\n        getProgram(material, scene, object);\n        material.side = FrontSide;\n        material.needsUpdate = true;\n        getProgram(material, scene, object);\n        material.side = DoubleSide;\n      } else {\n        getProgram(material, scene, object);\n      }\n    }\n    this.compile = function(scene, camera, targetScene = null) {\n      if (targetScene === null) targetScene = scene;\n      currentRenderState = renderStates.get(targetScene);\n      currentRenderState.init(camera);\n      renderStateStack.push(currentRenderState);\n      targetScene.traverseVisible(function(object) {\n        if (object.isLight && object.layers.test(camera.layers)) {\n          currentRenderState.pushLight(object);\n          if (object.castShadow) {\n            currentRenderState.pushShadow(object);\n          }\n        }\n      });\n      if (scene !== targetScene) {\n        scene.traverseVisible(function(object) {\n          if (object.isLight && object.layers.test(camera.layers)) {\n            currentRenderState.pushLight(object);\n            if (object.castShadow) {\n              currentRenderState.pushShadow(object);\n            }\n          }\n        });\n      }\n      currentRenderState.setupLights();\n      const materials2 = /* @__PURE__ */ new Set();\n      scene.traverse(function(object) {\n        if (!(object.isMesh || object.isPoints || object.isLine || object.isSprite)) {\n          return;\n        }\n        const material = object.material;\n        if (material) {\n          if (Array.isArray(material)) {\n            for (let i = 0; i < material.length; i++) {\n              const material2 = material[i];\n              prepareMaterial(material2, targetScene, object);\n              materials2.add(material2);\n            }\n          } else {\n            prepareMaterial(material, targetScene, object);\n            materials2.add(material);\n          }\n        }\n      });\n      renderStateStack.pop();\n      currentRenderState = null;\n      return materials2;\n    };\n    this.compileAsync = function(scene, camera, targetScene = null) {\n      const materials2 = this.compile(scene, camera, targetScene);\n      return new Promise((resolve) => {\n        function checkMaterialsReady() {\n          materials2.forEach(function(material) {\n            const materialProperties = properties.get(material);\n            const program = materialProperties.currentProgram;\n            if (program.isReady()) {\n              materials2.delete(material);\n            }\n          });\n          if (materials2.size === 0) {\n            resolve(scene);\n            return;\n          }\n          setTimeout(checkMaterialsReady, 10);\n        }\n        if (extensions.get(\"KHR_parallel_shader_compile\") !== null) {\n          checkMaterialsReady();\n        } else {\n          setTimeout(checkMaterialsReady, 10);\n        }\n      });\n    };\n    let onAnimationFrameCallback = null;\n    function onAnimationFrame(time) {\n      if (onAnimationFrameCallback) onAnimationFrameCallback(time);\n    }\n    function onXRSessionStart() {\n      animation.stop();\n    }\n    function onXRSessionEnd() {\n      animation.start();\n    }\n    const animation = new WebGLAnimation();\n    animation.setAnimationLoop(onAnimationFrame);\n    if (typeof self !== \"undefined\") animation.setContext(self);\n    this.setAnimationLoop = function(callback) {\n      onAnimationFrameCallback = callback;\n      xr.setAnimationLoop(callback);\n      callback === null ? animation.stop() : animation.start();\n    };\n    xr.addEventListener(\"sessionstart\", onXRSessionStart);\n    xr.addEventListener(\"sessionend\", onXRSessionEnd);\n    this.render = function(scene, camera) {\n      if (camera !== void 0 && camera.isCamera !== true) {\n        console.error(\"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.\");\n        return;\n      }\n      if (_isContextLost === true) return;\n      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();\n      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();\n      if (xr.enabled === true && xr.isPresenting === true) {\n        if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);\n        camera = xr.getCamera();\n      }\n      if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);\n      currentRenderState = renderStates.get(scene, renderStateStack.length);\n      currentRenderState.init(camera);\n      renderStateStack.push(currentRenderState);\n      _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n      _frustum.setFromProjectionMatrix(_projScreenMatrix2);\n      _localClippingEnabled = this.localClippingEnabled;\n      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);\n      currentRenderList = renderLists.get(scene, renderListStack.length);\n      currentRenderList.init();\n      renderListStack.push(currentRenderList);\n      if (xr.enabled === true && xr.isPresenting === true) {\n        const depthSensingMesh = _this.xr.getDepthSensingMesh();\n        if (depthSensingMesh !== null) {\n          projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects);\n        }\n      }\n      projectObject(scene, camera, 0, _this.sortObjects);\n      currentRenderList.finish();\n      if (_this.sortObjects === true) {\n        currentRenderList.sort(_opaqueSort, _transparentSort);\n      }\n      _renderBackground = xr.enabled === false || xr.isPresenting === false || xr.hasDepthSensing() === false;\n      if (_renderBackground) {\n        background.addToRenderList(currentRenderList, scene);\n      }\n      this.info.render.frame++;\n      if (_clippingEnabled === true) clipping.beginShadows();\n      const shadowsArray = currentRenderState.state.shadowsArray;\n      shadowMap.render(shadowsArray, scene, camera);\n      if (_clippingEnabled === true) clipping.endShadows();\n      if (this.info.autoReset === true) this.info.reset();\n      const opaqueObjects = currentRenderList.opaque;\n      const transmissiveObjects = currentRenderList.transmissive;\n      currentRenderState.setupLights();\n      if (camera.isArrayCamera) {\n        const cameras = camera.cameras;\n        if (transmissiveObjects.length > 0) {\n          for (let i = 0, l = cameras.length; i < l; i++) {\n            const camera2 = cameras[i];\n            renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);\n          }\n        }\n        if (_renderBackground) background.render(scene);\n        for (let i = 0, l = cameras.length; i < l; i++) {\n          const camera2 = cameras[i];\n          renderScene(currentRenderList, scene, camera2, camera2.viewport);\n        }\n      } else {\n        if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);\n        if (_renderBackground) background.render(scene);\n        renderScene(currentRenderList, scene, camera);\n      }\n      if (_currentRenderTarget !== null) {\n        textures.updateMultisampleRenderTarget(_currentRenderTarget);\n        textures.updateRenderTargetMipmap(_currentRenderTarget);\n      }\n      if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);\n      bindingStates.resetDefaultState();\n      _currentMaterialId = -1;\n      _currentCamera = null;\n      renderStateStack.pop();\n      if (renderStateStack.length > 0) {\n        currentRenderState = renderStateStack[renderStateStack.length - 1];\n        if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera);\n      } else {\n        currentRenderState = null;\n      }\n      renderListStack.pop();\n      if (renderListStack.length > 0) {\n        currentRenderList = renderListStack[renderListStack.length - 1];\n      } else {\n        currentRenderList = null;\n      }\n    };\n    function projectObject(object, camera, groupOrder, sortObjects) {\n      if (object.visible === false) return;\n      const visible = object.layers.test(camera.layers);\n      if (visible) {\n        if (object.isGroup) {\n          groupOrder = object.renderOrder;\n        } else if (object.isLOD) {\n          if (object.autoUpdate === true) object.update(camera);\n        } else if (object.isLight) {\n          currentRenderState.pushLight(object);\n          if (object.castShadow) {\n            currentRenderState.pushShadow(object);\n          }\n        } else if (object.isSprite) {\n          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n            if (sortObjects) {\n              _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);\n            }\n            const geometry = objects.update(object);\n            const material = object.material;\n            if (material.visible) {\n              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);\n            }\n          }\n        } else if (object.isMesh || object.isLine || object.isPoints) {\n          if (!object.frustumCulled || _frustum.intersectsObject(object)) {\n            const geometry = objects.update(object);\n            const material = object.material;\n            if (sortObjects) {\n              if (object.boundingSphere !== void 0) {\n                if (object.boundingSphere === null) object.computeBoundingSphere();\n                _vector4.copy(object.boundingSphere.center);\n              } else {\n                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n                _vector4.copy(geometry.boundingSphere.center);\n              }\n              _vector4.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);\n            }\n            if (Array.isArray(material)) {\n              const groups = geometry.groups;\n              for (let i = 0, l = groups.length; i < l; i++) {\n                const group = groups[i];\n                const groupMaterial = material[group.materialIndex];\n                if (groupMaterial && groupMaterial.visible) {\n                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group);\n                }\n              }\n            } else if (material.visible) {\n              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);\n            }\n          }\n        }\n      }\n      const children = object.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        projectObject(children[i], camera, groupOrder, sortObjects);\n      }\n    }\n    function renderScene(currentRenderList2, scene, camera, viewport) {\n      const opaqueObjects = currentRenderList2.opaque;\n      const transmissiveObjects = currentRenderList2.transmissive;\n      const transparentObjects = currentRenderList2.transparent;\n      currentRenderState.setupLightsView(camera);\n      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);\n      if (viewport) state.viewport(_currentViewport.copy(viewport));\n      if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);\n      if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);\n      if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);\n      state.buffers.depth.setTest(true);\n      state.buffers.depth.setMask(true);\n      state.buffers.color.setMask(true);\n      state.setPolygonOffset(false);\n    }\n    function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {\n      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n      if (overrideMaterial !== null) {\n        return;\n      }\n      if (currentRenderState.state.transmissionRenderTarget[camera.id] === void 0) {\n        currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {\n          generateMipmaps: true,\n          type: extensions.has(\"EXT_color_buffer_half_float\") || extensions.has(\"EXT_color_buffer_float\") ? HalfFloatType : UnsignedByteType,\n          minFilter: LinearMipmapLinearFilter,\n          samples: 4,\n          stencilBuffer: stencil,\n          resolveDepthBuffer: false,\n          resolveStencilBuffer: false,\n          colorSpace: ColorManagement.workingColorSpace\n        });\n      }\n      const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];\n      const activeViewport = camera.viewport || _currentViewport;\n      transmissionRenderTarget.setSize(activeViewport.z, activeViewport.w);\n      const currentRenderTarget = _this.getRenderTarget();\n      _this.setRenderTarget(transmissionRenderTarget);\n      _this.getClearColor(_currentClearColor);\n      _currentClearAlpha = _this.getClearAlpha();\n      if (_currentClearAlpha < 1) _this.setClearColor(16777215, 0.5);\n      _this.clear();\n      if (_renderBackground) background.render(scene);\n      const currentToneMapping = _this.toneMapping;\n      _this.toneMapping = NoToneMapping;\n      const currentCameraViewport = camera.viewport;\n      if (camera.viewport !== void 0) camera.viewport = void 0;\n      currentRenderState.setupLightsView(camera);\n      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);\n      renderObjects(opaqueObjects, scene, camera);\n      textures.updateMultisampleRenderTarget(transmissionRenderTarget);\n      textures.updateRenderTargetMipmap(transmissionRenderTarget);\n      if (extensions.has(\"WEBGL_multisampled_render_to_texture\") === false) {\n        let renderTargetNeedsUpdate = false;\n        for (let i = 0, l = transmissiveObjects.length; i < l; i++) {\n          const renderItem = transmissiveObjects[i];\n          const object = renderItem.object;\n          const geometry = renderItem.geometry;\n          const material = renderItem.material;\n          const group = renderItem.group;\n          if (material.side === DoubleSide && object.layers.test(camera.layers)) {\n            const currentSide = material.side;\n            material.side = BackSide;\n            material.needsUpdate = true;\n            renderObject(object, scene, camera, geometry, material, group);\n            material.side = currentSide;\n            material.needsUpdate = true;\n            renderTargetNeedsUpdate = true;\n          }\n        }\n        if (renderTargetNeedsUpdate === true) {\n          textures.updateMultisampleRenderTarget(transmissionRenderTarget);\n          textures.updateRenderTargetMipmap(transmissionRenderTarget);\n        }\n      }\n      _this.setRenderTarget(currentRenderTarget);\n      _this.setClearColor(_currentClearColor, _currentClearAlpha);\n      if (currentCameraViewport !== void 0) camera.viewport = currentCameraViewport;\n      _this.toneMapping = currentToneMapping;\n    }\n    function renderObjects(renderList2, scene, camera) {\n      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n      for (let i = 0, l = renderList2.length; i < l; i++) {\n        const renderItem = renderList2[i];\n        const object = renderItem.object;\n        const geometry = renderItem.geometry;\n        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n        const group = renderItem.group;\n        if (object.layers.test(camera.layers)) {\n          renderObject(object, scene, camera, geometry, material, group);\n        }\n      }\n    }\n    function renderObject(object, scene, camera, geometry, material, group) {\n      object.onBeforeRender(_this, scene, camera, geometry, material, group);\n      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n      material.onBeforeRender(_this, scene, camera, geometry, object, group);\n      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {\n        material.side = BackSide;\n        material.needsUpdate = true;\n        _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n        material.side = FrontSide;\n        material.needsUpdate = true;\n        _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n        material.side = DoubleSide;\n      } else {\n        _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n      }\n      object.onAfterRender(_this, scene, camera, geometry, material, group);\n    }\n    function getProgram(material, scene, object) {\n      if (scene.isScene !== true) scene = _emptyScene;\n      const materialProperties = properties.get(material);\n      const lights = currentRenderState.state.lights;\n      const shadowsArray = currentRenderState.state.shadowsArray;\n      const lightsStateVersion = lights.state.version;\n      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);\n      const programCacheKey = programCache.getProgramCacheKey(parameters2);\n      let programs = materialProperties.programs;\n      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n      materialProperties.fog = scene.fog;\n      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);\n      materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;\n      if (programs === void 0) {\n        material.addEventListener(\"dispose\", onMaterialDispose);\n        programs = /* @__PURE__ */ new Map();\n        materialProperties.programs = programs;\n      }\n      let program = programs.get(programCacheKey);\n      if (program !== void 0) {\n        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {\n          updateCommonMaterialProperties(material, parameters2);\n          return program;\n        }\n      } else {\n        parameters2.uniforms = programCache.getUniforms(material);\n        material.onBeforeCompile(parameters2, _this);\n        program = programCache.acquireProgram(parameters2, programCacheKey);\n        programs.set(programCacheKey, program);\n        materialProperties.uniforms = parameters2.uniforms;\n      }\n      const uniforms2 = materialProperties.uniforms;\n      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {\n        uniforms2.clippingPlanes = clipping.uniform;\n      }\n      updateCommonMaterialProperties(material, parameters2);\n      materialProperties.needsLights = materialNeedsLights(material);\n      materialProperties.lightsStateVersion = lightsStateVersion;\n      if (materialProperties.needsLights) {\n        uniforms2.ambientLightColor.value = lights.state.ambient;\n        uniforms2.lightProbe.value = lights.state.probe;\n        uniforms2.directionalLights.value = lights.state.directional;\n        uniforms2.directionalLightShadows.value = lights.state.directionalShadow;\n        uniforms2.spotLights.value = lights.state.spot;\n        uniforms2.spotLightShadows.value = lights.state.spotShadow;\n        uniforms2.rectAreaLights.value = lights.state.rectArea;\n        uniforms2.ltc_1.value = lights.state.rectAreaLTC1;\n        uniforms2.ltc_2.value = lights.state.rectAreaLTC2;\n        uniforms2.pointLights.value = lights.state.point;\n        uniforms2.pointLightShadows.value = lights.state.pointShadow;\n        uniforms2.hemisphereLights.value = lights.state.hemi;\n        uniforms2.directionalShadowMap.value = lights.state.directionalShadowMap;\n        uniforms2.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n        uniforms2.spotShadowMap.value = lights.state.spotShadowMap;\n        uniforms2.spotLightMatrix.value = lights.state.spotLightMatrix;\n        uniforms2.spotLightMap.value = lights.state.spotLightMap;\n        uniforms2.pointShadowMap.value = lights.state.pointShadowMap;\n        uniforms2.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n      }\n      materialProperties.currentProgram = program;\n      materialProperties.uniformsList = null;\n      return program;\n    }\n    function getUniformList(materialProperties) {\n      if (materialProperties.uniformsList === null) {\n        const progUniforms = materialProperties.currentProgram.getUniforms();\n        materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);\n      }\n      return materialProperties.uniformsList;\n    }\n    function updateCommonMaterialProperties(material, parameters2) {\n      const materialProperties = properties.get(material);\n      materialProperties.outputColorSpace = parameters2.outputColorSpace;\n      materialProperties.batching = parameters2.batching;\n      materialProperties.batchingColor = parameters2.batchingColor;\n      materialProperties.instancing = parameters2.instancing;\n      materialProperties.instancingColor = parameters2.instancingColor;\n      materialProperties.instancingMorph = parameters2.instancingMorph;\n      materialProperties.skinning = parameters2.skinning;\n      materialProperties.morphTargets = parameters2.morphTargets;\n      materialProperties.morphNormals = parameters2.morphNormals;\n      materialProperties.morphColors = parameters2.morphColors;\n      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;\n      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;\n      materialProperties.numIntersection = parameters2.numClipIntersection;\n      materialProperties.vertexAlphas = parameters2.vertexAlphas;\n      materialProperties.vertexTangents = parameters2.vertexTangents;\n      materialProperties.toneMapping = parameters2.toneMapping;\n    }\n    function setProgram(camera, scene, geometry, material, object) {\n      if (scene.isScene !== true) scene = _emptyScene;\n      textures.resetTextureUnits();\n      const fog = scene.fog;\n      const environment = material.isMeshStandardMaterial ? scene.environment : null;\n      const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;\n      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);\n      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;\n      const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);\n      const morphTargets = !!geometry.morphAttributes.position;\n      const morphNormals = !!geometry.morphAttributes.normal;\n      const morphColors = !!geometry.morphAttributes.color;\n      let toneMapping = NoToneMapping;\n      if (material.toneMapped) {\n        if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {\n          toneMapping = _this.toneMapping;\n        }\n      }\n      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;\n      const materialProperties = properties.get(material);\n      const lights = currentRenderState.state.lights;\n      if (_clippingEnabled === true) {\n        if (_localClippingEnabled === true || camera !== _currentCamera) {\n          const useCache = camera === _currentCamera && material.id === _currentMaterialId;\n          clipping.setState(material, camera, useCache);\n        }\n      }\n      let needsProgramChange = false;\n      if (material.version === materialProperties.__version) {\n        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {\n          needsProgramChange = true;\n        } else if (materialProperties.outputColorSpace !== colorSpace) {\n          needsProgramChange = true;\n        } else if (object.isBatchedMesh && materialProperties.batching === false) {\n          needsProgramChange = true;\n        } else if (!object.isBatchedMesh && materialProperties.batching === true) {\n          needsProgramChange = true;\n        } else if (object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null) {\n          needsProgramChange = true;\n        } else if (object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null) {\n          needsProgramChange = true;\n        } else if (object.isInstancedMesh && materialProperties.instancing === false) {\n          needsProgramChange = true;\n        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {\n          needsProgramChange = true;\n        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {\n          needsProgramChange = true;\n        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {\n          needsProgramChange = true;\n        } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {\n          needsProgramChange = true;\n        } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {\n          needsProgramChange = true;\n        } else if (object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null) {\n          needsProgramChange = true;\n        } else if (object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null) {\n          needsProgramChange = true;\n        } else if (materialProperties.envMap !== envMap) {\n          needsProgramChange = true;\n        } else if (material.fog === true && materialProperties.fog !== fog) {\n          needsProgramChange = true;\n        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {\n          needsProgramChange = true;\n        } else if (materialProperties.vertexAlphas !== vertexAlphas) {\n          needsProgramChange = true;\n        } else if (materialProperties.vertexTangents !== vertexTangents) {\n          needsProgramChange = true;\n        } else if (materialProperties.morphTargets !== morphTargets) {\n          needsProgramChange = true;\n        } else if (materialProperties.morphNormals !== morphNormals) {\n          needsProgramChange = true;\n        } else if (materialProperties.morphColors !== morphColors) {\n          needsProgramChange = true;\n        } else if (materialProperties.toneMapping !== toneMapping) {\n          needsProgramChange = true;\n        } else if (materialProperties.morphTargetsCount !== morphTargetsCount) {\n          needsProgramChange = true;\n        }\n      } else {\n        needsProgramChange = true;\n        materialProperties.__version = material.version;\n      }\n      let program = materialProperties.currentProgram;\n      if (needsProgramChange === true) {\n        program = getProgram(material, scene, object);\n      }\n      let refreshProgram = false;\n      let refreshMaterial = false;\n      let refreshLights = false;\n      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;\n      if (state.useProgram(program.program)) {\n        refreshProgram = true;\n        refreshMaterial = true;\n        refreshLights = true;\n      }\n      if (material.id !== _currentMaterialId) {\n        _currentMaterialId = material.id;\n        refreshMaterial = true;\n      }\n      if (refreshProgram || _currentCamera !== camera) {\n        const reverseDepthBuffer2 = state.buffers.depth.getReversed();\n        if (reverseDepthBuffer2) {\n          _currentProjectionMatrix.copy(camera.projectionMatrix);\n          toNormalizedProjectionMatrix(_currentProjectionMatrix);\n          toReversedProjectionMatrix(_currentProjectionMatrix);\n          p_uniforms.setValue(_gl, \"projectionMatrix\", _currentProjectionMatrix);\n        } else {\n          p_uniforms.setValue(_gl, \"projectionMatrix\", camera.projectionMatrix);\n        }\n        p_uniforms.setValue(_gl, \"viewMatrix\", camera.matrixWorldInverse);\n        const uCamPos = p_uniforms.map.cameraPosition;\n        if (uCamPos !== void 0) {\n          uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera.matrixWorld));\n        }\n        if (capabilities.logarithmicDepthBuffer) {\n          p_uniforms.setValue(\n            _gl,\n            \"logDepthBufFC\",\n            2 / (Math.log(camera.far + 1) / Math.LN2)\n          );\n        }\n        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {\n          p_uniforms.setValue(_gl, \"isOrthographic\", camera.isOrthographicCamera === true);\n        }\n        if (_currentCamera !== camera) {\n          _currentCamera = camera;\n          refreshMaterial = true;\n          refreshLights = true;\n        }\n      }\n      if (object.isSkinnedMesh) {\n        p_uniforms.setOptional(_gl, object, \"bindMatrix\");\n        p_uniforms.setOptional(_gl, object, \"bindMatrixInverse\");\n        const skeleton = object.skeleton;\n        if (skeleton) {\n          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();\n          p_uniforms.setValue(_gl, \"boneTexture\", skeleton.boneTexture, textures);\n        }\n      }\n      if (object.isBatchedMesh) {\n        p_uniforms.setOptional(_gl, object, \"batchingTexture\");\n        p_uniforms.setValue(_gl, \"batchingTexture\", object._matricesTexture, textures);\n        p_uniforms.setOptional(_gl, object, \"batchingIdTexture\");\n        p_uniforms.setValue(_gl, \"batchingIdTexture\", object._indirectTexture, textures);\n        p_uniforms.setOptional(_gl, object, \"batchingColorTexture\");\n        if (object._colorsTexture !== null) {\n          p_uniforms.setValue(_gl, \"batchingColorTexture\", object._colorsTexture, textures);\n        }\n      }\n      const morphAttributes = geometry.morphAttributes;\n      if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0) {\n        morphtargets.update(object, geometry, program);\n      }\n      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {\n        materialProperties.receiveShadow = object.receiveShadow;\n        p_uniforms.setValue(_gl, \"receiveShadow\", object.receiveShadow);\n      }\n      if (material.isMeshGouraudMaterial && material.envMap !== null) {\n        m_uniforms.envMap.value = envMap;\n        m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;\n      }\n      if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) {\n        m_uniforms.envMapIntensity.value = scene.environmentIntensity;\n      }\n      if (refreshMaterial) {\n        p_uniforms.setValue(_gl, \"toneMappingExposure\", _this.toneMappingExposure);\n        if (materialProperties.needsLights) {\n          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);\n        }\n        if (fog && material.fog === true) {\n          materials.refreshFogUniforms(m_uniforms, fog);\n        }\n        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);\n        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);\n      }\n      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {\n        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);\n        material.uniformsNeedUpdate = false;\n      }\n      if (material.isSpriteMaterial) {\n        p_uniforms.setValue(_gl, \"center\", object.center);\n      }\n      p_uniforms.setValue(_gl, \"modelViewMatrix\", object.modelViewMatrix);\n      p_uniforms.setValue(_gl, \"normalMatrix\", object.normalMatrix);\n      p_uniforms.setValue(_gl, \"modelMatrix\", object.matrixWorld);\n      if (material.isShaderMaterial || material.isRawShaderMaterial) {\n        const groups = material.uniformsGroups;\n        for (let i = 0, l = groups.length; i < l; i++) {\n          const group = groups[i];\n          uniformsGroups.update(group, program);\n          uniformsGroups.bind(group, program);\n        }\n      }\n      return program;\n    }\n    function markUniformsLightsNeedsUpdate(uniforms2, value) {\n      uniforms2.ambientLightColor.needsUpdate = value;\n      uniforms2.lightProbe.needsUpdate = value;\n      uniforms2.directionalLights.needsUpdate = value;\n      uniforms2.directionalLightShadows.needsUpdate = value;\n      uniforms2.pointLights.needsUpdate = value;\n      uniforms2.pointLightShadows.needsUpdate = value;\n      uniforms2.spotLights.needsUpdate = value;\n      uniforms2.spotLightShadows.needsUpdate = value;\n      uniforms2.rectAreaLights.needsUpdate = value;\n      uniforms2.hemisphereLights.needsUpdate = value;\n    }\n    function materialNeedsLights(material) {\n      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;\n    }\n    this.getActiveCubeFace = function() {\n      return _currentActiveCubeFace;\n    };\n    this.getActiveMipmapLevel = function() {\n      return _currentActiveMipmapLevel;\n    };\n    this.getRenderTarget = function() {\n      return _currentRenderTarget;\n    };\n    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {\n      properties.get(renderTarget.texture).__webglTexture = colorTexture;\n      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;\n      const renderTargetProperties = properties.get(renderTarget);\n      renderTargetProperties.__hasExternalTextures = true;\n      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;\n      if (!renderTargetProperties.__autoAllocateDepthBuffer) {\n        if (extensions.has(\"WEBGL_multisampled_render_to_texture\") === true) {\n          console.warn(\"THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided\");\n          renderTargetProperties.__useRenderToTexture = false;\n        }\n      }\n    };\n    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {\n      const renderTargetProperties = properties.get(renderTarget);\n      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;\n      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;\n    };\n    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {\n      _currentRenderTarget = renderTarget;\n      _currentActiveCubeFace = activeCubeFace;\n      _currentActiveMipmapLevel = activeMipmapLevel;\n      let useDefaultFramebuffer = true;\n      let framebuffer = null;\n      let isCube = false;\n      let isRenderTarget3D = false;\n      if (renderTarget) {\n        const renderTargetProperties = properties.get(renderTarget);\n        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {\n          state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n          useDefaultFramebuffer = false;\n        } else if (renderTargetProperties.__webglFramebuffer === void 0) {\n          textures.setupRenderTarget(renderTarget);\n        } else if (renderTargetProperties.__hasExternalTextures) {\n          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);\n        } else if (renderTarget.depthBuffer) {\n          const depthTexture = renderTarget.depthTexture;\n          if (renderTargetProperties.__boundDepthTexture !== depthTexture) {\n            if (depthTexture !== null && properties.has(depthTexture) && (renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height)) {\n              throw new Error(\"WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.\");\n            }\n            textures.setupDepthRenderbuffer(renderTarget);\n          }\n        }\n        const texture = renderTarget.texture;\n        if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {\n          isRenderTarget3D = true;\n        }\n        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;\n        if (renderTarget.isWebGLCubeRenderTarget) {\n          if (Array.isArray(__webglFramebuffer[activeCubeFace])) {\n            framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];\n          } else {\n            framebuffer = __webglFramebuffer[activeCubeFace];\n          }\n          isCube = true;\n        } else if (renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {\n          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;\n        } else {\n          if (Array.isArray(__webglFramebuffer)) {\n            framebuffer = __webglFramebuffer[activeMipmapLevel];\n          } else {\n            framebuffer = __webglFramebuffer;\n          }\n        }\n        _currentViewport.copy(renderTarget.viewport);\n        _currentScissor.copy(renderTarget.scissor);\n        _currentScissorTest = renderTarget.scissorTest;\n      } else {\n        _currentViewport.copy(_viewport2).multiplyScalar(_pixelRatio).floor();\n        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();\n        _currentScissorTest = _scissorTest;\n      }\n      const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n      if (framebufferBound && useDefaultFramebuffer) {\n        state.drawBuffers(renderTarget, framebuffer);\n      }\n      state.viewport(_currentViewport);\n      state.scissor(_currentScissor);\n      state.setScissorTest(_currentScissorTest);\n      if (isCube) {\n        const textureProperties = properties.get(renderTarget.texture);\n        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);\n      } else if (isRenderTarget3D) {\n        const textureProperties = properties.get(renderTarget.texture);\n        const layer = activeCubeFace || 0;\n        _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);\n      }\n      _currentMaterialId = -1;\n    };\n    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {\n      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\n        console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.\");\n        return;\n      }\n      let framebuffer = properties.get(renderTarget).__webglFramebuffer;\n      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {\n        framebuffer = framebuffer[activeCubeFaceIndex];\n      }\n      if (framebuffer) {\n        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n        try {\n          const texture = renderTarget.texture;\n          const textureFormat = texture.format;\n          const textureType = texture.type;\n          if (!capabilities.textureFormatReadable(textureFormat)) {\n            console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.\");\n            return;\n          }\n          if (!capabilities.textureTypeReadable(textureType)) {\n            console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.\");\n            return;\n          }\n          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {\n            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);\n          }\n        } finally {\n          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;\n          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);\n        }\n      }\n    };\n    this.readRenderTargetPixelsAsync = async function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {\n      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\n        throw new Error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.\");\n      }\n      let framebuffer = properties.get(renderTarget).__webglFramebuffer;\n      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {\n        framebuffer = framebuffer[activeCubeFaceIndex];\n      }\n      if (framebuffer) {\n        const texture = renderTarget.texture;\n        const textureFormat = texture.format;\n        const textureType = texture.type;\n        if (!capabilities.textureFormatReadable(textureFormat)) {\n          throw new Error(\"THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.\");\n        }\n        if (!capabilities.textureTypeReadable(textureType)) {\n          throw new Error(\"THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.\");\n        }\n        if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {\n          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n          const glBuffer = _gl.createBuffer();\n          _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);\n          _gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ);\n          _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);\n          const currFramebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;\n          state.bindFramebuffer(_gl.FRAMEBUFFER, currFramebuffer);\n          const sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n          _gl.flush();\n          await probeAsync(_gl, sync, 4);\n          _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);\n          _gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer);\n          _gl.deleteBuffer(glBuffer);\n          _gl.deleteSync(sync);\n          return buffer;\n        } else {\n          throw new Error(\"THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.\");\n        }\n      }\n    };\n    this.copyFramebufferToTexture = function(texture, position = null, level = 0) {\n      if (texture.isTexture !== true) {\n        warnOnce(\"WebGLRenderer: copyFramebufferToTexture function signature has changed.\");\n        position = arguments[0] || null;\n        texture = arguments[1];\n      }\n      const levelScale = Math.pow(2, -level);\n      const width = Math.floor(texture.image.width * levelScale);\n      const height = Math.floor(texture.image.height * levelScale);\n      const x = position !== null ? position.x : 0;\n      const y = position !== null ? position.y : 0;\n      textures.setTexture2D(texture, 0);\n      _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x, y, width, height);\n      state.unbindTexture();\n    };\n    this.copyTextureToTexture = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {\n      if (srcTexture.isTexture !== true) {\n        warnOnce(\"WebGLRenderer: copyTextureToTexture function signature has changed.\");\n        dstPosition = arguments[0] || null;\n        srcTexture = arguments[1];\n        dstTexture = arguments[2];\n        level = arguments[3] || 0;\n        srcRegion = null;\n      }\n      let width, height, depth2, minX, minY, minZ;\n      let dstX, dstY, dstZ;\n      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;\n      if (srcRegion !== null) {\n        width = srcRegion.max.x - srcRegion.min.x;\n        height = srcRegion.max.y - srcRegion.min.y;\n        depth2 = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;\n        minX = srcRegion.min.x;\n        minY = srcRegion.min.y;\n        minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;\n      } else {\n        width = image.width;\n        height = image.height;\n        depth2 = image.depth || 1;\n        minX = 0;\n        minY = 0;\n        minZ = 0;\n      }\n      if (dstPosition !== null) {\n        dstX = dstPosition.x;\n        dstY = dstPosition.y;\n        dstZ = dstPosition.z;\n      } else {\n        dstX = 0;\n        dstY = 0;\n        dstZ = 0;\n      }\n      const glFormat = utils.convert(dstTexture.format);\n      const glType = utils.convert(dstTexture.type);\n      let glTarget;\n      if (dstTexture.isData3DTexture) {\n        textures.setTexture3D(dstTexture, 0);\n        glTarget = _gl.TEXTURE_3D;\n      } else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {\n        textures.setTexture2DArray(dstTexture, 0);\n        glTarget = _gl.TEXTURE_2D_ARRAY;\n      } else {\n        textures.setTexture2D(dstTexture, 0);\n        glTarget = _gl.TEXTURE_2D;\n      }\n      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);\n      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);\n      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);\n      const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);\n      const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);\n      const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);\n      const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);\n      const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);\n      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);\n      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);\n      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);\n      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);\n      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);\n      const isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;\n      const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;\n      if (srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture) {\n        const srcTextureProperties = properties.get(srcTexture);\n        const dstTextureProperties = properties.get(dstTexture);\n        const srcRenderTargetProperties = properties.get(srcTextureProperties.__renderTarget);\n        const dstRenderTargetProperties = properties.get(dstTextureProperties.__renderTarget);\n        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, srcRenderTargetProperties.__webglFramebuffer);\n        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, dstRenderTargetProperties.__webglFramebuffer);\n        for (let i = 0; i < depth2; i++) {\n          if (isSrc3D) {\n            _gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(srcTexture).__webglTexture, level, minZ + i);\n          }\n          if (srcTexture.isDepthTexture) {\n            if (isDst3D) {\n              _gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(dstTexture).__webglTexture, level, dstZ + i);\n            }\n            _gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST);\n          } else if (isDst3D) {\n            _gl.copyTexSubImage3D(glTarget, level, dstX, dstY, dstZ + i, minX, minY, width, height);\n          } else {\n            _gl.copyTexSubImage2D(glTarget, level, dstX, dstY, dstZ + i, minX, minY, width, height);\n          }\n        }\n        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);\n        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);\n      } else {\n        if (isDst3D) {\n          if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {\n            _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image.data);\n          } else if (dstTexture.isCompressedArrayTexture) {\n            _gl.compressedTexSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, image.data);\n          } else {\n            _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image);\n          }\n        } else {\n          if (srcTexture.isDataTexture) {\n            _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data);\n          } else if (srcTexture.isCompressedTexture) {\n            _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data);\n          } else {\n            _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image);\n          }\n        }\n      }\n      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);\n      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);\n      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);\n      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);\n      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);\n      if (level === 0 && dstTexture.generateMipmaps) {\n        _gl.generateMipmap(glTarget);\n      }\n      state.unbindTexture();\n    };\n    this.copyTextureToTexture3D = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {\n      if (srcTexture.isTexture !== true) {\n        warnOnce(\"WebGLRenderer: copyTextureToTexture3D function signature has changed.\");\n        srcRegion = arguments[0] || null;\n        dstPosition = arguments[1] || null;\n        srcTexture = arguments[2];\n        dstTexture = arguments[3];\n        level = arguments[4] || 0;\n      }\n      warnOnce('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use \"copyTextureToTexture\" instead.');\n      return this.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);\n    };\n    this.initRenderTarget = function(target) {\n      if (properties.get(target).__webglFramebuffer === void 0) {\n        textures.setupRenderTarget(target);\n      }\n    };\n    this.initTexture = function(texture) {\n      if (texture.isCubeTexture) {\n        textures.setTextureCube(texture, 0);\n      } else if (texture.isData3DTexture) {\n        textures.setTexture3D(texture, 0);\n      } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {\n        textures.setTexture2DArray(texture, 0);\n      } else {\n        textures.setTexture2D(texture, 0);\n      }\n      state.unbindTexture();\n    };\n    this.resetState = function() {\n      _currentActiveCubeFace = 0;\n      _currentActiveMipmapLevel = 0;\n      _currentRenderTarget = null;\n      state.reset();\n      bindingStates.reset();\n    };\n    if (typeof __THREE_DEVTOOLS__ !== \"undefined\") {\n      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"observe\", { detail: this }));\n    }\n  }\n  get coordinateSystem() {\n    return WebGLCoordinateSystem;\n  }\n  get outputColorSpace() {\n    return this._outputColorSpace;\n  }\n  set outputColorSpace(colorSpace) {\n    this._outputColorSpace = colorSpace;\n    const gl = this.getContext();\n    gl.drawingBufferColorspace = ColorManagement._getDrawingBufferColorSpace(colorSpace);\n    gl.unpackColorSpace = ColorManagement._getUnpackColorSpace();\n  }\n}\nclass Scene extends Object3D {\n  constructor() {\n    super();\n    this.isScene = true;\n    this.type = \"Scene\";\n    this.background = null;\n    this.environment = null;\n    this.fog = null;\n    this.backgroundBlurriness = 0;\n    this.backgroundIntensity = 1;\n    this.backgroundRotation = new Euler();\n    this.environmentIntensity = 1;\n    this.environmentRotation = new Euler();\n    this.overrideMaterial = null;\n    if (typeof __THREE_DEVTOOLS__ !== \"undefined\") {\n      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"observe\", { detail: this }));\n    }\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    if (source.background !== null) this.background = source.background.clone();\n    if (source.environment !== null) this.environment = source.environment.clone();\n    if (source.fog !== null) this.fog = source.fog.clone();\n    this.backgroundBlurriness = source.backgroundBlurriness;\n    this.backgroundIntensity = source.backgroundIntensity;\n    this.backgroundRotation.copy(source.backgroundRotation);\n    this.environmentIntensity = source.environmentIntensity;\n    this.environmentRotation.copy(source.environmentRotation);\n    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    if (this.fog !== null) data.object.fog = this.fog.toJSON();\n    if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;\n    if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;\n    data.object.backgroundRotation = this.backgroundRotation.toArray();\n    if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;\n    data.object.environmentRotation = this.environmentRotation.toArray();\n    return data;\n  }\n}\nclass InterleavedBuffer {\n  constructor(array, stride) {\n    this.isInterleavedBuffer = true;\n    this.array = array;\n    this.stride = stride;\n    this.count = array !== void 0 ? array.length / stride : 0;\n    this.usage = StaticDrawUsage;\n    this.updateRanges = [];\n    this.version = 0;\n    this.uuid = generateUUID();\n  }\n  onUploadCallback() {\n  }\n  set needsUpdate(value) {\n    if (value === true) this.version++;\n  }\n  setUsage(value) {\n    this.usage = value;\n    return this;\n  }\n  addUpdateRange(start, count) {\n    this.updateRanges.push({ start, count });\n  }\n  clearUpdateRanges() {\n    this.updateRanges.length = 0;\n  }\n  copy(source) {\n    this.array = new source.array.constructor(source.array);\n    this.count = source.count;\n    this.stride = source.stride;\n    this.usage = source.usage;\n    return this;\n  }\n  copyAt(index1, attribute, index2) {\n    index1 *= this.stride;\n    index2 *= attribute.stride;\n    for (let i = 0, l = this.stride; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n    return this;\n  }\n  set(value, offset = 0) {\n    this.array.set(value, offset);\n    return this;\n  }\n  clone(data) {\n    if (data.arrayBuffers === void 0) {\n      data.arrayBuffers = {};\n    }\n    if (this.array.buffer._uuid === void 0) {\n      this.array.buffer._uuid = generateUUID();\n    }\n    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {\n      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;\n    }\n    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);\n    const ib = new this.constructor(array, this.stride);\n    ib.setUsage(this.usage);\n    return ib;\n  }\n  onUpload(callback) {\n    this.onUploadCallback = callback;\n    return this;\n  }\n  toJSON(data) {\n    if (data.arrayBuffers === void 0) {\n      data.arrayBuffers = {};\n    }\n    if (this.array.buffer._uuid === void 0) {\n      this.array.buffer._uuid = generateUUID();\n    }\n    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {\n      data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));\n    }\n    return {\n      uuid: this.uuid,\n      buffer: this.array.buffer._uuid,\n      type: this.array.constructor.name,\n      stride: this.stride\n    };\n  }\n}\nconst _vector$6 = /* @__PURE__ */ new Vector3();\nclass InterleavedBufferAttribute {\n  constructor(interleavedBuffer, itemSize, offset, normalized = false) {\n    this.isInterleavedBufferAttribute = true;\n    this.name = \"\";\n    this.data = interleavedBuffer;\n    this.itemSize = itemSize;\n    this.offset = offset;\n    this.normalized = normalized;\n  }\n  get count() {\n    return this.data.count;\n  }\n  get array() {\n    return this.data.array;\n  }\n  set needsUpdate(value) {\n    this.data.needsUpdate = value;\n  }\n  applyMatrix4(m) {\n    for (let i = 0, l = this.data.count; i < l; i++) {\n      _vector$6.fromBufferAttribute(this, i);\n      _vector$6.applyMatrix4(m);\n      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n    }\n    return this;\n  }\n  applyNormalMatrix(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$6.fromBufferAttribute(this, i);\n      _vector$6.applyNormalMatrix(m);\n      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n    }\n    return this;\n  }\n  transformDirection(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$6.fromBufferAttribute(this, i);\n      _vector$6.transformDirection(m);\n      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n    }\n    return this;\n  }\n  getComponent(index, component) {\n    let value = this.array[index * this.data.stride + this.offset + component];\n    if (this.normalized) value = denormalize(value, this.array);\n    return value;\n  }\n  setComponent(index, component, value) {\n    if (this.normalized) value = normalize(value, this.array);\n    this.data.array[index * this.data.stride + this.offset + component] = value;\n    return this;\n  }\n  setX(index, x) {\n    if (this.normalized) x = normalize(x, this.array);\n    this.data.array[index * this.data.stride + this.offset] = x;\n    return this;\n  }\n  setY(index, y) {\n    if (this.normalized) y = normalize(y, this.array);\n    this.data.array[index * this.data.stride + this.offset + 1] = y;\n    return this;\n  }\n  setZ(index, z) {\n    if (this.normalized) z = normalize(z, this.array);\n    this.data.array[index * this.data.stride + this.offset + 2] = z;\n    return this;\n  }\n  setW(index, w) {\n    if (this.normalized) w = normalize(w, this.array);\n    this.data.array[index * this.data.stride + this.offset + 3] = w;\n    return this;\n  }\n  getX(index) {\n    let x = this.data.array[index * this.data.stride + this.offset];\n    if (this.normalized) x = denormalize(x, this.array);\n    return x;\n  }\n  getY(index) {\n    let y = this.data.array[index * this.data.stride + this.offset + 1];\n    if (this.normalized) y = denormalize(y, this.array);\n    return y;\n  }\n  getZ(index) {\n    let z = this.data.array[index * this.data.stride + this.offset + 2];\n    if (this.normalized) z = denormalize(z, this.array);\n    return z;\n  }\n  getW(index) {\n    let w = this.data.array[index * this.data.stride + this.offset + 3];\n    if (this.normalized) w = denormalize(w, this.array);\n    return w;\n  }\n  setXY(index, x, y) {\n    index = index * this.data.stride + this.offset;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n    }\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    return this;\n  }\n  setXYZ(index, x, y, z) {\n    index = index * this.data.stride + this.offset;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n      z = normalize(z, this.array);\n    }\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    return this;\n  }\n  setXYZW(index, x, y, z, w) {\n    index = index * this.data.stride + this.offset;\n    if (this.normalized) {\n      x = normalize(x, this.array);\n      y = normalize(y, this.array);\n      z = normalize(z, this.array);\n      w = normalize(w, this.array);\n    }\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    this.data.array[index + 3] = w;\n    return this;\n  }\n  clone(data) {\n    if (data === void 0) {\n      console.log(\"THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.\");\n      const array = [];\n      for (let i = 0; i < this.count; i++) {\n        const index = i * this.data.stride + this.offset;\n        for (let j = 0; j < this.itemSize; j++) {\n          array.push(this.data.array[index + j]);\n        }\n      }\n      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);\n    } else {\n      if (data.interleavedBuffers === void 0) {\n        data.interleavedBuffers = {};\n      }\n      if (data.interleavedBuffers[this.data.uuid] === void 0) {\n        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);\n      }\n      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);\n    }\n  }\n  toJSON(data) {\n    if (data === void 0) {\n      console.log(\"THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.\");\n      const array = [];\n      for (let i = 0; i < this.count; i++) {\n        const index = i * this.data.stride + this.offset;\n        for (let j = 0; j < this.itemSize; j++) {\n          array.push(this.data.array[index + j]);\n        }\n      }\n      return {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array,\n        normalized: this.normalized\n      };\n    } else {\n      if (data.interleavedBuffers === void 0) {\n        data.interleavedBuffers = {};\n      }\n      if (data.interleavedBuffers[this.data.uuid] === void 0) {\n        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);\n      }\n      return {\n        isInterleavedBufferAttribute: true,\n        itemSize: this.itemSize,\n        data: this.data.uuid,\n        offset: this.offset,\n        normalized: this.normalized\n      };\n    }\n  }\n}\nclass SpriteMaterial extends Material {\n  static get type() {\n    return \"SpriteMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    this.isSpriteMaterial = true;\n    this.color = new Color(16777215);\n    this.map = null;\n    this.alphaMap = null;\n    this.rotation = 0;\n    this.sizeAttenuation = true;\n    this.transparent = true;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.rotation = source.rotation;\n    this.sizeAttenuation = source.sizeAttenuation;\n    this.fog = source.fog;\n    return this;\n  }\n}\nlet _geometry;\nconst _intersectPoint = /* @__PURE__ */ new Vector3();\nconst _worldScale = /* @__PURE__ */ new Vector3();\nconst _mvPosition = /* @__PURE__ */ new Vector3();\nconst _alignedPosition = /* @__PURE__ */ new Vector2();\nconst _rotatedPosition = /* @__PURE__ */ new Vector2();\nconst _viewWorldMatrix = /* @__PURE__ */ new Matrix4();\nconst _vA$2 = /* @__PURE__ */ new Vector3();\nconst _vB$2 = /* @__PURE__ */ new Vector3();\nconst _vC$2 = /* @__PURE__ */ new Vector3();\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\nclass Sprite extends Object3D {\n  constructor(material = new SpriteMaterial()) {\n    super();\n    this.isSprite = true;\n    this.type = \"Sprite\";\n    if (_geometry === void 0) {\n      _geometry = new BufferGeometry();\n      const float32Array = new Float32Array([\n        -0.5,\n        -0.5,\n        0,\n        0,\n        0,\n        0.5,\n        -0.5,\n        0,\n        1,\n        0,\n        0.5,\n        0.5,\n        0,\n        1,\n        1,\n        -0.5,\n        0.5,\n        0,\n        0,\n        1\n      ]);\n      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n      _geometry.setIndex([0, 1, 2, 0, 2, 3]);\n      _geometry.setAttribute(\"position\", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n      _geometry.setAttribute(\"uv\", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n    }\n    this.geometry = _geometry;\n    this.material = material;\n    this.center = new Vector2(0.5, 0.5);\n  }\n  raycast(raycaster, intersects2) {\n    if (raycaster.camera === null) {\n      console.error('THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.');\n    }\n    _worldScale.setFromMatrixScale(this.matrixWorld);\n    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);\n    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);\n    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);\n    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {\n      _worldScale.multiplyScalar(-_mvPosition.z);\n    }\n    const rotation = this.material.rotation;\n    let sin, cos;\n    if (rotation !== 0) {\n      cos = Math.cos(rotation);\n      sin = Math.sin(rotation);\n    }\n    const center = this.center;\n    transformVertex(_vA$2.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    transformVertex(_vB$2.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    transformVertex(_vC$2.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    _uvA.set(0, 0);\n    _uvB.set(1, 0);\n    _uvC.set(1, 1);\n    let intersect2 = raycaster.ray.intersectTriangle(_vA$2, _vB$2, _vC$2, false, _intersectPoint);\n    if (intersect2 === null) {\n      transformVertex(_vB$2.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n      _uvB.set(0, 1);\n      intersect2 = raycaster.ray.intersectTriangle(_vA$2, _vC$2, _vB$2, false, _intersectPoint);\n      if (intersect2 === null) {\n        return;\n      }\n    }\n    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far) return;\n    intersects2.push({\n      distance,\n      point: _intersectPoint.clone(),\n      uv: Triangle.getInterpolation(_intersectPoint, _vA$2, _vB$2, _vC$2, _uvA, _uvB, _uvC, new Vector2()),\n      face: null,\n      object: this\n    });\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    if (source.center !== void 0) this.center.copy(source.center);\n    this.material = source.material;\n    return this;\n  }\n}\nfunction transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {\n  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);\n  if (sin !== void 0) {\n    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;\n    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;\n  } else {\n    _rotatedPosition.copy(_alignedPosition);\n  }\n  vertexPosition.copy(mvPosition);\n  vertexPosition.x += _rotatedPosition.x;\n  vertexPosition.y += _rotatedPosition.y;\n  vertexPosition.applyMatrix4(_viewWorldMatrix);\n}\nconst _basePosition = /* @__PURE__ */ new Vector3();\nconst _skinIndex = /* @__PURE__ */ new Vector4();\nconst _skinWeight = /* @__PURE__ */ new Vector4();\nconst _vector3 = /* @__PURE__ */ new Vector3();\nconst _matrix4 = /* @__PURE__ */ new Matrix4();\nconst _vertex = /* @__PURE__ */ new Vector3();\nconst _sphere$4 = /* @__PURE__ */ new Sphere();\nconst _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();\nconst _ray$2 = /* @__PURE__ */ new Ray();\nclass SkinnedMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isSkinnedMesh = true;\n    this.type = \"SkinnedMesh\";\n    this.bindMode = AttachedBindMode;\n    this.bindMatrix = new Matrix4();\n    this.bindMatrixInverse = new Matrix4();\n    this.boundingBox = null;\n    this.boundingSphere = null;\n  }\n  computeBoundingBox() {\n    const geometry = this.geometry;\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    this.boundingBox.makeEmpty();\n    const positionAttribute = geometry.getAttribute(\"position\");\n    for (let i = 0; i < positionAttribute.count; i++) {\n      this.getVertexPosition(i, _vertex);\n      this.boundingBox.expandByPoint(_vertex);\n    }\n  }\n  computeBoundingSphere() {\n    const geometry = this.geometry;\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    this.boundingSphere.makeEmpty();\n    const positionAttribute = geometry.getAttribute(\"position\");\n    for (let i = 0; i < positionAttribute.count; i++) {\n      this.getVertexPosition(i, _vertex);\n      this.boundingSphere.expandByPoint(_vertex);\n    }\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.bindMode = source.bindMode;\n    this.bindMatrix.copy(source.bindMatrix);\n    this.bindMatrixInverse.copy(source.bindMatrixInverse);\n    this.skeleton = source.skeleton;\n    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();\n    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();\n    return this;\n  }\n  raycast(raycaster, intersects2) {\n    const material = this.material;\n    const matrixWorld = this.matrixWorld;\n    if (material === void 0) return;\n    if (this.boundingSphere === null) this.computeBoundingSphere();\n    _sphere$4.copy(this.boundingSphere);\n    _sphere$4.applyMatrix4(matrixWorld);\n    if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;\n    _inverseMatrix$2.copy(matrixWorld).invert();\n    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);\n    if (this.boundingBox !== null) {\n      if (_ray$2.intersectsBox(this.boundingBox) === false) return;\n    }\n    this._computeIntersections(raycaster, intersects2, _ray$2);\n  }\n  getVertexPosition(index, target) {\n    super.getVertexPosition(index, target);\n    this.applyBoneTransform(index, target);\n    return target;\n  }\n  bind(skeleton, bindMatrix) {\n    this.skeleton = skeleton;\n    if (bindMatrix === void 0) {\n      this.updateMatrixWorld(true);\n      this.skeleton.calculateInverses();\n      bindMatrix = this.matrixWorld;\n    }\n    this.bindMatrix.copy(bindMatrix);\n    this.bindMatrixInverse.copy(bindMatrix).invert();\n  }\n  pose() {\n    this.skeleton.pose();\n  }\n  normalizeSkinWeights() {\n    const vector = new Vector4();\n    const skinWeight = this.geometry.attributes.skinWeight;\n    for (let i = 0, l = skinWeight.count; i < l; i++) {\n      vector.fromBufferAttribute(skinWeight, i);\n      const scale = 1 / vector.manhattanLength();\n      if (scale !== Infinity) {\n        vector.multiplyScalar(scale);\n      } else {\n        vector.set(1, 0, 0, 0);\n      }\n      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);\n    }\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.bindMode === AttachedBindMode) {\n      this.bindMatrixInverse.copy(this.matrixWorld).invert();\n    } else if (this.bindMode === DetachedBindMode) {\n      this.bindMatrixInverse.copy(this.bindMatrix).invert();\n    } else {\n      console.warn(\"THREE.SkinnedMesh: Unrecognized bindMode: \" + this.bindMode);\n    }\n  }\n  applyBoneTransform(index, vector) {\n    const skeleton = this.skeleton;\n    const geometry = this.geometry;\n    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n    _basePosition.copy(vector).applyMatrix4(this.bindMatrix);\n    vector.set(0, 0, 0);\n    for (let i = 0; i < 4; i++) {\n      const weight = _skinWeight.getComponent(i);\n      if (weight !== 0) {\n        const boneIndex = _skinIndex.getComponent(i);\n        _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);\n        vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);\n      }\n    }\n    return vector.applyMatrix4(this.bindMatrixInverse);\n  }\n}\nclass Bone extends Object3D {\n  constructor() {\n    super();\n    this.isBone = true;\n    this.type = \"Bone\";\n  }\n}\nclass DataTexture extends Texture {\n  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {\n    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);\n    this.isDataTexture = true;\n    this.image = { data, width, height };\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n  }\n}\nconst _offsetMatrix = /* @__PURE__ */ new Matrix4();\nconst _identityMatrix$1 = /* @__PURE__ */ new Matrix4();\nclass Skeleton {\n  constructor(bones = [], boneInverses = []) {\n    this.uuid = generateUUID();\n    this.bones = bones.slice(0);\n    this.boneInverses = boneInverses;\n    this.boneMatrices = null;\n    this.boneTexture = null;\n    this.init();\n  }\n  init() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    this.boneMatrices = new Float32Array(bones.length * 16);\n    if (boneInverses.length === 0) {\n      this.calculateInverses();\n    } else {\n      if (bones.length !== boneInverses.length) {\n        console.warn(\"THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.\");\n        this.boneInverses = [];\n        for (let i = 0, il = this.bones.length; i < il; i++) {\n          this.boneInverses.push(new Matrix4());\n        }\n      }\n    }\n  }\n  calculateInverses() {\n    this.boneInverses.length = 0;\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const inverse = new Matrix4();\n      if (this.bones[i]) {\n        inverse.copy(this.bones[i].matrixWorld).invert();\n      }\n      this.boneInverses.push(inverse);\n    }\n  }\n  pose() {\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n      if (bone) {\n        bone.matrixWorld.copy(this.boneInverses[i]).invert();\n      }\n    }\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n      if (bone) {\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(bone.matrixWorld);\n        } else {\n          bone.matrix.copy(bone.matrixWorld);\n        }\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n      }\n    }\n  }\n  update() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    const boneMatrices = this.boneMatrices;\n    const boneTexture = this.boneTexture;\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix$1;\n      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\n      _offsetMatrix.toArray(boneMatrices, i * 16);\n    }\n    if (boneTexture !== null) {\n      boneTexture.needsUpdate = true;\n    }\n  }\n  clone() {\n    return new Skeleton(this.bones, this.boneInverses);\n  }\n  computeBoneTexture() {\n    let size = Math.sqrt(this.bones.length * 4);\n    size = Math.ceil(size / 4) * 4;\n    size = Math.max(size, 4);\n    const boneMatrices = new Float32Array(size * size * 4);\n    boneMatrices.set(this.boneMatrices);\n    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n    boneTexture.needsUpdate = true;\n    this.boneMatrices = boneMatrices;\n    this.boneTexture = boneTexture;\n    return this;\n  }\n  getBoneByName(name) {\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n      if (bone.name === name) {\n        return bone;\n      }\n    }\n    return void 0;\n  }\n  dispose() {\n    if (this.boneTexture !== null) {\n      this.boneTexture.dispose();\n      this.boneTexture = null;\n    }\n  }\n  fromJSON(json, bones) {\n    this.uuid = json.uuid;\n    for (let i = 0, l = json.bones.length; i < l; i++) {\n      const uuid = json.bones[i];\n      let bone = bones[uuid];\n      if (bone === void 0) {\n        console.warn(\"THREE.Skeleton: No bone found with UUID:\", uuid);\n        bone = new Bone();\n      }\n      this.bones.push(bone);\n      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));\n    }\n    this.init();\n    return this;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.6,\n        type: \"Skeleton\",\n        generator: \"Skeleton.toJSON\"\n      },\n      bones: [],\n      boneInverses: []\n    };\n    data.uuid = this.uuid;\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    for (let i = 0, l = bones.length; i < l; i++) {\n      const bone = bones[i];\n      data.bones.push(bone.uuid);\n      const boneInverse = boneInverses[i];\n      data.boneInverses.push(boneInverse.toArray());\n    }\n    return data;\n  }\n}\nclass InstancedBufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized, meshPerAttribute = 1) {\n    super(array, itemSize, normalized);\n    this.isInstancedBufferAttribute = true;\n    this.meshPerAttribute = meshPerAttribute;\n  }\n  copy(source) {\n    super.copy(source);\n    this.meshPerAttribute = source.meshPerAttribute;\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.meshPerAttribute = this.meshPerAttribute;\n    data.isInstancedBufferAttribute = true;\n    return data;\n  }\n}\nconst _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();\nconst _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();\nconst _instanceIntersects = [];\nconst _box3 = /* @__PURE__ */ new Box3();\nconst _identity = /* @__PURE__ */ new Matrix4();\nconst _mesh$1 = /* @__PURE__ */ new Mesh();\nconst _sphere$3 = /* @__PURE__ */ new Sphere();\nclass InstancedMesh extends Mesh {\n  constructor(geometry, material, count) {\n    super(geometry, material);\n    this.isInstancedMesh = true;\n    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);\n    this.instanceColor = null;\n    this.morphTexture = null;\n    this.count = count;\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    for (let i = 0; i < count; i++) {\n      this.setMatrixAt(i, _identity);\n    }\n  }\n  computeBoundingBox() {\n    const geometry = this.geometry;\n    const count = this.count;\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    this.boundingBox.makeEmpty();\n    for (let i = 0; i < count; i++) {\n      this.getMatrixAt(i, _instanceLocalMatrix);\n      _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);\n      this.boundingBox.union(_box3);\n    }\n  }\n  computeBoundingSphere() {\n    const geometry = this.geometry;\n    const count = this.count;\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    this.boundingSphere.makeEmpty();\n    for (let i = 0; i < count; i++) {\n      this.getMatrixAt(i, _instanceLocalMatrix);\n      _sphere$3.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);\n      this.boundingSphere.union(_sphere$3);\n    }\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.instanceMatrix.copy(source.instanceMatrix);\n    if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();\n    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();\n    this.count = source.count;\n    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();\n    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();\n    return this;\n  }\n  getColorAt(index, color) {\n    color.fromArray(this.instanceColor.array, index * 3);\n  }\n  getMatrixAt(index, matrix) {\n    matrix.fromArray(this.instanceMatrix.array, index * 16);\n  }\n  getMorphAt(index, object) {\n    const objectInfluences = object.morphTargetInfluences;\n    const array = this.morphTexture.source.data.data;\n    const len = objectInfluences.length + 1;\n    const dataIndex = index * len + 1;\n    for (let i = 0; i < objectInfluences.length; i++) {\n      objectInfluences[i] = array[dataIndex + i];\n    }\n  }\n  raycast(raycaster, intersects2) {\n    const matrixWorld = this.matrixWorld;\n    const raycastTimes = this.count;\n    _mesh$1.geometry = this.geometry;\n    _mesh$1.material = this.material;\n    if (_mesh$1.material === void 0) return;\n    if (this.boundingSphere === null) this.computeBoundingSphere();\n    _sphere$3.copy(this.boundingSphere);\n    _sphere$3.applyMatrix4(matrixWorld);\n    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;\n    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {\n      this.getMatrixAt(instanceId, _instanceLocalMatrix);\n      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);\n      _mesh$1.matrixWorld = _instanceWorldMatrix;\n      _mesh$1.raycast(raycaster, _instanceIntersects);\n      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n        const intersect2 = _instanceIntersects[i];\n        intersect2.instanceId = instanceId;\n        intersect2.object = this;\n        intersects2.push(intersect2);\n      }\n      _instanceIntersects.length = 0;\n    }\n  }\n  setColorAt(index, color) {\n    if (this.instanceColor === null) {\n      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3);\n    }\n    color.toArray(this.instanceColor.array, index * 3);\n  }\n  setMatrixAt(index, matrix) {\n    matrix.toArray(this.instanceMatrix.array, index * 16);\n  }\n  setMorphAt(index, object) {\n    const objectInfluences = object.morphTargetInfluences;\n    const len = objectInfluences.length + 1;\n    if (this.morphTexture === null) {\n      this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType);\n    }\n    const array = this.morphTexture.source.data.data;\n    let morphInfluencesSum = 0;\n    for (let i = 0; i < objectInfluences.length; i++) {\n      morphInfluencesSum += objectInfluences[i];\n    }\n    const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n    const dataIndex = len * index;\n    array[dataIndex] = morphBaseInfluence;\n    array.set(objectInfluences, dataIndex + 1);\n  }\n  updateMorphTargets() {\n  }\n  dispose() {\n    this.dispatchEvent({ type: \"dispose\" });\n    if (this.morphTexture !== null) {\n      this.morphTexture.dispose();\n      this.morphTexture = null;\n    }\n    return this;\n  }\n}\nclass LineBasicMaterial extends Material {\n  static get type() {\n    return \"LineBasicMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    this.isLineBasicMaterial = true;\n    this.color = new Color(16777215);\n    this.map = null;\n    this.linewidth = 1;\n    this.linecap = \"round\";\n    this.linejoin = \"round\";\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.linewidth = source.linewidth;\n    this.linecap = source.linecap;\n    this.linejoin = source.linejoin;\n    this.fog = source.fog;\n    return this;\n  }\n}\nconst _vStart = /* @__PURE__ */ new Vector3();\nconst _vEnd = /* @__PURE__ */ new Vector3();\nconst _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();\nconst _ray$1$1 = /* @__PURE__ */ new Ray();\nconst _sphere$1 = /* @__PURE__ */ new Sphere();\nconst _intersectPointOnRay = /* @__PURE__ */ new Vector3();\nconst _intersectPointOnSegment = /* @__PURE__ */ new Vector3();\nclass Line extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {\n    super();\n    this.isLine = true;\n    this.type = \"Line\";\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n  computeLineDistances() {\n    const geometry = this.geometry;\n    if (geometry.index === null) {\n      const positionAttribute = geometry.attributes.position;\n      const lineDistances = [0];\n      for (let i = 1, l = positionAttribute.count; i < l; i++) {\n        _vStart.fromBufferAttribute(positionAttribute, i - 1);\n        _vEnd.fromBufferAttribute(positionAttribute, i);\n        lineDistances[i] = lineDistances[i - 1];\n        lineDistances[i] += _vStart.distanceTo(_vEnd);\n      }\n      geometry.setAttribute(\"lineDistance\", new Float32BufferAttribute(lineDistances, 1));\n    } else {\n      console.warn(\"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.\");\n    }\n    return this;\n  }\n  raycast(raycaster, intersects2) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Line.threshold;\n    const drawRange = geometry.drawRange;\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n    _sphere$1.copy(geometry.boundingSphere);\n    _sphere$1.applyMatrix4(matrixWorld);\n    _sphere$1.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;\n    _inverseMatrix$1.copy(matrixWorld).invert();\n    _ray$1$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n    const step = this.isLineSegments ? 2 : 1;\n    const index = geometry.index;\n    const attributes = geometry.attributes;\n    const positionAttribute = attributes.position;\n    if (index !== null) {\n      const start = Math.max(0, drawRange.start);\n      const end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (let i = start, l = end - 1; i < l; i += step) {\n        const a = index.getX(i);\n        const b = index.getX(i + 1);\n        const intersect2 = checkIntersection(this, raycaster, _ray$1$1, localThresholdSq, a, b);\n        if (intersect2) {\n          intersects2.push(intersect2);\n        }\n      }\n      if (this.isLineLoop) {\n        const a = index.getX(end - 1);\n        const b = index.getX(start);\n        const intersect2 = checkIntersection(this, raycaster, _ray$1$1, localThresholdSq, a, b);\n        if (intersect2) {\n          intersects2.push(intersect2);\n        }\n      }\n    } else {\n      const start = Math.max(0, drawRange.start);\n      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (let i = start, l = end - 1; i < l; i += step) {\n        const intersect2 = checkIntersection(this, raycaster, _ray$1$1, localThresholdSq, i, i + 1);\n        if (intersect2) {\n          intersects2.push(intersect2);\n        }\n      }\n      if (this.isLineLoop) {\n        const intersect2 = checkIntersection(this, raycaster, _ray$1$1, localThresholdSq, end - 1, start);\n        if (intersect2) {\n          intersects2.push(intersect2);\n        }\n      }\n    }\n  }\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    const morphAttributes = geometry.morphAttributes;\n    const keys = Object.keys(morphAttributes);\n    if (keys.length > 0) {\n      const morphAttribute = morphAttributes[keys[0]];\n      if (morphAttribute !== void 0) {\n        this.morphTargetInfluences = [];\n        this.morphTargetDictionary = {};\n        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n          const name = morphAttribute[m].name || String(m);\n          this.morphTargetInfluences.push(0);\n          this.morphTargetDictionary[name] = m;\n        }\n      }\n    }\n  }\n}\nfunction checkIntersection(object, raycaster, ray, thresholdSq, a, b) {\n  const positionAttribute = object.geometry.attributes.position;\n  _vStart.fromBufferAttribute(positionAttribute, a);\n  _vEnd.fromBufferAttribute(positionAttribute, b);\n  const distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);\n  if (distSq > thresholdSq) return;\n  _intersectPointOnRay.applyMatrix4(object.matrixWorld);\n  const distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);\n  if (distance < raycaster.near || distance > raycaster.far) return;\n  return {\n    distance,\n    // What do we want? intersection point on the ray or on the segment??\n    // point: raycaster.ray.at( distance ),\n    point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),\n    index: a,\n    face: null,\n    faceIndex: null,\n    barycoord: null,\n    object\n  };\n}\nconst _start$1 = /* @__PURE__ */ new Vector3();\nconst _end$1 = /* @__PURE__ */ new Vector3();\nclass LineSegments extends Line {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isLineSegments = true;\n    this.type = \"LineSegments\";\n  }\n  computeLineDistances() {\n    const geometry = this.geometry;\n    if (geometry.index === null) {\n      const positionAttribute = geometry.attributes.position;\n      const lineDistances = [];\n      for (let i = 0, l = positionAttribute.count; i < l; i += 2) {\n        _start$1.fromBufferAttribute(positionAttribute, i);\n        _end$1.fromBufferAttribute(positionAttribute, i + 1);\n        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];\n        lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);\n      }\n      geometry.setAttribute(\"lineDistance\", new Float32BufferAttribute(lineDistances, 1));\n    } else {\n      console.warn(\"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.\");\n    }\n    return this;\n  }\n}\nclass LineLoop extends Line {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isLineLoop = true;\n    this.type = \"LineLoop\";\n  }\n}\nclass PointsMaterial extends Material {\n  static get type() {\n    return \"PointsMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    this.isPointsMaterial = true;\n    this.color = new Color(16777215);\n    this.map = null;\n    this.alphaMap = null;\n    this.size = 1;\n    this.sizeAttenuation = true;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.size = source.size;\n    this.sizeAttenuation = source.sizeAttenuation;\n    this.fog = source.fog;\n    return this;\n  }\n}\nconst _inverseMatrix = /* @__PURE__ */ new Matrix4();\nconst _ray$4 = /* @__PURE__ */ new Ray();\nconst _sphere$2 = /* @__PURE__ */ new Sphere();\nconst _position$2 = /* @__PURE__ */ new Vector3();\nclass Points extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {\n    super();\n    this.isPoints = true;\n    this.type = \"Points\";\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n  raycast(raycaster, intersects2) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Points.threshold;\n    const drawRange = geometry.drawRange;\n    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n    _sphere$2.copy(geometry.boundingSphere);\n    _sphere$2.applyMatrix4(matrixWorld);\n    _sphere$2.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere$2) === false) return;\n    _inverseMatrix.copy(matrixWorld).invert();\n    _ray$4.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n    const index = geometry.index;\n    const attributes = geometry.attributes;\n    const positionAttribute = attributes.position;\n    if (index !== null) {\n      const start = Math.max(0, drawRange.start);\n      const end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (let i = start, il = end; i < il; i++) {\n        const a = index.getX(i);\n        _position$2.fromBufferAttribute(positionAttribute, a);\n        testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);\n      }\n    } else {\n      const start = Math.max(0, drawRange.start);\n      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (let i = start, l = end; i < l; i++) {\n        _position$2.fromBufferAttribute(positionAttribute, i);\n        testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);\n      }\n    }\n  }\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    const morphAttributes = geometry.morphAttributes;\n    const keys = Object.keys(morphAttributes);\n    if (keys.length > 0) {\n      const morphAttribute = morphAttributes[keys[0]];\n      if (morphAttribute !== void 0) {\n        this.morphTargetInfluences = [];\n        this.morphTargetDictionary = {};\n        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n          const name = morphAttribute[m].name || String(m);\n          this.morphTargetInfluences.push(0);\n          this.morphTargetDictionary[name] = m;\n        }\n      }\n    }\n  }\n}\nfunction testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {\n  const rayPointDistanceSq = _ray$4.distanceSqToPoint(point);\n  if (rayPointDistanceSq < localThresholdSq) {\n    const intersectPoint = new Vector3();\n    _ray$4.closestPointToPoint(point, intersectPoint);\n    intersectPoint.applyMatrix4(matrixWorld);\n    const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far) return;\n    intersects2.push({\n      distance,\n      distanceToRay: Math.sqrt(rayPointDistanceSq),\n      point: intersectPoint,\n      index,\n      face: null,\n      faceIndex: null,\n      barycoord: null,\n      object\n    });\n  }\n}\nclass CompressedTexture extends Texture {\n  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace) {\n    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);\n    this.isCompressedTexture = true;\n    this.image = { width, height };\n    this.mipmaps = mipmaps;\n    this.flipY = false;\n    this.generateMipmaps = false;\n  }\n}\nclass CanvasTexture extends Texture {\n  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.isCanvasTexture = true;\n    this.needsUpdate = true;\n  }\n}\nclass Curve {\n  constructor() {\n    this.type = \"Curve\";\n    this.arcLengthDivisions = 200;\n  }\n  // Virtual base class method to overwrite and implement in subclasses\n  //\t- t [0 .. 1]\n  getPoint() {\n    console.warn(\"THREE.Curve: .getPoint() not implemented.\");\n    return null;\n  }\n  // Get point at relative position in curve according to arc length\n  // - u [0 .. 1]\n  getPointAt(u, optionalTarget) {\n    const t2 = this.getUtoTmapping(u);\n    return this.getPoint(t2, optionalTarget);\n  }\n  // Get sequence of points using getPoint( t )\n  getPoints(divisions = 5) {\n    const points = [];\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPoint(d / divisions));\n    }\n    return points;\n  }\n  // Get sequence of points using getPointAt( u )\n  getSpacedPoints(divisions = 5) {\n    const points = [];\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPointAt(d / divisions));\n    }\n    return points;\n  }\n  // Get total curve arc length\n  getLength() {\n    const lengths = this.getLengths();\n    return lengths[lengths.length - 1];\n  }\n  // Get list of cumulative segment lengths\n  getLengths(divisions = this.arcLengthDivisions) {\n    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n      return this.cacheArcLengths;\n    }\n    this.needsUpdate = false;\n    const cache2 = [];\n    let current, last = this.getPoint(0);\n    let sum = 0;\n    cache2.push(0);\n    for (let p = 1; p <= divisions; p++) {\n      current = this.getPoint(p / divisions);\n      sum += current.distanceTo(last);\n      cache2.push(sum);\n      last = current;\n    }\n    this.cacheArcLengths = cache2;\n    return cache2;\n  }\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.getLengths();\n  }\n  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n  getUtoTmapping(u, distance) {\n    const arcLengths = this.getLengths();\n    let i = 0;\n    const il = arcLengths.length;\n    let targetArcLength;\n    if (distance) {\n      targetArcLength = distance;\n    } else {\n      targetArcLength = u * arcLengths[il - 1];\n    }\n    let low = 0, high = il - 1, comparison;\n    while (low <= high) {\n      i = Math.floor(low + (high - low) / 2);\n      comparison = arcLengths[i] - targetArcLength;\n      if (comparison < 0) {\n        low = i + 1;\n      } else if (comparison > 0) {\n        high = i - 1;\n      } else {\n        high = i;\n        break;\n      }\n    }\n    i = high;\n    if (arcLengths[i] === targetArcLength) {\n      return i / (il - 1);\n    }\n    const lengthBefore = arcLengths[i];\n    const lengthAfter = arcLengths[i + 1];\n    const segmentLength = lengthAfter - lengthBefore;\n    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\n    const t2 = (i + segmentFraction) / (il - 1);\n    return t2;\n  }\n  // Returns a unit vector tangent at t\n  // In case any sub curve does not implement its tangent derivation,\n  // 2 points a small delta apart will be used to find its gradient\n  // which seems to give a reasonable approximation\n  getTangent(t2, optionalTarget) {\n    const delta = 1e-4;\n    let t1 = t2 - delta;\n    let t22 = t2 + delta;\n    if (t1 < 0) t1 = 0;\n    if (t22 > 1) t22 = 1;\n    const pt1 = this.getPoint(t1);\n    const pt2 = this.getPoint(t22);\n    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());\n    tangent.copy(pt2).sub(pt1).normalize();\n    return tangent;\n  }\n  getTangentAt(u, optionalTarget) {\n    const t2 = this.getUtoTmapping(u);\n    return this.getTangent(t2, optionalTarget);\n  }\n  computeFrenetFrames(segments, closed) {\n    const normal = new Vector3();\n    const tangents = [];\n    const normals = [];\n    const binormals = [];\n    const vec = new Vector3();\n    const mat = new Matrix4();\n    for (let i = 0; i <= segments; i++) {\n      const u = i / segments;\n      tangents[i] = this.getTangentAt(u, new Vector3());\n    }\n    normals[0] = new Vector3();\n    binormals[0] = new Vector3();\n    let min = Number.MAX_VALUE;\n    const tx = Math.abs(tangents[0].x);\n    const ty = Math.abs(tangents[0].y);\n    const tz = Math.abs(tangents[0].z);\n    if (tx <= min) {\n      min = tx;\n      normal.set(1, 0, 0);\n    }\n    if (ty <= min) {\n      min = ty;\n      normal.set(0, 1, 0);\n    }\n    if (tz <= min) {\n      normal.set(0, 0, 1);\n    }\n    vec.crossVectors(tangents[0], normal).normalize();\n    normals[0].crossVectors(tangents[0], vec);\n    binormals[0].crossVectors(tangents[0], normals[0]);\n    for (let i = 1; i <= segments; i++) {\n      normals[i] = normals[i - 1].clone();\n      binormals[i] = binormals[i - 1].clone();\n      vec.crossVectors(tangents[i - 1], tangents[i]);\n      if (vec.length() > Number.EPSILON) {\n        vec.normalize();\n        const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1));\n        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n      }\n      binormals[i].crossVectors(tangents[i], normals[i]);\n    }\n    if (closed === true) {\n      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));\n      theta /= segments;\n      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n        theta = -theta;\n      }\n      for (let i = 1; i <= segments; i++) {\n        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n        binormals[i].crossVectors(tangents[i], normals[i]);\n      }\n    }\n    return {\n      tangents,\n      normals,\n      binormals\n    };\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.arcLengthDivisions = source.arcLengthDivisions;\n    return this;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.6,\n        type: \"Curve\",\n        generator: \"Curve.toJSON\"\n      }\n    };\n    data.arcLengthDivisions = this.arcLengthDivisions;\n    data.type = this.type;\n    return data;\n  }\n  fromJSON(json) {\n    this.arcLengthDivisions = json.arcLengthDivisions;\n    return this;\n  }\n}\nclass CylinderGeometry extends BufferGeometry {\n  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super();\n    this.type = \"CylinderGeometry\";\n    this.parameters = {\n      radiusTop,\n      radiusBottom,\n      height,\n      radialSegments,\n      heightSegments,\n      openEnded,\n      thetaStart,\n      thetaLength\n    };\n    const scope = this;\n    radialSegments = Math.floor(radialSegments);\n    heightSegments = Math.floor(heightSegments);\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    let index = 0;\n    const indexArray = [];\n    const halfHeight = height / 2;\n    let groupStart = 0;\n    generateTorso();\n    if (openEnded === false) {\n      if (radiusTop > 0) generateCap(true);\n      if (radiusBottom > 0) generateCap(false);\n    }\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function generateTorso() {\n      const normal = new Vector3();\n      const vertex2 = new Vector3();\n      let groupCount = 0;\n      const slope = (radiusBottom - radiusTop) / height;\n      for (let y = 0; y <= heightSegments; y++) {\n        const indexRow = [];\n        const v = y / heightSegments;\n        const radius = v * (radiusBottom - radiusTop) + radiusTop;\n        for (let x = 0; x <= radialSegments; x++) {\n          const u = x / radialSegments;\n          const theta = u * thetaLength + thetaStart;\n          const sinTheta = Math.sin(theta);\n          const cosTheta = Math.cos(theta);\n          vertex2.x = radius * sinTheta;\n          vertex2.y = -v * height + halfHeight;\n          vertex2.z = radius * cosTheta;\n          vertices.push(vertex2.x, vertex2.y, vertex2.z);\n          normal.set(sinTheta, slope, cosTheta).normalize();\n          normals.push(normal.x, normal.y, normal.z);\n          uvs.push(u, 1 - v);\n          indexRow.push(index++);\n        }\n        indexArray.push(indexRow);\n      }\n      for (let x = 0; x < radialSegments; x++) {\n        for (let y = 0; y < heightSegments; y++) {\n          const a = indexArray[y][x];\n          const b = indexArray[y + 1][x];\n          const c = indexArray[y + 1][x + 1];\n          const d = indexArray[y][x + 1];\n          if (radiusTop > 0 || y !== 0) {\n            indices.push(a, b, d);\n            groupCount += 3;\n          }\n          if (radiusBottom > 0 || y !== heightSegments - 1) {\n            indices.push(b, c, d);\n            groupCount += 3;\n          }\n        }\n      }\n      scope.addGroup(groupStart, groupCount, 0);\n      groupStart += groupCount;\n    }\n    function generateCap(top) {\n      const centerIndexStart = index;\n      const uv = new Vector2();\n      const vertex2 = new Vector3();\n      let groupCount = 0;\n      const radius = top === true ? radiusTop : radiusBottom;\n      const sign2 = top === true ? 1 : -1;\n      for (let x = 1; x <= radialSegments; x++) {\n        vertices.push(0, halfHeight * sign2, 0);\n        normals.push(0, sign2, 0);\n        uvs.push(0.5, 0.5);\n        index++;\n      }\n      const centerIndexEnd = index;\n      for (let x = 0; x <= radialSegments; x++) {\n        const u = x / radialSegments;\n        const theta = u * thetaLength + thetaStart;\n        const cosTheta = Math.cos(theta);\n        const sinTheta = Math.sin(theta);\n        vertex2.x = radius * sinTheta;\n        vertex2.y = halfHeight * sign2;\n        vertex2.z = radius * cosTheta;\n        vertices.push(vertex2.x, vertex2.y, vertex2.z);\n        normals.push(0, sign2, 0);\n        uv.x = cosTheta * 0.5 + 0.5;\n        uv.y = sinTheta * 0.5 * sign2 + 0.5;\n        uvs.push(uv.x, uv.y);\n        index++;\n      }\n      for (let x = 0; x < radialSegments; x++) {\n        const c = centerIndexStart + x;\n        const i = centerIndexEnd + x;\n        if (top === true) {\n          indices.push(i, i + 1, c);\n        } else {\n          indices.push(i + 1, i, c);\n        }\n        groupCount += 3;\n      }\n      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);\n      groupStart += groupCount;\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n  static fromJSON(data) {\n    return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n  }\n}\nconst _v0 = /* @__PURE__ */ new Vector3();\nconst _v1$1 = /* @__PURE__ */ new Vector3();\nconst _normal = /* @__PURE__ */ new Vector3();\nconst _triangle = /* @__PURE__ */ new Triangle();\nclass EdgesGeometry extends BufferGeometry {\n  constructor(geometry = null, thresholdAngle = 1) {\n    super();\n    this.type = \"EdgesGeometry\";\n    this.parameters = {\n      geometry,\n      thresholdAngle\n    };\n    if (geometry !== null) {\n      const precisionPoints = 4;\n      const precision = Math.pow(10, precisionPoints);\n      const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);\n      const indexAttr = geometry.getIndex();\n      const positionAttr = geometry.getAttribute(\"position\");\n      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n      const indexArr = [0, 0, 0];\n      const vertKeys = [\"a\", \"b\", \"c\"];\n      const hashes = new Array(3);\n      const edgeData = {};\n      const vertices = [];\n      for (let i = 0; i < indexCount; i += 3) {\n        if (indexAttr) {\n          indexArr[0] = indexAttr.getX(i);\n          indexArr[1] = indexAttr.getX(i + 1);\n          indexArr[2] = indexAttr.getX(i + 2);\n        } else {\n          indexArr[0] = i;\n          indexArr[1] = i + 1;\n          indexArr[2] = i + 2;\n        }\n        const { a, b, c } = _triangle;\n        a.fromBufferAttribute(positionAttr, indexArr[0]);\n        b.fromBufferAttribute(positionAttr, indexArr[1]);\n        c.fromBufferAttribute(positionAttr, indexArr[2]);\n        _triangle.getNormal(_normal);\n        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;\n        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;\n        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;\n        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {\n          continue;\n        }\n        for (let j = 0; j < 3; j++) {\n          const jNext = (j + 1) % 3;\n          const vecHash0 = hashes[j];\n          const vecHash1 = hashes[jNext];\n          const v0 = _triangle[vertKeys[j]];\n          const v1 = _triangle[vertKeys[jNext]];\n          const hash = `${vecHash0}_${vecHash1}`;\n          const reverseHash = `${vecHash1}_${vecHash0}`;\n          if (reverseHash in edgeData && edgeData[reverseHash]) {\n            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {\n              vertices.push(v0.x, v0.y, v0.z);\n              vertices.push(v1.x, v1.y, v1.z);\n            }\n            edgeData[reverseHash] = null;\n          } else if (!(hash in edgeData)) {\n            edgeData[hash] = {\n              index0: indexArr[j],\n              index1: indexArr[jNext],\n              normal: _normal.clone()\n            };\n          }\n        }\n      }\n      for (const key in edgeData) {\n        if (edgeData[key]) {\n          const { index0, index1 } = edgeData[key];\n          _v0.fromBufferAttribute(positionAttr, index0);\n          _v1$1.fromBufferAttribute(positionAttr, index1);\n          vertices.push(_v0.x, _v0.y, _v0.z);\n          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);\n        }\n      }\n      this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n}\nconst Earcut = {\n  triangulate: function(data, holeIndices, dim = 2) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n    let minX, minY, maxX, maxY, x, y, invSize;\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n    if (data.length > 80 * dim) {\n      minX = maxX = data[0];\n      minY = maxY = data[1];\n      for (let i = dim; i < outerLen; i += dim) {\n        x = data[i];\n        y = data[i + 1];\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n      }\n      invSize = Math.max(maxX - minX, maxY - minY);\n      invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n    return triangles;\n  }\n};\nfunction linkedList(data, start, end, dim, clockwise) {\n  let i, last;\n  if (clockwise === signedArea(data, start, end, dim) > 0) {\n    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n  }\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n  return last;\n}\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n  let p = start, again;\n  do {\n    again = false;\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n  return end;\n}\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return;\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n  let stop = ear, prev, next;\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      triangles.push(prev.i / dim | 0);\n      triangles.push(ear.i / dim | 0);\n      triangles.push(next.i / dim | 0);\n      removeNode(ear);\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n    ear = next;\n    if (ear === stop) {\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n      break;\n    }\n  }\n}\nfunction isEar(ear) {\n  const a = ear.prev, b = ear, c = ear.next;\n  if (area(a, b, c) >= 0) return false;\n  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n  let p = c.next;\n  while (p !== a) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.next;\n  }\n  return true;\n}\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev, b = ear, c = ear.next;\n  if (area(a, b, c) >= 0) return false;\n  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;\n  const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);\n  let p = ear.prevZ, n = ear.nextZ;\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n  while (p && p.z >= minZ) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n  }\n  while (n && n.z <= maxZ) {\n    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n  return true;\n}\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n  do {\n    const a = p.prev, b = p.next.next;\n    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n      triangles.push(a.i / dim | 0);\n      triangles.push(p.i / dim | 0);\n      triangles.push(b.i / dim | 0);\n      removeNode(p);\n      removeNode(p.next);\n      p = start = b;\n    }\n    p = p.next;\n  } while (p !== start);\n  return filterPoints(p);\n}\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  let a = start;\n  do {\n    let b = a.next.next;\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        let c = splitPolygon(a, b);\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n        return;\n      }\n      b = b.next;\n    }\n    a = a.next;\n  } while (a !== start);\n}\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n  const queue = [];\n  let i, len, start, end, list;\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n  queue.sort(compareX);\n  for (i = 0; i < queue.length; i++) {\n    outerNode = eliminateHole(queue[i], outerNode);\n  }\n  return outerNode;\n}\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\nfunction eliminateHole(hole, outerNode) {\n  const bridge = findHoleBridge(hole, outerNode);\n  if (!bridge) {\n    return outerNode;\n  }\n  const bridgeReverse = splitPolygon(bridge, hole);\n  filterPoints(bridgeReverse, bridgeReverse.next);\n  return filterPoints(bridge, bridge.next);\n}\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode, qx = -Infinity, m;\n  const hx = hole.x, hy = hole.y;\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n      if (x <= hx && x > qx) {\n        qx = x;\n        m = p.x < p.next.x ? p : p.next;\n        if (x === hx) return m;\n      }\n    }\n    p = p.next;\n  } while (p !== outerNode);\n  if (!m) return null;\n  const stop = m, mx = m.x, my = m.y;\n  let tanMin = Infinity, tan;\n  p = m;\n  do {\n    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n      tan = Math.abs(hy - p.y) / (hx - p.x);\n      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n    p = p.next;\n  } while (p !== stop);\n  return m;\n}\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n  do {\n    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n  sortLinked(p);\n}\nfunction sortLinked(list) {\n  let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n      qSize = inSize;\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n        if (tail) tail.nextZ = e;\n        else list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n      p = q;\n    }\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n  return list;\n}\nfunction zOrder(x, y, minX, minY, invSize) {\n  x = (x - minX) * invSize | 0;\n  y = (y - minY) * invSize | 0;\n  x = (x | x << 8) & 16711935;\n  x = (x | x << 4) & 252645135;\n  x = (x | x << 2) & 858993459;\n  x = (x | x << 1) & 1431655765;\n  y = (y | y << 8) & 16711935;\n  y = (y | y << 4) & 252645135;\n  y = (y | y << 2) & 858993459;\n  y = (y | y << 1) & 1431655765;\n  return x | y << 1;\n}\nfunction getLeftmost(start) {\n  let p = start, leftmost = start;\n  do {\n    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n  return leftmost;\n}\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\nfunction isValidDiagonal(a, b) {\n  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);\n}\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4) return true;\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true;\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true;\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true;\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true;\n  return false;\n}\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\nfunction intersectsPolygon(a, b) {\n  let p = a;\n  do {\n    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n    p = p.next;\n  } while (p !== a);\n  return false;\n}\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\nfunction middleInside(a, b) {\n  let p = a, inside = false;\n  const px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;\n  do {\n    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)\n      inside = !inside;\n    p = p.next;\n  } while (p !== a);\n  return inside;\n}\nfunction splitPolygon(a, b) {\n  const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;\n  a.next = b;\n  b.prev = a;\n  a2.next = an;\n  an.prev = a2;\n  b2.next = a2;\n  a2.prev = b2;\n  bp.next = b2;\n  b2.prev = bp;\n  return b2;\n}\nfunction insertNode(i, x, y, last) {\n  const p = new Node(i, x, y);\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n  return p;\n}\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\nfunction Node(i, x, y) {\n  this.i = i;\n  this.x = x;\n  this.y = y;\n  this.prev = null;\n  this.next = null;\n  this.z = 0;\n  this.prevZ = null;\n  this.nextZ = null;\n  this.steiner = false;\n}\nfunction signedArea(data, start, end, dim) {\n  let sum = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n    j = i;\n  }\n  return sum;\n}\nclass ShapeUtils {\n  // calculate area of the contour polygon\n  static area(contour) {\n    const n = contour.length;\n    let a = 0;\n    for (let p = n - 1, q = 0; q < n; p = q++) {\n      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n    }\n    return a * 0.5;\n  }\n  static isClockWise(pts) {\n    return ShapeUtils.area(pts) < 0;\n  }\n  static triangulateShape(contour, holes) {\n    const vertices = [];\n    const holeIndices = [];\n    const faces = [];\n    removeDupEndPts(contour);\n    addContour(vertices, contour);\n    let holeIndex = contour.length;\n    holes.forEach(removeDupEndPts);\n    for (let i = 0; i < holes.length; i++) {\n      holeIndices.push(holeIndex);\n      holeIndex += holes[i].length;\n      addContour(vertices, holes[i]);\n    }\n    const triangles = Earcut.triangulate(vertices, holeIndices);\n    for (let i = 0; i < triangles.length; i += 3) {\n      faces.push(triangles.slice(i, i + 3));\n    }\n    return faces;\n  }\n}\nfunction removeDupEndPts(points) {\n  const l = points.length;\n  if (l > 2 && points[l - 1].equals(points[0])) {\n    points.pop();\n  }\n}\nfunction addContour(vertices, contour) {\n  for (let i = 0; i < contour.length; i++) {\n    vertices.push(contour[i].x);\n    vertices.push(contour[i].y);\n  }\n}\nclass WireframeGeometry extends BufferGeometry {\n  constructor(geometry = null) {\n    super();\n    this.type = \"WireframeGeometry\";\n    this.parameters = {\n      geometry\n    };\n    if (geometry !== null) {\n      const vertices = [];\n      const edges = /* @__PURE__ */ new Set();\n      const start = new Vector3();\n      const end = new Vector3();\n      if (geometry.index !== null) {\n        const position = geometry.attributes.position;\n        const indices = geometry.index;\n        let groups = geometry.groups;\n        if (groups.length === 0) {\n          groups = [{ start: 0, count: indices.count, materialIndex: 0 }];\n        }\n        for (let o = 0, ol = groups.length; o < ol; ++o) {\n          const group = groups[o];\n          const groupStart = group.start;\n          const groupCount = group.count;\n          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {\n            for (let j = 0; j < 3; j++) {\n              const index1 = indices.getX(i + j);\n              const index2 = indices.getX(i + (j + 1) % 3);\n              start.fromBufferAttribute(position, index1);\n              end.fromBufferAttribute(position, index2);\n              if (isUniqueEdge(start, end, edges) === true) {\n                vertices.push(start.x, start.y, start.z);\n                vertices.push(end.x, end.y, end.z);\n              }\n            }\n          }\n        }\n      } else {\n        const position = geometry.attributes.position;\n        for (let i = 0, l = position.count / 3; i < l; i++) {\n          for (let j = 0; j < 3; j++) {\n            const index1 = 3 * i + j;\n            const index2 = 3 * i + (j + 1) % 3;\n            start.fromBufferAttribute(position, index1);\n            end.fromBufferAttribute(position, index2);\n            if (isUniqueEdge(start, end, edges) === true) {\n              vertices.push(start.x, start.y, start.z);\n              vertices.push(end.x, end.y, end.z);\n            }\n          }\n        }\n      }\n      this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.parameters = Object.assign({}, source.parameters);\n    return this;\n  }\n}\nfunction isUniqueEdge(start, end, edges) {\n  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\n  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;\n  if (edges.has(hash1) === true || edges.has(hash2) === true) {\n    return false;\n  } else {\n    edges.add(hash1);\n    edges.add(hash2);\n    return true;\n  }\n}\nclass MeshStandardMaterial extends Material {\n  static get type() {\n    return \"MeshStandardMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshStandardMaterial = true;\n    this.defines = { \"STANDARD\": \"\" };\n    this.color = new Color(16777215);\n    this.roughness = 1;\n    this.metalness = 0;\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity = 1;\n    this.emissive = new Color(0);\n    this.emissiveIntensity = 1;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.roughnessMap = null;\n    this.metalnessMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.envMapRotation = new Euler();\n    this.envMapIntensity = 1;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n    this.flatShading = false;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.defines = { \"STANDARD\": \"\" };\n    this.color.copy(source.color);\n    this.roughness = source.roughness;\n    this.metalness = source.metalness;\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.roughnessMap = source.roughnessMap;\n    this.metalnessMap = source.metalnessMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.envMapRotation.copy(source.envMapRotation);\n    this.envMapIntensity = source.envMapIntensity;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.flatShading = source.flatShading;\n    this.fog = source.fog;\n    return this;\n  }\n}\nclass MeshPhysicalMaterial extends MeshStandardMaterial {\n  static get type() {\n    return \"MeshPhysicalMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshPhysicalMaterial = true;\n    this.defines = {\n      \"STANDARD\": \"\",\n      \"PHYSICAL\": \"\"\n    };\n    this.anisotropyRotation = 0;\n    this.anisotropyMap = null;\n    this.clearcoatMap = null;\n    this.clearcoatRoughness = 0;\n    this.clearcoatRoughnessMap = null;\n    this.clearcoatNormalScale = new Vector2(1, 1);\n    this.clearcoatNormalMap = null;\n    this.ior = 1.5;\n    Object.defineProperty(this, \"reflectivity\", {\n      get: function() {\n        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);\n      },\n      set: function(reflectivity) {\n        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);\n      }\n    });\n    this.iridescenceMap = null;\n    this.iridescenceIOR = 1.3;\n    this.iridescenceThicknessRange = [100, 400];\n    this.iridescenceThicknessMap = null;\n    this.sheenColor = new Color(0);\n    this.sheenColorMap = null;\n    this.sheenRoughness = 1;\n    this.sheenRoughnessMap = null;\n    this.transmissionMap = null;\n    this.thickness = 0;\n    this.thicknessMap = null;\n    this.attenuationDistance = Infinity;\n    this.attenuationColor = new Color(1, 1, 1);\n    this.specularIntensity = 1;\n    this.specularIntensityMap = null;\n    this.specularColor = new Color(1, 1, 1);\n    this.specularColorMap = null;\n    this._anisotropy = 0;\n    this._clearcoat = 0;\n    this._dispersion = 0;\n    this._iridescence = 0;\n    this._sheen = 0;\n    this._transmission = 0;\n    this.setValues(parameters);\n  }\n  get anisotropy() {\n    return this._anisotropy;\n  }\n  set anisotropy(value) {\n    if (this._anisotropy > 0 !== value > 0) {\n      this.version++;\n    }\n    this._anisotropy = value;\n  }\n  get clearcoat() {\n    return this._clearcoat;\n  }\n  set clearcoat(value) {\n    if (this._clearcoat > 0 !== value > 0) {\n      this.version++;\n    }\n    this._clearcoat = value;\n  }\n  get iridescence() {\n    return this._iridescence;\n  }\n  set iridescence(value) {\n    if (this._iridescence > 0 !== value > 0) {\n      this.version++;\n    }\n    this._iridescence = value;\n  }\n  get dispersion() {\n    return this._dispersion;\n  }\n  set dispersion(value) {\n    if (this._dispersion > 0 !== value > 0) {\n      this.version++;\n    }\n    this._dispersion = value;\n  }\n  get sheen() {\n    return this._sheen;\n  }\n  set sheen(value) {\n    if (this._sheen > 0 !== value > 0) {\n      this.version++;\n    }\n    this._sheen = value;\n  }\n  get transmission() {\n    return this._transmission;\n  }\n  set transmission(value) {\n    if (this._transmission > 0 !== value > 0) {\n      this.version++;\n    }\n    this._transmission = value;\n  }\n  copy(source) {\n    super.copy(source);\n    this.defines = {\n      \"STANDARD\": \"\",\n      \"PHYSICAL\": \"\"\n    };\n    this.anisotropy = source.anisotropy;\n    this.anisotropyRotation = source.anisotropyRotation;\n    this.anisotropyMap = source.anisotropyMap;\n    this.clearcoat = source.clearcoat;\n    this.clearcoatMap = source.clearcoatMap;\n    this.clearcoatRoughness = source.clearcoatRoughness;\n    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n    this.clearcoatNormalMap = source.clearcoatNormalMap;\n    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);\n    this.dispersion = source.dispersion;\n    this.ior = source.ior;\n    this.iridescence = source.iridescence;\n    this.iridescenceMap = source.iridescenceMap;\n    this.iridescenceIOR = source.iridescenceIOR;\n    this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];\n    this.iridescenceThicknessMap = source.iridescenceThicknessMap;\n    this.sheen = source.sheen;\n    this.sheenColor.copy(source.sheenColor);\n    this.sheenColorMap = source.sheenColorMap;\n    this.sheenRoughness = source.sheenRoughness;\n    this.sheenRoughnessMap = source.sheenRoughnessMap;\n    this.transmission = source.transmission;\n    this.transmissionMap = source.transmissionMap;\n    this.thickness = source.thickness;\n    this.thicknessMap = source.thicknessMap;\n    this.attenuationDistance = source.attenuationDistance;\n    this.attenuationColor.copy(source.attenuationColor);\n    this.specularIntensity = source.specularIntensity;\n    this.specularIntensityMap = source.specularIntensityMap;\n    this.specularColor.copy(source.specularColor);\n    this.specularColorMap = source.specularColorMap;\n    return this;\n  }\n}\nclass MeshPhongMaterial extends Material {\n  static get type() {\n    return \"MeshPhongMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshPhongMaterial = true;\n    this.color = new Color(16777215);\n    this.specular = new Color(1118481);\n    this.shininess = 30;\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity = 1;\n    this.emissive = new Color(0);\n    this.emissiveIntensity = 1;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.envMapRotation = new Euler();\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n    this.flatShading = false;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.specular.copy(source.specular);\n    this.shininess = source.shininess;\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.envMapRotation.copy(source.envMapRotation);\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.flatShading = source.flatShading;\n    this.fog = source.fog;\n    return this;\n  }\n}\nclass MeshNormalMaterial extends Material {\n  static get type() {\n    return \"MeshNormalMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshNormalMaterial = true;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.flatShading = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.flatShading = source.flatShading;\n    return this;\n  }\n}\nclass MeshLambertMaterial extends Material {\n  static get type() {\n    return \"MeshLambertMaterial\";\n  }\n  constructor(parameters) {\n    super();\n    this.isMeshLambertMaterial = true;\n    this.color = new Color(16777215);\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity = 1;\n    this.emissive = new Color(0);\n    this.emissiveIntensity = 1;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.envMapRotation = new Euler();\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n    this.flatShading = false;\n    this.fog = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.envMapRotation.copy(source.envMapRotation);\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.flatShading = source.flatShading;\n    this.fog = source.fog;\n    return this;\n  }\n}\nfunction convertArray(array, type, forceClone) {\n  if (!array || // let 'undefined' and 'null' pass\n  !forceClone && array.constructor === type) return array;\n  if (typeof type.BYTES_PER_ELEMENT === \"number\") {\n    return new type(array);\n  }\n  return Array.prototype.slice.call(array);\n}\nfunction isTypedArray(object) {\n  return ArrayBuffer.isView(object) && !(object instanceof DataView);\n}\nfunction getKeyframeOrder(times) {\n  function compareTime(i, j) {\n    return times[i] - times[j];\n  }\n  const n = times.length;\n  const result = new Array(n);\n  for (let i = 0; i !== n; ++i) result[i] = i;\n  result.sort(compareTime);\n  return result;\n}\nfunction sortedArray(values, stride, order) {\n  const nValues = values.length;\n  const result = new values.constructor(nValues);\n  for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\n    const srcOffset = order[i] * stride;\n    for (let j = 0; j !== stride; ++j) {\n      result[dstOffset++] = values[srcOffset + j];\n    }\n  }\n  return result;\n}\nfunction flattenJSON(jsonKeys, times, values, valuePropertyName) {\n  let i = 1, key = jsonKeys[0];\n  while (key !== void 0 && key[valuePropertyName] === void 0) {\n    key = jsonKeys[i++];\n  }\n  if (key === void 0) return;\n  let value = key[valuePropertyName];\n  if (value === void 0) return;\n  if (Array.isArray(value)) {\n    do {\n      value = key[valuePropertyName];\n      if (value !== void 0) {\n        times.push(key.time);\n        values.push.apply(values, value);\n      }\n      key = jsonKeys[i++];\n    } while (key !== void 0);\n  } else if (value.toArray !== void 0) {\n    do {\n      value = key[valuePropertyName];\n      if (value !== void 0) {\n        times.push(key.time);\n        value.toArray(values, values.length);\n      }\n      key = jsonKeys[i++];\n    } while (key !== void 0);\n  } else {\n    do {\n      value = key[valuePropertyName];\n      if (value !== void 0) {\n        times.push(key.time);\n        values.push(value);\n      }\n      key = jsonKeys[i++];\n    } while (key !== void 0);\n  }\n}\nclass Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    this.parameterPositions = parameterPositions;\n    this._cachedIndex = 0;\n    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);\n    this.sampleValues = sampleValues;\n    this.valueSize = sampleSize;\n    this.settings = null;\n    this.DefaultSettings_ = {};\n  }\n  evaluate(t2) {\n    const pp = this.parameterPositions;\n    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];\n    validate_interval: {\n      seek: {\n        let right;\n        linear_scan: {\n          forward_scan: if (!(t2 < t1)) {\n            for (let giveUpAt = i1 + 2; ; ) {\n              if (t1 === void 0) {\n                if (t2 < t0) break forward_scan;\n                i1 = pp.length;\n                this._cachedIndex = i1;\n                return this.copySampleValue_(i1 - 1);\n              }\n              if (i1 === giveUpAt) break;\n              t0 = t1;\n              t1 = pp[++i1];\n              if (t2 < t1) {\n                break seek;\n              }\n            }\n            right = pp.length;\n            break linear_scan;\n          }\n          if (!(t2 >= t0)) {\n            const t1global = pp[1];\n            if (t2 < t1global) {\n              i1 = 2;\n              t0 = t1global;\n            }\n            for (let giveUpAt = i1 - 2; ; ) {\n              if (t0 === void 0) {\n                this._cachedIndex = 0;\n                return this.copySampleValue_(0);\n              }\n              if (i1 === giveUpAt) break;\n              t1 = t0;\n              t0 = pp[--i1 - 1];\n              if (t2 >= t0) {\n                break seek;\n              }\n            }\n            right = i1;\n            i1 = 0;\n            break linear_scan;\n          }\n          break validate_interval;\n        }\n        while (i1 < right) {\n          const mid = i1 + right >>> 1;\n          if (t2 < pp[mid]) {\n            right = mid;\n          } else {\n            i1 = mid + 1;\n          }\n        }\n        t1 = pp[i1];\n        t0 = pp[i1 - 1];\n        if (t0 === void 0) {\n          this._cachedIndex = 0;\n          return this.copySampleValue_(0);\n        }\n        if (t1 === void 0) {\n          i1 = pp.length;\n          this._cachedIndex = i1;\n          return this.copySampleValue_(i1 - 1);\n        }\n      }\n      this._cachedIndex = i1;\n      this.intervalChanged_(i1, t0, t1);\n    }\n    return this.interpolate_(i1, t0, t2, t1);\n  }\n  getSettings_() {\n    return this.settings || this.DefaultSettings_;\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n  // Template methods for derived classes:\n  interpolate_() {\n    throw new Error(\"call to abstract method\");\n  }\n  intervalChanged_() {\n  }\n}\nclass CubicInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this._weightPrev = -0;\n    this._offsetPrev = -0;\n    this._weightNext = -0;\n    this._offsetNext = -0;\n    this.DefaultSettings_ = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding\n    };\n  }\n  intervalChanged_(i1, t0, t1) {\n    const pp = this.parameterPositions;\n    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];\n    if (tPrev === void 0) {\n      switch (this.getSettings_().endingStart) {\n        case ZeroSlopeEnding:\n          iPrev = i1;\n          tPrev = 2 * t0 - t1;\n          break;\n        case WrapAroundEnding:\n          iPrev = pp.length - 2;\n          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];\n          break;\n        default:\n          iPrev = i1;\n          tPrev = t1;\n      }\n    }\n    if (tNext === void 0) {\n      switch (this.getSettings_().endingEnd) {\n        case ZeroSlopeEnding:\n          iNext = i1;\n          tNext = 2 * t1 - t0;\n          break;\n        case WrapAroundEnding:\n          iNext = 1;\n          tNext = t1 + pp[1] - pp[0];\n          break;\n        default:\n          iNext = i1 - 1;\n          tNext = t0;\n      }\n    }\n    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;\n    this._weightPrev = halfDt / (t0 - tPrev);\n    this._weightNext = halfDt / (tNext - t1);\n    this._offsetPrev = iPrev * stride;\n    this._offsetNext = iNext * stride;\n  }\n  interpolate_(i1, t0, t2, t1) {\n    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t2 - t0) / (t1 - t0), pp = p * p, ppp = pp * p;\n    const sP = -wP * ppp + 2 * wP * pp - wP * p;\n    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n    const sN = wN * ppp - wN * pp;\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];\n    }\n    return result;\n  }\n}\nclass LinearInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  interpolate_(i1, t0, t2, t1) {\n    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;\n    }\n    return result;\n  }\n}\nclass DiscreteInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  interpolate_(i1) {\n    return this.copySampleValue_(i1 - 1);\n  }\n}\nclass KeyframeTrack {\n  constructor(name, times, values, interpolation) {\n    if (name === void 0) throw new Error(\"THREE.KeyframeTrack: track name is undefined\");\n    if (times === void 0 || times.length === 0) throw new Error(\"THREE.KeyframeTrack: no keyframes in track named \" + name);\n    this.name = name;\n    this.times = convertArray(times, this.TimeBufferType);\n    this.values = convertArray(values, this.ValueBufferType);\n    this.setInterpolation(interpolation || this.DefaultInterpolation);\n  }\n  // Serialization (in static context, because of constructor invocation\n  // and automatic invocation of .toJSON):\n  static toJSON(track) {\n    const trackType = track.constructor;\n    let json;\n    if (trackType.toJSON !== this.toJSON) {\n      json = trackType.toJSON(track);\n    } else {\n      json = {\n        \"name\": track.name,\n        \"times\": convertArray(track.times, Array),\n        \"values\": convertArray(track.values, Array)\n      };\n      const interpolation = track.getInterpolation();\n      if (interpolation !== track.DefaultInterpolation) {\n        json.interpolation = interpolation;\n      }\n    }\n    json.type = track.ValueTypeName;\n    return json;\n  }\n  InterpolantFactoryMethodDiscrete(result) {\n    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n  InterpolantFactoryMethodLinear(result) {\n    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n  InterpolantFactoryMethodSmooth(result) {\n    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n  setInterpolation(interpolation) {\n    let factoryMethod;\n    switch (interpolation) {\n      case InterpolateDiscrete:\n        factoryMethod = this.InterpolantFactoryMethodDiscrete;\n        break;\n      case InterpolateLinear:\n        factoryMethod = this.InterpolantFactoryMethodLinear;\n        break;\n      case InterpolateSmooth:\n        factoryMethod = this.InterpolantFactoryMethodSmooth;\n        break;\n    }\n    if (factoryMethod === void 0) {\n      const message = \"unsupported interpolation for \" + this.ValueTypeName + \" keyframe track named \" + this.name;\n      if (this.createInterpolant === void 0) {\n        if (interpolation !== this.DefaultInterpolation) {\n          this.setInterpolation(this.DefaultInterpolation);\n        } else {\n          throw new Error(message);\n        }\n      }\n      console.warn(\"THREE.KeyframeTrack:\", message);\n      return this;\n    }\n    this.createInterpolant = factoryMethod;\n    return this;\n  }\n  getInterpolation() {\n    switch (this.createInterpolant) {\n      case this.InterpolantFactoryMethodDiscrete:\n        return InterpolateDiscrete;\n      case this.InterpolantFactoryMethodLinear:\n        return InterpolateLinear;\n      case this.InterpolantFactoryMethodSmooth:\n        return InterpolateSmooth;\n    }\n  }\n  getValueSize() {\n    return this.values.length / this.times.length;\n  }\n  // move all keyframes either forwards or backwards in time\n  shift(timeOffset) {\n    if (timeOffset !== 0) {\n      const times = this.times;\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] += timeOffset;\n      }\n    }\n    return this;\n  }\n  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n  scale(timeScale) {\n    if (timeScale !== 1) {\n      const times = this.times;\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] *= timeScale;\n      }\n    }\n    return this;\n  }\n  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n  trim(startTime, endTime) {\n    const times = this.times, nKeys = times.length;\n    let from = 0, to = nKeys - 1;\n    while (from !== nKeys && times[from] < startTime) {\n      ++from;\n    }\n    while (to !== -1 && times[to] > endTime) {\n      --to;\n    }\n    ++to;\n    if (from !== 0 || to !== nKeys) {\n      if (from >= to) {\n        to = Math.max(to, 1);\n        from = to - 1;\n      }\n      const stride = this.getValueSize();\n      this.times = times.slice(from, to);\n      this.values = this.values.slice(from * stride, to * stride);\n    }\n    return this;\n  }\n  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n  validate() {\n    let valid = true;\n    const valueSize = this.getValueSize();\n    if (valueSize - Math.floor(valueSize) !== 0) {\n      console.error(\"THREE.KeyframeTrack: Invalid value size in track.\", this);\n      valid = false;\n    }\n    const times = this.times, values = this.values, nKeys = times.length;\n    if (nKeys === 0) {\n      console.error(\"THREE.KeyframeTrack: Track is empty.\", this);\n      valid = false;\n    }\n    let prevTime = null;\n    for (let i = 0; i !== nKeys; i++) {\n      const currTime = times[i];\n      if (typeof currTime === \"number\" && isNaN(currTime)) {\n        console.error(\"THREE.KeyframeTrack: Time is not a valid number.\", this, i, currTime);\n        valid = false;\n        break;\n      }\n      if (prevTime !== null && prevTime > currTime) {\n        console.error(\"THREE.KeyframeTrack: Out of order keys.\", this, i, currTime, prevTime);\n        valid = false;\n        break;\n      }\n      prevTime = currTime;\n    }\n    if (values !== void 0) {\n      if (isTypedArray(values)) {\n        for (let i = 0, n = values.length; i !== n; ++i) {\n          const value = values[i];\n          if (isNaN(value)) {\n            console.error(\"THREE.KeyframeTrack: Value is not a valid number.\", this, i, value);\n            valid = false;\n            break;\n          }\n        }\n      }\n    }\n    return valid;\n  }\n  // removes equivalent sequential keys as common in morph target sequences\n  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n  optimize() {\n    const times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;\n    let writeIndex = 1;\n    for (let i = 1; i < lastIndex; ++i) {\n      let keep = false;\n      const time = times[i];\n      const timeNext = times[i + 1];\n      if (time !== timeNext && (i !== 1 || time !== times[0])) {\n        if (!smoothInterpolation) {\n          const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;\n          for (let j = 0; j !== stride; ++j) {\n            const value = values[offset + j];\n            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {\n              keep = true;\n              break;\n            }\n          }\n        } else {\n          keep = true;\n        }\n      }\n      if (keep) {\n        if (i !== writeIndex) {\n          times[writeIndex] = times[i];\n          const readOffset = i * stride, writeOffset = writeIndex * stride;\n          for (let j = 0; j !== stride; ++j) {\n            values[writeOffset + j] = values[readOffset + j];\n          }\n        }\n        ++writeIndex;\n      }\n    }\n    if (lastIndex > 0) {\n      times[writeIndex] = times[lastIndex];\n      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {\n        values[writeOffset + j] = values[readOffset + j];\n      }\n      ++writeIndex;\n    }\n    if (writeIndex !== times.length) {\n      this.times = times.slice(0, writeIndex);\n      this.values = values.slice(0, writeIndex * stride);\n    } else {\n      this.times = times;\n      this.values = values;\n    }\n    return this;\n  }\n  clone() {\n    const times = this.times.slice();\n    const values = this.values.slice();\n    const TypedKeyframeTrack = this.constructor;\n    const track = new TypedKeyframeTrack(this.name, times, values);\n    track.createInterpolant = this.createInterpolant;\n    return track;\n  }\n}\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\nclass BooleanKeyframeTrack extends KeyframeTrack {\n  // No interpolation parameter because only InterpolateDiscrete is valid.\n  constructor(name, times, values) {\n    super(name, times, values);\n  }\n}\nBooleanKeyframeTrack.prototype.ValueTypeName = \"bool\";\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;\nclass ColorKeyframeTrack extends KeyframeTrack {\n}\nColorKeyframeTrack.prototype.ValueTypeName = \"color\";\nclass NumberKeyframeTrack extends KeyframeTrack {\n}\nNumberKeyframeTrack.prototype.ValueTypeName = \"number\";\nclass QuaternionLinearInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  interpolate_(i1, t0, t2, t1) {\n    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);\n    let offset = i1 * stride;\n    for (let end = offset + stride; offset !== end; offset += 4) {\n      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);\n    }\n    return result;\n  }\n}\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n  InterpolantFactoryMethodLinear(result) {\n    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n}\nQuaternionKeyframeTrack.prototype.ValueTypeName = \"quaternion\";\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;\nclass StringKeyframeTrack extends KeyframeTrack {\n  // No interpolation parameter because only InterpolateDiscrete is valid.\n  constructor(name, times, values) {\n    super(name, times, values);\n  }\n}\nStringKeyframeTrack.prototype.ValueTypeName = \"string\";\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;\nclass VectorKeyframeTrack extends KeyframeTrack {\n}\nVectorKeyframeTrack.prototype.ValueTypeName = \"vector\";\nclass AnimationClip {\n  constructor(name = \"\", duration = -1, tracks = [], blendMode = NormalAnimationBlendMode) {\n    this.name = name;\n    this.tracks = tracks;\n    this.duration = duration;\n    this.blendMode = blendMode;\n    this.uuid = generateUUID();\n    if (this.duration < 0) {\n      this.resetDuration();\n    }\n  }\n  static parse(json) {\n    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);\n    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {\n      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\n    }\n    const clip = new this(json.name, json.duration, tracks, json.blendMode);\n    clip.uuid = json.uuid;\n    return clip;\n  }\n  static toJSON(clip) {\n    const tracks = [], clipTracks = clip.tracks;\n    const json = {\n      \"name\": clip.name,\n      \"duration\": clip.duration,\n      \"tracks\": tracks,\n      \"uuid\": clip.uuid,\n      \"blendMode\": clip.blendMode\n    };\n    for (let i = 0, n = clipTracks.length; i !== n; ++i) {\n      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n    }\n    return json;\n  }\n  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {\n    const numMorphTargets = morphTargetSequence.length;\n    const tracks = [];\n    for (let i = 0; i < numMorphTargets; i++) {\n      let times = [];\n      let values = [];\n      times.push(\n        (i + numMorphTargets - 1) % numMorphTargets,\n        i,\n        (i + 1) % numMorphTargets\n      );\n      values.push(0, 1, 0);\n      const order = getKeyframeOrder(times);\n      times = sortedArray(times, 1, order);\n      values = sortedArray(values, 1, order);\n      if (!noLoop && times[0] === 0) {\n        times.push(numMorphTargets);\n        values.push(values[0]);\n      }\n      tracks.push(\n        new NumberKeyframeTrack(\n          \".morphTargetInfluences[\" + morphTargetSequence[i].name + \"]\",\n          times,\n          values\n        ).scale(1 / fps)\n      );\n    }\n    return new this(name, -1, tracks);\n  }\n  static findByName(objectOrClipArray, name) {\n    let clipArray = objectOrClipArray;\n    if (!Array.isArray(objectOrClipArray)) {\n      const o = objectOrClipArray;\n      clipArray = o.geometry && o.geometry.animations || o.animations;\n    }\n    for (let i = 0; i < clipArray.length; i++) {\n      if (clipArray[i].name === name) {\n        return clipArray[i];\n      }\n    }\n    return null;\n  }\n  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {\n    const animationToMorphTargets = {};\n    const pattern = /^([\\w-]*?)([\\d]+)$/;\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = morphTargets[i];\n      const parts = morphTarget.name.match(pattern);\n      if (parts && parts.length > 1) {\n        const name = parts[1];\n        let animationMorphTargets = animationToMorphTargets[name];\n        if (!animationMorphTargets) {\n          animationToMorphTargets[name] = animationMorphTargets = [];\n        }\n        animationMorphTargets.push(morphTarget);\n      }\n    }\n    const clips = [];\n    for (const name in animationToMorphTargets) {\n      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));\n    }\n    return clips;\n  }\n  // parse the animation.hierarchy format\n  static parseAnimation(animation, bones) {\n    if (!animation) {\n      console.error(\"THREE.AnimationClip: No animation in JSONLoader data.\");\n      return null;\n    }\n    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {\n      if (animationKeys.length !== 0) {\n        const times = [];\n        const values = [];\n        flattenJSON(animationKeys, times, values, propertyName);\n        if (times.length !== 0) {\n          destTracks.push(new trackType(trackName, times, values));\n        }\n      }\n    };\n    const tracks = [];\n    const clipName = animation.name || \"default\";\n    const fps = animation.fps || 30;\n    const blendMode = animation.blendMode;\n    let duration = animation.length || -1;\n    const hierarchyTracks = animation.hierarchy || [];\n    for (let h = 0; h < hierarchyTracks.length; h++) {\n      const animationKeys = hierarchyTracks[h].keys;\n      if (!animationKeys || animationKeys.length === 0) continue;\n      if (animationKeys[0].morphTargets) {\n        const morphTargetNames = {};\n        let k;\n        for (k = 0; k < animationKeys.length; k++) {\n          if (animationKeys[k].morphTargets) {\n            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {\n              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n            }\n          }\n        }\n        for (const morphTargetName in morphTargetNames) {\n          const times = [];\n          const values = [];\n          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {\n            const animationKey = animationKeys[k];\n            times.push(animationKey.time);\n            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n          }\n          tracks.push(new NumberKeyframeTrack(\".morphTargetInfluence[\" + morphTargetName + \"]\", times, values));\n        }\n        duration = morphTargetNames.length * fps;\n      } else {\n        const boneName = \".bones[\" + bones[h].name + \"]\";\n        addNonemptyTrack(\n          VectorKeyframeTrack,\n          boneName + \".position\",\n          animationKeys,\n          \"pos\",\n          tracks\n        );\n        addNonemptyTrack(\n          QuaternionKeyframeTrack,\n          boneName + \".quaternion\",\n          animationKeys,\n          \"rot\",\n          tracks\n        );\n        addNonemptyTrack(\n          VectorKeyframeTrack,\n          boneName + \".scale\",\n          animationKeys,\n          \"scl\",\n          tracks\n        );\n      }\n    }\n    if (tracks.length === 0) {\n      return null;\n    }\n    const clip = new this(clipName, duration, tracks, blendMode);\n    return clip;\n  }\n  resetDuration() {\n    const tracks = this.tracks;\n    let duration = 0;\n    for (let i = 0, n = tracks.length; i !== n; ++i) {\n      const track = this.tracks[i];\n      duration = Math.max(duration, track.times[track.times.length - 1]);\n    }\n    this.duration = duration;\n    return this;\n  }\n  trim() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].trim(0, this.duration);\n    }\n    return this;\n  }\n  validate() {\n    let valid = true;\n    for (let i = 0; i < this.tracks.length; i++) {\n      valid = valid && this.tracks[i].validate();\n    }\n    return valid;\n  }\n  optimize() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].optimize();\n    }\n    return this;\n  }\n  clone() {\n    const tracks = [];\n    for (let i = 0; i < this.tracks.length; i++) {\n      tracks.push(this.tracks[i].clone());\n    }\n    return new this.constructor(this.name, this.duration, tracks, this.blendMode);\n  }\n  toJSON() {\n    return this.constructor.toJSON(this);\n  }\n}\nfunction getTrackTypeForValueTypeName(typeName) {\n  switch (typeName.toLowerCase()) {\n    case \"scalar\":\n    case \"double\":\n    case \"float\":\n    case \"number\":\n    case \"integer\":\n      return NumberKeyframeTrack;\n    case \"vector\":\n    case \"vector2\":\n    case \"vector3\":\n    case \"vector4\":\n      return VectorKeyframeTrack;\n    case \"color\":\n      return ColorKeyframeTrack;\n    case \"quaternion\":\n      return QuaternionKeyframeTrack;\n    case \"bool\":\n    case \"boolean\":\n      return BooleanKeyframeTrack;\n    case \"string\":\n      return StringKeyframeTrack;\n  }\n  throw new Error(\"THREE.KeyframeTrack: Unsupported typeName: \" + typeName);\n}\nfunction parseKeyframeTrack(json) {\n  if (json.type === void 0) {\n    throw new Error(\"THREE.KeyframeTrack: track type undefined, can not parse\");\n  }\n  const trackType = getTrackTypeForValueTypeName(json.type);\n  if (json.times === void 0) {\n    const times = [], values = [];\n    flattenJSON(json.keys, times, values, \"value\");\n    json.times = times;\n    json.values = values;\n  }\n  if (trackType.parse !== void 0) {\n    return trackType.parse(json);\n  } else {\n    return new trackType(json.name, json.times, json.values, json.interpolation);\n  }\n}\nconst Cache = {\n  enabled: false,\n  files: {},\n  add: function(key, file2) {\n    if (this.enabled === false) return;\n    this.files[key] = file2;\n  },\n  get: function(key) {\n    if (this.enabled === false) return;\n    return this.files[key];\n  },\n  remove: function(key) {\n    delete this.files[key];\n  },\n  clear: function() {\n    this.files = {};\n  }\n};\nclass LoadingManager {\n  constructor(onLoad, onProgress, onError) {\n    const scope = this;\n    let isLoading = false;\n    let itemsLoaded = 0;\n    let itemsTotal = 0;\n    let urlModifier = void 0;\n    const handlers = [];\n    this.onStart = void 0;\n    this.onLoad = onLoad;\n    this.onProgress = onProgress;\n    this.onError = onError;\n    this.itemStart = function(url2) {\n      itemsTotal++;\n      if (isLoading === false) {\n        if (scope.onStart !== void 0) {\n          scope.onStart(url2, itemsLoaded, itemsTotal);\n        }\n      }\n      isLoading = true;\n    };\n    this.itemEnd = function(url2) {\n      itemsLoaded++;\n      if (scope.onProgress !== void 0) {\n        scope.onProgress(url2, itemsLoaded, itemsTotal);\n      }\n      if (itemsLoaded === itemsTotal) {\n        isLoading = false;\n        if (scope.onLoad !== void 0) {\n          scope.onLoad();\n        }\n      }\n    };\n    this.itemError = function(url2) {\n      if (scope.onError !== void 0) {\n        scope.onError(url2);\n      }\n    };\n    this.resolveURL = function(url2) {\n      if (urlModifier) {\n        return urlModifier(url2);\n      }\n      return url2;\n    };\n    this.setURLModifier = function(transform) {\n      urlModifier = transform;\n      return this;\n    };\n    this.addHandler = function(regex, loader) {\n      handlers.push(regex, loader);\n      return this;\n    };\n    this.removeHandler = function(regex) {\n      const index = handlers.indexOf(regex);\n      if (index !== -1) {\n        handlers.splice(index, 2);\n      }\n      return this;\n    };\n    this.getHandler = function(file2) {\n      for (let i = 0, l = handlers.length; i < l; i += 2) {\n        const regex = handlers[i];\n        const loader = handlers[i + 1];\n        if (regex.global) regex.lastIndex = 0;\n        if (regex.test(file2)) {\n          return loader;\n        }\n      }\n      return null;\n    };\n  }\n}\nconst DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();\nclass Loader {\n  constructor(manager) {\n    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;\n    this.crossOrigin = \"anonymous\";\n    this.withCredentials = false;\n    this.path = \"\";\n    this.resourcePath = \"\";\n    this.requestHeader = {};\n  }\n  load() {\n  }\n  loadAsync(url2, onProgress) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.load(url2, resolve, onProgress, reject);\n    });\n  }\n  parse() {\n  }\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  setWithCredentials(value) {\n    this.withCredentials = value;\n    return this;\n  }\n  setPath(path) {\n    this.path = path;\n    return this;\n  }\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath;\n    return this;\n  }\n  setRequestHeader(requestHeader) {\n    this.requestHeader = requestHeader;\n    return this;\n  }\n}\nLoader.DEFAULT_MATERIAL_NAME = \"__DEFAULT\";\nconst loading = {};\nclass HttpError extends Error {\n  constructor(message, response) {\n    super(message);\n    this.response = response;\n  }\n}\nclass FileLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url2, onLoad, onProgress, onError) {\n    if (url2 === void 0) url2 = \"\";\n    if (this.path !== void 0) url2 = this.path + url2;\n    url2 = this.manager.resolveURL(url2);\n    const cached = Cache.get(url2);\n    if (cached !== void 0) {\n      this.manager.itemStart(url2);\n      setTimeout(() => {\n        if (onLoad) onLoad(cached);\n        this.manager.itemEnd(url2);\n      }, 0);\n      return cached;\n    }\n    if (loading[url2] !== void 0) {\n      loading[url2].push({\n        onLoad,\n        onProgress,\n        onError\n      });\n      return;\n    }\n    loading[url2] = [];\n    loading[url2].push({\n      onLoad,\n      onProgress,\n      onError\n    });\n    const req = new Request(url2, {\n      headers: new Headers(this.requestHeader),\n      credentials: this.withCredentials ? \"include\" : \"same-origin\"\n      // An abort controller could be added within a future PR\n    });\n    const mimeType = this.mimeType;\n    const responseType = this.responseType;\n    fetch(req).then((response) => {\n      if (response.status === 200 || response.status === 0) {\n        if (response.status === 0) {\n          console.warn(\"THREE.FileLoader: HTTP Status 0 received.\");\n        }\n        if (typeof ReadableStream === \"undefined\" || response.body === void 0 || response.body.getReader === void 0) {\n          return response;\n        }\n        const callbacks = loading[url2];\n        const reader = response.body.getReader();\n        const contentLength = response.headers.get(\"X-File-Size\") || response.headers.get(\"Content-Length\");\n        const total = contentLength ? parseInt(contentLength) : 0;\n        const lengthComputable = total !== 0;\n        let loaded = 0;\n        const stream = new ReadableStream({\n          start(controller) {\n            readData();\n            function readData() {\n              reader.read().then(({ done, value }) => {\n                if (done) {\n                  controller.close();\n                } else {\n                  loaded += value.byteLength;\n                  const event = new ProgressEvent(\"progress\", { lengthComputable, loaded, total });\n                  for (let i = 0, il = callbacks.length; i < il; i++) {\n                    const callback = callbacks[i];\n                    if (callback.onProgress) callback.onProgress(event);\n                  }\n                  controller.enqueue(value);\n                  readData();\n                }\n              }, (e) => {\n                controller.error(e);\n              });\n            }\n          }\n        });\n        return new Response(stream);\n      } else {\n        throw new HttpError(`fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`, response);\n      }\n    }).then((response) => {\n      switch (responseType) {\n        case \"arraybuffer\":\n          return response.arrayBuffer();\n        case \"blob\":\n          return response.blob();\n        case \"document\":\n          return response.text().then((text) => {\n            const parser = new DOMParser();\n            return parser.parseFromString(text, mimeType);\n          });\n        case \"json\":\n          return response.json();\n        default:\n          if (mimeType === void 0) {\n            return response.text();\n          } else {\n            const re = /charset=\"?([^;\"\\s]*)\"?/i;\n            const exec = re.exec(mimeType);\n            const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;\n            const decoder = new TextDecoder(label);\n            return response.arrayBuffer().then((ab) => decoder.decode(ab));\n          }\n      }\n    }).then((data) => {\n      Cache.add(url2, data);\n      const callbacks = loading[url2];\n      delete loading[url2];\n      for (let i = 0, il = callbacks.length; i < il; i++) {\n        const callback = callbacks[i];\n        if (callback.onLoad) callback.onLoad(data);\n      }\n    }).catch((err2) => {\n      const callbacks = loading[url2];\n      if (callbacks === void 0) {\n        this.manager.itemError(url2);\n        throw err2;\n      }\n      delete loading[url2];\n      for (let i = 0, il = callbacks.length; i < il; i++) {\n        const callback = callbacks[i];\n        if (callback.onError) callback.onError(err2);\n      }\n      this.manager.itemError(url2);\n    }).finally(() => {\n      this.manager.itemEnd(url2);\n    });\n    this.manager.itemStart(url2);\n  }\n  setResponseType(value) {\n    this.responseType = value;\n    return this;\n  }\n  setMimeType(value) {\n    this.mimeType = value;\n    return this;\n  }\n}\nclass ImageLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url2, onLoad, onProgress, onError) {\n    if (this.path !== void 0) url2 = this.path + url2;\n    url2 = this.manager.resolveURL(url2);\n    const scope = this;\n    const cached = Cache.get(url2);\n    if (cached !== void 0) {\n      scope.manager.itemStart(url2);\n      setTimeout(function() {\n        if (onLoad) onLoad(cached);\n        scope.manager.itemEnd(url2);\n      }, 0);\n      return cached;\n    }\n    const image = createElementNS(\"img\");\n    function onImageLoad() {\n      removeEventListeners();\n      Cache.add(url2, this);\n      if (onLoad) onLoad(this);\n      scope.manager.itemEnd(url2);\n    }\n    function onImageError(event) {\n      removeEventListeners();\n      if (onError) onError(event);\n      scope.manager.itemError(url2);\n      scope.manager.itemEnd(url2);\n    }\n    function removeEventListeners() {\n      image.removeEventListener(\"load\", onImageLoad, false);\n      image.removeEventListener(\"error\", onImageError, false);\n    }\n    image.addEventListener(\"load\", onImageLoad, false);\n    image.addEventListener(\"error\", onImageError, false);\n    if (url2.slice(0, 5) !== \"data:\") {\n      if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin;\n    }\n    scope.manager.itemStart(url2);\n    image.src = url2;\n    return image;\n  }\n}\nclass TextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url2, onLoad, onProgress, onError) {\n    const texture = new Texture();\n    const loader = new ImageLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setPath(this.path);\n    loader.load(url2, function(image) {\n      texture.image = image;\n      texture.needsUpdate = true;\n      if (onLoad !== void 0) {\n        onLoad(texture);\n      }\n    }, onProgress, onError);\n    return texture;\n  }\n}\nclass Light extends Object3D {\n  constructor(color, intensity = 1) {\n    super();\n    this.isLight = true;\n    this.type = \"Light\";\n    this.color = new Color(color);\n    this.intensity = intensity;\n  }\n  dispose() {\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.color.copy(source.color);\n    this.intensity = source.intensity;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.color = this.color.getHex();\n    data.object.intensity = this.intensity;\n    if (this.groundColor !== void 0) data.object.groundColor = this.groundColor.getHex();\n    if (this.distance !== void 0) data.object.distance = this.distance;\n    if (this.angle !== void 0) data.object.angle = this.angle;\n    if (this.decay !== void 0) data.object.decay = this.decay;\n    if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;\n    if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();\n    if (this.target !== void 0) data.object.target = this.target.uuid;\n    return data;\n  }\n}\nconst _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();\nconst _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();\nconst _lookTarget$1 = /* @__PURE__ */ new Vector3();\nclass LightShadow {\n  constructor(camera) {\n    this.camera = camera;\n    this.intensity = 1;\n    this.bias = 0;\n    this.normalBias = 0;\n    this.radius = 1;\n    this.blurSamples = 8;\n    this.mapSize = new Vector2(512, 512);\n    this.map = null;\n    this.mapPass = null;\n    this.matrix = new Matrix4();\n    this.autoUpdate = true;\n    this.needsUpdate = false;\n    this._frustum = new Frustum();\n    this._frameExtents = new Vector2(1, 1);\n    this._viewportCount = 1;\n    this._viewports = [\n      new Vector4(0, 0, 1, 1)\n    ];\n  }\n  getViewportCount() {\n    return this._viewportCount;\n  }\n  getFrustum() {\n    return this._frustum;\n  }\n  updateMatrices(light) {\n    const shadowCamera = this.camera;\n    const shadowMatrix = this.matrix;\n    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);\n    shadowCamera.position.copy(_lightPositionWorld$1);\n    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);\n    shadowCamera.lookAt(_lookTarget$1);\n    shadowCamera.updateMatrixWorld();\n    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\n    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);\n    shadowMatrix.set(\n      0.5,\n      0,\n      0,\n      0.5,\n      0,\n      0.5,\n      0,\n      0.5,\n      0,\n      0,\n      0.5,\n      0.5,\n      0,\n      0,\n      0,\n      1\n    );\n    shadowMatrix.multiply(_projScreenMatrix$1);\n  }\n  getViewport(viewportIndex) {\n    return this._viewports[viewportIndex];\n  }\n  getFrameExtents() {\n    return this._frameExtents;\n  }\n  dispose() {\n    if (this.map) {\n      this.map.dispose();\n    }\n    if (this.mapPass) {\n      this.mapPass.dispose();\n    }\n  }\n  copy(source) {\n    this.camera = source.camera.clone();\n    this.intensity = source.intensity;\n    this.bias = source.bias;\n    this.radius = source.radius;\n    this.mapSize.copy(source.mapSize);\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  toJSON() {\n    const object = {};\n    if (this.intensity !== 1) object.intensity = this.intensity;\n    if (this.bias !== 0) object.bias = this.bias;\n    if (this.normalBias !== 0) object.normalBias = this.normalBias;\n    if (this.radius !== 1) object.radius = this.radius;\n    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();\n    object.camera = this.camera.toJSON(false).object;\n    delete object.camera.matrix;\n    return object;\n  }\n}\nclass SpotLightShadow extends LightShadow {\n  constructor() {\n    super(new PerspectiveCamera(50, 1, 0.5, 500));\n    this.isSpotLightShadow = true;\n    this.focus = 1;\n  }\n  updateMatrices(light) {\n    const camera = this.camera;\n    const fov2 = RAD2DEG * 2 * light.angle * this.focus;\n    const aspect2 = this.mapSize.width / this.mapSize.height;\n    const far = light.distance || camera.far;\n    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {\n      camera.fov = fov2;\n      camera.aspect = aspect2;\n      camera.far = far;\n      camera.updateProjectionMatrix();\n    }\n    super.updateMatrices(light);\n  }\n  copy(source) {\n    super.copy(source);\n    this.focus = source.focus;\n    return this;\n  }\n}\nclass SpotLight extends Light {\n  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {\n    super(color, intensity);\n    this.isSpotLight = true;\n    this.type = \"SpotLight\";\n    this.position.copy(Object3D.DEFAULT_UP);\n    this.updateMatrix();\n    this.target = new Object3D();\n    this.distance = distance;\n    this.angle = angle;\n    this.penumbra = penumbra;\n    this.decay = decay;\n    this.map = null;\n    this.shadow = new SpotLightShadow();\n  }\n  get power() {\n    return this.intensity * Math.PI;\n  }\n  set power(power) {\n    this.intensity = power / Math.PI;\n  }\n  dispose() {\n    this.shadow.dispose();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.distance = source.distance;\n    this.angle = source.angle;\n    this.penumbra = source.penumbra;\n    this.decay = source.decay;\n    this.target = source.target.clone();\n    this.shadow = source.shadow.clone();\n    return this;\n  }\n}\nconst _projScreenMatrix = /* @__PURE__ */ new Matrix4();\nconst _lightPositionWorld = /* @__PURE__ */ new Vector3();\nconst _lookTarget = /* @__PURE__ */ new Vector3();\nclass PointLightShadow extends LightShadow {\n  constructor() {\n    super(new PerspectiveCamera(90, 1, 0.5, 500));\n    this.isPointLightShadow = true;\n    this._frameExtents = new Vector2(4, 2);\n    this._viewportCount = 6;\n    this._viewports = [\n      // These viewports map a cube-map onto a 2D texture with the\n      // following orientation:\n      //\n      //  xzXZ\n      //   y Y\n      //\n      // X - Positive x direction\n      // x - Negative x direction\n      // Y - Positive y direction\n      // y - Negative y direction\n      // Z - Positive z direction\n      // z - Negative z direction\n      // positive X\n      new Vector4(2, 1, 1, 1),\n      // negative X\n      new Vector4(0, 1, 1, 1),\n      // positive Z\n      new Vector4(3, 1, 1, 1),\n      // negative Z\n      new Vector4(1, 1, 1, 1),\n      // positive Y\n      new Vector4(3, 0, 1, 1),\n      // negative Y\n      new Vector4(1, 0, 1, 1)\n    ];\n    this._cubeDirections = [\n      new Vector3(1, 0, 0),\n      new Vector3(-1, 0, 0),\n      new Vector3(0, 0, 1),\n      new Vector3(0, 0, -1),\n      new Vector3(0, 1, 0),\n      new Vector3(0, -1, 0)\n    ];\n    this._cubeUps = [\n      new Vector3(0, 1, 0),\n      new Vector3(0, 1, 0),\n      new Vector3(0, 1, 0),\n      new Vector3(0, 1, 0),\n      new Vector3(0, 0, 1),\n      new Vector3(0, 0, -1)\n    ];\n  }\n  updateMatrices(light, viewportIndex = 0) {\n    const camera = this.camera;\n    const shadowMatrix = this.matrix;\n    const far = light.distance || camera.far;\n    if (far !== camera.far) {\n      camera.far = far;\n      camera.updateProjectionMatrix();\n    }\n    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\n    camera.position.copy(_lightPositionWorld);\n    _lookTarget.copy(camera.position);\n    _lookTarget.add(this._cubeDirections[viewportIndex]);\n    camera.up.copy(this._cubeUps[viewportIndex]);\n    camera.lookAt(_lookTarget);\n    camera.updateMatrixWorld();\n    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n    this._frustum.setFromProjectionMatrix(_projScreenMatrix);\n  }\n}\nclass PointLight extends Light {\n  constructor(color, intensity, distance = 0, decay = 2) {\n    super(color, intensity);\n    this.isPointLight = true;\n    this.type = \"PointLight\";\n    this.distance = distance;\n    this.decay = decay;\n    this.shadow = new PointLightShadow();\n  }\n  get power() {\n    return this.intensity * 4 * Math.PI;\n  }\n  set power(power) {\n    this.intensity = power / (4 * Math.PI);\n  }\n  dispose() {\n    this.shadow.dispose();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.distance = source.distance;\n    this.decay = source.decay;\n    this.shadow = source.shadow.clone();\n    return this;\n  }\n}\nclass DirectionalLightShadow extends LightShadow {\n  constructor() {\n    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));\n    this.isDirectionalLightShadow = true;\n  }\n}\nclass DirectionalLight extends Light {\n  constructor(color, intensity) {\n    super(color, intensity);\n    this.isDirectionalLight = true;\n    this.type = \"DirectionalLight\";\n    this.position.copy(Object3D.DEFAULT_UP);\n    this.updateMatrix();\n    this.target = new Object3D();\n    this.shadow = new DirectionalLightShadow();\n  }\n  dispose() {\n    this.shadow.dispose();\n  }\n  copy(source) {\n    super.copy(source);\n    this.target = source.target.clone();\n    this.shadow = source.shadow.clone();\n    return this;\n  }\n}\nclass AmbientLight extends Light {\n  constructor(color, intensity) {\n    super(color, intensity);\n    this.isAmbientLight = true;\n    this.type = \"AmbientLight\";\n  }\n}\nclass LoaderUtils {\n  static decodeText(array) {\n    console.warn(\"THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.\");\n    if (typeof TextDecoder !== \"undefined\") {\n      return new TextDecoder().decode(array);\n    }\n    let s = \"\";\n    for (let i = 0, il = array.length; i < il; i++) {\n      s += String.fromCharCode(array[i]);\n    }\n    try {\n      return decodeURIComponent(escape(s));\n    } catch (e) {\n      return s;\n    }\n  }\n  static extractUrlBase(url2) {\n    const index = url2.lastIndexOf(\"/\");\n    if (index === -1) return \"./\";\n    return url2.slice(0, index + 1);\n  }\n  static resolveURL(url2, path) {\n    if (typeof url2 !== \"string\" || url2 === \"\") return \"\";\n    if (/^https?:\\/\\//i.test(path) && /^\\//.test(url2)) {\n      path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, \"$1\");\n    }\n    if (/^(https?:)?\\/\\//i.test(url2)) return url2;\n    if (/^data:.*,.*$/i.test(url2)) return url2;\n    if (/^blob:.*$/i.test(url2)) return url2;\n    return path + url2;\n  }\n}\nclass InstancedBufferGeometry extends BufferGeometry {\n  constructor() {\n    super();\n    this.isInstancedBufferGeometry = true;\n    this.type = \"InstancedBufferGeometry\";\n    this.instanceCount = Infinity;\n  }\n  copy(source) {\n    super.copy(source);\n    this.instanceCount = source.instanceCount;\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.instanceCount = this.instanceCount;\n    data.isInstancedBufferGeometry = true;\n    return data;\n  }\n}\nclass ImageBitmapLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.isImageBitmapLoader = true;\n    if (typeof createImageBitmap === \"undefined\") {\n      console.warn(\"THREE.ImageBitmapLoader: createImageBitmap() not supported.\");\n    }\n    if (typeof fetch === \"undefined\") {\n      console.warn(\"THREE.ImageBitmapLoader: fetch() not supported.\");\n    }\n    this.options = { premultiplyAlpha: \"none\" };\n  }\n  setOptions(options) {\n    this.options = options;\n    return this;\n  }\n  load(url2, onLoad, onProgress, onError) {\n    if (url2 === void 0) url2 = \"\";\n    if (this.path !== void 0) url2 = this.path + url2;\n    url2 = this.manager.resolveURL(url2);\n    const scope = this;\n    const cached = Cache.get(url2);\n    if (cached !== void 0) {\n      scope.manager.itemStart(url2);\n      if (cached.then) {\n        cached.then((imageBitmap) => {\n          if (onLoad) onLoad(imageBitmap);\n          scope.manager.itemEnd(url2);\n        }).catch((e) => {\n          if (onError) onError(e);\n        });\n        return;\n      }\n      setTimeout(function() {\n        if (onLoad) onLoad(cached);\n        scope.manager.itemEnd(url2);\n      }, 0);\n      return cached;\n    }\n    const fetchOptions = {};\n    fetchOptions.credentials = this.crossOrigin === \"anonymous\" ? \"same-origin\" : \"include\";\n    fetchOptions.headers = this.requestHeader;\n    const promise = fetch(url2, fetchOptions).then(function(res) {\n      return res.blob();\n    }).then(function(blob2) {\n      return createImageBitmap(blob2, Object.assign(scope.options, { colorSpaceConversion: \"none\" }));\n    }).then(function(imageBitmap) {\n      Cache.add(url2, imageBitmap);\n      if (onLoad) onLoad(imageBitmap);\n      scope.manager.itemEnd(url2);\n      return imageBitmap;\n    }).catch(function(e) {\n      if (onError) onError(e);\n      Cache.remove(url2);\n      scope.manager.itemError(url2);\n      scope.manager.itemEnd(url2);\n    });\n    Cache.add(url2, promise);\n    scope.manager.itemStart(url2);\n  }\n}\nclass Clock {\n  constructor(autoStart = true) {\n    this.autoStart = autoStart;\n    this.startTime = 0;\n    this.oldTime = 0;\n    this.elapsedTime = 0;\n    this.running = false;\n  }\n  start() {\n    this.startTime = now();\n    this.oldTime = this.startTime;\n    this.elapsedTime = 0;\n    this.running = true;\n  }\n  stop() {\n    this.getElapsedTime();\n    this.running = false;\n    this.autoStart = false;\n  }\n  getElapsedTime() {\n    this.getDelta();\n    return this.elapsedTime;\n  }\n  getDelta() {\n    let diff = 0;\n    if (this.autoStart && !this.running) {\n      this.start();\n      return 0;\n    }\n    if (this.running) {\n      const newTime = now();\n      diff = (newTime - this.oldTime) / 1e3;\n      this.oldTime = newTime;\n      this.elapsedTime += diff;\n    }\n    return diff;\n  }\n}\nfunction now() {\n  return performance.now();\n}\nclass PropertyMixer {\n  constructor(binding, typeName, valueSize) {\n    this.binding = binding;\n    this.valueSize = valueSize;\n    let mixFunction, mixFunctionAdditive, setIdentity;\n    switch (typeName) {\n      case \"quaternion\":\n        mixFunction = this._slerp;\n        mixFunctionAdditive = this._slerpAdditive;\n        setIdentity = this._setAdditiveIdentityQuaternion;\n        this.buffer = new Float64Array(valueSize * 6);\n        this._workIndex = 5;\n        break;\n      case \"string\":\n      case \"bool\":\n        mixFunction = this._select;\n        mixFunctionAdditive = this._select;\n        setIdentity = this._setAdditiveIdentityOther;\n        this.buffer = new Array(valueSize * 5);\n        break;\n      default:\n        mixFunction = this._lerp;\n        mixFunctionAdditive = this._lerpAdditive;\n        setIdentity = this._setAdditiveIdentityNumeric;\n        this.buffer = new Float64Array(valueSize * 5);\n    }\n    this._mixBufferRegion = mixFunction;\n    this._mixBufferRegionAdditive = mixFunctionAdditive;\n    this._setIdentity = setIdentity;\n    this._origIndex = 3;\n    this._addIndex = 4;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n    this.useCount = 0;\n    this.referenceCount = 0;\n  }\n  // accumulate data in the 'incoming' region into 'accu<i>'\n  accumulate(accuIndex, weight) {\n    const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;\n    let currentWeight = this.cumulativeWeight;\n    if (currentWeight === 0) {\n      for (let i = 0; i !== stride; ++i) {\n        buffer[offset + i] = buffer[i];\n      }\n      currentWeight = weight;\n    } else {\n      currentWeight += weight;\n      const mix = weight / currentWeight;\n      this._mixBufferRegion(buffer, offset, 0, mix, stride);\n    }\n    this.cumulativeWeight = currentWeight;\n  }\n  // accumulate data in the 'incoming' region into 'add'\n  accumulateAdditive(weight) {\n    const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;\n    if (this.cumulativeWeightAdditive === 0) {\n      this._setIdentity();\n    }\n    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);\n    this.cumulativeWeightAdditive += weight;\n  }\n  // apply the state of 'accu<i>' to the binding when accus differ\n  apply(accuIndex) {\n    const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n    if (weight < 1) {\n      const originalValueOffset = stride * this._origIndex;\n      this._mixBufferRegion(\n        buffer,\n        offset,\n        originalValueOffset,\n        1 - weight,\n        stride\n      );\n    }\n    if (weightAdditive > 0) {\n      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);\n    }\n    for (let i = stride, e = stride + stride; i !== e; ++i) {\n      if (buffer[i] !== buffer[i + stride]) {\n        binding.setValue(buffer, offset);\n        break;\n      }\n    }\n  }\n  // remember the state of the bound property and copy it to both accus\n  saveOriginalState() {\n    const binding = this.binding;\n    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;\n    binding.getValue(buffer, originalValueOffset);\n    for (let i = stride, e = originalValueOffset; i !== e; ++i) {\n      buffer[i] = buffer[originalValueOffset + i % stride];\n    }\n    this._setIdentity();\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n  }\n  // apply the state previously taken via 'saveOriginalState' to the binding\n  restoreOriginalState() {\n    const originalValueOffset = this.valueSize * 3;\n    this.binding.setValue(this.buffer, originalValueOffset);\n  }\n  _setAdditiveIdentityNumeric() {\n    const startIndex = this._addIndex * this.valueSize;\n    const endIndex = startIndex + this.valueSize;\n    for (let i = startIndex; i < endIndex; i++) {\n      this.buffer[i] = 0;\n    }\n  }\n  _setAdditiveIdentityQuaternion() {\n    this._setAdditiveIdentityNumeric();\n    this.buffer[this._addIndex * this.valueSize + 3] = 1;\n  }\n  _setAdditiveIdentityOther() {\n    const startIndex = this._origIndex * this.valueSize;\n    const targetIndex = this._addIndex * this.valueSize;\n    for (let i = 0; i < this.valueSize; i++) {\n      this.buffer[targetIndex + i] = this.buffer[startIndex + i];\n    }\n  }\n  // mix functions\n  _select(buffer, dstOffset, srcOffset, t2, stride) {\n    if (t2 >= 0.5) {\n      for (let i = 0; i !== stride; ++i) {\n        buffer[dstOffset + i] = buffer[srcOffset + i];\n      }\n    }\n  }\n  _slerp(buffer, dstOffset, srcOffset, t2) {\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);\n  }\n  _slerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {\n    const workOffset = this._workIndex * stride;\n    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);\n  }\n  _lerp(buffer, dstOffset, srcOffset, t2, stride) {\n    const s = 1 - t2;\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t2;\n    }\n  }\n  _lerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n      buffer[j] = buffer[j] + buffer[srcOffset + i] * t2;\n    }\n  }\n}\nconst _RESERVED_CHARS_RE = \"\\\\[\\\\]\\\\.:\\\\/\";\nconst _reservedRe = new RegExp(\"[\" + _RESERVED_CHARS_RE + \"]\", \"g\");\nconst _wordChar = \"[^\" + _RESERVED_CHARS_RE + \"]\";\nconst _wordCharOrDot = \"[^\" + _RESERVED_CHARS_RE.replace(\"\\\\.\", \"\") + \"]\";\nconst _directoryRe = /* @__PURE__ */ /((?:WC+[\\/:])*)/.source.replace(\"WC\", _wordChar);\nconst _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace(\"WCOD\", _wordCharOrDot);\nconst _objectRe = /* @__PURE__ */ /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace(\"WC\", _wordChar);\nconst _propertyRe = /* @__PURE__ */ /\\.(WC+)(?:\\[(.+)\\])?/.source.replace(\"WC\", _wordChar);\nconst _trackRe = new RegExp(\n  \"^\" + _directoryRe + _nodeRe + _objectRe + _propertyRe + \"$\"\n);\nconst _supportedObjectNames = [\"material\", \"materials\", \"bones\", \"map\"];\nclass Composite {\n  constructor(targetGroup, path, optionalParsedPath) {\n    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);\n    this._targetGroup = targetGroup;\n    this._bindings = targetGroup.subscribe_(path, parsedPath);\n  }\n  getValue(array, offset) {\n    this.bind();\n    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];\n    if (binding !== void 0) binding.getValue(array, offset);\n  }\n  setValue(array, offset) {\n    const bindings = this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].setValue(array, offset);\n    }\n  }\n  bind() {\n    const bindings = this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].bind();\n    }\n  }\n  unbind() {\n    const bindings = this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].unbind();\n    }\n  }\n}\nclass PropertyBinding {\n  constructor(rootNode, path, parsedPath) {\n    this.path = path;\n    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\n    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);\n    this.rootNode = rootNode;\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n  static create(root, path, parsedPath) {\n    if (!(root && root.isAnimationObjectGroup)) {\n      return new PropertyBinding(root, path, parsedPath);\n    } else {\n      return new PropertyBinding.Composite(root, path, parsedPath);\n    }\n  }\n  /**\n   * Replaces spaces with underscores and removes unsupported characters from\n   * node names, to ensure compatibility with parseTrackName().\n   *\n   * @param {string} name Node name to be sanitized.\n   * @return {string}\n   */\n  static sanitizeNodeName(name) {\n    return name.replace(/\\s/g, \"_\").replace(_reservedRe, \"\");\n  }\n  static parseTrackName(trackName) {\n    const matches = _trackRe.exec(trackName);\n    if (matches === null) {\n      throw new Error(\"PropertyBinding: Cannot parse trackName: \" + trackName);\n    }\n    const results = {\n      // directoryName: matches[ 1 ], // (tschw) currently unused\n      nodeName: matches[2],\n      objectName: matches[3],\n      objectIndex: matches[4],\n      propertyName: matches[5],\n      // required\n      propertyIndex: matches[6]\n    };\n    const lastDot = results.nodeName && results.nodeName.lastIndexOf(\".\");\n    if (lastDot !== void 0 && lastDot !== -1) {\n      const objectName = results.nodeName.substring(lastDot + 1);\n      if (_supportedObjectNames.indexOf(objectName) !== -1) {\n        results.nodeName = results.nodeName.substring(0, lastDot);\n        results.objectName = objectName;\n      }\n    }\n    if (results.propertyName === null || results.propertyName.length === 0) {\n      throw new Error(\"PropertyBinding: can not parse propertyName from trackName: \" + trackName);\n    }\n    return results;\n  }\n  static findNode(root, nodeName) {\n    if (nodeName === void 0 || nodeName === \"\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {\n      return root;\n    }\n    if (root.skeleton) {\n      const bone = root.skeleton.getBoneByName(nodeName);\n      if (bone !== void 0) {\n        return bone;\n      }\n    }\n    if (root.children) {\n      const searchNodeSubtree = function(children) {\n        for (let i = 0; i < children.length; i++) {\n          const childNode = children[i];\n          if (childNode.name === nodeName || childNode.uuid === nodeName) {\n            return childNode;\n          }\n          const result = searchNodeSubtree(childNode.children);\n          if (result) return result;\n        }\n        return null;\n      };\n      const subTreeNode = searchNodeSubtree(root.children);\n      if (subTreeNode) {\n        return subTreeNode;\n      }\n    }\n    return null;\n  }\n  // these are used to \"bind\" a nonexistent property\n  _getValue_unavailable() {\n  }\n  _setValue_unavailable() {\n  }\n  // Getters\n  _getValue_direct(buffer, offset) {\n    buffer[offset] = this.targetObject[this.propertyName];\n  }\n  _getValue_array(buffer, offset) {\n    const source = this.resolvedProperty;\n    for (let i = 0, n = source.length; i !== n; ++i) {\n      buffer[offset++] = source[i];\n    }\n  }\n  _getValue_arrayElement(buffer, offset) {\n    buffer[offset] = this.resolvedProperty[this.propertyIndex];\n  }\n  _getValue_toArray(buffer, offset) {\n    this.resolvedProperty.toArray(buffer, offset);\n  }\n  // Direct\n  _setValue_direct(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n  }\n  _setValue_direct_setNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  // EntireArray\n  _setValue_array(buffer, offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n  }\n  _setValue_array_setNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  // ArrayElement\n  _setValue_arrayElement(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n  }\n  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  // HasToFromArray\n  _setValue_fromArray(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n  }\n  _setValue_fromArray_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  _getValue_unbound(targetArray, offset) {\n    this.bind();\n    this.getValue(targetArray, offset);\n  }\n  _setValue_unbound(sourceArray, offset) {\n    this.bind();\n    this.setValue(sourceArray, offset);\n  }\n  // create getter / setter pair for a property in the scene graph\n  bind() {\n    let targetObject = this.node;\n    const parsedPath = this.parsedPath;\n    const objectName = parsedPath.objectName;\n    const propertyName = parsedPath.propertyName;\n    let propertyIndex = parsedPath.propertyIndex;\n    if (!targetObject) {\n      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);\n      this.node = targetObject;\n    }\n    this.getValue = this._getValue_unavailable;\n    this.setValue = this._setValue_unavailable;\n    if (!targetObject) {\n      console.warn(\"THREE.PropertyBinding: No target node found for track: \" + this.path + \".\");\n      return;\n    }\n    if (objectName) {\n      let objectIndex = parsedPath.objectIndex;\n      switch (objectName) {\n        case \"materials\":\n          if (!targetObject.material) {\n            console.error(\"THREE.PropertyBinding: Can not bind to material as node does not have a material.\", this);\n            return;\n          }\n          if (!targetObject.material.materials) {\n            console.error(\"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.\", this);\n            return;\n          }\n          targetObject = targetObject.material.materials;\n          break;\n        case \"bones\":\n          if (!targetObject.skeleton) {\n            console.error(\"THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.\", this);\n            return;\n          }\n          targetObject = targetObject.skeleton.bones;\n          for (let i = 0; i < targetObject.length; i++) {\n            if (targetObject[i].name === objectIndex) {\n              objectIndex = i;\n              break;\n            }\n          }\n          break;\n        case \"map\":\n          if (\"map\" in targetObject) {\n            targetObject = targetObject.map;\n            break;\n          }\n          if (!targetObject.material) {\n            console.error(\"THREE.PropertyBinding: Can not bind to material as node does not have a material.\", this);\n            return;\n          }\n          if (!targetObject.material.map) {\n            console.error(\"THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.\", this);\n            return;\n          }\n          targetObject = targetObject.material.map;\n          break;\n        default:\n          if (targetObject[objectName] === void 0) {\n            console.error(\"THREE.PropertyBinding: Can not bind to objectName of node undefined.\", this);\n            return;\n          }\n          targetObject = targetObject[objectName];\n      }\n      if (objectIndex !== void 0) {\n        if (targetObject[objectIndex] === void 0) {\n          console.error(\"THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.\", this, targetObject);\n          return;\n        }\n        targetObject = targetObject[objectIndex];\n      }\n    }\n    const nodeProperty = targetObject[propertyName];\n    if (nodeProperty === void 0) {\n      const nodeName = parsedPath.nodeName;\n      console.error(\"THREE.PropertyBinding: Trying to update property for track: \" + nodeName + \".\" + propertyName + \" but it wasn't found.\", targetObject);\n      return;\n    }\n    let versioning = this.Versioning.None;\n    this.targetObject = targetObject;\n    if (targetObject.needsUpdate !== void 0) {\n      versioning = this.Versioning.NeedsUpdate;\n    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {\n      versioning = this.Versioning.MatrixWorldNeedsUpdate;\n    }\n    let bindingType = this.BindingType.Direct;\n    if (propertyIndex !== void 0) {\n      if (propertyName === \"morphTargetInfluences\") {\n        if (!targetObject.geometry) {\n          console.error(\"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.\", this);\n          return;\n        }\n        if (!targetObject.geometry.morphAttributes) {\n          console.error(\"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.\", this);\n          return;\n        }\n        if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {\n          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n        }\n      }\n      bindingType = this.BindingType.ArrayElement;\n      this.resolvedProperty = nodeProperty;\n      this.propertyIndex = propertyIndex;\n    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {\n      bindingType = this.BindingType.HasFromToArray;\n      this.resolvedProperty = nodeProperty;\n    } else if (Array.isArray(nodeProperty)) {\n      bindingType = this.BindingType.EntireArray;\n      this.resolvedProperty = nodeProperty;\n    } else {\n      this.propertyName = propertyName;\n    }\n    this.getValue = this.GetterByBindingType[bindingType];\n    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n  }\n  unbind() {\n    this.node = null;\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n}\nPropertyBinding.Composite = Composite;\nPropertyBinding.prototype.BindingType = {\n  Direct: 0,\n  EntireArray: 1,\n  ArrayElement: 2,\n  HasFromToArray: 3\n};\nPropertyBinding.prototype.Versioning = {\n  None: 0,\n  NeedsUpdate: 1,\n  MatrixWorldNeedsUpdate: 2\n};\nPropertyBinding.prototype.GetterByBindingType = [\n  PropertyBinding.prototype._getValue_direct,\n  PropertyBinding.prototype._getValue_array,\n  PropertyBinding.prototype._getValue_arrayElement,\n  PropertyBinding.prototype._getValue_toArray\n];\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n  [\n    // Direct\n    PropertyBinding.prototype._setValue_direct,\n    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate\n  ],\n  [\n    // EntireArray\n    PropertyBinding.prototype._setValue_array,\n    PropertyBinding.prototype._setValue_array_setNeedsUpdate,\n    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate\n  ],\n  [\n    // ArrayElement\n    PropertyBinding.prototype._setValue_arrayElement,\n    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate\n  ],\n  [\n    // HasToFromArray\n    PropertyBinding.prototype._setValue_fromArray,\n    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate\n  ]\n];\nclass AnimationAction {\n  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {\n    this._mixer = mixer;\n    this._clip = clip;\n    this._localRoot = localRoot;\n    this.blendMode = blendMode;\n    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);\n    const interpolantSettings = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding\n    };\n    for (let i = 0; i !== nTracks; ++i) {\n      const interpolant = tracks[i].createInterpolant(null);\n      interpolants[i] = interpolant;\n      interpolant.settings = interpolantSettings;\n    }\n    this._interpolantSettings = interpolantSettings;\n    this._interpolants = interpolants;\n    this._propertyBindings = new Array(nTracks);\n    this._cacheIndex = null;\n    this._byClipCacheIndex = null;\n    this._timeScaleInterpolant = null;\n    this._weightInterpolant = null;\n    this.loop = LoopRepeat;\n    this._loopCount = -1;\n    this._startTime = null;\n    this.time = 0;\n    this.timeScale = 1;\n    this._effectiveTimeScale = 1;\n    this.weight = 1;\n    this._effectiveWeight = 1;\n    this.repetitions = Infinity;\n    this.paused = false;\n    this.enabled = true;\n    this.clampWhenFinished = false;\n    this.zeroSlopeAtStart = true;\n    this.zeroSlopeAtEnd = true;\n  }\n  // State & Scheduling\n  play() {\n    this._mixer._activateAction(this);\n    return this;\n  }\n  stop() {\n    this._mixer._deactivateAction(this);\n    return this.reset();\n  }\n  reset() {\n    this.paused = false;\n    this.enabled = true;\n    this.time = 0;\n    this._loopCount = -1;\n    this._startTime = null;\n    return this.stopFading().stopWarping();\n  }\n  isRunning() {\n    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);\n  }\n  // return true when play has been called\n  isScheduled() {\n    return this._mixer._isActiveAction(this);\n  }\n  startAt(time) {\n    this._startTime = time;\n    return this;\n  }\n  setLoop(mode, repetitions) {\n    this.loop = mode;\n    this.repetitions = repetitions;\n    return this;\n  }\n  // Weight\n  // set the weight stopping any scheduled fading\n  // although .enabled = false yields an effective weight of zero, this\n  // method does *not* change .enabled, because it would be confusing\n  setEffectiveWeight(weight) {\n    this.weight = weight;\n    this._effectiveWeight = this.enabled ? weight : 0;\n    return this.stopFading();\n  }\n  // return the weight considering fading and .enabled\n  getEffectiveWeight() {\n    return this._effectiveWeight;\n  }\n  fadeIn(duration) {\n    return this._scheduleFading(duration, 0, 1);\n  }\n  fadeOut(duration) {\n    return this._scheduleFading(duration, 1, 0);\n  }\n  crossFadeFrom(fadeOutAction, duration, warp) {\n    fadeOutAction.fadeOut(duration);\n    this.fadeIn(duration);\n    if (warp) {\n      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;\n      fadeOutAction.warp(1, startEndRatio, duration);\n      this.warp(endStartRatio, 1, duration);\n    }\n    return this;\n  }\n  crossFadeTo(fadeInAction, duration, warp) {\n    return fadeInAction.crossFadeFrom(this, duration, warp);\n  }\n  stopFading() {\n    const weightInterpolant = this._weightInterpolant;\n    if (weightInterpolant !== null) {\n      this._weightInterpolant = null;\n      this._mixer._takeBackControlInterpolant(weightInterpolant);\n    }\n    return this;\n  }\n  // Time Scale Control\n  // set the time scale stopping any scheduled warping\n  // although .paused = true yields an effective time scale of zero, this\n  // method does *not* change .paused, because it would be confusing\n  setEffectiveTimeScale(timeScale) {\n    this.timeScale = timeScale;\n    this._effectiveTimeScale = this.paused ? 0 : timeScale;\n    return this.stopWarping();\n  }\n  // return the time scale considering warping and .paused\n  getEffectiveTimeScale() {\n    return this._effectiveTimeScale;\n  }\n  setDuration(duration) {\n    this.timeScale = this._clip.duration / duration;\n    return this.stopWarping();\n  }\n  syncWith(action) {\n    this.time = action.time;\n    this.timeScale = action.timeScale;\n    return this.stopWarping();\n  }\n  halt(duration) {\n    return this.warp(this._effectiveTimeScale, 0, duration);\n  }\n  warp(startTimeScale, endTimeScale, duration) {\n    const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;\n    let interpolant = this._timeScaleInterpolant;\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._timeScaleInterpolant = interpolant;\n    }\n    const times = interpolant.parameterPositions, values = interpolant.sampleValues;\n    times[0] = now2;\n    times[1] = now2 + duration;\n    values[0] = startTimeScale / timeScale;\n    values[1] = endTimeScale / timeScale;\n    return this;\n  }\n  stopWarping() {\n    const timeScaleInterpolant = this._timeScaleInterpolant;\n    if (timeScaleInterpolant !== null) {\n      this._timeScaleInterpolant = null;\n      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);\n    }\n    return this;\n  }\n  // Object Accessors\n  getMixer() {\n    return this._mixer;\n  }\n  getClip() {\n    return this._clip;\n  }\n  getRoot() {\n    return this._localRoot || this._mixer._root;\n  }\n  // Interna\n  _update(time, deltaTime, timeDirection, accuIndex) {\n    if (!this.enabled) {\n      this._updateWeight(time);\n      return;\n    }\n    const startTime = this._startTime;\n    if (startTime !== null) {\n      const timeRunning = (time - startTime) * timeDirection;\n      if (timeRunning < 0 || timeDirection === 0) {\n        deltaTime = 0;\n      } else {\n        this._startTime = null;\n        deltaTime = timeDirection * timeRunning;\n      }\n    }\n    deltaTime *= this._updateTimeScale(time);\n    const clipTime = this._updateTime(deltaTime);\n    const weight = this._updateWeight(time);\n    if (weight > 0) {\n      const interpolants = this._interpolants;\n      const propertyMixers = this._propertyBindings;\n      switch (this.blendMode) {\n        case AdditiveAnimationBlendMode:\n          for (let j = 0, m = interpolants.length; j !== m; ++j) {\n            interpolants[j].evaluate(clipTime);\n            propertyMixers[j].accumulateAdditive(weight);\n          }\n          break;\n        case NormalAnimationBlendMode:\n        default:\n          for (let j = 0, m = interpolants.length; j !== m; ++j) {\n            interpolants[j].evaluate(clipTime);\n            propertyMixers[j].accumulate(accuIndex, weight);\n          }\n      }\n    }\n  }\n  _updateWeight(time) {\n    let weight = 0;\n    if (this.enabled) {\n      weight = this.weight;\n      const interpolant = this._weightInterpolant;\n      if (interpolant !== null) {\n        const interpolantValue = interpolant.evaluate(time)[0];\n        weight *= interpolantValue;\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopFading();\n          if (interpolantValue === 0) {\n            this.enabled = false;\n          }\n        }\n      }\n    }\n    this._effectiveWeight = weight;\n    return weight;\n  }\n  _updateTimeScale(time) {\n    let timeScale = 0;\n    if (!this.paused) {\n      timeScale = this.timeScale;\n      const interpolant = this._timeScaleInterpolant;\n      if (interpolant !== null) {\n        const interpolantValue = interpolant.evaluate(time)[0];\n        timeScale *= interpolantValue;\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopWarping();\n          if (timeScale === 0) {\n            this.paused = true;\n          } else {\n            this.timeScale = timeScale;\n          }\n        }\n      }\n    }\n    this._effectiveTimeScale = timeScale;\n    return timeScale;\n  }\n  _updateTime(deltaTime) {\n    const duration = this._clip.duration;\n    const loop = this.loop;\n    let time = this.time + deltaTime;\n    let loopCount = this._loopCount;\n    const pingPong = loop === LoopPingPong;\n    if (deltaTime === 0) {\n      if (loopCount === -1) return time;\n      return pingPong && (loopCount & 1) === 1 ? duration - time : time;\n    }\n    if (loop === LoopOnce) {\n      if (loopCount === -1) {\n        this._loopCount = 0;\n        this._setEndings(true, true, false);\n      }\n      handle_stop: {\n        if (time >= duration) {\n          time = duration;\n        } else if (time < 0) {\n          time = 0;\n        } else {\n          this.time = time;\n          break handle_stop;\n        }\n        if (this.clampWhenFinished) this.paused = true;\n        else this.enabled = false;\n        this.time = time;\n        this._mixer.dispatchEvent({\n          type: \"finished\",\n          action: this,\n          direction: deltaTime < 0 ? -1 : 1\n        });\n      }\n    } else {\n      if (loopCount === -1) {\n        if (deltaTime >= 0) {\n          loopCount = 0;\n          this._setEndings(true, this.repetitions === 0, pingPong);\n        } else {\n          this._setEndings(this.repetitions === 0, true, pingPong);\n        }\n      }\n      if (time >= duration || time < 0) {\n        const loopDelta = Math.floor(time / duration);\n        time -= duration * loopDelta;\n        loopCount += Math.abs(loopDelta);\n        const pending = this.repetitions - loopCount;\n        if (pending <= 0) {\n          if (this.clampWhenFinished) this.paused = true;\n          else this.enabled = false;\n          time = deltaTime > 0 ? duration : 0;\n          this.time = time;\n          this._mixer.dispatchEvent({\n            type: \"finished\",\n            action: this,\n            direction: deltaTime > 0 ? 1 : -1\n          });\n        } else {\n          if (pending === 1) {\n            const atStart = deltaTime < 0;\n            this._setEndings(atStart, !atStart, pingPong);\n          } else {\n            this._setEndings(false, false, pingPong);\n          }\n          this._loopCount = loopCount;\n          this.time = time;\n          this._mixer.dispatchEvent({\n            type: \"loop\",\n            action: this,\n            loopDelta\n          });\n        }\n      } else {\n        this.time = time;\n      }\n      if (pingPong && (loopCount & 1) === 1) {\n        return duration - time;\n      }\n    }\n    return time;\n  }\n  _setEndings(atStart, atEnd, pingPong) {\n    const settings = this._interpolantSettings;\n    if (pingPong) {\n      settings.endingStart = ZeroSlopeEnding;\n      settings.endingEnd = ZeroSlopeEnding;\n    } else {\n      if (atStart) {\n        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n      } else {\n        settings.endingStart = WrapAroundEnding;\n      }\n      if (atEnd) {\n        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n      } else {\n        settings.endingEnd = WrapAroundEnding;\n      }\n    }\n  }\n  _scheduleFading(duration, weightNow, weightThen) {\n    const mixer = this._mixer, now2 = mixer.time;\n    let interpolant = this._weightInterpolant;\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._weightInterpolant = interpolant;\n    }\n    const times = interpolant.parameterPositions, values = interpolant.sampleValues;\n    times[0] = now2;\n    values[0] = weightNow;\n    times[1] = now2 + duration;\n    values[1] = weightThen;\n    return this;\n  }\n}\nconst _controlInterpolantsResultBuffer = new Float32Array(1);\nclass AnimationMixer extends EventDispatcher {\n  constructor(root) {\n    super();\n    this._root = root;\n    this._initMemoryManager();\n    this._accuIndex = 0;\n    this.time = 0;\n    this.timeScale = 1;\n  }\n  _bindAction(action, prototypeAction) {\n    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;\n    let bindingsByName = bindingsByRoot[rootUuid];\n    if (bindingsByName === void 0) {\n      bindingsByName = {};\n      bindingsByRoot[rootUuid] = bindingsByName;\n    }\n    for (let i = 0; i !== nTracks; ++i) {\n      const track = tracks[i], trackName = track.name;\n      let binding = bindingsByName[trackName];\n      if (binding !== void 0) {\n        ++binding.referenceCount;\n        bindings[i] = binding;\n      } else {\n        binding = bindings[i];\n        if (binding !== void 0) {\n          if (binding._cacheIndex === null) {\n            ++binding.referenceCount;\n            this._addInactiveBinding(binding, rootUuid, trackName);\n          }\n          continue;\n        }\n        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;\n        binding = new PropertyMixer(\n          PropertyBinding.create(root, trackName, path),\n          track.ValueTypeName,\n          track.getValueSize()\n        );\n        ++binding.referenceCount;\n        this._addInactiveBinding(binding, rootUuid, trackName);\n        bindings[i] = binding;\n      }\n      interpolants[i].resultBuffer = binding.buffer;\n    }\n  }\n  _activateAction(action) {\n    if (!this._isActiveAction(action)) {\n      if (action._cacheIndex === null) {\n        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];\n        this._bindAction(\n          action,\n          actionsForClip && actionsForClip.knownActions[0]\n        );\n        this._addInactiveAction(action, clipUuid, rootUuid);\n      }\n      const bindings = action._propertyBindings;\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n        if (binding.useCount++ === 0) {\n          this._lendBinding(binding);\n          binding.saveOriginalState();\n        }\n      }\n      this._lendAction(action);\n    }\n  }\n  _deactivateAction(action) {\n    if (this._isActiveAction(action)) {\n      const bindings = action._propertyBindings;\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n        if (--binding.useCount === 0) {\n          binding.restoreOriginalState();\n          this._takeBackBinding(binding);\n        }\n      }\n      this._takeBackAction(action);\n    }\n  }\n  // Memory manager\n  _initMemoryManager() {\n    this._actions = [];\n    this._nActiveActions = 0;\n    this._actionsByClip = {};\n    this._bindings = [];\n    this._nActiveBindings = 0;\n    this._bindingsByRootAndName = {};\n    this._controlInterpolants = [];\n    this._nActiveControlInterpolants = 0;\n    const scope = this;\n    this.stats = {\n      actions: {\n        get total() {\n          return scope._actions.length;\n        },\n        get inUse() {\n          return scope._nActiveActions;\n        }\n      },\n      bindings: {\n        get total() {\n          return scope._bindings.length;\n        },\n        get inUse() {\n          return scope._nActiveBindings;\n        }\n      },\n      controlInterpolants: {\n        get total() {\n          return scope._controlInterpolants.length;\n        },\n        get inUse() {\n          return scope._nActiveControlInterpolants;\n        }\n      }\n    };\n  }\n  // Memory management for AnimationAction objects\n  _isActiveAction(action) {\n    const index = action._cacheIndex;\n    return index !== null && index < this._nActiveActions;\n  }\n  _addInactiveAction(action, clipUuid, rootUuid) {\n    const actions = this._actions, actionsByClip = this._actionsByClip;\n    let actionsForClip = actionsByClip[clipUuid];\n    if (actionsForClip === void 0) {\n      actionsForClip = {\n        knownActions: [action],\n        actionByRoot: {}\n      };\n      action._byClipCacheIndex = 0;\n      actionsByClip[clipUuid] = actionsForClip;\n    } else {\n      const knownActions = actionsForClip.knownActions;\n      action._byClipCacheIndex = knownActions.length;\n      knownActions.push(action);\n    }\n    action._cacheIndex = actions.length;\n    actions.push(action);\n    actionsForClip.actionByRoot[rootUuid] = action;\n  }\n  _removeInactiveAction(action) {\n    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;\n    lastInactiveAction._cacheIndex = cacheIndex;\n    actions[cacheIndex] = lastInactiveAction;\n    actions.pop();\n    action._cacheIndex = null;\n    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;\n    lastKnownAction._byClipCacheIndex = byClipCacheIndex;\n    knownActionsForClip[byClipCacheIndex] = lastKnownAction;\n    knownActionsForClip.pop();\n    action._byClipCacheIndex = null;\n    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;\n    delete actionByRoot[rootUuid];\n    if (knownActionsForClip.length === 0) {\n      delete actionsByClip[clipUuid];\n    }\n    this._removeInactiveBindingsForAction(action);\n  }\n  _removeInactiveBindingsForAction(action) {\n    const bindings = action._propertyBindings;\n    for (let i = 0, n = bindings.length; i !== n; ++i) {\n      const binding = bindings[i];\n      if (--binding.referenceCount === 0) {\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n  _lendAction(action) {\n    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];\n    action._cacheIndex = lastActiveIndex;\n    actions[lastActiveIndex] = action;\n    firstInactiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = firstInactiveAction;\n  }\n  _takeBackAction(action) {\n    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];\n    action._cacheIndex = firstInactiveIndex;\n    actions[firstInactiveIndex] = action;\n    lastActiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = lastActiveAction;\n  }\n  // Memory management for PropertyMixer objects\n  _addInactiveBinding(binding, rootUuid, trackName) {\n    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;\n    let bindingByName = bindingsByRoot[rootUuid];\n    if (bindingByName === void 0) {\n      bindingByName = {};\n      bindingsByRoot[rootUuid] = bindingByName;\n    }\n    bindingByName[trackName] = binding;\n    binding._cacheIndex = bindings.length;\n    bindings.push(binding);\n  }\n  _removeInactiveBinding(binding) {\n    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;\n    lastInactiveBinding._cacheIndex = cacheIndex;\n    bindings[cacheIndex] = lastInactiveBinding;\n    bindings.pop();\n    delete bindingByName[trackName];\n    if (Object.keys(bindingByName).length === 0) {\n      delete bindingsByRoot[rootUuid];\n    }\n  }\n  _lendBinding(binding) {\n    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];\n    binding._cacheIndex = lastActiveIndex;\n    bindings[lastActiveIndex] = binding;\n    firstInactiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = firstInactiveBinding;\n  }\n  _takeBackBinding(binding) {\n    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];\n    binding._cacheIndex = firstInactiveIndex;\n    bindings[firstInactiveIndex] = binding;\n    lastActiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = lastActiveBinding;\n  }\n  // Memory management of Interpolants for weight and time scale\n  _lendControlInterpolant() {\n    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;\n    let interpolant = interpolants[lastActiveIndex];\n    if (interpolant === void 0) {\n      interpolant = new LinearInterpolant(\n        new Float32Array(2),\n        new Float32Array(2),\n        1,\n        _controlInterpolantsResultBuffer\n      );\n      interpolant.__cacheIndex = lastActiveIndex;\n      interpolants[lastActiveIndex] = interpolant;\n    }\n    return interpolant;\n  }\n  _takeBackControlInterpolant(interpolant) {\n    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];\n    interpolant.__cacheIndex = firstInactiveIndex;\n    interpolants[firstInactiveIndex] = interpolant;\n    lastActiveInterpolant.__cacheIndex = prevIndex;\n    interpolants[prevIndex] = lastActiveInterpolant;\n  }\n  // return an action for a clip optionally using a custom root target\n  // object (this method allocates a lot of dynamic memory in case a\n  // previously unknown clip/root combination is specified)\n  clipAction(clip, optionalRoot, blendMode) {\n    const root = optionalRoot || this._root, rootUuid = root.uuid;\n    let clipObject = typeof clip === \"string\" ? AnimationClip.findByName(root, clip) : clip;\n    const clipUuid = clipObject !== null ? clipObject.uuid : clip;\n    const actionsForClip = this._actionsByClip[clipUuid];\n    let prototypeAction = null;\n    if (blendMode === void 0) {\n      if (clipObject !== null) {\n        blendMode = clipObject.blendMode;\n      } else {\n        blendMode = NormalAnimationBlendMode;\n      }\n    }\n    if (actionsForClip !== void 0) {\n      const existingAction = actionsForClip.actionByRoot[rootUuid];\n      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {\n        return existingAction;\n      }\n      prototypeAction = actionsForClip.knownActions[0];\n      if (clipObject === null)\n        clipObject = prototypeAction._clip;\n    }\n    if (clipObject === null) return null;\n    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);\n    this._bindAction(newAction, prototypeAction);\n    this._addInactiveAction(newAction, clipUuid, rootUuid);\n    return newAction;\n  }\n  // get an existing action\n  existingAction(clip, optionalRoot) {\n    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === \"string\" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];\n    if (actionsForClip !== void 0) {\n      return actionsForClip.actionByRoot[rootUuid] || null;\n    }\n    return null;\n  }\n  // deactivates all previously scheduled actions\n  stopAllAction() {\n    const actions = this._actions, nActions = this._nActiveActions;\n    for (let i = nActions - 1; i >= 0; --i) {\n      actions[i].stop();\n    }\n    return this;\n  }\n  // advance the time and update apply the animation\n  update(deltaTime) {\n    deltaTime *= this.timeScale;\n    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;\n    for (let i = 0; i !== nActions; ++i) {\n      const action = actions[i];\n      action._update(time, deltaTime, timeDirection, accuIndex);\n    }\n    const bindings = this._bindings, nBindings = this._nActiveBindings;\n    for (let i = 0; i !== nBindings; ++i) {\n      bindings[i].apply(accuIndex);\n    }\n    return this;\n  }\n  // Allows you to seek to a specific time in an animation.\n  setTime(timeInSeconds) {\n    this.time = 0;\n    for (let i = 0; i < this._actions.length; i++) {\n      this._actions[i].time = 0;\n    }\n    return this.update(timeInSeconds);\n  }\n  // return this mixer's root target object\n  getRoot() {\n    return this._root;\n  }\n  // free all resources specific to a particular clip\n  uncacheClip(clip) {\n    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];\n    if (actionsForClip !== void 0) {\n      const actionsToRemove = actionsForClip.knownActions;\n      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {\n        const action = actionsToRemove[i];\n        this._deactivateAction(action);\n        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];\n        action._cacheIndex = null;\n        action._byClipCacheIndex = null;\n        lastInactiveAction._cacheIndex = cacheIndex;\n        actions[cacheIndex] = lastInactiveAction;\n        actions.pop();\n        this._removeInactiveBindingsForAction(action);\n      }\n      delete actionsByClip[clipUuid];\n    }\n  }\n  // free all resources specific to a particular root target object\n  uncacheRoot(root) {\n    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;\n    for (const clipUuid in actionsByClip) {\n      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];\n      if (action !== void 0) {\n        this._deactivateAction(action);\n        this._removeInactiveAction(action);\n      }\n    }\n    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];\n    if (bindingByName !== void 0) {\n      for (const trackName in bindingByName) {\n        const binding = bindingByName[trackName];\n        binding.restoreOriginalState();\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n  // remove a targeted clip from the cache\n  uncacheAction(clip, optionalRoot) {\n    const action = this.existingAction(clip, optionalRoot);\n    if (action !== null) {\n      this._deactivateAction(action);\n      this._removeInactiveAction(action);\n    }\n  }\n}\nclass InstancedInterleavedBuffer extends InterleavedBuffer {\n  constructor(array, stride, meshPerAttribute = 1) {\n    super(array, stride);\n    this.isInstancedInterleavedBuffer = true;\n    this.meshPerAttribute = meshPerAttribute;\n  }\n  copy(source) {\n    super.copy(source);\n    this.meshPerAttribute = source.meshPerAttribute;\n    return this;\n  }\n  clone(data) {\n    const ib = super.clone(data);\n    ib.meshPerAttribute = this.meshPerAttribute;\n    return ib;\n  }\n  toJSON(data) {\n    const json = super.toJSON(data);\n    json.isInstancedInterleavedBuffer = true;\n    json.meshPerAttribute = this.meshPerAttribute;\n    return json;\n  }\n}\nconst _matrix = /* @__PURE__ */ new Matrix4();\nclass Raycaster {\n  constructor(origin, direction, near = 0, far = Infinity) {\n    this.ray = new Ray(origin, direction);\n    this.near = near;\n    this.far = far;\n    this.camera = null;\n    this.layers = new Layers();\n    this.params = {\n      Mesh: {},\n      Line: { threshold: 1 },\n      LOD: {},\n      Points: { threshold: 1 },\n      Sprite: {}\n    };\n  }\n  set(origin, direction) {\n    this.ray.set(origin, direction);\n  }\n  setFromCamera(coords, camera) {\n    if (camera.isPerspectiveCamera) {\n      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\n      this.camera = camera;\n    } else if (camera.isOrthographicCamera) {\n      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);\n      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n      this.camera = camera;\n    } else {\n      console.error(\"THREE.Raycaster: Unsupported camera type: \" + camera.type);\n    }\n  }\n  setFromXRController(controller) {\n    _matrix.identity().extractRotation(controller.matrixWorld);\n    this.ray.origin.setFromMatrixPosition(controller.matrixWorld);\n    this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);\n    return this;\n  }\n  intersectObject(object, recursive = true, intersects2 = []) {\n    intersect(object, this, intersects2, recursive);\n    intersects2.sort(ascSort);\n    return intersects2;\n  }\n  intersectObjects(objects, recursive = true, intersects2 = []) {\n    for (let i = 0, l = objects.length; i < l; i++) {\n      intersect(objects[i], this, intersects2, recursive);\n    }\n    intersects2.sort(ascSort);\n    return intersects2;\n  }\n}\nfunction ascSort(a, b) {\n  return a.distance - b.distance;\n}\nfunction intersect(object, raycaster, intersects2, recursive) {\n  let propagate = true;\n  if (object.layers.test(raycaster.layers)) {\n    const result = object.raycast(raycaster, intersects2);\n    if (result === false) propagate = false;\n  }\n  if (propagate === true && recursive === true) {\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      intersect(children[i], raycaster, intersects2, true);\n    }\n  }\n}\nclass Spherical {\n  constructor(radius = 1, phi = 0, theta = 0) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this;\n  }\n  set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this;\n  }\n  copy(other) {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n    return this;\n  }\n  // restrict phi to be between EPS and PI-EPS\n  makeSafe() {\n    const EPS = 1e-6;\n    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));\n    return this;\n  }\n  setFromVector3(v) {\n    return this.setFromCartesianCoords(v.x, v.y, v.z);\n  }\n  setFromCartesianCoords(x, y, z) {\n    this.radius = Math.sqrt(x * x + y * y + z * z);\n    if (this.radius === 0) {\n      this.theta = 0;\n      this.phi = 0;\n    } else {\n      this.theta = Math.atan2(x, z);\n      this.phi = Math.acos(clamp(y / this.radius, -1, 1));\n    }\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nconst _startP = /* @__PURE__ */ new Vector3();\nconst _startEnd = /* @__PURE__ */ new Vector3();\nclass Line3 {\n  constructor(start = new Vector3(), end = new Vector3()) {\n    this.start = start;\n    this.end = end;\n  }\n  set(start, end) {\n    this.start.copy(start);\n    this.end.copy(end);\n    return this;\n  }\n  copy(line) {\n    this.start.copy(line.start);\n    this.end.copy(line.end);\n    return this;\n  }\n  getCenter(target) {\n    return target.addVectors(this.start, this.end).multiplyScalar(0.5);\n  }\n  delta(target) {\n    return target.subVectors(this.end, this.start);\n  }\n  distanceSq() {\n    return this.start.distanceToSquared(this.end);\n  }\n  distance() {\n    return this.start.distanceTo(this.end);\n  }\n  at(t2, target) {\n    return this.delta(target).multiplyScalar(t2).add(this.start);\n  }\n  closestPointToPointParameter(point, clampToLine) {\n    _startP.subVectors(point, this.start);\n    _startEnd.subVectors(this.end, this.start);\n    const startEnd2 = _startEnd.dot(_startEnd);\n    const startEnd_startP = _startEnd.dot(_startP);\n    let t2 = startEnd_startP / startEnd2;\n    if (clampToLine) {\n      t2 = clamp(t2, 0, 1);\n    }\n    return t2;\n  }\n  closestPointToPoint(point, clampToLine, target) {\n    const t2 = this.closestPointToPointParameter(point, clampToLine);\n    return this.delta(target).multiplyScalar(t2).add(this.start);\n  }\n  applyMatrix4(matrix) {\n    this.start.applyMatrix4(matrix);\n    this.end.applyMatrix4(matrix);\n    return this;\n  }\n  equals(line) {\n    return line.start.equals(this.start) && line.end.equals(this.end);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nclass GridHelper extends LineSegments {\n  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {\n    color1 = new Color(color1);\n    color2 = new Color(color2);\n    const center = divisions / 2;\n    const step = size / divisions;\n    const halfSize = size / 2;\n    const vertices = [], colors = [];\n    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {\n      vertices.push(-halfSize, 0, k, halfSize, 0, k);\n      vertices.push(k, 0, -halfSize, k, 0, halfSize);\n      const color = i === center ? color1 : color2;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"color\", new Float32BufferAttribute(colors, 3));\n    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });\n    super(geometry, material);\n    this.type = \"GridHelper\";\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}\nclass Controls extends EventDispatcher {\n  constructor(object, domElement = null) {\n    super();\n    this.object = object;\n    this.domElement = domElement;\n    this.enabled = true;\n    this.state = -1;\n    this.keys = {};\n    this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null };\n    this.touches = { ONE: null, TWO: null };\n  }\n  connect() {\n  }\n  disconnect() {\n  }\n  dispose() {\n  }\n  update() {\n  }\n}\nif (typeof __THREE_DEVTOOLS__ !== \"undefined\") {\n  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"register\", { detail: {\n    revision: REVISION\n  } }));\n}\nif (typeof window !== \"undefined\") {\n  if (window.__THREE__) {\n    console.warn(\"WARNING: Multiple instances of Three.js being imported.\");\n  } else {\n    window.__THREE__ = REVISION;\n  }\n}\nvar __defProp$j = Object.defineProperty;\nvar __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$j = (obj, key, value) => __defNormalProp$j(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass CameraManager {\n  constructor(renderer, eventManager, nodeStorage) {\n    __publicField$j(this, \"perspectiveCamera\");\n    __publicField$j(this, \"orthographicCamera\");\n    __publicField$j(this, \"activeCamera\");\n    __publicField$j(this, \"renderer\");\n    __publicField$j(this, \"eventManager\");\n    __publicField$j(this, \"nodeStorage\");\n    __publicField$j(this, \"controls\", null);\n    __publicField$j(this, \"DEFAULT_DISTANCE\", 10);\n    __publicField$j(this, \"DEFAULT_LOOK_AT\", 0);\n    __publicField$j(this, \"DEFAULT_CAMERA\", {\n      near: 0.01,\n      far: 1e4\n    });\n    __publicField$j(this, \"DEFAULT_PERSPECTIVE_CAMERA\", {\n      fov: 35,\n      aspect: 1\n    });\n    __publicField$j(this, \"DEFAULT_FRUSTUM_SIZE\", 10);\n    __publicField$j(this, \"DEFAULT_ORTHOGRAPHIC_CAMERA\", {\n      left: -this.DEFAULT_FRUSTUM_SIZE / 2,\n      right: this.DEFAULT_FRUSTUM_SIZE / 2,\n      top: this.DEFAULT_FRUSTUM_SIZE / 2,\n      bottom: -this.DEFAULT_FRUSTUM_SIZE / 2\n    });\n    this.renderer = renderer;\n    this.eventManager = eventManager;\n    this.nodeStorage = nodeStorage;\n    this.perspectiveCamera = new PerspectiveCamera(\n      this.DEFAULT_PERSPECTIVE_CAMERA.fov,\n      this.DEFAULT_PERSPECTIVE_CAMERA.aspect,\n      this.DEFAULT_CAMERA.near,\n      this.DEFAULT_CAMERA.far\n    );\n    this.orthographicCamera = new OrthographicCamera(\n      this.DEFAULT_ORTHOGRAPHIC_CAMERA.left,\n      this.DEFAULT_ORTHOGRAPHIC_CAMERA.right,\n      this.DEFAULT_ORTHOGRAPHIC_CAMERA.top,\n      this.DEFAULT_ORTHOGRAPHIC_CAMERA.bottom,\n      this.DEFAULT_CAMERA.near,\n      this.DEFAULT_CAMERA.far\n    );\n    this.reset();\n    this.activeCamera = this.perspectiveCamera;\n  }\n  init() {\n  }\n  dispose() {\n  }\n  setControls(controls) {\n    this.controls = controls;\n    if (this.controls) {\n      this.controls.addEventListener(\"end\", () => {\n        this.nodeStorage.storeNodeProperty(\"Camera Info\", this.getCameraState());\n      });\n    }\n  }\n  getCurrentCameraType() {\n    return this.activeCamera === this.perspectiveCamera ? \"perspective\" : \"orthographic\";\n  }\n  toggleCamera(cameraType) {\n    var _a2;\n    const oldCamera = this.activeCamera;\n    const position = oldCamera.position.clone();\n    const rotation = oldCamera.rotation.clone();\n    const target = ((_a2 = this.controls) == null ? void 0 : _a2.target.clone()) || new Vector3();\n    const oldZoom = oldCamera instanceof OrthographicCamera ? oldCamera.zoom : oldCamera.zoom;\n    if (!cameraType) {\n      this.activeCamera = oldCamera === this.perspectiveCamera ? this.orthographicCamera : this.perspectiveCamera;\n    } else {\n      this.activeCamera = cameraType === \"perspective\" ? this.perspectiveCamera : this.orthographicCamera;\n      if (oldCamera === this.activeCamera) {\n        return;\n      }\n    }\n    this.activeCamera.position.copy(position);\n    this.activeCamera.rotation.copy(rotation);\n    if (this.activeCamera instanceof OrthographicCamera) {\n      this.activeCamera.zoom = oldZoom;\n      this.activeCamera.updateProjectionMatrix();\n    } else if (this.activeCamera instanceof PerspectiveCamera) {\n      this.activeCamera.zoom = oldZoom;\n      this.activeCamera.updateProjectionMatrix();\n    }\n    if (this.controls) {\n      this.controls.object = this.activeCamera;\n      this.controls.target.copy(target);\n      this.controls.update();\n    }\n    this.eventManager.emitEvent(\"cameraTypeChange\", cameraType);\n  }\n  setFOV(fov2) {\n    if (this.activeCamera === this.perspectiveCamera) {\n      this.perspectiveCamera.fov = fov2;\n      this.perspectiveCamera.updateProjectionMatrix();\n    }\n    this.eventManager.emitEvent(\"fovChange\", fov2);\n  }\n  getCameraState() {\n    var _a2;\n    return {\n      position: this.activeCamera.position.clone(),\n      target: ((_a2 = this.controls) == null ? void 0 : _a2.target.clone()) || new Vector3(),\n      zoom: this.activeCamera instanceof OrthographicCamera ? this.activeCamera.zoom : this.activeCamera.zoom,\n      cameraType: this.getCurrentCameraType()\n    };\n  }\n  setCameraState(state) {\n    var _a2, _b2;\n    this.activeCamera.position.copy(state.position);\n    (_a2 = this.controls) == null ? void 0 : _a2.target.copy(state.target);\n    if (this.activeCamera instanceof OrthographicCamera) {\n      this.activeCamera.zoom = state.zoom;\n      this.activeCamera.updateProjectionMatrix();\n    } else if (this.activeCamera instanceof PerspectiveCamera) {\n      this.activeCamera.zoom = state.zoom;\n      this.activeCamera.updateProjectionMatrix();\n    }\n    (_b2 = this.controls) == null ? void 0 : _b2.update();\n  }\n  handleResize(width, height) {\n    const aspect2 = width / height;\n    this.updateAspectRatio(aspect2);\n  }\n  updateAspectRatio(aspect2) {\n    if (this.activeCamera === this.perspectiveCamera) {\n      this.perspectiveCamera.aspect = aspect2;\n      this.perspectiveCamera.updateProjectionMatrix();\n    } else {\n      const frustumSize = 10;\n      this.orthographicCamera.left = -frustumSize * aspect2 / 2;\n      this.orthographicCamera.right = frustumSize * aspect2 / 2;\n      this.orthographicCamera.top = frustumSize / 2;\n      this.orthographicCamera.bottom = -frustumSize / 2;\n      this.orthographicCamera.updateProjectionMatrix();\n    }\n  }\n  setupForModel(size) {\n    var _a2, _b2;\n    const distance = Math.max(size.x, size.z) * 2;\n    const height = size.y * 2;\n    this.perspectiveCamera.position.set(distance, height, distance);\n    this.orthographicCamera.position.set(distance, height, distance);\n    if (this.activeCamera === this.perspectiveCamera) {\n      this.perspectiveCamera.lookAt(0, size.y / 2, 0);\n      this.perspectiveCamera.updateProjectionMatrix();\n    } else {\n      const frustumSize = Math.max(size.x, size.y, size.z) * 2;\n      const aspect2 = this.perspectiveCamera.aspect;\n      this.orthographicCamera.left = -frustumSize * aspect2 / 2;\n      this.orthographicCamera.right = frustumSize * aspect2 / 2;\n      this.orthographicCamera.top = frustumSize / 2;\n      this.orthographicCamera.bottom = -frustumSize / 2;\n      this.orthographicCamera.lookAt(0, size.y / 2, 0);\n      this.orthographicCamera.updateProjectionMatrix();\n    }\n    (_a2 = this.controls) == null ? void 0 : _a2.target.set(0, size.y / 2, 0);\n    (_b2 = this.controls) == null ? void 0 : _b2.update();\n  }\n  reset() {\n    this.perspectiveCamera.position.set(\n      this.DEFAULT_DISTANCE,\n      this.DEFAULT_DISTANCE,\n      this.DEFAULT_DISTANCE\n    );\n    this.orthographicCamera.position.set(\n      this.DEFAULT_DISTANCE,\n      this.DEFAULT_DISTANCE,\n      this.DEFAULT_DISTANCE\n    );\n    this.perspectiveCamera.lookAt(\n      this.DEFAULT_LOOK_AT,\n      this.DEFAULT_LOOK_AT,\n      this.DEFAULT_LOOK_AT\n    );\n    this.orthographicCamera.lookAt(\n      this.DEFAULT_LOOK_AT,\n      this.DEFAULT_LOOK_AT,\n      this.DEFAULT_LOOK_AT\n    );\n    this.perspectiveCamera.updateProjectionMatrix();\n    this.orthographicCamera.updateProjectionMatrix();\n  }\n}\nconst _changeEvent = { type: \"change\" };\nconst _startEvent = { type: \"start\" };\nconst _endEvent = { type: \"end\" };\nconst _ray$1 = new Ray();\nconst _plane = new Plane();\nconst _TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);\nconst _v = new Vector3();\nconst _twoPI = 2 * Math.PI;\nconst _STATE = {\n  NONE: -1,\n  ROTATE: 0,\n  DOLLY: 1,\n  PAN: 2,\n  TOUCH_ROTATE: 3,\n  TOUCH_PAN: 4,\n  TOUCH_DOLLY_PAN: 5,\n  TOUCH_DOLLY_ROTATE: 6\n};\nconst _EPS = 1e-6;\nclass OrbitControls extends Controls {\n  constructor(object, domElement = null) {\n    super(object, domElement);\n    this.state = _STATE.NONE;\n    this.enabled = true;\n    this.target = new Vector3();\n    this.cursor = new Vector3();\n    this.minDistance = 0;\n    this.maxDistance = Infinity;\n    this.minZoom = 0;\n    this.maxZoom = Infinity;\n    this.minTargetRadius = 0;\n    this.maxTargetRadius = Infinity;\n    this.minPolarAngle = 0;\n    this.maxPolarAngle = Math.PI;\n    this.minAzimuthAngle = -Infinity;\n    this.maxAzimuthAngle = Infinity;\n    this.enableDamping = false;\n    this.dampingFactor = 0.05;\n    this.enableZoom = true;\n    this.zoomSpeed = 1;\n    this.enableRotate = true;\n    this.rotateSpeed = 1;\n    this.enablePan = true;\n    this.panSpeed = 1;\n    this.screenSpacePanning = true;\n    this.keyPanSpeed = 7;\n    this.zoomToCursor = false;\n    this.autoRotate = false;\n    this.autoRotateSpeed = 2;\n    this.keys = { LEFT: \"ArrowLeft\", UP: \"ArrowUp\", RIGHT: \"ArrowRight\", BOTTOM: \"ArrowDown\" };\n    this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };\n    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };\n    this.target0 = this.target.clone();\n    this.position0 = this.object.position.clone();\n    this.zoom0 = this.object.zoom;\n    this._domElementKeyEvents = null;\n    this._lastPosition = new Vector3();\n    this._lastQuaternion = new Quaternion();\n    this._lastTargetPosition = new Vector3();\n    this._quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));\n    this._quatInverse = this._quat.clone().invert();\n    this._spherical = new Spherical();\n    this._sphericalDelta = new Spherical();\n    this._scale = 1;\n    this._panOffset = new Vector3();\n    this._rotateStart = new Vector2();\n    this._rotateEnd = new Vector2();\n    this._rotateDelta = new Vector2();\n    this._panStart = new Vector2();\n    this._panEnd = new Vector2();\n    this._panDelta = new Vector2();\n    this._dollyStart = new Vector2();\n    this._dollyEnd = new Vector2();\n    this._dollyDelta = new Vector2();\n    this._dollyDirection = new Vector3();\n    this._mouse = new Vector2();\n    this._performCursorZoom = false;\n    this._pointers = [];\n    this._pointerPositions = {};\n    this._controlActive = false;\n    this._onPointerMove = onPointerMove.bind(this);\n    this._onPointerDown = onPointerDown.bind(this);\n    this._onPointerUp = onPointerUp.bind(this);\n    this._onContextMenu = onContextMenu.bind(this);\n    this._onMouseWheel = onMouseWheel.bind(this);\n    this._onKeyDown = onKeyDown.bind(this);\n    this._onTouchStart = onTouchStart.bind(this);\n    this._onTouchMove = onTouchMove.bind(this);\n    this._onMouseDown = onMouseDown.bind(this);\n    this._onMouseMove = onMouseMove.bind(this);\n    this._interceptControlDown = interceptControlDown.bind(this);\n    this._interceptControlUp = interceptControlUp.bind(this);\n    if (this.domElement !== null) {\n      this.connect();\n    }\n    this.update();\n  }\n  connect() {\n    this.domElement.addEventListener(\"pointerdown\", this._onPointerDown);\n    this.domElement.addEventListener(\"pointercancel\", this._onPointerUp);\n    this.domElement.addEventListener(\"contextmenu\", this._onContextMenu);\n    this.domElement.addEventListener(\"wheel\", this._onMouseWheel, { passive: false });\n    const document2 = this.domElement.getRootNode();\n    document2.addEventListener(\"keydown\", this._interceptControlDown, { passive: true, capture: true });\n    this.domElement.style.touchAction = \"none\";\n  }\n  disconnect() {\n    this.domElement.removeEventListener(\"pointerdown\", this._onPointerDown);\n    this.domElement.removeEventListener(\"pointermove\", this._onPointerMove);\n    this.domElement.removeEventListener(\"pointerup\", this._onPointerUp);\n    this.domElement.removeEventListener(\"pointercancel\", this._onPointerUp);\n    this.domElement.removeEventListener(\"wheel\", this._onMouseWheel);\n    this.domElement.removeEventListener(\"contextmenu\", this._onContextMenu);\n    this.stopListenToKeyEvents();\n    const document2 = this.domElement.getRootNode();\n    document2.removeEventListener(\"keydown\", this._interceptControlDown, { capture: true });\n    this.domElement.style.touchAction = \"auto\";\n  }\n  dispose() {\n    this.disconnect();\n  }\n  getPolarAngle() {\n    return this._spherical.phi;\n  }\n  getAzimuthalAngle() {\n    return this._spherical.theta;\n  }\n  getDistance() {\n    return this.object.position.distanceTo(this.target);\n  }\n  listenToKeyEvents(domElement) {\n    domElement.addEventListener(\"keydown\", this._onKeyDown);\n    this._domElementKeyEvents = domElement;\n  }\n  stopListenToKeyEvents() {\n    if (this._domElementKeyEvents !== null) {\n      this._domElementKeyEvents.removeEventListener(\"keydown\", this._onKeyDown);\n      this._domElementKeyEvents = null;\n    }\n  }\n  saveState() {\n    this.target0.copy(this.target);\n    this.position0.copy(this.object.position);\n    this.zoom0 = this.object.zoom;\n  }\n  reset() {\n    this.target.copy(this.target0);\n    this.object.position.copy(this.position0);\n    this.object.zoom = this.zoom0;\n    this.object.updateProjectionMatrix();\n    this.dispatchEvent(_changeEvent);\n    this.update();\n    this.state = _STATE.NONE;\n  }\n  update(deltaTime = null) {\n    const position = this.object.position;\n    _v.copy(position).sub(this.target);\n    _v.applyQuaternion(this._quat);\n    this._spherical.setFromVector3(_v);\n    if (this.autoRotate && this.state === _STATE.NONE) {\n      this._rotateLeft(this._getAutoRotationAngle(deltaTime));\n    }\n    if (this.enableDamping) {\n      this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor;\n      this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor;\n    } else {\n      this._spherical.theta += this._sphericalDelta.theta;\n      this._spherical.phi += this._sphericalDelta.phi;\n    }\n    let min = this.minAzimuthAngle;\n    let max2 = this.maxAzimuthAngle;\n    if (isFinite(min) && isFinite(max2)) {\n      if (min < -Math.PI) min += _twoPI;\n      else if (min > Math.PI) min -= _twoPI;\n      if (max2 < -Math.PI) max2 += _twoPI;\n      else if (max2 > Math.PI) max2 -= _twoPI;\n      if (min <= max2) {\n        this._spherical.theta = Math.max(min, Math.min(max2, this._spherical.theta));\n      } else {\n        this._spherical.theta = this._spherical.theta > (min + max2) / 2 ? Math.max(min, this._spherical.theta) : Math.min(max2, this._spherical.theta);\n      }\n    }\n    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi));\n    this._spherical.makeSafe();\n    if (this.enableDamping === true) {\n      this.target.addScaledVector(this._panOffset, this.dampingFactor);\n    } else {\n      this.target.add(this._panOffset);\n    }\n    this.target.sub(this.cursor);\n    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius);\n    this.target.add(this.cursor);\n    let zoomChanged = false;\n    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) {\n      this._spherical.radius = this._clampDistance(this._spherical.radius);\n    } else {\n      const prevRadius = this._spherical.radius;\n      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale);\n      zoomChanged = prevRadius != this._spherical.radius;\n    }\n    _v.setFromSpherical(this._spherical);\n    _v.applyQuaternion(this._quatInverse);\n    position.copy(this.target).add(_v);\n    this.object.lookAt(this.target);\n    if (this.enableDamping === true) {\n      this._sphericalDelta.theta *= 1 - this.dampingFactor;\n      this._sphericalDelta.phi *= 1 - this.dampingFactor;\n      this._panOffset.multiplyScalar(1 - this.dampingFactor);\n    } else {\n      this._sphericalDelta.set(0, 0, 0);\n      this._panOffset.set(0, 0, 0);\n    }\n    if (this.zoomToCursor && this._performCursorZoom) {\n      let newRadius = null;\n      if (this.object.isPerspectiveCamera) {\n        const prevRadius = _v.length();\n        newRadius = this._clampDistance(prevRadius * this._scale);\n        const radiusDelta = prevRadius - newRadius;\n        this.object.position.addScaledVector(this._dollyDirection, radiusDelta);\n        this.object.updateMatrixWorld();\n        zoomChanged = !!radiusDelta;\n      } else if (this.object.isOrthographicCamera) {\n        const mouseBefore = new Vector3(this._mouse.x, this._mouse.y, 0);\n        mouseBefore.unproject(this.object);\n        const prevZoom = this.object.zoom;\n        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));\n        this.object.updateProjectionMatrix();\n        zoomChanged = prevZoom !== this.object.zoom;\n        const mouseAfter = new Vector3(this._mouse.x, this._mouse.y, 0);\n        mouseAfter.unproject(this.object);\n        this.object.position.sub(mouseAfter).add(mouseBefore);\n        this.object.updateMatrixWorld();\n        newRadius = _v.length();\n      } else {\n        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.\");\n        this.zoomToCursor = false;\n      }\n      if (newRadius !== null) {\n        if (this.screenSpacePanning) {\n          this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position);\n        } else {\n          _ray$1.origin.copy(this.object.position);\n          _ray$1.direction.set(0, 0, -1).transformDirection(this.object.matrix);\n          if (Math.abs(this.object.up.dot(_ray$1.direction)) < _TILT_LIMIT) {\n            this.object.lookAt(this.target);\n          } else {\n            _plane.setFromNormalAndCoplanarPoint(this.object.up, this.target);\n            _ray$1.intersectPlane(_plane, this.target);\n          }\n        }\n      }\n    } else if (this.object.isOrthographicCamera) {\n      const prevZoom = this.object.zoom;\n      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale));\n      if (prevZoom !== this.object.zoom) {\n        this.object.updateProjectionMatrix();\n        zoomChanged = true;\n      }\n    }\n    this._scale = 1;\n    this._performCursorZoom = false;\n    if (zoomChanged || this._lastPosition.distanceToSquared(this.object.position) > _EPS || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > _EPS || this._lastTargetPosition.distanceToSquared(this.target) > _EPS) {\n      this.dispatchEvent(_changeEvent);\n      this._lastPosition.copy(this.object.position);\n      this._lastQuaternion.copy(this.object.quaternion);\n      this._lastTargetPosition.copy(this.target);\n      return true;\n    }\n    return false;\n  }\n  _getAutoRotationAngle(deltaTime) {\n    if (deltaTime !== null) {\n      return _twoPI / 60 * this.autoRotateSpeed * deltaTime;\n    } else {\n      return _twoPI / 60 / 60 * this.autoRotateSpeed;\n    }\n  }\n  _getZoomScale(delta) {\n    const normalizedDelta = Math.abs(delta * 0.01);\n    return Math.pow(0.95, this.zoomSpeed * normalizedDelta);\n  }\n  _rotateLeft(angle) {\n    this._sphericalDelta.theta -= angle;\n  }\n  _rotateUp(angle) {\n    this._sphericalDelta.phi -= angle;\n  }\n  _panLeft(distance, objectMatrix) {\n    _v.setFromMatrixColumn(objectMatrix, 0);\n    _v.multiplyScalar(-distance);\n    this._panOffset.add(_v);\n  }\n  _panUp(distance, objectMatrix) {\n    if (this.screenSpacePanning === true) {\n      _v.setFromMatrixColumn(objectMatrix, 1);\n    } else {\n      _v.setFromMatrixColumn(objectMatrix, 0);\n      _v.crossVectors(this.object.up, _v);\n    }\n    _v.multiplyScalar(distance);\n    this._panOffset.add(_v);\n  }\n  // deltaX and deltaY are in pixels; right and down are positive\n  _pan(deltaX, deltaY) {\n    const element = this.domElement;\n    if (this.object.isPerspectiveCamera) {\n      const position = this.object.position;\n      _v.copy(position).sub(this.target);\n      let targetDistance = _v.length();\n      targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180);\n      this._panLeft(2 * deltaX * targetDistance / element.clientHeight, this.object.matrix);\n      this._panUp(2 * deltaY * targetDistance / element.clientHeight, this.object.matrix);\n    } else if (this.object.isOrthographicCamera) {\n      this._panLeft(deltaX * (this.object.right - this.object.left) / this.object.zoom / element.clientWidth, this.object.matrix);\n      this._panUp(deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element.clientHeight, this.object.matrix);\n    } else {\n      console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n      this.enablePan = false;\n    }\n  }\n  _dollyOut(dollyScale) {\n    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {\n      this._scale /= dollyScale;\n    } else {\n      console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n      this.enableZoom = false;\n    }\n  }\n  _dollyIn(dollyScale) {\n    if (this.object.isPerspectiveCamera || this.object.isOrthographicCamera) {\n      this._scale *= dollyScale;\n    } else {\n      console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n      this.enableZoom = false;\n    }\n  }\n  _updateZoomParameters(x, y) {\n    if (!this.zoomToCursor) {\n      return;\n    }\n    this._performCursorZoom = true;\n    const rect = this.domElement.getBoundingClientRect();\n    const dx = x - rect.left;\n    const dy = y - rect.top;\n    const w = rect.width;\n    const h = rect.height;\n    this._mouse.x = dx / w * 2 - 1;\n    this._mouse.y = -(dy / h) * 2 + 1;\n    this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();\n  }\n  _clampDistance(dist) {\n    return Math.max(this.minDistance, Math.min(this.maxDistance, dist));\n  }\n  //\n  // event callbacks - update the object state\n  //\n  _handleMouseDownRotate(event) {\n    this._rotateStart.set(event.clientX, event.clientY);\n  }\n  _handleMouseDownDolly(event) {\n    this._updateZoomParameters(event.clientX, event.clientX);\n    this._dollyStart.set(event.clientX, event.clientY);\n  }\n  _handleMouseDownPan(event) {\n    this._panStart.set(event.clientX, event.clientY);\n  }\n  _handleMouseMoveRotate(event) {\n    this._rotateEnd.set(event.clientX, event.clientY);\n    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);\n    const element = this.domElement;\n    this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight);\n    this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);\n    this._rotateStart.copy(this._rotateEnd);\n    this.update();\n  }\n  _handleMouseMoveDolly(event) {\n    this._dollyEnd.set(event.clientX, event.clientY);\n    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart);\n    if (this._dollyDelta.y > 0) {\n      this._dollyOut(this._getZoomScale(this._dollyDelta.y));\n    } else if (this._dollyDelta.y < 0) {\n      this._dollyIn(this._getZoomScale(this._dollyDelta.y));\n    }\n    this._dollyStart.copy(this._dollyEnd);\n    this.update();\n  }\n  _handleMouseMovePan(event) {\n    this._panEnd.set(event.clientX, event.clientY);\n    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);\n    this._pan(this._panDelta.x, this._panDelta.y);\n    this._panStart.copy(this._panEnd);\n    this.update();\n  }\n  _handleMouseWheel(event) {\n    this._updateZoomParameters(event.clientX, event.clientY);\n    if (event.deltaY < 0) {\n      this._dollyIn(this._getZoomScale(event.deltaY));\n    } else if (event.deltaY > 0) {\n      this._dollyOut(this._getZoomScale(event.deltaY));\n    }\n    this.update();\n  }\n  _handleKeyDown(event) {\n    let needsUpdate = false;\n    switch (event.code) {\n      case this.keys.UP:\n        if (event.ctrlKey || event.metaKey || event.shiftKey) {\n          this._rotateUp(_twoPI * this.rotateSpeed / this.domElement.clientHeight);\n        } else {\n          this._pan(0, this.keyPanSpeed);\n        }\n        needsUpdate = true;\n        break;\n      case this.keys.BOTTOM:\n        if (event.ctrlKey || event.metaKey || event.shiftKey) {\n          this._rotateUp(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);\n        } else {\n          this._pan(0, -this.keyPanSpeed);\n        }\n        needsUpdate = true;\n        break;\n      case this.keys.LEFT:\n        if (event.ctrlKey || event.metaKey || event.shiftKey) {\n          this._rotateLeft(_twoPI * this.rotateSpeed / this.domElement.clientHeight);\n        } else {\n          this._pan(this.keyPanSpeed, 0);\n        }\n        needsUpdate = true;\n        break;\n      case this.keys.RIGHT:\n        if (event.ctrlKey || event.metaKey || event.shiftKey) {\n          this._rotateLeft(-_twoPI * this.rotateSpeed / this.domElement.clientHeight);\n        } else {\n          this._pan(-this.keyPanSpeed, 0);\n        }\n        needsUpdate = true;\n        break;\n    }\n    if (needsUpdate) {\n      event.preventDefault();\n      this.update();\n    }\n  }\n  _handleTouchStartRotate(event) {\n    if (this._pointers.length === 1) {\n      this._rotateStart.set(event.pageX, event.pageY);\n    } else {\n      const position = this._getSecondPointerPosition(event);\n      const x = 0.5 * (event.pageX + position.x);\n      const y = 0.5 * (event.pageY + position.y);\n      this._rotateStart.set(x, y);\n    }\n  }\n  _handleTouchStartPan(event) {\n    if (this._pointers.length === 1) {\n      this._panStart.set(event.pageX, event.pageY);\n    } else {\n      const position = this._getSecondPointerPosition(event);\n      const x = 0.5 * (event.pageX + position.x);\n      const y = 0.5 * (event.pageY + position.y);\n      this._panStart.set(x, y);\n    }\n  }\n  _handleTouchStartDolly(event) {\n    const position = this._getSecondPointerPosition(event);\n    const dx = event.pageX - position.x;\n    const dy = event.pageY - position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    this._dollyStart.set(0, distance);\n  }\n  _handleTouchStartDollyPan(event) {\n    if (this.enableZoom) this._handleTouchStartDolly(event);\n    if (this.enablePan) this._handleTouchStartPan(event);\n  }\n  _handleTouchStartDollyRotate(event) {\n    if (this.enableZoom) this._handleTouchStartDolly(event);\n    if (this.enableRotate) this._handleTouchStartRotate(event);\n  }\n  _handleTouchMoveRotate(event) {\n    if (this._pointers.length == 1) {\n      this._rotateEnd.set(event.pageX, event.pageY);\n    } else {\n      const position = this._getSecondPointerPosition(event);\n      const x = 0.5 * (event.pageX + position.x);\n      const y = 0.5 * (event.pageY + position.y);\n      this._rotateEnd.set(x, y);\n    }\n    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);\n    const element = this.domElement;\n    this._rotateLeft(_twoPI * this._rotateDelta.x / element.clientHeight);\n    this._rotateUp(_twoPI * this._rotateDelta.y / element.clientHeight);\n    this._rotateStart.copy(this._rotateEnd);\n  }\n  _handleTouchMovePan(event) {\n    if (this._pointers.length === 1) {\n      this._panEnd.set(event.pageX, event.pageY);\n    } else {\n      const position = this._getSecondPointerPosition(event);\n      const x = 0.5 * (event.pageX + position.x);\n      const y = 0.5 * (event.pageY + position.y);\n      this._panEnd.set(x, y);\n    }\n    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed);\n    this._pan(this._panDelta.x, this._panDelta.y);\n    this._panStart.copy(this._panEnd);\n  }\n  _handleTouchMoveDolly(event) {\n    const position = this._getSecondPointerPosition(event);\n    const dx = event.pageX - position.x;\n    const dy = event.pageY - position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    this._dollyEnd.set(0, distance);\n    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed));\n    this._dollyOut(this._dollyDelta.y);\n    this._dollyStart.copy(this._dollyEnd);\n    const centerX = (event.pageX + position.x) * 0.5;\n    const centerY = (event.pageY + position.y) * 0.5;\n    this._updateZoomParameters(centerX, centerY);\n  }\n  _handleTouchMoveDollyPan(event) {\n    if (this.enableZoom) this._handleTouchMoveDolly(event);\n    if (this.enablePan) this._handleTouchMovePan(event);\n  }\n  _handleTouchMoveDollyRotate(event) {\n    if (this.enableZoom) this._handleTouchMoveDolly(event);\n    if (this.enableRotate) this._handleTouchMoveRotate(event);\n  }\n  // pointers\n  _addPointer(event) {\n    this._pointers.push(event.pointerId);\n  }\n  _removePointer(event) {\n    delete this._pointerPositions[event.pointerId];\n    for (let i = 0; i < this._pointers.length; i++) {\n      if (this._pointers[i] == event.pointerId) {\n        this._pointers.splice(i, 1);\n        return;\n      }\n    }\n  }\n  _isTrackingPointer(event) {\n    for (let i = 0; i < this._pointers.length; i++) {\n      if (this._pointers[i] == event.pointerId) return true;\n    }\n    return false;\n  }\n  _trackPointer(event) {\n    let position = this._pointerPositions[event.pointerId];\n    if (position === void 0) {\n      position = new Vector2();\n      this._pointerPositions[event.pointerId] = position;\n    }\n    position.set(event.pageX, event.pageY);\n  }\n  _getSecondPointerPosition(event) {\n    const pointerId = event.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];\n    return this._pointerPositions[pointerId];\n  }\n  //\n  _customWheelEvent(event) {\n    const mode = event.deltaMode;\n    const newEvent = {\n      clientX: event.clientX,\n      clientY: event.clientY,\n      deltaY: event.deltaY\n    };\n    switch (mode) {\n      case 1:\n        newEvent.deltaY *= 16;\n        break;\n      case 2:\n        newEvent.deltaY *= 100;\n        break;\n    }\n    if (event.ctrlKey && !this._controlActive) {\n      newEvent.deltaY *= 10;\n    }\n    return newEvent;\n  }\n}\nfunction onPointerDown(event) {\n  if (this.enabled === false) return;\n  if (this._pointers.length === 0) {\n    this.domElement.setPointerCapture(event.pointerId);\n    this.domElement.addEventListener(\"pointermove\", this._onPointerMove);\n    this.domElement.addEventListener(\"pointerup\", this._onPointerUp);\n  }\n  if (this._isTrackingPointer(event)) return;\n  this._addPointer(event);\n  if (event.pointerType === \"touch\") {\n    this._onTouchStart(event);\n  } else {\n    this._onMouseDown(event);\n  }\n}\nfunction onPointerMove(event) {\n  if (this.enabled === false) return;\n  if (event.pointerType === \"touch\") {\n    this._onTouchMove(event);\n  } else {\n    this._onMouseMove(event);\n  }\n}\nfunction onPointerUp(event) {\n  this._removePointer(event);\n  switch (this._pointers.length) {\n    case 0:\n      this.domElement.releasePointerCapture(event.pointerId);\n      this.domElement.removeEventListener(\"pointermove\", this._onPointerMove);\n      this.domElement.removeEventListener(\"pointerup\", this._onPointerUp);\n      this.dispatchEvent(_endEvent);\n      this.state = _STATE.NONE;\n      break;\n    case 1:\n      const pointerId = this._pointers[0];\n      const position = this._pointerPositions[pointerId];\n      this._onTouchStart({ pointerId, pageX: position.x, pageY: position.y });\n      break;\n  }\n}\nfunction onMouseDown(event) {\n  let mouseAction;\n  switch (event.button) {\n    case 0:\n      mouseAction = this.mouseButtons.LEFT;\n      break;\n    case 1:\n      mouseAction = this.mouseButtons.MIDDLE;\n      break;\n    case 2:\n      mouseAction = this.mouseButtons.RIGHT;\n      break;\n    default:\n      mouseAction = -1;\n  }\n  switch (mouseAction) {\n    case MOUSE.DOLLY:\n      if (this.enableZoom === false) return;\n      this._handleMouseDownDolly(event);\n      this.state = _STATE.DOLLY;\n      break;\n    case MOUSE.ROTATE:\n      if (event.ctrlKey || event.metaKey || event.shiftKey) {\n        if (this.enablePan === false) return;\n        this._handleMouseDownPan(event);\n        this.state = _STATE.PAN;\n      } else {\n        if (this.enableRotate === false) return;\n        this._handleMouseDownRotate(event);\n        this.state = _STATE.ROTATE;\n      }\n      break;\n    case MOUSE.PAN:\n      if (event.ctrlKey || event.metaKey || event.shiftKey) {\n        if (this.enableRotate === false) return;\n        this._handleMouseDownRotate(event);\n        this.state = _STATE.ROTATE;\n      } else {\n        if (this.enablePan === false) return;\n        this._handleMouseDownPan(event);\n        this.state = _STATE.PAN;\n      }\n      break;\n    default:\n      this.state = _STATE.NONE;\n  }\n  if (this.state !== _STATE.NONE) {\n    this.dispatchEvent(_startEvent);\n  }\n}\nfunction onMouseMove(event) {\n  switch (this.state) {\n    case _STATE.ROTATE:\n      if (this.enableRotate === false) return;\n      this._handleMouseMoveRotate(event);\n      break;\n    case _STATE.DOLLY:\n      if (this.enableZoom === false) return;\n      this._handleMouseMoveDolly(event);\n      break;\n    case _STATE.PAN:\n      if (this.enablePan === false) return;\n      this._handleMouseMovePan(event);\n      break;\n  }\n}\nfunction onMouseWheel(event) {\n  if (this.enabled === false || this.enableZoom === false || this.state !== _STATE.NONE) return;\n  event.preventDefault();\n  this.dispatchEvent(_startEvent);\n  this._handleMouseWheel(this._customWheelEvent(event));\n  this.dispatchEvent(_endEvent);\n}\nfunction onKeyDown(event) {\n  if (this.enabled === false || this.enablePan === false) return;\n  this._handleKeyDown(event);\n}\nfunction onTouchStart(event) {\n  this._trackPointer(event);\n  switch (this._pointers.length) {\n    case 1:\n      switch (this.touches.ONE) {\n        case TOUCH.ROTATE:\n          if (this.enableRotate === false) return;\n          this._handleTouchStartRotate(event);\n          this.state = _STATE.TOUCH_ROTATE;\n          break;\n        case TOUCH.PAN:\n          if (this.enablePan === false) return;\n          this._handleTouchStartPan(event);\n          this.state = _STATE.TOUCH_PAN;\n          break;\n        default:\n          this.state = _STATE.NONE;\n      }\n      break;\n    case 2:\n      switch (this.touches.TWO) {\n        case TOUCH.DOLLY_PAN:\n          if (this.enableZoom === false && this.enablePan === false) return;\n          this._handleTouchStartDollyPan(event);\n          this.state = _STATE.TOUCH_DOLLY_PAN;\n          break;\n        case TOUCH.DOLLY_ROTATE:\n          if (this.enableZoom === false && this.enableRotate === false) return;\n          this._handleTouchStartDollyRotate(event);\n          this.state = _STATE.TOUCH_DOLLY_ROTATE;\n          break;\n        default:\n          this.state = _STATE.NONE;\n      }\n      break;\n    default:\n      this.state = _STATE.NONE;\n  }\n  if (this.state !== _STATE.NONE) {\n    this.dispatchEvent(_startEvent);\n  }\n}\nfunction onTouchMove(event) {\n  this._trackPointer(event);\n  switch (this.state) {\n    case _STATE.TOUCH_ROTATE:\n      if (this.enableRotate === false) return;\n      this._handleTouchMoveRotate(event);\n      this.update();\n      break;\n    case _STATE.TOUCH_PAN:\n      if (this.enablePan === false) return;\n      this._handleTouchMovePan(event);\n      this.update();\n      break;\n    case _STATE.TOUCH_DOLLY_PAN:\n      if (this.enableZoom === false && this.enablePan === false) return;\n      this._handleTouchMoveDollyPan(event);\n      this.update();\n      break;\n    case _STATE.TOUCH_DOLLY_ROTATE:\n      if (this.enableZoom === false && this.enableRotate === false) return;\n      this._handleTouchMoveDollyRotate(event);\n      this.update();\n      break;\n    default:\n      this.state = _STATE.NONE;\n  }\n}\nfunction onContextMenu(event) {\n  if (this.enabled === false) return;\n  event.preventDefault();\n}\nfunction interceptControlDown(event) {\n  if (event.key === \"Control\") {\n    this._controlActive = true;\n    const document2 = this.domElement.getRootNode();\n    document2.addEventListener(\"keyup\", this._interceptControlUp, { passive: true, capture: true });\n  }\n}\nfunction interceptControlUp(event) {\n  if (event.key === \"Control\") {\n    this._controlActive = false;\n    const document2 = this.domElement.getRootNode();\n    document2.removeEventListener(\"keyup\", this._interceptControlUp, { passive: true, capture: true });\n  }\n}\nvar __defProp$i = Object.defineProperty;\nvar __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$i = (obj, key, value) => __defNormalProp$i(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass ControlsManager {\n  constructor(renderer, camera, eventManager, nodeStorage) {\n    __publicField$i(this, \"controls\");\n    __publicField$i(this, \"eventManager\");\n    __publicField$i(this, \"nodeStorage\");\n    __publicField$i(this, \"camera\");\n    this.eventManager = eventManager;\n    this.nodeStorage = nodeStorage;\n    this.camera = camera;\n    this.controls = new OrbitControls(camera, renderer.domElement);\n    this.controls.enableDamping = true;\n  }\n  init() {\n    this.controls.addEventListener(\"end\", () => {\n      this.nodeStorage.storeNodeProperty(\"Camera Info\", {\n        position: this.camera.position.clone(),\n        target: this.controls.target.clone(),\n        zoom: this.camera instanceof OrthographicCamera ? this.camera.zoom : this.camera.zoom,\n        cameraType: this.camera instanceof PerspectiveCamera ? \"perspective\" : \"orthographic\"\n      });\n    });\n  }\n  dispose() {\n    this.controls.dispose();\n  }\n  handleResize() {\n  }\n  update() {\n    this.controls.update();\n  }\n  updateCamera(camera) {\n    const position = this.controls.object.position.clone();\n    const target = this.controls.target.clone();\n    this.camera = camera;\n    this.controls.object = camera;\n    this.controls.target = target;\n    camera.position.copy(position);\n    this.controls.update();\n  }\n  reset() {\n    this.controls.target.set(0, 0, 0);\n    this.controls.update();\n  }\n}\nvar __defProp$h = Object.defineProperty;\nvar __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$h = (obj, key, value) => __defNormalProp$h(obj, key + \"\", value);\nclass EventManager {\n  constructor() {\n    __publicField$h(this, \"listeners\", {});\n  }\n  addEventListener(event, callback) {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(callback);\n  }\n  removeEventListener(event, callback) {\n    if (this.listeners[event]) {\n      this.listeners[event] = this.listeners[event].filter(\n        (cb) => cb !== callback\n      );\n    }\n  }\n  emitEvent(event, data) {\n    if (this.listeners[event]) {\n      this.listeners[event].forEach((callback) => callback(data));\n    }\n  }\n}\nvar __defProp$g = Object.defineProperty;\nvar __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$g = (obj, key, value) => __defNormalProp$g(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass LightingManager {\n  constructor(scene, eventManager) {\n    __publicField$g(this, \"lights\", []);\n    __publicField$g(this, \"scene\");\n    __publicField$g(this, \"eventManager\");\n    this.scene = scene;\n    this.eventManager = eventManager;\n  }\n  init() {\n    this.setupLights();\n  }\n  dispose() {\n    this.lights.forEach((light) => {\n      this.scene.remove(light);\n    });\n    this.lights = [];\n  }\n  setupLights() {\n    const ambientLight = new AmbientLight(16777215, 0.5);\n    this.scene.add(ambientLight);\n    this.lights.push(ambientLight);\n    const mainLight = new DirectionalLight(16777215, 0.8);\n    mainLight.position.set(0, 10, 10);\n    this.scene.add(mainLight);\n    this.lights.push(mainLight);\n    const backLight = new DirectionalLight(16777215, 0.5);\n    backLight.position.set(0, 10, -10);\n    this.scene.add(backLight);\n    this.lights.push(backLight);\n    const leftFillLight = new DirectionalLight(16777215, 0.3);\n    leftFillLight.position.set(-10, 0, 0);\n    this.scene.add(leftFillLight);\n    this.lights.push(leftFillLight);\n    const rightFillLight = new DirectionalLight(16777215, 0.3);\n    rightFillLight.position.set(10, 0, 0);\n    this.scene.add(rightFillLight);\n    this.lights.push(rightFillLight);\n    const bottomLight = new DirectionalLight(16777215, 0.2);\n    bottomLight.position.set(0, -10, 0);\n    this.scene.add(bottomLight);\n    this.lights.push(bottomLight);\n  }\n  setLightIntensity(intensity) {\n    this.lights.forEach((light) => {\n      if (light instanceof DirectionalLight) {\n        if (light === this.lights[1]) {\n          light.intensity = intensity * 0.8;\n        } else if (light === this.lights[2]) {\n          light.intensity = intensity * 0.5;\n        } else if (light === this.lights[5]) {\n          light.intensity = intensity * 0.2;\n        } else {\n          light.intensity = intensity * 0.3;\n        }\n      } else if (light instanceof AmbientLight) {\n        light.intensity = intensity * 0.5;\n      }\n    });\n    this.eventManager.emitEvent(\"lightIntensityChange\", intensity);\n  }\n  reset() {\n  }\n}\nvar u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\nvar fleb = new u8([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  2,\n  2,\n  2,\n  2,\n  3,\n  3,\n  3,\n  3,\n  4,\n  4,\n  4,\n  4,\n  5,\n  5,\n  5,\n  5,\n  0,\n  /* unused */\n  0,\n  0,\n  /* impossible */\n  0\n]);\nvar fdeb = new u8([\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  2,\n  2,\n  3,\n  3,\n  4,\n  4,\n  5,\n  5,\n  6,\n  6,\n  7,\n  7,\n  8,\n  8,\n  9,\n  9,\n  10,\n  10,\n  11,\n  11,\n  12,\n  12,\n  13,\n  13,\n  /* unused */\n  0,\n  0\n]);\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\nvar freb = function(eb, start) {\n  var b = new u16(31);\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  }\n  var r = new i32(b[30]);\n  for (var i = 1; i < 30; ++i) {\n    for (var j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    }\n  }\n  return { b, r };\n};\nvar _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b.b;\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n  var x = (i & 43690) >> 1 | (i & 21845) << 1;\n  x = (x & 52428) >> 2 | (x & 13107) << 2;\n  x = (x & 61680) >> 4 | (x & 3855) << 4;\n  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n}\nvar hMap = function(cd, mb, r) {\n  var s = cd.length;\n  var i = 0;\n  var l = new u16(mb);\n  for (; i < s; ++i) {\n    if (cd[i])\n      ++l[cd[i] - 1];\n  }\n  var le = new u16(mb);\n  for (i = 1; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n  var co;\n  if (r) {\n    co = new u16(1 << mb);\n    var rvb = 15 - mb;\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        var sv = i << 4 | cd[i];\n        var r_1 = mb - cd[i];\n        var v = le[cd[i] - 1]++ << r_1;\n        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n          co[rev[v] >> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];\n      }\n    }\n  }\n  return co;\n};\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n  flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n  flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n  flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n  flt[i] = 8;\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n  fdt[i] = 5;\nvar flrm = /* @__PURE__ */ hMap(flt, 9, 1);\nvar fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\nvar max = function(a) {\n  var m = a[0];\n  for (var i = 1; i < a.length; ++i) {\n    if (a[i] > m)\n      m = a[i];\n  }\n  return m;\n};\nvar bits = function(d, p, m) {\n  var o = p / 8 | 0;\n  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\nvar bits16 = function(d, p) {\n  var o = p / 8 | 0;\n  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\nvar shft = function(p) {\n  return (p + 7) / 8 | 0;\n};\nvar slc = function(v, s, e) {\n  if (e == null || e > v.length)\n    e = v.length;\n  return new u8(v.subarray(s, e));\n};\nvar ec = [\n  \"unexpected EOF\",\n  \"invalid block type\",\n  \"invalid length/literal\",\n  \"invalid distance\",\n  \"stream finished\",\n  \"no stream handler\",\n  ,\n  \"no callback\",\n  \"invalid UTF-8 data\",\n  \"extra field too long\",\n  \"date not in range 1980-2099\",\n  \"filename too long\",\n  \"stream finishing\",\n  \"invalid zip data\"\n  // determined by unknown compression method\n];\nvar err = function(ind, msg, nt) {\n  var e = new Error(msg || ec[ind]);\n  e.code = ind;\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(e, err);\n  if (!nt)\n    throw e;\n  return e;\n};\nvar inflt = function(dat, st, buf, dict) {\n  var sl = dat.length, dl = 0;\n  if (!sl || st.f && !st.l)\n    return buf || new u8(0);\n  var noBuf = !buf;\n  var resize = noBuf || st.i != 2;\n  var noSt = st.i;\n  if (noBuf)\n    buf = new u8(sl * 3);\n  var cbuf = function(l2) {\n    var bl = buf.length;\n    if (l2 > bl) {\n      var nbuf = new u8(Math.max(bl * 2, l2));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  };\n  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n  var tbts = sl * 8;\n  do {\n    if (!lm) {\n      final = bits(dat, pos, 1);\n      var type = bits(dat, pos + 1, 3);\n      pos += 3;\n      if (!type) {\n        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t2 = s + l;\n        if (t2 > sl) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (resize)\n          cbuf(bt + l);\n        buf.set(dat.subarray(s, t2), bt);\n        st.b = bt += l, st.p = pos = t2 * 8, st.f = final;\n        continue;\n      } else if (type == 1)\n        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n      else if (type == 2) {\n        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n        var tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14;\n        var ldt = new u8(tl);\n        var clt = new u8(19);\n        for (var i = 0; i < hcLen; ++i) {\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n        }\n        pos += hcLen * 3;\n        var clb = max(clt), clbmsk = (1 << clb) - 1;\n        var clm = hMap(clt, clb, 1);\n        for (var i = 0; i < tl; ) {\n          var r = clm[bits(dat, pos, clbmsk)];\n          pos += r & 15;\n          var s = r >> 4;\n          if (s < 16) {\n            ldt[i++] = s;\n          } else {\n            var c = 0, n = 0;\n            if (s == 16)\n              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n            else if (s == 17)\n              n = 3 + bits(dat, pos, 7), pos += 3;\n            else if (s == 18)\n              n = 11 + bits(dat, pos, 127), pos += 7;\n            while (n--)\n              ldt[i++] = c;\n          }\n        }\n        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n        lbt = max(lt);\n        dbt = max(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else\n        err(1);\n      if (pos > tbts) {\n        if (noSt)\n          err(0);\n        break;\n      }\n    }\n    if (resize)\n      cbuf(bt + 131072);\n    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n    var lpos = pos;\n    for (; ; lpos = pos) {\n      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n      pos += c & 15;\n      if (pos > tbts) {\n        if (noSt)\n          err(0);\n        break;\n      }\n      if (!c)\n        err(2);\n      if (sym < 256)\n        buf[bt++] = sym;\n      else if (sym == 256) {\n        lpos = pos, lm = null;\n        break;\n      } else {\n        var add = sym - 254;\n        if (sym > 264) {\n          var i = sym - 257, b = fleb[i];\n          add = bits(dat, pos, (1 << b) - 1) + fl[i];\n          pos += b;\n        }\n        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n        if (!d)\n          err(3);\n        pos += d & 15;\n        var dt = fd[dsym];\n        if (dsym > 3) {\n          var b = fdeb[dsym];\n          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n        }\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (resize)\n          cbuf(bt + 131072);\n        var end = bt + add;\n        if (bt < dt) {\n          var shift = dl - dt, dend = Math.min(dt, end);\n          if (shift + bt < 0)\n            err(3);\n          for (; bt < dend; ++bt)\n            buf[bt] = dict[shift + bt];\n        }\n        for (; bt < end; ++bt)\n          buf[bt] = buf[bt - dt];\n      }\n    }\n    st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n    if (lm)\n      final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n};\nvar et = /* @__PURE__ */ new u8(0);\nvar zls = function(d, dict) {\n  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)\n    err(6, \"invalid zlib data\");\n  if ((d[1] >> 5 & 1) == +!dict)\n    err(6, \"invalid zlib data: \" + (d[1] & 32 ? \"need\" : \"unexpected\") + \" dictionary\");\n  return (d[1] >> 3 & 4) + 2;\n};\nfunction unzlibSync(data, opts) {\n  return inflt(data.subarray(zls(data, opts), -4), { i: 2 }, opts, opts);\n}\nvar td = typeof TextDecoder != \"undefined\" && /* @__PURE__ */ new TextDecoder();\nvar tds = 0;\ntry {\n  td.decode(et, { stream: true });\n  tds = 1;\n} catch (e) {\n}\nfunction findSpan(p, u, U) {\n  const n = U.length - p - 1;\n  if (u >= U[n]) {\n    return n - 1;\n  }\n  if (u <= U[p]) {\n    return p;\n  }\n  let low = p;\n  let high = n;\n  let mid = Math.floor((low + high) / 2);\n  while (u < U[mid] || u >= U[mid + 1]) {\n    if (u < U[mid]) {\n      high = mid;\n    } else {\n      low = mid;\n    }\n    mid = Math.floor((low + high) / 2);\n  }\n  return mid;\n}\nfunction calcBasisFunctions(span, u, p, U) {\n  const N = [];\n  const left = [];\n  const right = [];\n  N[0] = 1;\n  for (let j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j];\n    right[j] = U[span + j] - u;\n    let saved = 0;\n    for (let r = 0; r < j; ++r) {\n      const rv = right[r + 1];\n      const lv = left[j - r];\n      const temp = N[r] / (rv + lv);\n      N[r] = saved + rv * temp;\n      saved = lv * temp;\n    }\n    N[j] = saved;\n  }\n  return N;\n}\nfunction calcBSplinePoint(p, U, P, u) {\n  const span = findSpan(p, u, U);\n  const N = calcBasisFunctions(span, u, p, U);\n  const C = new Vector4(0, 0, 0, 0);\n  for (let j = 0; j <= p; ++j) {\n    const point = P[span - p + j];\n    const Nj = N[j];\n    const wNj = point.w * Nj;\n    C.x += point.x * wNj;\n    C.y += point.y * wNj;\n    C.z += point.z * wNj;\n    C.w += point.w * Nj;\n  }\n  return C;\n}\nfunction calcBasisFunctionDerivatives(span, u, p, n, U) {\n  const zeroArr = [];\n  for (let i = 0; i <= p; ++i)\n    zeroArr[i] = 0;\n  const ders = [];\n  for (let i = 0; i <= n; ++i)\n    ders[i] = zeroArr.slice(0);\n  const ndu = [];\n  for (let i = 0; i <= p; ++i)\n    ndu[i] = zeroArr.slice(0);\n  ndu[0][0] = 1;\n  const left = zeroArr.slice(0);\n  const right = zeroArr.slice(0);\n  for (let j = 1; j <= p; ++j) {\n    left[j] = u - U[span + 1 - j];\n    right[j] = U[span + j] - u;\n    let saved = 0;\n    for (let r2 = 0; r2 < j; ++r2) {\n      const rv = right[r2 + 1];\n      const lv = left[j - r2];\n      ndu[j][r2] = rv + lv;\n      const temp = ndu[r2][j - 1] / ndu[j][r2];\n      ndu[r2][j] = saved + rv * temp;\n      saved = lv * temp;\n    }\n    ndu[j][j] = saved;\n  }\n  for (let j = 0; j <= p; ++j) {\n    ders[0][j] = ndu[j][p];\n  }\n  for (let r2 = 0; r2 <= p; ++r2) {\n    let s1 = 0;\n    let s2 = 1;\n    const a = [];\n    for (let i = 0; i <= p; ++i) {\n      a[i] = zeroArr.slice(0);\n    }\n    a[0][0] = 1;\n    for (let k = 1; k <= n; ++k) {\n      let d = 0;\n      const rk = r2 - k;\n      const pk = p - k;\n      if (r2 >= k) {\n        a[s2][0] = a[s1][0] / ndu[pk + 1][rk];\n        d = a[s2][0] * ndu[rk][pk];\n      }\n      const j1 = rk >= -1 ? 1 : -rk;\n      const j2 = r2 - 1 <= pk ? k - 1 : p - r2;\n      for (let j3 = j1; j3 <= j2; ++j3) {\n        a[s2][j3] = (a[s1][j3] - a[s1][j3 - 1]) / ndu[pk + 1][rk + j3];\n        d += a[s2][j3] * ndu[rk + j3][pk];\n      }\n      if (r2 <= pk) {\n        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r2];\n        d += a[s2][k] * ndu[r2][pk];\n      }\n      ders[k][r2] = d;\n      const j = s1;\n      s1 = s2;\n      s2 = j;\n    }\n  }\n  let r = p;\n  for (let k = 1; k <= n; ++k) {\n    for (let j = 0; j <= p; ++j) {\n      ders[k][j] *= r;\n    }\n    r *= p - k;\n  }\n  return ders;\n}\nfunction calcBSplineDerivatives(p, U, P, u, nd) {\n  const du = nd < p ? nd : p;\n  const CK = [];\n  const span = findSpan(p, u, U);\n  const nders = calcBasisFunctionDerivatives(span, u, p, du, U);\n  const Pw = [];\n  for (let i = 0; i < P.length; ++i) {\n    const point = P[i].clone();\n    const w = point.w;\n    point.x *= w;\n    point.y *= w;\n    point.z *= w;\n    Pw[i] = point;\n  }\n  for (let k = 0; k <= du; ++k) {\n    const point = Pw[span - p].clone().multiplyScalar(nders[k][0]);\n    for (let j = 1; j <= p; ++j) {\n      point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));\n    }\n    CK[k] = point;\n  }\n  for (let k = du + 1; k <= nd + 1; ++k) {\n    CK[k] = new Vector4(0, 0, 0);\n  }\n  return CK;\n}\nfunction calcKoverI(k, i) {\n  let nom = 1;\n  for (let j = 2; j <= k; ++j) {\n    nom *= j;\n  }\n  let denom = 1;\n  for (let j = 2; j <= i; ++j) {\n    denom *= j;\n  }\n  for (let j = 2; j <= k - i; ++j) {\n    denom *= j;\n  }\n  return nom / denom;\n}\nfunction calcRationalCurveDerivatives(Pders) {\n  const nd = Pders.length;\n  const Aders = [];\n  const wders = [];\n  for (let i = 0; i < nd; ++i) {\n    const point = Pders[i];\n    Aders[i] = new Vector3(point.x, point.y, point.z);\n    wders[i] = point.w;\n  }\n  const CK = [];\n  for (let k = 0; k < nd; ++k) {\n    const v = Aders[k].clone();\n    for (let i = 1; i <= k; ++i) {\n      v.sub(CK[k - i].clone().multiplyScalar(calcKoverI(k, i) * wders[i]));\n    }\n    CK[k] = v.divideScalar(wders[0]);\n  }\n  return CK;\n}\nfunction calcNURBSDerivatives(p, U, P, u, nd) {\n  const Pders = calcBSplineDerivatives(p, U, P, u, nd);\n  return calcRationalCurveDerivatives(Pders);\n}\nclass NURBSCurve extends Curve {\n  constructor(degree, knots, controlPoints, startKnot, endKnot) {\n    super();\n    const knotsLength = knots ? knots.length - 1 : 0;\n    const pointsLength = controlPoints ? controlPoints.length : 0;\n    this.degree = degree;\n    this.knots = knots;\n    this.controlPoints = [];\n    this.startKnot = startKnot || 0;\n    this.endKnot = endKnot || knotsLength;\n    for (let i = 0; i < pointsLength; ++i) {\n      const point = controlPoints[i];\n      this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);\n    }\n  }\n  getPoint(t2, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    const u = this.knots[this.startKnot] + t2 * (this.knots[this.endKnot] - this.knots[this.startKnot]);\n    const hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);\n    if (hpoint.w !== 1) {\n      hpoint.divideScalar(hpoint.w);\n    }\n    return point.set(hpoint.x, hpoint.y, hpoint.z);\n  }\n  getTangent(t2, optionalTarget = new Vector3()) {\n    const tangent = optionalTarget;\n    const u = this.knots[0] + t2 * (this.knots[this.knots.length - 1] - this.knots[0]);\n    const ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);\n    tangent.copy(ders[1]).normalize();\n    return tangent;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.degree = this.degree;\n    data.knots = [...this.knots];\n    data.controlPoints = this.controlPoints.map((p) => p.toArray());\n    data.startKnot = this.startKnot;\n    data.endKnot = this.endKnot;\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.degree = json.degree;\n    this.knots = [...json.knots];\n    this.controlPoints = json.controlPoints.map((p) => new Vector4(p[0], p[1], p[2], p[3]));\n    this.startKnot = json.startKnot;\n    this.endKnot = json.endKnot;\n    return this;\n  }\n}\nlet fbxTree;\nlet connections;\nlet sceneGraph;\nclass FBXLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url2, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === \"\" ? LoaderUtils.extractUrlBase(url2) : scope.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url2, function(buffer) {\n      try {\n        onLoad(scope.parse(buffer, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url2);\n      }\n    }, onProgress, onError);\n  }\n  parse(FBXBuffer, path) {\n    if (isFbxFormatBinary(FBXBuffer)) {\n      fbxTree = new BinaryParser().parse(FBXBuffer);\n    } else {\n      const FBXText = convertArrayBufferToString(FBXBuffer);\n      if (!isFbxFormatASCII(FBXText)) {\n        throw new Error(\"THREE.FBXLoader: Unknown format.\");\n      }\n      if (getFbxVersion(FBXText) < 7e3) {\n        throw new Error(\"THREE.FBXLoader: FBX version not supported, FileVersion: \" + getFbxVersion(FBXText));\n      }\n      fbxTree = new TextParser().parse(FBXText);\n    }\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);\n  }\n}\nclass FBXTreeParser {\n  constructor(textureLoader, manager) {\n    this.textureLoader = textureLoader;\n    this.manager = manager;\n  }\n  parse() {\n    connections = this.parseConnections();\n    const images = this.parseImages();\n    const textures = this.parseTextures(images);\n    const materials = this.parseMaterials(textures);\n    const deformers = this.parseDeformers();\n    const geometryMap = new GeometryParser().parse(deformers);\n    this.parseScene(deformers, geometryMap, materials);\n    return sceneGraph;\n  }\n  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n  // and details the connection type\n  parseConnections() {\n    const connectionMap = /* @__PURE__ */ new Map();\n    if (\"Connections\" in fbxTree) {\n      const rawConnections = fbxTree.Connections.connections;\n      rawConnections.forEach(function(rawConnection) {\n        const fromID = rawConnection[0];\n        const toID = rawConnection[1];\n        const relationship = rawConnection[2];\n        if (!connectionMap.has(fromID)) {\n          connectionMap.set(fromID, {\n            parents: [],\n            children: []\n          });\n        }\n        const parentRelationship = { ID: toID, relationship };\n        connectionMap.get(fromID).parents.push(parentRelationship);\n        if (!connectionMap.has(toID)) {\n          connectionMap.set(toID, {\n            parents: [],\n            children: []\n          });\n        }\n        const childRelationship = { ID: fromID, relationship };\n        connectionMap.get(toID).children.push(childRelationship);\n      });\n    }\n    return connectionMap;\n  }\n  // Parse FBXTree.Objects.Video for embedded image data\n  // These images are connected to textures in FBXTree.Objects.Textures\n  // via FBXTree.Connections.\n  parseImages() {\n    const images = {};\n    const blobs = {};\n    if (\"Video\" in fbxTree.Objects) {\n      const videoNodes = fbxTree.Objects.Video;\n      for (const nodeID in videoNodes) {\n        const videoNode = videoNodes[nodeID];\n        const id2 = parseInt(nodeID);\n        images[id2] = videoNode.RelativeFilename || videoNode.Filename;\n        if (\"Content\" in videoNode) {\n          const arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\n          const base64Content = typeof videoNode.Content === \"string\" && videoNode.Content !== \"\";\n          if (arrayBufferContent || base64Content) {\n            const image = this.parseImage(videoNodes[nodeID]);\n            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;\n          }\n        }\n      }\n    }\n    for (const id2 in images) {\n      const filename = images[id2];\n      if (blobs[filename] !== void 0) images[id2] = blobs[filename];\n      else images[id2] = images[id2].split(\"\\\\\").pop();\n    }\n    return images;\n  }\n  // Parse embedded image data in FBXTree.Video.Content\n  parseImage(videoNode) {\n    const content = videoNode.Content;\n    const fileName = videoNode.RelativeFilename || videoNode.Filename;\n    const extension = fileName.slice(fileName.lastIndexOf(\".\") + 1).toLowerCase();\n    let type;\n    switch (extension) {\n      case \"bmp\":\n        type = \"image/bmp\";\n        break;\n      case \"jpg\":\n      case \"jpeg\":\n        type = \"image/jpeg\";\n        break;\n      case \"png\":\n        type = \"image/png\";\n        break;\n      case \"tif\":\n        type = \"image/tiff\";\n        break;\n      case \"tga\":\n        if (this.manager.getHandler(\".tga\") === null) {\n          console.warn(\"FBXLoader: TGA loader not found, skipping \", fileName);\n        }\n        type = \"image/tga\";\n        break;\n      default:\n        console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n        return;\n    }\n    if (typeof content === \"string\") {\n      return \"data:\" + type + \";base64,\" + content;\n    } else {\n      const array = new Uint8Array(content);\n      return window.URL.createObjectURL(new Blob([array], { type }));\n    }\n  }\n  // Parse nodes in FBXTree.Objects.Texture\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\n  // to images in FBXTree.Objects.Video\n  parseTextures(images) {\n    const textureMap = /* @__PURE__ */ new Map();\n    if (\"Texture\" in fbxTree.Objects) {\n      const textureNodes = fbxTree.Objects.Texture;\n      for (const nodeID in textureNodes) {\n        const texture = this.parseTexture(textureNodes[nodeID], images);\n        textureMap.set(parseInt(nodeID), texture);\n      }\n    }\n    return textureMap;\n  }\n  // Parse individual node in FBXTree.Objects.Texture\n  parseTexture(textureNode, images) {\n    const texture = this.loadTexture(textureNode, images);\n    texture.ID = textureNode.id;\n    texture.name = textureNode.attrName;\n    const wrapModeU = textureNode.WrapModeU;\n    const wrapModeV = textureNode.WrapModeV;\n    const valueU = wrapModeU !== void 0 ? wrapModeU.value : 0;\n    const valueV = wrapModeV !== void 0 ? wrapModeV.value : 0;\n    texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;\n    texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;\n    if (\"Scaling\" in textureNode) {\n      const values = textureNode.Scaling.value;\n      texture.repeat.x = values[0];\n      texture.repeat.y = values[1];\n    }\n    if (\"Translation\" in textureNode) {\n      const values = textureNode.Translation.value;\n      texture.offset.x = values[0];\n      texture.offset.y = values[1];\n    }\n    return texture;\n  }\n  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\n  loadTexture(textureNode, images) {\n    const nonNativeExtensions = /* @__PURE__ */ new Set([\"tga\", \"tif\", \"tiff\", \"exr\", \"dds\", \"hdr\", \"ktx2\"]);\n    const extension = textureNode.FileName.split(\".\").pop().toLowerCase();\n    const loader = nonNativeExtensions.has(extension) ? this.manager.getHandler(`.${extension}`) : this.textureLoader;\n    if (!loader) {\n      console.warn(\n        `FBXLoader: ${extension.toUpperCase()} loader not found, creating placeholder texture for`,\n        textureNode.RelativeFilename\n      );\n      return new Texture();\n    }\n    const loaderPath = loader.path;\n    if (!loaderPath) {\n      loader.setPath(this.textureLoader.path);\n    }\n    const children = connections.get(textureNode.id).children;\n    let fileName;\n    if (children !== void 0 && children.length > 0 && images[children[0].ID] !== void 0) {\n      fileName = images[children[0].ID];\n      if (fileName.indexOf(\"blob:\") === 0 || fileName.indexOf(\"data:\") === 0) {\n        loader.setPath(void 0);\n      }\n    }\n    const texture = loader.load(fileName);\n    loader.setPath(loaderPath);\n    return texture;\n  }\n  // Parse nodes in FBXTree.Objects.Material\n  parseMaterials(textureMap) {\n    const materialMap = /* @__PURE__ */ new Map();\n    if (\"Material\" in fbxTree.Objects) {\n      const materialNodes = fbxTree.Objects.Material;\n      for (const nodeID in materialNodes) {\n        const material = this.parseMaterial(materialNodes[nodeID], textureMap);\n        if (material !== null) materialMap.set(parseInt(nodeID), material);\n      }\n    }\n    return materialMap;\n  }\n  // Parse single node in FBXTree.Objects.Material\n  // Materials are connected to texture maps in FBXTree.Objects.Textures\n  // FBX format currently only supports Lambert and Phong shading models\n  parseMaterial(materialNode, textureMap) {\n    const ID = materialNode.id;\n    const name = materialNode.attrName;\n    let type = materialNode.ShadingModel;\n    if (typeof type === \"object\") {\n      type = type.value;\n    }\n    if (!connections.has(ID)) return null;\n    const parameters = this.parseParameters(materialNode, textureMap, ID);\n    let material;\n    switch (type.toLowerCase()) {\n      case \"phong\":\n        material = new MeshPhongMaterial();\n        break;\n      case \"lambert\":\n        material = new MeshLambertMaterial();\n        break;\n      default:\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n        material = new MeshPhongMaterial();\n        break;\n    }\n    material.setValues(parameters);\n    material.name = name;\n    return material;\n  }\n  // Parse FBX material and return parameters suitable for a three.js material\n  // Also parse the texture map and return any textures associated with the material\n  parseParameters(materialNode, textureMap, ID) {\n    const parameters = {};\n    if (materialNode.BumpFactor) {\n      parameters.bumpScale = materialNode.BumpFactor.value;\n    }\n    if (materialNode.Diffuse) {\n      parameters.color = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.Diffuse.value), SRGBColorSpace);\n    } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === \"Color\" || materialNode.DiffuseColor.type === \"ColorRGB\")) {\n      parameters.color = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.DiffuseColor.value), SRGBColorSpace);\n    }\n    if (materialNode.DisplacementFactor) {\n      parameters.displacementScale = materialNode.DisplacementFactor.value;\n    }\n    if (materialNode.Emissive) {\n      parameters.emissive = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.Emissive.value), SRGBColorSpace);\n    } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === \"Color\" || materialNode.EmissiveColor.type === \"ColorRGB\")) {\n      parameters.emissive = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.EmissiveColor.value), SRGBColorSpace);\n    }\n    if (materialNode.EmissiveFactor) {\n      parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);\n    }\n    parameters.opacity = 1 - (materialNode.TransparencyFactor ? parseFloat(materialNode.TransparencyFactor.value) : 0);\n    if (parameters.opacity === 1 || parameters.opacity === 0) {\n      parameters.opacity = materialNode.Opacity ? parseFloat(materialNode.Opacity.value) : null;\n      if (parameters.opacity === null) {\n        parameters.opacity = 1 - (materialNode.TransparentColor ? parseFloat(materialNode.TransparentColor.value[0]) : 0);\n      }\n    }\n    if (parameters.opacity < 1) {\n      parameters.transparent = true;\n    }\n    if (materialNode.ReflectionFactor) {\n      parameters.reflectivity = materialNode.ReflectionFactor.value;\n    }\n    if (materialNode.Shininess) {\n      parameters.shininess = materialNode.Shininess.value;\n    }\n    if (materialNode.Specular) {\n      parameters.specular = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.Specular.value), SRGBColorSpace);\n    } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === \"Color\") {\n      parameters.specular = ColorManagement.toWorkingColorSpace(new Color().fromArray(materialNode.SpecularColor.value), SRGBColorSpace);\n    }\n    const scope = this;\n    connections.get(ID).children.forEach(function(child) {\n      const type = child.relationship;\n      switch (type) {\n        case \"Bump\":\n          parameters.bumpMap = scope.getTexture(textureMap, child.ID);\n          break;\n        case \"Maya|TEX_ao_map\":\n          parameters.aoMap = scope.getTexture(textureMap, child.ID);\n          break;\n        case \"DiffuseColor\":\n        case \"Maya|TEX_color_map\":\n          parameters.map = scope.getTexture(textureMap, child.ID);\n          if (parameters.map !== void 0) {\n            parameters.map.colorSpace = SRGBColorSpace;\n          }\n          break;\n        case \"DisplacementColor\":\n          parameters.displacementMap = scope.getTexture(textureMap, child.ID);\n          break;\n        case \"EmissiveColor\":\n          parameters.emissiveMap = scope.getTexture(textureMap, child.ID);\n          if (parameters.emissiveMap !== void 0) {\n            parameters.emissiveMap.colorSpace = SRGBColorSpace;\n          }\n          break;\n        case \"NormalMap\":\n        case \"Maya|TEX_normal_map\":\n          parameters.normalMap = scope.getTexture(textureMap, child.ID);\n          break;\n        case \"ReflectionColor\":\n          parameters.envMap = scope.getTexture(textureMap, child.ID);\n          if (parameters.envMap !== void 0) {\n            parameters.envMap.mapping = EquirectangularReflectionMapping;\n            parameters.envMap.colorSpace = SRGBColorSpace;\n          }\n          break;\n        case \"SpecularColor\":\n          parameters.specularMap = scope.getTexture(textureMap, child.ID);\n          if (parameters.specularMap !== void 0) {\n            parameters.specularMap.colorSpace = SRGBColorSpace;\n          }\n          break;\n        case \"TransparentColor\":\n        case \"TransparencyFactor\":\n          parameters.alphaMap = scope.getTexture(textureMap, child.ID);\n          parameters.transparent = true;\n          break;\n        case \"AmbientColor\":\n        case \"ShininessExponent\":\n        case \"SpecularFactor\":\n        case \"VectorDisplacementColor\":\n        default:\n          console.warn(\"THREE.FBXLoader: %s map is not supported in three.js, skipping texture.\", type);\n          break;\n      }\n    });\n    return parameters;\n  }\n  // get a texture from the textureMap for use by a material.\n  getTexture(textureMap, id2) {\n    if (\"LayeredTexture\" in fbxTree.Objects && id2 in fbxTree.Objects.LayeredTexture) {\n      console.warn(\"THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.\");\n      id2 = connections.get(id2).children[0].ID;\n    }\n    return textureMap.get(id2);\n  }\n  // Parse nodes in FBXTree.Objects.Deformer\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n  parseDeformers() {\n    const skeletons = {};\n    const morphTargets = {};\n    if (\"Deformer\" in fbxTree.Objects) {\n      const DeformerNodes = fbxTree.Objects.Deformer;\n      for (const nodeID in DeformerNodes) {\n        const deformerNode = DeformerNodes[nodeID];\n        const relationships = connections.get(parseInt(nodeID));\n        if (deformerNode.attrType === \"Skin\") {\n          const skeleton = this.parseSkeleton(relationships, DeformerNodes);\n          skeleton.ID = nodeID;\n          if (relationships.parents.length > 1) console.warn(\"THREE.FBXLoader: skeleton attached to more than one geometry is not supported.\");\n          skeleton.geometryID = relationships.parents[0].ID;\n          skeletons[nodeID] = skeleton;\n        } else if (deformerNode.attrType === \"BlendShape\") {\n          const morphTarget = {\n            id: nodeID\n          };\n          morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);\n          morphTarget.id = nodeID;\n          if (relationships.parents.length > 1) console.warn(\"THREE.FBXLoader: morph target attached to more than one geometry is not supported.\");\n          morphTargets[nodeID] = morphTarget;\n        }\n      }\n    }\n    return {\n      skeletons,\n      morphTargets\n    };\n  }\n  // Parse single nodes in FBXTree.Objects.Deformer\n  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n  // Each skin node represents a skeleton and each cluster node represents a bone\n  parseSkeleton(relationships, deformerNodes) {\n    const rawBones = [];\n    relationships.children.forEach(function(child) {\n      const boneNode = deformerNodes[child.ID];\n      if (boneNode.attrType !== \"Cluster\") return;\n      const rawBone = {\n        ID: child.ID,\n        indices: [],\n        weights: [],\n        transformLink: new Matrix4().fromArray(boneNode.TransformLink.a)\n        // transform: new Matrix4().fromArray( boneNode.Transform.a ),\n        // linkMode: boneNode.Mode,\n      };\n      if (\"Indexes\" in boneNode) {\n        rawBone.indices = boneNode.Indexes.a;\n        rawBone.weights = boneNode.Weights.a;\n      }\n      rawBones.push(rawBone);\n    });\n    return {\n      rawBones,\n      bones: []\n    };\n  }\n  // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n  parseMorphTargets(relationships, deformerNodes) {\n    const rawMorphTargets = [];\n    for (let i = 0; i < relationships.children.length; i++) {\n      const child = relationships.children[i];\n      const morphTargetNode = deformerNodes[child.ID];\n      const rawMorphTarget = {\n        name: morphTargetNode.attrName,\n        initialWeight: morphTargetNode.DeformPercent,\n        id: morphTargetNode.id,\n        fullWeights: morphTargetNode.FullWeights.a\n      };\n      if (morphTargetNode.attrType !== \"BlendShapeChannel\") return;\n      rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function(child2) {\n        return child2.relationship === void 0;\n      })[0].ID;\n      rawMorphTargets.push(rawMorphTarget);\n    }\n    return rawMorphTargets;\n  }\n  // create the main Group() to be returned by the loader\n  parseScene(deformers, geometryMap, materialMap) {\n    sceneGraph = new Group();\n    const modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);\n    const modelNodes = fbxTree.Objects.Model;\n    const scope = this;\n    modelMap.forEach(function(model) {\n      const modelNode = modelNodes[model.ID];\n      scope.setLookAtProperties(model, modelNode);\n      const parentConnections = connections.get(model.ID).parents;\n      parentConnections.forEach(function(connection) {\n        const parent = modelMap.get(connection.ID);\n        if (parent !== void 0) parent.add(model);\n      });\n      if (model.parent === null) {\n        sceneGraph.add(model);\n      }\n    });\n    this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);\n    this.addGlobalSceneSettings();\n    sceneGraph.traverse(function(node) {\n      if (node.userData.transformData) {\n        if (node.parent) {\n          node.userData.transformData.parentMatrix = node.parent.matrix;\n          node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;\n        }\n        const transform = generateTransform(node.userData.transformData);\n        node.applyMatrix4(transform);\n        node.updateWorldMatrix();\n      }\n    });\n    const animations = new AnimationParser().parse();\n    if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {\n      sceneGraph.children[0].animations = animations;\n      sceneGraph = sceneGraph.children[0];\n    }\n    sceneGraph.animations = animations;\n  }\n  // parse nodes in FBXTree.Objects.Model\n  parseModels(skeletons, geometryMap, materialMap) {\n    const modelMap = /* @__PURE__ */ new Map();\n    const modelNodes = fbxTree.Objects.Model;\n    for (const nodeID in modelNodes) {\n      const id2 = parseInt(nodeID);\n      const node = modelNodes[nodeID];\n      const relationships = connections.get(id2);\n      let model = this.buildSkeleton(relationships, skeletons, id2, node.attrName);\n      if (!model) {\n        switch (node.attrType) {\n          case \"Camera\":\n            model = this.createCamera(relationships);\n            break;\n          case \"Light\":\n            model = this.createLight(relationships);\n            break;\n          case \"Mesh\":\n            model = this.createMesh(relationships, geometryMap, materialMap);\n            break;\n          case \"NurbsCurve\":\n            model = this.createCurve(relationships, geometryMap);\n            break;\n          case \"LimbNode\":\n          case \"Root\":\n            model = new Bone();\n            break;\n          case \"Null\":\n          default:\n            model = new Group();\n            break;\n        }\n        model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : \"\";\n        model.userData.originalName = node.attrName;\n        model.ID = id2;\n      }\n      this.getTransformData(model, node);\n      modelMap.set(id2, model);\n    }\n    return modelMap;\n  }\n  buildSkeleton(relationships, skeletons, id2, name) {\n    let bone = null;\n    relationships.parents.forEach(function(parent) {\n      for (const ID in skeletons) {\n        const skeleton = skeletons[ID];\n        skeleton.rawBones.forEach(function(rawBone, i) {\n          if (rawBone.ID === parent.ID) {\n            const subBone = bone;\n            bone = new Bone();\n            bone.matrixWorld.copy(rawBone.transformLink);\n            bone.name = name ? PropertyBinding.sanitizeNodeName(name) : \"\";\n            bone.userData.originalName = name;\n            bone.ID = id2;\n            skeleton.bones[i] = bone;\n            if (subBone !== null) {\n              bone.add(subBone);\n            }\n          }\n        });\n      }\n    });\n    return bone;\n  }\n  // create a PerspectiveCamera or OrthographicCamera\n  createCamera(relationships) {\n    let model;\n    let cameraAttribute;\n    relationships.children.forEach(function(child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID];\n      if (attr !== void 0) {\n        cameraAttribute = attr;\n      }\n    });\n    if (cameraAttribute === void 0) {\n      model = new Object3D();\n    } else {\n      let type = 0;\n      if (cameraAttribute.CameraProjectionType !== void 0 && cameraAttribute.CameraProjectionType.value === 1) {\n        type = 1;\n      }\n      let nearClippingPlane = 1;\n      if (cameraAttribute.NearPlane !== void 0) {\n        nearClippingPlane = cameraAttribute.NearPlane.value / 1e3;\n      }\n      let farClippingPlane = 1e3;\n      if (cameraAttribute.FarPlane !== void 0) {\n        farClippingPlane = cameraAttribute.FarPlane.value / 1e3;\n      }\n      let width = window.innerWidth;\n      let height = window.innerHeight;\n      if (cameraAttribute.AspectWidth !== void 0 && cameraAttribute.AspectHeight !== void 0) {\n        width = cameraAttribute.AspectWidth.value;\n        height = cameraAttribute.AspectHeight.value;\n      }\n      const aspect2 = width / height;\n      let fov2 = 45;\n      if (cameraAttribute.FieldOfView !== void 0) {\n        fov2 = cameraAttribute.FieldOfView.value;\n      }\n      const focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n      switch (type) {\n        case 0:\n          model = new PerspectiveCamera(fov2, aspect2, nearClippingPlane, farClippingPlane);\n          if (focalLength !== null) model.setFocalLength(focalLength);\n          break;\n        case 1:\n          console.warn(\"THREE.FBXLoader: Orthographic cameras not supported yet.\");\n          model = new Object3D();\n          break;\n        default:\n          console.warn(\"THREE.FBXLoader: Unknown camera type \" + type + \".\");\n          model = new Object3D();\n          break;\n      }\n    }\n    return model;\n  }\n  // Create a DirectionalLight, PointLight or SpotLight\n  createLight(relationships) {\n    let model;\n    let lightAttribute;\n    relationships.children.forEach(function(child) {\n      const attr = fbxTree.Objects.NodeAttribute[child.ID];\n      if (attr !== void 0) {\n        lightAttribute = attr;\n      }\n    });\n    if (lightAttribute === void 0) {\n      model = new Object3D();\n    } else {\n      let type;\n      if (lightAttribute.LightType === void 0) {\n        type = 0;\n      } else {\n        type = lightAttribute.LightType.value;\n      }\n      let color = 16777215;\n      if (lightAttribute.Color !== void 0) {\n        color = ColorManagement.toWorkingColorSpace(new Color().fromArray(lightAttribute.Color.value), SRGBColorSpace);\n      }\n      let intensity = lightAttribute.Intensity === void 0 ? 1 : lightAttribute.Intensity.value / 100;\n      if (lightAttribute.CastLightOnObject !== void 0 && lightAttribute.CastLightOnObject.value === 0) {\n        intensity = 0;\n      }\n      let distance = 0;\n      if (lightAttribute.FarAttenuationEnd !== void 0) {\n        if (lightAttribute.EnableFarAttenuation !== void 0 && lightAttribute.EnableFarAttenuation.value === 0) {\n          distance = 0;\n        } else {\n          distance = lightAttribute.FarAttenuationEnd.value;\n        }\n      }\n      const decay = 1;\n      switch (type) {\n        case 0:\n          model = new PointLight(color, intensity, distance, decay);\n          break;\n        case 1:\n          model = new DirectionalLight(color, intensity);\n          break;\n        case 2:\n          let angle = Math.PI / 3;\n          if (lightAttribute.InnerAngle !== void 0) {\n            angle = MathUtils.degToRad(lightAttribute.InnerAngle.value);\n          }\n          let penumbra = 0;\n          if (lightAttribute.OuterAngle !== void 0) {\n            penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);\n            penumbra = Math.max(penumbra, 1);\n          }\n          model = new SpotLight(color, intensity, distance, angle, penumbra, decay);\n          break;\n        default:\n          console.warn(\"THREE.FBXLoader: Unknown light type \" + lightAttribute.LightType.value + \", defaulting to a PointLight.\");\n          model = new PointLight(color, intensity);\n          break;\n      }\n      if (lightAttribute.CastShadows !== void 0 && lightAttribute.CastShadows.value === 1) {\n        model.castShadow = true;\n      }\n    }\n    return model;\n  }\n  createMesh(relationships, geometryMap, materialMap) {\n    let model;\n    let geometry = null;\n    let material = null;\n    const materials = [];\n    relationships.children.forEach(function(child) {\n      if (geometryMap.has(child.ID)) {\n        geometry = geometryMap.get(child.ID);\n      }\n      if (materialMap.has(child.ID)) {\n        materials.push(materialMap.get(child.ID));\n      }\n    });\n    if (materials.length > 1) {\n      material = materials;\n    } else if (materials.length > 0) {\n      material = materials[0];\n    } else {\n      material = new MeshPhongMaterial({\n        name: Loader.DEFAULT_MATERIAL_NAME,\n        color: 13421772\n      });\n      materials.push(material);\n    }\n    if (\"color\" in geometry.attributes) {\n      materials.forEach(function(material2) {\n        material2.vertexColors = true;\n      });\n    }\n    if (geometry.FBX_Deformer) {\n      model = new SkinnedMesh(geometry, material);\n      model.normalizeSkinWeights();\n    } else {\n      model = new Mesh(geometry, material);\n    }\n    return model;\n  }\n  createCurve(relationships, geometryMap) {\n    const geometry = relationships.children.reduce(function(geo, child) {\n      if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\n      return geo;\n    }, null);\n    const material = new LineBasicMaterial({\n      name: Loader.DEFAULT_MATERIAL_NAME,\n      color: 3342591,\n      linewidth: 1\n    });\n    return new Line(geometry, material);\n  }\n  // parse the model node for transform data\n  getTransformData(model, modelNode) {\n    const transformData = {};\n    if (\"InheritType\" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\n    if (\"RotationOrder\" in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);\n    else transformData.eulerOrder = getEulerOrder(0);\n    if (\"Lcl_Translation\" in modelNode) transformData.translation = modelNode.Lcl_Translation.value;\n    if (\"PreRotation\" in modelNode) transformData.preRotation = modelNode.PreRotation.value;\n    if (\"Lcl_Rotation\" in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;\n    if (\"PostRotation\" in modelNode) transformData.postRotation = modelNode.PostRotation.value;\n    if (\"Lcl_Scaling\" in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;\n    if (\"ScalingOffset\" in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;\n    if (\"ScalingPivot\" in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;\n    if (\"RotationOffset\" in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;\n    if (\"RotationPivot\" in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;\n    model.userData.transformData = transformData;\n  }\n  setLookAtProperties(model, modelNode) {\n    if (\"LookAtProperty\" in modelNode) {\n      const children = connections.get(model.ID).children;\n      children.forEach(function(child) {\n        if (child.relationship === \"LookAtProperty\") {\n          const lookAtTarget = fbxTree.Objects.Model[child.ID];\n          if (\"Lcl_Translation\" in lookAtTarget) {\n            const pos = lookAtTarget.Lcl_Translation.value;\n            if (model.target !== void 0) {\n              model.target.position.fromArray(pos);\n              sceneGraph.add(model.target);\n            } else {\n              model.lookAt(new Vector3().fromArray(pos));\n            }\n          }\n        }\n      });\n    }\n  }\n  bindSkeleton(skeletons, geometryMap, modelMap) {\n    const bindMatrices = this.parsePoseNodes();\n    for (const ID in skeletons) {\n      const skeleton = skeletons[ID];\n      const parents = connections.get(parseInt(skeleton.ID)).parents;\n      parents.forEach(function(parent) {\n        if (geometryMap.has(parent.ID)) {\n          const geoID = parent.ID;\n          const geoRelationships = connections.get(geoID);\n          geoRelationships.parents.forEach(function(geoConnParent) {\n            if (modelMap.has(geoConnParent.ID)) {\n              const model = modelMap.get(geoConnParent.ID);\n              model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);\n            }\n          });\n        }\n      });\n    }\n  }\n  parsePoseNodes() {\n    const bindMatrices = {};\n    if (\"Pose\" in fbxTree.Objects) {\n      const BindPoseNode = fbxTree.Objects.Pose;\n      for (const nodeID in BindPoseNode) {\n        if (BindPoseNode[nodeID].attrType === \"BindPose\" && BindPoseNode[nodeID].NbPoseNodes > 0) {\n          const poseNodes = BindPoseNode[nodeID].PoseNode;\n          if (Array.isArray(poseNodes)) {\n            poseNodes.forEach(function(poseNode) {\n              bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);\n            });\n          } else {\n            bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);\n          }\n        }\n      }\n    }\n    return bindMatrices;\n  }\n  addGlobalSceneSettings() {\n    if (\"GlobalSettings\" in fbxTree) {\n      if (\"AmbientColor\" in fbxTree.GlobalSettings) {\n        const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n        const r = ambientColor[0];\n        const g = ambientColor[1];\n        const b = ambientColor[2];\n        if (r !== 0 || g !== 0 || b !== 0) {\n          const color = new Color().setRGB(r, g, b, SRGBColorSpace);\n          sceneGraph.add(new AmbientLight(color, 1));\n        }\n      }\n      if (\"UnitScaleFactor\" in fbxTree.GlobalSettings) {\n        sceneGraph.userData.unitScaleFactor = fbxTree.GlobalSettings.UnitScaleFactor.value;\n      }\n    }\n  }\n}\nclass GeometryParser {\n  constructor() {\n    this.negativeMaterialIndices = false;\n  }\n  // Parse nodes in FBXTree.Objects.Geometry\n  parse(deformers) {\n    const geometryMap = /* @__PURE__ */ new Map();\n    if (\"Geometry\" in fbxTree.Objects) {\n      const geoNodes = fbxTree.Objects.Geometry;\n      for (const nodeID in geoNodes) {\n        const relationships = connections.get(parseInt(nodeID));\n        const geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);\n        geometryMap.set(parseInt(nodeID), geo);\n      }\n    }\n    if (this.negativeMaterialIndices === true) {\n      console.warn(\"THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected.\");\n    }\n    return geometryMap;\n  }\n  // Parse single node in FBXTree.Objects.Geometry\n  parseGeometry(relationships, geoNode, deformers) {\n    switch (geoNode.attrType) {\n      case \"Mesh\":\n        return this.parseMeshGeometry(relationships, geoNode, deformers);\n      case \"NurbsCurve\":\n        return this.parseNurbsGeometry(geoNode);\n    }\n  }\n  // Parse single node mesh geometry in FBXTree.Objects.Geometry\n  parseMeshGeometry(relationships, geoNode, deformers) {\n    const skeletons = deformers.skeletons;\n    const morphTargets = [];\n    const modelNodes = relationships.parents.map(function(parent) {\n      return fbxTree.Objects.Model[parent.ID];\n    });\n    if (modelNodes.length === 0) return;\n    const skeleton = relationships.children.reduce(function(skeleton2, child) {\n      if (skeletons[child.ID] !== void 0) skeleton2 = skeletons[child.ID];\n      return skeleton2;\n    }, null);\n    relationships.children.forEach(function(child) {\n      if (deformers.morphTargets[child.ID] !== void 0) {\n        morphTargets.push(deformers.morphTargets[child.ID]);\n      }\n    });\n    const modelNode = modelNodes[0];\n    const transformData = {};\n    if (\"RotationOrder\" in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);\n    if (\"InheritType\" in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\n    if (\"GeometricTranslation\" in modelNode) transformData.translation = modelNode.GeometricTranslation.value;\n    if (\"GeometricRotation\" in modelNode) transformData.rotation = modelNode.GeometricRotation.value;\n    if (\"GeometricScaling\" in modelNode) transformData.scale = modelNode.GeometricScaling.value;\n    const transform = generateTransform(transformData);\n    return this.genGeometry(geoNode, skeleton, morphTargets, transform);\n  }\n  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\n  genGeometry(geoNode, skeleton, morphTargets, preTransform) {\n    const geo = new BufferGeometry();\n    if (geoNode.attrName) geo.name = geoNode.attrName;\n    const geoInfo = this.parseGeoNode(geoNode, skeleton);\n    const buffers = this.genBuffers(geoInfo);\n    const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);\n    positionAttribute.applyMatrix4(preTransform);\n    geo.setAttribute(\"position\", positionAttribute);\n    if (buffers.colors.length > 0) {\n      geo.setAttribute(\"color\", new Float32BufferAttribute(buffers.colors, 3));\n    }\n    if (skeleton) {\n      geo.setAttribute(\"skinIndex\", new Uint16BufferAttribute(buffers.weightsIndices, 4));\n      geo.setAttribute(\"skinWeight\", new Float32BufferAttribute(buffers.vertexWeights, 4));\n      geo.FBX_Deformer = skeleton;\n    }\n    if (buffers.normal.length > 0) {\n      const normalMatrix = new Matrix3().getNormalMatrix(preTransform);\n      const normalAttribute = new Float32BufferAttribute(buffers.normal, 3);\n      normalAttribute.applyNormalMatrix(normalMatrix);\n      geo.setAttribute(\"normal\", normalAttribute);\n    }\n    buffers.uvs.forEach(function(uvBuffer, i) {\n      const name = i === 0 ? \"uv\" : `uv${i}`;\n      geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2));\n    });\n    if (geoInfo.material && geoInfo.material.mappingType !== \"AllSame\") {\n      let prevMaterialIndex = buffers.materialIndex[0];\n      let startIndex = 0;\n      buffers.materialIndex.forEach(function(currentIndex, i) {\n        if (currentIndex !== prevMaterialIndex) {\n          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n          prevMaterialIndex = currentIndex;\n          startIndex = i;\n        }\n      });\n      if (geo.groups.length > 0) {\n        const lastGroup = geo.groups[geo.groups.length - 1];\n        const lastIndex = lastGroup.start + lastGroup.count;\n        if (lastIndex !== buffers.materialIndex.length) {\n          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\n        }\n      }\n      if (geo.groups.length === 0) {\n        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\n      }\n    }\n    this.addMorphTargets(geo, geoNode, morphTargets, preTransform);\n    return geo;\n  }\n  parseGeoNode(geoNode, skeleton) {\n    const geoInfo = {};\n    geoInfo.vertexPositions = geoNode.Vertices !== void 0 ? geoNode.Vertices.a : [];\n    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== void 0 ? geoNode.PolygonVertexIndex.a : [];\n    if (geoNode.LayerElementColor) {\n      geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);\n    }\n    if (geoNode.LayerElementMaterial) {\n      geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);\n    }\n    if (geoNode.LayerElementNormal) {\n      geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);\n    }\n    if (geoNode.LayerElementUV) {\n      geoInfo.uv = [];\n      let i = 0;\n      while (geoNode.LayerElementUV[i]) {\n        if (geoNode.LayerElementUV[i].UV) {\n          geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));\n        }\n        i++;\n      }\n    }\n    geoInfo.weightTable = {};\n    if (skeleton !== null) {\n      geoInfo.skeleton = skeleton;\n      skeleton.rawBones.forEach(function(rawBone, i) {\n        rawBone.indices.forEach(function(index, j) {\n          if (geoInfo.weightTable[index] === void 0) geoInfo.weightTable[index] = [];\n          geoInfo.weightTable[index].push({\n            id: i,\n            weight: rawBone.weights[j]\n          });\n        });\n      });\n    }\n    return geoInfo;\n  }\n  genBuffers(geoInfo) {\n    const buffers = {\n      vertex: [],\n      normal: [],\n      colors: [],\n      uvs: [],\n      materialIndex: [],\n      vertexWeights: [],\n      weightsIndices: []\n    };\n    let polygonIndex = 0;\n    let faceLength = 0;\n    let displayedWeightsWarning = false;\n    let facePositionIndexes = [];\n    let faceNormals = [];\n    let faceColors = [];\n    let faceUVs = [];\n    let faceWeights = [];\n    let faceWeightIndices = [];\n    const scope = this;\n    geoInfo.vertexIndices.forEach(function(vertexIndex, polygonVertexIndex) {\n      let materialIndex;\n      let endOfFace = false;\n      if (vertexIndex < 0) {\n        vertexIndex = vertexIndex ^ -1;\n        endOfFace = true;\n      }\n      let weightIndices = [];\n      let weights = [];\n      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n      if (geoInfo.color) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\n        faceColors.push(data[0], data[1], data[2]);\n      }\n      if (geoInfo.skeleton) {\n        if (geoInfo.weightTable[vertexIndex] !== void 0) {\n          geoInfo.weightTable[vertexIndex].forEach(function(wt) {\n            weights.push(wt.weight);\n            weightIndices.push(wt.id);\n          });\n        }\n        if (weights.length > 4) {\n          if (!displayedWeightsWarning) {\n            console.warn(\"THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.\");\n            displayedWeightsWarning = true;\n          }\n          const wIndex = [0, 0, 0, 0];\n          const Weight = [0, 0, 0, 0];\n          weights.forEach(function(weight, weightIndex) {\n            let currentWeight = weight;\n            let currentIndex = weightIndices[weightIndex];\n            Weight.forEach(function(comparedWeight, comparedWeightIndex, comparedWeightArray) {\n              if (currentWeight > comparedWeight) {\n                comparedWeightArray[comparedWeightIndex] = currentWeight;\n                currentWeight = comparedWeight;\n                const tmp = wIndex[comparedWeightIndex];\n                wIndex[comparedWeightIndex] = currentIndex;\n                currentIndex = tmp;\n              }\n            });\n          });\n          weightIndices = wIndex;\n          weights = Weight;\n        }\n        while (weights.length < 4) {\n          weights.push(0);\n          weightIndices.push(0);\n        }\n        for (let i = 0; i < 4; ++i) {\n          faceWeights.push(weights[i]);\n          faceWeightIndices.push(weightIndices[i]);\n        }\n      }\n      if (geoInfo.normal) {\n        const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\n        faceNormals.push(data[0], data[1], data[2]);\n      }\n      if (geoInfo.material && geoInfo.material.mappingType !== \"AllSame\") {\n        materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\n        if (materialIndex < 0) {\n          scope.negativeMaterialIndices = true;\n          materialIndex = 0;\n        }\n      }\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function(uv, i) {\n          const data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\n          if (faceUVs[i] === void 0) {\n            faceUVs[i] = [];\n          }\n          faceUVs[i].push(data[0]);\n          faceUVs[i].push(data[1]);\n        });\n      }\n      faceLength++;\n      if (endOfFace) {\n        scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);\n        polygonIndex++;\n        faceLength = 0;\n        facePositionIndexes = [];\n        faceNormals = [];\n        faceColors = [];\n        faceUVs = [];\n        faceWeights = [];\n        faceWeightIndices = [];\n      }\n    });\n    return buffers;\n  }\n  // See https://www.khronos.org/opengl/wiki/Calculating_a_Surface_Normal\n  getNormalNewell(vertices) {\n    const normal = new Vector3(0, 0, 0);\n    for (let i = 0; i < vertices.length; i++) {\n      const current = vertices[i];\n      const next = vertices[(i + 1) % vertices.length];\n      normal.x += (current.y - next.y) * (current.z + next.z);\n      normal.y += (current.z - next.z) * (current.x + next.x);\n      normal.z += (current.x - next.x) * (current.y + next.y);\n    }\n    normal.normalize();\n    return normal;\n  }\n  getNormalTangentAndBitangent(vertices) {\n    const normalVector = this.getNormalNewell(vertices);\n    const up = Math.abs(normalVector.z) > 0.5 ? new Vector3(0, 1, 0) : new Vector3(0, 0, 1);\n    const tangent = up.cross(normalVector).normalize();\n    const bitangent = normalVector.clone().cross(tangent).normalize();\n    return {\n      normal: normalVector,\n      tangent,\n      bitangent\n    };\n  }\n  flattenVertex(vertex2, normalTangent, normalBitangent) {\n    return new Vector2(\n      vertex2.dot(normalTangent),\n      vertex2.dot(normalBitangent)\n    );\n  }\n  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n  genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\n    let triangles;\n    if (faceLength > 3) {\n      const vertices = [];\n      const positions = geoInfo.baseVertexPositions || geoInfo.vertexPositions;\n      for (let i = 0; i < facePositionIndexes.length; i += 3) {\n        vertices.push(\n          new Vector3(\n            positions[facePositionIndexes[i]],\n            positions[facePositionIndexes[i + 1]],\n            positions[facePositionIndexes[i + 2]]\n          )\n        );\n      }\n      const { tangent, bitangent } = this.getNormalTangentAndBitangent(vertices);\n      const triangulationInput = [];\n      for (const vertex2 of vertices) {\n        triangulationInput.push(this.flattenVertex(vertex2, tangent, bitangent));\n      }\n      triangles = ShapeUtils.triangulateShape(triangulationInput, []);\n    } else {\n      triangles = [[0, 1, 2]];\n    }\n    for (const [i0, i1, i2] of triangles) {\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i0 * 3 + 2]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i1 * 3 + 2]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2 * 3 + 2]]);\n      if (geoInfo.skeleton) {\n        buffers.vertexWeights.push(faceWeights[i0 * 4]);\n        buffers.vertexWeights.push(faceWeights[i0 * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[i0 * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[i0 * 4 + 3]);\n        buffers.vertexWeights.push(faceWeights[i1 * 4]);\n        buffers.vertexWeights.push(faceWeights[i1 * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[i1 * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[i1 * 4 + 3]);\n        buffers.vertexWeights.push(faceWeights[i2 * 4]);\n        buffers.vertexWeights.push(faceWeights[i2 * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[i2 * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[i2 * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[i0 * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[i0 * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[i1 * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[i1 * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[i2 * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[i2 * 4 + 3]);\n      }\n      if (geoInfo.color) {\n        buffers.colors.push(faceColors[i0 * 3]);\n        buffers.colors.push(faceColors[i0 * 3 + 1]);\n        buffers.colors.push(faceColors[i0 * 3 + 2]);\n        buffers.colors.push(faceColors[i1 * 3]);\n        buffers.colors.push(faceColors[i1 * 3 + 1]);\n        buffers.colors.push(faceColors[i1 * 3 + 2]);\n        buffers.colors.push(faceColors[i2 * 3]);\n        buffers.colors.push(faceColors[i2 * 3 + 1]);\n        buffers.colors.push(faceColors[i2 * 3 + 2]);\n      }\n      if (geoInfo.material && geoInfo.material.mappingType !== \"AllSame\") {\n        buffers.materialIndex.push(materialIndex);\n        buffers.materialIndex.push(materialIndex);\n        buffers.materialIndex.push(materialIndex);\n      }\n      if (geoInfo.normal) {\n        buffers.normal.push(faceNormals[i0 * 3]);\n        buffers.normal.push(faceNormals[i0 * 3 + 1]);\n        buffers.normal.push(faceNormals[i0 * 3 + 2]);\n        buffers.normal.push(faceNormals[i1 * 3]);\n        buffers.normal.push(faceNormals[i1 * 3 + 1]);\n        buffers.normal.push(faceNormals[i1 * 3 + 2]);\n        buffers.normal.push(faceNormals[i2 * 3]);\n        buffers.normal.push(faceNormals[i2 * 3 + 1]);\n        buffers.normal.push(faceNormals[i2 * 3 + 2]);\n      }\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function(uv, j) {\n          if (buffers.uvs[j] === void 0) buffers.uvs[j] = [];\n          buffers.uvs[j].push(faceUVs[j][i0 * 2]);\n          buffers.uvs[j].push(faceUVs[j][i0 * 2 + 1]);\n          buffers.uvs[j].push(faceUVs[j][i1 * 2]);\n          buffers.uvs[j].push(faceUVs[j][i1 * 2 + 1]);\n          buffers.uvs[j].push(faceUVs[j][i2 * 2]);\n          buffers.uvs[j].push(faceUVs[j][i2 * 2 + 1]);\n        });\n      }\n    }\n  }\n  addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {\n    if (morphTargets.length === 0) return;\n    parentGeo.morphTargetsRelative = true;\n    parentGeo.morphAttributes.position = [];\n    const scope = this;\n    morphTargets.forEach(function(morphTarget) {\n      morphTarget.rawTargets.forEach(function(rawTarget) {\n        const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];\n        if (morphGeoNode !== void 0) {\n          scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);\n        }\n      });\n    });\n  }\n  // a morph geometry node is similar to a standard  node, and the node is also contained\n  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n  // and a special attribute Index defining which vertices of the original geometry are affected\n  // Normal and position attributes only have data for the vertices that are affected by the morph\n  genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {\n    const basePositions = parentGeoNode.Vertices !== void 0 ? parentGeoNode.Vertices.a : [];\n    const baseIndices = parentGeoNode.PolygonVertexIndex !== void 0 ? parentGeoNode.PolygonVertexIndex.a : [];\n    const morphPositionsSparse = morphGeoNode.Vertices !== void 0 ? morphGeoNode.Vertices.a : [];\n    const morphIndices = morphGeoNode.Indexes !== void 0 ? morphGeoNode.Indexes.a : [];\n    const length = parentGeo.attributes.position.count * 3;\n    const morphPositions = new Float32Array(length);\n    for (let i = 0; i < morphIndices.length; i++) {\n      const morphIndex = morphIndices[i] * 3;\n      morphPositions[morphIndex] = morphPositionsSparse[i * 3];\n      morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];\n      morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];\n    }\n    const morphGeoInfo = {\n      vertexIndices: baseIndices,\n      vertexPositions: morphPositions,\n      baseVertexPositions: basePositions\n    };\n    const morphBuffers = this.genBuffers(morphGeoInfo);\n    const positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);\n    positionAttribute.name = name || morphGeoNode.attrName;\n    positionAttribute.applyMatrix4(preTransform);\n    parentGeo.morphAttributes.position.push(positionAttribute);\n  }\n  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n  parseNormals(NormalNode) {\n    const mappingType = NormalNode.MappingInformationType;\n    const referenceType = NormalNode.ReferenceInformationType;\n    const buffer = NormalNode.Normals.a;\n    let indexBuffer = [];\n    if (referenceType === \"IndexToDirect\") {\n      if (\"NormalIndex\" in NormalNode) {\n        indexBuffer = NormalNode.NormalIndex.a;\n      } else if (\"NormalsIndex\" in NormalNode) {\n        indexBuffer = NormalNode.NormalsIndex.a;\n      }\n    }\n    return {\n      dataSize: 3,\n      buffer,\n      indices: indexBuffer,\n      mappingType,\n      referenceType\n    };\n  }\n  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n  parseUVs(UVNode) {\n    const mappingType = UVNode.MappingInformationType;\n    const referenceType = UVNode.ReferenceInformationType;\n    const buffer = UVNode.UV.a;\n    let indexBuffer = [];\n    if (referenceType === \"IndexToDirect\") {\n      indexBuffer = UVNode.UVIndex.a;\n    }\n    return {\n      dataSize: 2,\n      buffer,\n      indices: indexBuffer,\n      mappingType,\n      referenceType\n    };\n  }\n  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n  parseVertexColors(ColorNode) {\n    const mappingType = ColorNode.MappingInformationType;\n    const referenceType = ColorNode.ReferenceInformationType;\n    const buffer = ColorNode.Colors.a;\n    let indexBuffer = [];\n    if (referenceType === \"IndexToDirect\") {\n      indexBuffer = ColorNode.ColorIndex.a;\n    }\n    for (let i = 0, c = new Color(); i < buffer.length; i += 4) {\n      c.fromArray(buffer, i);\n      ColorManagement.toWorkingColorSpace(c, SRGBColorSpace);\n      c.toArray(buffer, i);\n    }\n    return {\n      dataSize: 4,\n      buffer,\n      indices: indexBuffer,\n      mappingType,\n      referenceType\n    };\n  }\n  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n  parseMaterialIndices(MaterialNode) {\n    const mappingType = MaterialNode.MappingInformationType;\n    const referenceType = MaterialNode.ReferenceInformationType;\n    if (mappingType === \"NoMappingInformation\") {\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: \"AllSame\",\n        referenceType\n      };\n    }\n    const materialIndexBuffer = MaterialNode.Materials.a;\n    const materialIndices = [];\n    for (let i = 0; i < materialIndexBuffer.length; ++i) {\n      materialIndices.push(i);\n    }\n    return {\n      dataSize: 1,\n      buffer: materialIndexBuffer,\n      indices: materialIndices,\n      mappingType,\n      referenceType\n    };\n  }\n  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n  parseNurbsGeometry(geoNode) {\n    const order = parseInt(geoNode.Order);\n    if (isNaN(order)) {\n      console.error(\"THREE.FBXLoader: Invalid Order %s given for geometry ID: %s\", geoNode.Order, geoNode.id);\n      return new BufferGeometry();\n    }\n    const degree = order - 1;\n    const knots = geoNode.KnotVector.a;\n    const controlPoints = [];\n    const pointsValues = geoNode.Points.a;\n    for (let i = 0, l = pointsValues.length; i < l; i += 4) {\n      controlPoints.push(new Vector4().fromArray(pointsValues, i));\n    }\n    let startKnot, endKnot;\n    if (geoNode.Form === \"Closed\") {\n      controlPoints.push(controlPoints[0]);\n    } else if (geoNode.Form === \"Periodic\") {\n      startKnot = degree;\n      endKnot = knots.length - 1 - startKnot;\n      for (let i = 0; i < degree; ++i) {\n        controlPoints.push(controlPoints[i]);\n      }\n    }\n    const curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n    const points = curve.getPoints(controlPoints.length * 12);\n    return new BufferGeometry().setFromPoints(points);\n  }\n}\nclass AnimationParser {\n  // take raw animation clips and turn them into three.js animation clips\n  parse() {\n    const animationClips = [];\n    const rawClips = this.parseClips();\n    if (rawClips !== void 0) {\n      for (const key in rawClips) {\n        const rawClip = rawClips[key];\n        const clip = this.addClip(rawClip);\n        animationClips.push(clip);\n      }\n    }\n    return animationClips;\n  }\n  parseClips() {\n    if (fbxTree.Objects.AnimationCurve === void 0) return void 0;\n    const curveNodesMap = this.parseAnimationCurveNodes();\n    this.parseAnimationCurves(curveNodesMap);\n    const layersMap = this.parseAnimationLayers(curveNodesMap);\n    const rawClips = this.parseAnimStacks(layersMap);\n    return rawClips;\n  }\n  // parse nodes in FBXTree.Objects.AnimationCurveNode\n  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n  // and is referenced by an AnimationLayer\n  parseAnimationCurveNodes() {\n    const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n    const curveNodesMap = /* @__PURE__ */ new Map();\n    for (const nodeID in rawCurveNodes) {\n      const rawCurveNode = rawCurveNodes[nodeID];\n      if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\n        const curveNode = {\n          id: rawCurveNode.id,\n          attr: rawCurveNode.attrName,\n          curves: {}\n        };\n        curveNodesMap.set(curveNode.id, curveNode);\n      }\n    }\n    return curveNodesMap;\n  }\n  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n  // axis ( e.g. times and values of x rotation)\n  parseAnimationCurves(curveNodesMap) {\n    const rawCurves = fbxTree.Objects.AnimationCurve;\n    for (const nodeID in rawCurves) {\n      const animationCurve = {\n        id: rawCurves[nodeID].id,\n        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n        values: rawCurves[nodeID].KeyValueFloat.a\n      };\n      const relationships = connections.get(animationCurve.id);\n      if (relationships !== void 0) {\n        const animationCurveID = relationships.parents[0].ID;\n        const animationCurveRelationship = relationships.parents[0].relationship;\n        if (animationCurveRelationship.match(/X/)) {\n          curveNodesMap.get(animationCurveID).curves[\"x\"] = animationCurve;\n        } else if (animationCurveRelationship.match(/Y/)) {\n          curveNodesMap.get(animationCurveID).curves[\"y\"] = animationCurve;\n        } else if (animationCurveRelationship.match(/Z/)) {\n          curveNodesMap.get(animationCurveID).curves[\"z\"] = animationCurve;\n        } else if (animationCurveRelationship.match(/DeformPercent/) && curveNodesMap.has(animationCurveID)) {\n          curveNodesMap.get(animationCurveID).curves[\"morph\"] = animationCurve;\n        }\n      }\n    }\n  }\n  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n  // to various AnimationCurveNodes and is referenced by an AnimationStack node\n  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n  parseAnimationLayers(curveNodesMap) {\n    const rawLayers = fbxTree.Objects.AnimationLayer;\n    const layersMap = /* @__PURE__ */ new Map();\n    for (const nodeID in rawLayers) {\n      const layerCurveNodes = [];\n      const connection = connections.get(parseInt(nodeID));\n      if (connection !== void 0) {\n        const children = connection.children;\n        children.forEach(function(child, i) {\n          if (curveNodesMap.has(child.ID)) {\n            const curveNode = curveNodesMap.get(child.ID);\n            if (curveNode.curves.x !== void 0 || curveNode.curves.y !== void 0 || curveNode.curves.z !== void 0) {\n              if (layerCurveNodes[i] === void 0) {\n                const modelID = connections.get(child.ID).parents.filter(function(parent) {\n                  return parent.relationship !== void 0;\n                })[0].ID;\n                if (modelID !== void 0) {\n                  const rawModel = fbxTree.Objects.Model[modelID.toString()];\n                  if (rawModel === void 0) {\n                    console.warn(\"THREE.FBXLoader: Encountered a unused curve.\", child);\n                    return;\n                  }\n                  const node = {\n                    modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : \"\",\n                    ID: rawModel.id,\n                    initialPosition: [0, 0, 0],\n                    initialRotation: [0, 0, 0],\n                    initialScale: [1, 1, 1]\n                  };\n                  sceneGraph.traverse(function(child2) {\n                    if (child2.ID === rawModel.id) {\n                      node.transform = child2.matrix;\n                      if (child2.userData.transformData) node.eulerOrder = child2.userData.transformData.eulerOrder;\n                    }\n                  });\n                  if (!node.transform) node.transform = new Matrix4();\n                  if (\"PreRotation\" in rawModel) node.preRotation = rawModel.PreRotation.value;\n                  if (\"PostRotation\" in rawModel) node.postRotation = rawModel.PostRotation.value;\n                  layerCurveNodes[i] = node;\n                }\n              }\n              if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;\n            } else if (curveNode.curves.morph !== void 0) {\n              if (layerCurveNodes[i] === void 0) {\n                const deformerID = connections.get(child.ID).parents.filter(function(parent) {\n                  return parent.relationship !== void 0;\n                })[0].ID;\n                const morpherID = connections.get(deformerID).parents[0].ID;\n                const geoID = connections.get(morpherID).parents[0].ID;\n                const modelID = connections.get(geoID).parents[0].ID;\n                const rawModel = fbxTree.Objects.Model[modelID];\n                const node = {\n                  modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : \"\",\n                  morphName: fbxTree.Objects.Deformer[deformerID].attrName\n                };\n                layerCurveNodes[i] = node;\n              }\n              layerCurveNodes[i][curveNode.attr] = curveNode;\n            }\n          }\n        });\n        layersMap.set(parseInt(nodeID), layerCurveNodes);\n      }\n    }\n    return layersMap;\n  }\n  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n  // hierarchy. Each Stack node will be used to create a AnimationClip\n  parseAnimStacks(layersMap) {\n    const rawStacks = fbxTree.Objects.AnimationStack;\n    const rawClips = {};\n    for (const nodeID in rawStacks) {\n      const children = connections.get(parseInt(nodeID)).children;\n      if (children.length > 1) {\n        console.warn(\"THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.\");\n      }\n      const layer = layersMap.get(children[0].ID);\n      rawClips[nodeID] = {\n        name: rawStacks[nodeID].attrName,\n        layer\n      };\n    }\n    return rawClips;\n  }\n  addClip(rawClip) {\n    let tracks = [];\n    const scope = this;\n    rawClip.layer.forEach(function(rawTracks) {\n      tracks = tracks.concat(scope.generateTracks(rawTracks));\n    });\n    return new AnimationClip(rawClip.name, -1, tracks);\n  }\n  generateTracks(rawTracks) {\n    const tracks = [];\n    let initialPosition = new Vector3();\n    let initialScale = new Vector3();\n    if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, new Quaternion(), initialScale);\n    initialPosition = initialPosition.toArray();\n    initialScale = initialScale.toArray();\n    if (rawTracks.T !== void 0 && Object.keys(rawTracks.T.curves).length > 0) {\n      const positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, \"position\");\n      if (positionTrack !== void 0) tracks.push(positionTrack);\n    }\n    if (rawTracks.R !== void 0 && Object.keys(rawTracks.R.curves).length > 0) {\n      const rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);\n      if (rotationTrack !== void 0) tracks.push(rotationTrack);\n    }\n    if (rawTracks.S !== void 0 && Object.keys(rawTracks.S.curves).length > 0) {\n      const scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, \"scale\");\n      if (scaleTrack !== void 0) tracks.push(scaleTrack);\n    }\n    if (rawTracks.DeformPercent !== void 0) {\n      const morphTrack = this.generateMorphTrack(rawTracks);\n      if (morphTrack !== void 0) tracks.push(morphTrack);\n    }\n    return tracks;\n  }\n  generateVectorTrack(modelName, curves, initialValue, type) {\n    const times = this.getTimesForAllAxes(curves);\n    const values = this.getKeyframeTrackValues(times, curves, initialValue);\n    return new VectorKeyframeTrack(modelName + \".\" + type, times, values);\n  }\n  generateRotationTrack(modelName, curves, preRotation, postRotation, eulerOrder) {\n    let times;\n    let values;\n    if (curves.x !== void 0 && curves.y !== void 0 && curves.z !== void 0) {\n      const result = this.interpolateRotations(curves.x, curves.y, curves.z, eulerOrder);\n      times = result[0];\n      values = result[1];\n    }\n    const defaultEulerOrder = getEulerOrder(0);\n    if (preRotation !== void 0) {\n      preRotation = preRotation.map(MathUtils.degToRad);\n      preRotation.push(defaultEulerOrder);\n      preRotation = new Euler().fromArray(preRotation);\n      preRotation = new Quaternion().setFromEuler(preRotation);\n    }\n    if (postRotation !== void 0) {\n      postRotation = postRotation.map(MathUtils.degToRad);\n      postRotation.push(defaultEulerOrder);\n      postRotation = new Euler().fromArray(postRotation);\n      postRotation = new Quaternion().setFromEuler(postRotation).invert();\n    }\n    const quaternion = new Quaternion();\n    const euler = new Euler();\n    const quaternionValues = [];\n    if (!values || !times) return new QuaternionKeyframeTrack(modelName + \".quaternion\", [0], [0]);\n    for (let i = 0; i < values.length; i += 3) {\n      euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);\n      quaternion.setFromEuler(euler);\n      if (preRotation !== void 0) quaternion.premultiply(preRotation);\n      if (postRotation !== void 0) quaternion.multiply(postRotation);\n      if (i > 2) {\n        const prevQuat = new Quaternion().fromArray(\n          quaternionValues,\n          (i - 3) / 3 * 4\n        );\n        if (prevQuat.dot(quaternion) < 0) {\n          quaternion.set(-quaternion.x, -quaternion.y, -quaternion.z, -quaternion.w);\n        }\n      }\n      quaternion.toArray(quaternionValues, i / 3 * 4);\n    }\n    return new QuaternionKeyframeTrack(modelName + \".quaternion\", times, quaternionValues);\n  }\n  generateMorphTrack(rawTracks) {\n    const curves = rawTracks.DeformPercent.curves.morph;\n    const values = curves.values.map(function(val) {\n      return val / 100;\n    });\n    const morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];\n    return new NumberKeyframeTrack(rawTracks.modelName + \".morphTargetInfluences[\" + morphNum + \"]\", curves.times, values);\n  }\n  // For all animated objects, times are defined separately for each axis\n  // Here we'll combine the times into one sorted array without duplicates\n  getTimesForAllAxes(curves) {\n    let times = [];\n    if (curves.x !== void 0) times = times.concat(curves.x.times);\n    if (curves.y !== void 0) times = times.concat(curves.y.times);\n    if (curves.z !== void 0) times = times.concat(curves.z.times);\n    times = times.sort(function(a, b) {\n      return a - b;\n    });\n    if (times.length > 1) {\n      let targetIndex = 1;\n      let lastValue = times[0];\n      for (let i = 1; i < times.length; i++) {\n        const currentValue = times[i];\n        if (currentValue !== lastValue) {\n          times[targetIndex] = currentValue;\n          lastValue = currentValue;\n          targetIndex++;\n        }\n      }\n      times = times.slice(0, targetIndex);\n    }\n    return times;\n  }\n  getKeyframeTrackValues(times, curves, initialValue) {\n    const prevValue = initialValue;\n    const values = [];\n    let xIndex = -1;\n    let yIndex = -1;\n    let zIndex = -1;\n    times.forEach(function(time) {\n      if (curves.x) xIndex = curves.x.times.indexOf(time);\n      if (curves.y) yIndex = curves.y.times.indexOf(time);\n      if (curves.z) zIndex = curves.z.times.indexOf(time);\n      if (xIndex !== -1) {\n        const xValue = curves.x.values[xIndex];\n        values.push(xValue);\n        prevValue[0] = xValue;\n      } else {\n        values.push(prevValue[0]);\n      }\n      if (yIndex !== -1) {\n        const yValue = curves.y.values[yIndex];\n        values.push(yValue);\n        prevValue[1] = yValue;\n      } else {\n        values.push(prevValue[1]);\n      }\n      if (zIndex !== -1) {\n        const zValue = curves.z.values[zIndex];\n        values.push(zValue);\n        prevValue[2] = zValue;\n      } else {\n        values.push(prevValue[2]);\n      }\n    });\n    return values;\n  }\n  // Rotations are defined as Euler angles which can have values  of any size\n  // These will be converted to quaternions which don't support values greater than\n  // PI, so we'll interpolate large rotations\n  interpolateRotations(curvex, curvey, curvez, eulerOrder) {\n    const times = [];\n    const values = [];\n    times.push(curvex.times[0]);\n    values.push(MathUtils.degToRad(curvex.values[0]));\n    values.push(MathUtils.degToRad(curvey.values[0]));\n    values.push(MathUtils.degToRad(curvez.values[0]));\n    for (let i = 1; i < curvex.values.length; i++) {\n      const initialValue = [\n        curvex.values[i - 1],\n        curvey.values[i - 1],\n        curvez.values[i - 1]\n      ];\n      if (isNaN(initialValue[0]) || isNaN(initialValue[1]) || isNaN(initialValue[2])) {\n        continue;\n      }\n      const initialValueRad = initialValue.map(MathUtils.degToRad);\n      const currentValue = [\n        curvex.values[i],\n        curvey.values[i],\n        curvez.values[i]\n      ];\n      if (isNaN(currentValue[0]) || isNaN(currentValue[1]) || isNaN(currentValue[2])) {\n        continue;\n      }\n      const currentValueRad = currentValue.map(MathUtils.degToRad);\n      const valuesSpan = [\n        currentValue[0] - initialValue[0],\n        currentValue[1] - initialValue[1],\n        currentValue[2] - initialValue[2]\n      ];\n      const absoluteSpan = [\n        Math.abs(valuesSpan[0]),\n        Math.abs(valuesSpan[1]),\n        Math.abs(valuesSpan[2])\n      ];\n      if (absoluteSpan[0] >= 180 || absoluteSpan[1] >= 180 || absoluteSpan[2] >= 180) {\n        const maxAbsSpan = Math.max(...absoluteSpan);\n        const numSubIntervals = maxAbsSpan / 180;\n        const E1 = new Euler(...initialValueRad, eulerOrder);\n        const E2 = new Euler(...currentValueRad, eulerOrder);\n        const Q1 = new Quaternion().setFromEuler(E1);\n        const Q2 = new Quaternion().setFromEuler(E2);\n        if (Q1.dot(Q2)) {\n          Q2.set(-Q2.x, -Q2.y, -Q2.z, -Q2.w);\n        }\n        const initialTime = curvex.times[i - 1];\n        const timeSpan = curvex.times[i] - initialTime;\n        const Q = new Quaternion();\n        const E = new Euler();\n        for (let t2 = 0; t2 < 1; t2 += 1 / numSubIntervals) {\n          Q.copy(Q1.clone().slerp(Q2.clone(), t2));\n          times.push(initialTime + t2 * timeSpan);\n          E.setFromQuaternion(Q, eulerOrder);\n          values.push(E.x);\n          values.push(E.y);\n          values.push(E.z);\n        }\n      } else {\n        times.push(curvex.times[i]);\n        values.push(MathUtils.degToRad(curvex.values[i]));\n        values.push(MathUtils.degToRad(curvey.values[i]));\n        values.push(MathUtils.degToRad(curvez.values[i]));\n      }\n    }\n    return [times, values];\n  }\n}\nclass TextParser {\n  getPrevNode() {\n    return this.nodeStack[this.currentIndent - 2];\n  }\n  getCurrentNode() {\n    return this.nodeStack[this.currentIndent - 1];\n  }\n  getCurrentProp() {\n    return this.currentProp;\n  }\n  pushStack(node) {\n    this.nodeStack.push(node);\n    this.currentIndent += 1;\n  }\n  popStack() {\n    this.nodeStack.pop();\n    this.currentIndent -= 1;\n  }\n  setCurrentProp(val, name) {\n    this.currentProp = val;\n    this.currentPropName = name;\n  }\n  parse(text) {\n    this.currentIndent = 0;\n    this.allNodes = new FBXTree();\n    this.nodeStack = [];\n    this.currentProp = [];\n    this.currentPropName = \"\";\n    const scope = this;\n    const split = text.split(/[\\r\\n]+/);\n    split.forEach(function(line, i) {\n      const matchComment = line.match(/^[\\s\\t]*;/);\n      const matchEmpty = line.match(/^[\\s\\t]*$/);\n      if (matchComment || matchEmpty) return;\n      const matchBeginning = line.match(\"^\\\\t{\" + scope.currentIndent + \"}(\\\\w+):(.*){\", \"\");\n      const matchProperty = line.match(\"^\\\\t{\" + scope.currentIndent + \"}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)\");\n      const matchEnd = line.match(\"^\\\\t{\" + (scope.currentIndent - 1) + \"}}\");\n      if (matchBeginning) {\n        scope.parseNodeBegin(line, matchBeginning);\n      } else if (matchProperty) {\n        scope.parseNodeProperty(line, matchProperty, split[++i]);\n      } else if (matchEnd) {\n        scope.popStack();\n      } else if (line.match(/^[^\\s\\t}]/)) {\n        scope.parseNodePropertyContinued(line);\n      }\n    });\n    return this.allNodes;\n  }\n  parseNodeBegin(line, property) {\n    const nodeName = property[1].trim().replace(/^\"/, \"\").replace(/\"$/, \"\");\n    const nodeAttrs = property[2].split(\",\").map(function(attr) {\n      return attr.trim().replace(/^\"/, \"\").replace(/\"$/, \"\");\n    });\n    const node = { name: nodeName };\n    const attrs = this.parseNodeAttr(nodeAttrs);\n    const currentNode = this.getCurrentNode();\n    if (this.currentIndent === 0) {\n      this.allNodes.add(nodeName, node);\n    } else {\n      if (nodeName in currentNode) {\n        if (nodeName === \"PoseNode\") {\n          currentNode.PoseNode.push(node);\n        } else if (currentNode[nodeName].id !== void 0) {\n          currentNode[nodeName] = {};\n          currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\n        }\n        if (attrs.id !== \"\") currentNode[nodeName][attrs.id] = node;\n      } else if (typeof attrs.id === \"number\") {\n        currentNode[nodeName] = {};\n        currentNode[nodeName][attrs.id] = node;\n      } else if (nodeName !== \"Properties70\") {\n        if (nodeName === \"PoseNode\") currentNode[nodeName] = [node];\n        else currentNode[nodeName] = node;\n      }\n    }\n    if (typeof attrs.id === \"number\") node.id = attrs.id;\n    if (attrs.name !== \"\") node.attrName = attrs.name;\n    if (attrs.type !== \"\") node.attrType = attrs.type;\n    this.pushStack(node);\n  }\n  parseNodeAttr(attrs) {\n    let id2 = attrs[0];\n    if (attrs[0] !== \"\") {\n      id2 = parseInt(attrs[0]);\n      if (isNaN(id2)) {\n        id2 = attrs[0];\n      }\n    }\n    let name = \"\", type = \"\";\n    if (attrs.length > 1) {\n      name = attrs[1].replace(/^(\\w+)::/, \"\");\n      type = attrs[2];\n    }\n    return { id: id2, name, type };\n  }\n  parseNodeProperty(line, property, contentLine) {\n    let propName = property[1].replace(/^\"/, \"\").replace(/\"$/, \"\").trim();\n    let propValue = property[2].replace(/^\"/, \"\").replace(/\"$/, \"\").trim();\n    if (propName === \"Content\" && propValue === \",\") {\n      propValue = contentLine.replace(/\"/g, \"\").replace(/,$/, \"\").trim();\n    }\n    const currentNode = this.getCurrentNode();\n    const parentName = currentNode.name;\n    if (parentName === \"Properties70\") {\n      this.parseNodeSpecialProperty(line, propName, propValue);\n      return;\n    }\n    if (propName === \"C\") {\n      const connProps = propValue.split(\",\").slice(1);\n      const from = parseInt(connProps[0]);\n      const to = parseInt(connProps[1]);\n      let rest = propValue.split(\",\").slice(3);\n      rest = rest.map(function(elem) {\n        return elem.trim().replace(/^\"/, \"\");\n      });\n      propName = \"connections\";\n      propValue = [from, to];\n      append(propValue, rest);\n      if (currentNode[propName] === void 0) {\n        currentNode[propName] = [];\n      }\n    }\n    if (propName === \"Node\") currentNode.id = propValue;\n    if (propName in currentNode && Array.isArray(currentNode[propName])) {\n      currentNode[propName].push(propValue);\n    } else {\n      if (propName !== \"a\") currentNode[propName] = propValue;\n      else currentNode.a = propValue;\n    }\n    this.setCurrentProp(currentNode, propName);\n    if (propName === \"a\" && propValue.slice(-1) !== \",\") {\n      currentNode.a = parseNumberArray(propValue);\n    }\n  }\n  parseNodePropertyContinued(line) {\n    const currentNode = this.getCurrentNode();\n    currentNode.a += line;\n    if (line.slice(-1) !== \",\") {\n      currentNode.a = parseNumberArray(currentNode.a);\n    }\n  }\n  // parse \"Property70\"\n  parseNodeSpecialProperty(line, propName, propValue) {\n    const props = propValue.split('\",').map(function(prop) {\n      return prop.trim().replace(/^\\\"/, \"\").replace(/\\s/, \"_\");\n    });\n    const innerPropName = props[0];\n    const innerPropType1 = props[1];\n    const innerPropType2 = props[2];\n    const innerPropFlag = props[3];\n    let innerPropValue = props[4];\n    switch (innerPropType1) {\n      case \"int\":\n      case \"enum\":\n      case \"bool\":\n      case \"ULongLong\":\n      case \"double\":\n      case \"Number\":\n      case \"FieldOfView\":\n        innerPropValue = parseFloat(innerPropValue);\n        break;\n      case \"Color\":\n      case \"ColorRGB\":\n      case \"Vector3D\":\n      case \"Lcl_Translation\":\n      case \"Lcl_Rotation\":\n      case \"Lcl_Scaling\":\n        innerPropValue = parseNumberArray(innerPropValue);\n        break;\n    }\n    this.getPrevNode()[innerPropName] = {\n      \"type\": innerPropType1,\n      \"type2\": innerPropType2,\n      \"flag\": innerPropFlag,\n      \"value\": innerPropValue\n    };\n    this.setCurrentProp(this.getPrevNode(), innerPropName);\n  }\n}\nclass BinaryParser {\n  parse(buffer) {\n    const reader = new BinaryReader(buffer);\n    reader.skip(23);\n    const version = reader.getUint32();\n    if (version < 6400) {\n      throw new Error(\"THREE.FBXLoader: FBX version not supported, FileVersion: \" + version);\n    }\n    const allNodes = new FBXTree();\n    while (!this.endOfContent(reader)) {\n      const node = this.parseNode(reader, version);\n      if (node !== null) allNodes.add(node.name, node);\n    }\n    return allNodes;\n  }\n  // Check if reader has reached the end of content.\n  endOfContent(reader) {\n    if (reader.size() % 16 === 0) {\n      return (reader.getOffset() + 160 + 16 & ~15) >= reader.size();\n    } else {\n      return reader.getOffset() + 160 + 16 >= reader.size();\n    }\n  }\n  // recursively parse nodes until the end of the file is reached\n  parseNode(reader, version) {\n    const node = {};\n    const endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n    const numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();\n    version >= 7500 ? reader.getUint64() : reader.getUint32();\n    const nameLen = reader.getUint8();\n    const name = reader.getString(nameLen);\n    if (endOffset === 0) return null;\n    const propertyList = [];\n    for (let i = 0; i < numProperties; i++) {\n      propertyList.push(this.parseProperty(reader));\n    }\n    const id2 = propertyList.length > 0 ? propertyList[0] : \"\";\n    const attrName = propertyList.length > 1 ? propertyList[1] : \"\";\n    const attrType = propertyList.length > 2 ? propertyList[2] : \"\";\n    node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\n    while (endOffset > reader.getOffset()) {\n      const subNode = this.parseNode(reader, version);\n      if (subNode !== null) this.parseSubNode(name, node, subNode);\n    }\n    node.propertyList = propertyList;\n    if (typeof id2 === \"number\") node.id = id2;\n    if (attrName !== \"\") node.attrName = attrName;\n    if (attrType !== \"\") node.attrType = attrType;\n    if (name !== \"\") node.name = name;\n    return node;\n  }\n  parseSubNode(name, node, subNode) {\n    if (subNode.singleProperty === true) {\n      const value = subNode.propertyList[0];\n      if (Array.isArray(value)) {\n        node[subNode.name] = subNode;\n        subNode.a = value;\n      } else {\n        node[subNode.name] = value;\n      }\n    } else if (name === \"Connections\" && subNode.name === \"C\") {\n      const array = [];\n      subNode.propertyList.forEach(function(property, i) {\n        if (i !== 0) array.push(property);\n      });\n      if (node.connections === void 0) {\n        node.connections = [];\n      }\n      node.connections.push(array);\n    } else if (subNode.name === \"Properties70\") {\n      const keys = Object.keys(subNode);\n      keys.forEach(function(key) {\n        node[key] = subNode[key];\n      });\n    } else if (name === \"Properties70\" && subNode.name === \"P\") {\n      let innerPropName = subNode.propertyList[0];\n      let innerPropType1 = subNode.propertyList[1];\n      const innerPropType2 = subNode.propertyList[2];\n      const innerPropFlag = subNode.propertyList[3];\n      let innerPropValue;\n      if (innerPropName.indexOf(\"Lcl \") === 0) innerPropName = innerPropName.replace(\"Lcl \", \"Lcl_\");\n      if (innerPropType1.indexOf(\"Lcl \") === 0) innerPropType1 = innerPropType1.replace(\"Lcl \", \"Lcl_\");\n      if (innerPropType1 === \"Color\" || innerPropType1 === \"ColorRGB\" || innerPropType1 === \"Vector\" || innerPropType1 === \"Vector3D\" || innerPropType1.indexOf(\"Lcl_\") === 0) {\n        innerPropValue = [\n          subNode.propertyList[4],\n          subNode.propertyList[5],\n          subNode.propertyList[6]\n        ];\n      } else {\n        innerPropValue = subNode.propertyList[4];\n      }\n      node[innerPropName] = {\n        \"type\": innerPropType1,\n        \"type2\": innerPropType2,\n        \"flag\": innerPropFlag,\n        \"value\": innerPropValue\n      };\n    } else if (node[subNode.name] === void 0) {\n      if (typeof subNode.id === \"number\") {\n        node[subNode.name] = {};\n        node[subNode.name][subNode.id] = subNode;\n      } else {\n        node[subNode.name] = subNode;\n      }\n    } else {\n      if (subNode.name === \"PoseNode\") {\n        if (!Array.isArray(node[subNode.name])) {\n          node[subNode.name] = [node[subNode.name]];\n        }\n        node[subNode.name].push(subNode);\n      } else if (node[subNode.name][subNode.id] === void 0) {\n        node[subNode.name][subNode.id] = subNode;\n      }\n    }\n  }\n  parseProperty(reader) {\n    const type = reader.getString(1);\n    let length;\n    switch (type) {\n      case \"C\":\n        return reader.getBoolean();\n      case \"D\":\n        return reader.getFloat64();\n      case \"F\":\n        return reader.getFloat32();\n      case \"I\":\n        return reader.getInt32();\n      case \"L\":\n        return reader.getInt64();\n      case \"R\":\n        length = reader.getUint32();\n        return reader.getArrayBuffer(length);\n      case \"S\":\n        length = reader.getUint32();\n        return reader.getString(length);\n      case \"Y\":\n        return reader.getInt16();\n      case \"b\":\n      case \"c\":\n      case \"d\":\n      case \"f\":\n      case \"i\":\n      case \"l\":\n        const arrayLength = reader.getUint32();\n        const encoding = reader.getUint32();\n        const compressedLength = reader.getUint32();\n        if (encoding === 0) {\n          switch (type) {\n            case \"b\":\n            case \"c\":\n              return reader.getBooleanArray(arrayLength);\n            case \"d\":\n              return reader.getFloat64Array(arrayLength);\n            case \"f\":\n              return reader.getFloat32Array(arrayLength);\n            case \"i\":\n              return reader.getInt32Array(arrayLength);\n            case \"l\":\n              return reader.getInt64Array(arrayLength);\n          }\n        }\n        const data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength)));\n        const reader2 = new BinaryReader(data.buffer);\n        switch (type) {\n          case \"b\":\n          case \"c\":\n            return reader2.getBooleanArray(arrayLength);\n          case \"d\":\n            return reader2.getFloat64Array(arrayLength);\n          case \"f\":\n            return reader2.getFloat32Array(arrayLength);\n          case \"i\":\n            return reader2.getInt32Array(arrayLength);\n          case \"l\":\n            return reader2.getInt64Array(arrayLength);\n        }\n        break;\n      default:\n        throw new Error(\"THREE.FBXLoader: Unknown property type \" + type);\n    }\n  }\n}\nclass BinaryReader {\n  constructor(buffer, littleEndian) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this.littleEndian = littleEndian !== void 0 ? littleEndian : true;\n    this._textDecoder = new TextDecoder();\n  }\n  getOffset() {\n    return this.offset;\n  }\n  size() {\n    return this.dv.buffer.byteLength;\n  }\n  skip(length) {\n    this.offset += length;\n  }\n  // seems like true/false representation depends on exporter.\n  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n  // then sees LSB.\n  getBoolean() {\n    return (this.getUint8() & 1) === 1;\n  }\n  getBooleanArray(size) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n      a.push(this.getBoolean());\n    }\n    return a;\n  }\n  getUint8() {\n    const value = this.dv.getUint8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n  getInt16() {\n    const value = this.dv.getInt16(this.offset, this.littleEndian);\n    this.offset += 2;\n    return value;\n  }\n  getInt32() {\n    const value = this.dv.getInt32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n  getInt32Array(size) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt32());\n    }\n    return a;\n  }\n  getUint32() {\n    const value = this.dv.getUint32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n  // JavaScript doesn't support 64-bit integer so calculate this here\n  // 1 << 32 will return 1 so using multiply operation instead here.\n  // There's a possibility that this method returns wrong value if the value\n  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n  // TODO: safely handle 64-bit integer\n  getInt64() {\n    let low, high;\n    if (this.littleEndian) {\n      low = this.getUint32();\n      high = this.getUint32();\n    } else {\n      high = this.getUint32();\n      low = this.getUint32();\n    }\n    if (high & 2147483648) {\n      high = ~high & 4294967295;\n      low = ~low & 4294967295;\n      if (low === 4294967295) high = high + 1 & 4294967295;\n      low = low + 1 & 4294967295;\n      return -(high * 4294967296 + low);\n    }\n    return high * 4294967296 + low;\n  }\n  getInt64Array(size) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n      a.push(this.getInt64());\n    }\n    return a;\n  }\n  // Note: see getInt64() comment\n  getUint64() {\n    let low, high;\n    if (this.littleEndian) {\n      low = this.getUint32();\n      high = this.getUint32();\n    } else {\n      high = this.getUint32();\n      low = this.getUint32();\n    }\n    return high * 4294967296 + low;\n  }\n  getFloat32() {\n    const value = this.dv.getFloat32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n  getFloat32Array(size) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat32());\n    }\n    return a;\n  }\n  getFloat64() {\n    const value = this.dv.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  getFloat64Array(size) {\n    const a = [];\n    for (let i = 0; i < size; i++) {\n      a.push(this.getFloat64());\n    }\n    return a;\n  }\n  getArrayBuffer(size) {\n    const value = this.dv.buffer.slice(this.offset, this.offset + size);\n    this.offset += size;\n    return value;\n  }\n  getString(size) {\n    const start = this.offset;\n    let a = new Uint8Array(this.dv.buffer, start, size);\n    this.skip(size);\n    const nullByte = a.indexOf(0);\n    if (nullByte >= 0) a = new Uint8Array(this.dv.buffer, start, nullByte);\n    return this._textDecoder.decode(a);\n  }\n}\nclass FBXTree {\n  add(key, val) {\n    this[key] = val;\n  }\n}\nfunction isFbxFormatBinary(buffer) {\n  const CORRECT = \"Kaydara FBX Binary  \\0\";\n  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n}\nfunction isFbxFormatASCII(text) {\n  const CORRECT = [\"K\", \"a\", \"y\", \"d\", \"a\", \"r\", \"a\", \"\\\\\", \"F\", \"B\", \"X\", \"\\\\\", \"B\", \"i\", \"n\", \"a\", \"r\", \"y\", \"\\\\\", \"\\\\\"];\n  let cursor = 0;\n  function read(offset) {\n    const result = text[offset - 1];\n    text = text.slice(cursor + offset);\n    cursor++;\n    return result;\n  }\n  for (let i = 0; i < CORRECT.length; ++i) {\n    const num = read(1);\n    if (num === CORRECT[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getFbxVersion(text) {\n  const versionRegExp = /FBXVersion: (\\d+)/;\n  const match = text.match(versionRegExp);\n  if (match) {\n    const version = parseInt(match[1]);\n    return version;\n  }\n  throw new Error(\"THREE.FBXLoader: Cannot find the version number for the file given.\");\n}\nfunction convertFBXTimeToSeconds(time) {\n  return time / 46186158e3;\n}\nconst dataArray = [];\nfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n  let index;\n  switch (infoObject.mappingType) {\n    case \"ByPolygonVertex\":\n      index = polygonVertexIndex;\n      break;\n    case \"ByPolygon\":\n      index = polygonIndex;\n      break;\n    case \"ByVertice\":\n      index = vertexIndex;\n      break;\n    case \"AllSame\":\n      index = infoObject.indices[0];\n      break;\n    default:\n      console.warn(\"THREE.FBXLoader: unknown attribute mapping type \" + infoObject.mappingType);\n  }\n  if (infoObject.referenceType === \"IndexToDirect\") index = infoObject.indices[index];\n  const from = index * infoObject.dataSize;\n  const to = from + infoObject.dataSize;\n  return slice(dataArray, infoObject.buffer, from, to);\n}\nconst tempEuler = new Euler();\nconst tempVec = new Vector3();\nfunction generateTransform(transformData) {\n  const lTranslationM = new Matrix4();\n  const lPreRotationM = new Matrix4();\n  const lRotationM = new Matrix4();\n  const lPostRotationM = new Matrix4();\n  const lScalingM = new Matrix4();\n  const lScalingPivotM = new Matrix4();\n  const lScalingOffsetM = new Matrix4();\n  const lRotationOffsetM = new Matrix4();\n  const lRotationPivotM = new Matrix4();\n  const lParentGX = new Matrix4();\n  const lParentLX = new Matrix4();\n  const lGlobalT = new Matrix4();\n  const inheritType = transformData.inheritType ? transformData.inheritType : 0;\n  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));\n  const defaultEulerOrder = getEulerOrder(0);\n  if (transformData.preRotation) {\n    const array = transformData.preRotation.map(MathUtils.degToRad);\n    array.push(defaultEulerOrder);\n    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n  }\n  if (transformData.rotation) {\n    const array = transformData.rotation.map(MathUtils.degToRad);\n    array.push(transformData.eulerOrder || defaultEulerOrder);\n    lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n  }\n  if (transformData.postRotation) {\n    const array = transformData.postRotation.map(MathUtils.degToRad);\n    array.push(defaultEulerOrder);\n    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n    lPostRotationM.invert();\n  }\n  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale));\n  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));\n  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));\n  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));\n  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));\n  if (transformData.parentMatrixWorld) {\n    lParentLX.copy(transformData.parentMatrix);\n    lParentGX.copy(transformData.parentMatrixWorld);\n  }\n  const lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM);\n  const lParentGRM = new Matrix4();\n  lParentGRM.extractRotation(lParentGX);\n  const lParentTM = new Matrix4();\n  lParentTM.copyPosition(lParentGX);\n  const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);\n  const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);\n  const lLSM = lScalingM;\n  const lGlobalRS = new Matrix4();\n  if (inheritType === 0) {\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);\n  } else if (inheritType === 1) {\n    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);\n  } else {\n    const lParentLSM = new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX));\n    const lParentLSM_inv = lParentLSM.clone().invert();\n    const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);\n    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);\n  }\n  const lRotationPivotM_inv = lRotationPivotM.clone().invert();\n  const lScalingPivotM_inv = lScalingPivotM.clone().invert();\n  let lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);\n  const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);\n  const lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);\n  lGlobalT.copyPosition(lGlobalTranslation);\n  lTransform = lGlobalT.clone().multiply(lGlobalRS);\n  lTransform.premultiply(lParentGX.invert());\n  return lTransform;\n}\nfunction getEulerOrder(order) {\n  order = order || 0;\n  const enums = [\n    \"ZYX\",\n    // -> XYZ extrinsic\n    \"YZX\",\n    // -> XZY extrinsic\n    \"XZY\",\n    // -> YZX extrinsic\n    \"ZXY\",\n    // -> YXZ extrinsic\n    \"YXZ\",\n    // -> ZXY extrinsic\n    \"XYZ\"\n    // -> ZYX extrinsic\n    //'SphericXYZ', // not possible to support\n  ];\n  if (order === 6) {\n    console.warn(\"THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.\");\n    return enums[0];\n  }\n  return enums[order];\n}\nfunction parseNumberArray(value) {\n  const array = value.split(\",\").map(function(val) {\n    return parseFloat(val);\n  });\n  return array;\n}\nfunction convertArrayBufferToString(buffer, from, to) {\n  if (from === void 0) from = 0;\n  if (to === void 0) to = buffer.byteLength;\n  return new TextDecoder().decode(new Uint8Array(buffer, from, to));\n}\nfunction append(a, b) {\n  for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n    a[j] = b[i];\n  }\n}\nfunction slice(a, b, from, to) {\n  for (let i = from, j = 0; i < to; i++, j++) {\n    a[j] = b[i];\n  }\n  return a;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const tmpAttributes = {};\n  const tmpMorphAttributes = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const attr = geometry.attributes[name];\n    tmpAttributes[name] = new attr.constructor(\n      new attr.array.constructor(attr.count * attr.itemSize),\n      attr.itemSize,\n      attr.normalized\n    );\n    const morphAttributes = geometry.morphAttributes[name];\n    if (morphAttributes) {\n      if (!tmpMorphAttributes[name]) tmpMorphAttributes[name] = [];\n      morphAttributes.forEach((morphAttr, i2) => {\n        const array = new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize);\n        tmpMorphAttributes[name][i2] = new morphAttr.constructor(array, morphAttr.itemSize, morphAttr.normalized);\n      });\n    }\n  }\n  const halfTolerance = tolerance * 0.5;\n  const exponent = Math.log10(1 / tolerance);\n  const hashMultiplier = Math.pow(10, exponent);\n  const hashAdditive = halfTolerance * hashMultiplier;\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * hashMultiplier + hashAdditive)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttributes = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newArray = tmpAttributes[name];\n        const newMorphArrays = tmpMorphAttributes[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          const setterFunc = setters[k];\n          newArray[setterFunc](nextIndex, attribute[getterFunc](index));\n          if (morphAttributes) {\n            for (let m = 0, ml = morphAttributes.length; m < ml; m++) {\n              newMorphArrays[m][setterFunc](nextIndex, morphAttributes[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (const name in geometry.attributes) {\n    const tmpAttribute = tmpAttributes[name];\n    result.setAttribute(name, new tmpAttribute.constructor(\n      tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize),\n      tmpAttribute.itemSize,\n      tmpAttribute.normalized\n    ));\n    if (!(name in tmpMorphAttributes)) continue;\n    for (let j = 0; j < tmpMorphAttributes[name].length; j++) {\n      const tmpMorphAttribute = tmpMorphAttributes[name][j];\n      result.morphAttributes[name][j] = new tmpMorphAttribute.constructor(\n        tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize),\n        tmpMorphAttribute.itemSize,\n        tmpMorphAttribute.normalized\n      );\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (drawMode === TriangleFanDrawMode) {\n      for (let i = 1; i <= numberOfTriangles; i++) {\n        newIndices.push(index.getX(0));\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n      }\n    } else {\n      for (let i = 0; i < numberOfTriangles; i++) {\n        if (i % 2 === 0) {\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i + 2));\n        } else {\n          newIndices.push(index.getX(i + 2));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i));\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function(parser) {\n      return new GLTFMaterialsClearcoatExtension$1(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsDispersionExtension$1(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureAVIFExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSheenExtension$1(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsTransmissionExtension$1(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsVolumeExtension$1(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIorExtension$1(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension$1(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsSpecularExtension$1(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsIridescenceExtension$1(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsAnisotropyExtension$1(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsBumpExtension$1(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshGpuInstancing$1(parser);\n    });\n  }\n  load(url2, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      const relativeUrl = LoaderUtils.extractUrlBase(url2);\n      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url2);\n    }\n    this.manager.itemStart(url2);\n    const _onError = function(e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url2);\n      scope.manager.itemEnd(url2);\n    };\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url2, function(data) {\n      try {\n        scope.parse(data, resourcePath, function(gltf) {\n          onLoad(gltf);\n          scope.manager.itemEnd(url2);\n        }, _onError);\n      } catch (e) {\n        _onError(e);\n      }\n    }, onProgress, _onError);\n  }\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  parse(data, path, onLoad, onError) {\n    let json;\n    const extensions = {};\n    const plugins = {};\n    const textDecoder = new TextDecoder();\n    if (typeof data === \"string\") {\n      json = JSON.parse(data);\n    } else if (data instanceof ArrayBuffer) {\n      const magic = textDecoder.decode(new Uint8Array(data, 0, 4));\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError) onError(error);\n          return;\n        }\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n      } else {\n        json = JSON.parse(textDecoder.decode(data));\n      }\n    } else {\n      json = data;\n    }\n    if (json.asset === void 0 || json.asset.version[0] < 2) {\n      if (onError) onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      if (!plugin.name) console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\");\n      plugins[plugin.name] = plugin;\n      extensions[plugin.name] = true;\n    }\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension$1();\n            break;\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n        }\n      }\n    }\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n  parseAsync(data, path) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(data, path, resolve, reject);\n    });\n  }\n}\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function(key) {\n      return objects[key];\n    },\n    add: function(key, object) {\n      objects[key] = object;\n    },\n    remove: function(key) {\n      delete objects[key];\n    },\n    removeAll: function() {\n      objects = {};\n    }\n  };\n}\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_DISPERSION: \"KHR_materials_dispersion\",\n  KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n  KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n  KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n  KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n  EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n  EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    this.cache = { refs: {}, uses: {} };\n  }\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = \"light:\" + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency) return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new Color(16777215);\n    if (lightDef.color !== void 0) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);\n    const range = lightDef.range !== void 0 ? lightDef.range : 0;\n    switch (lightDef.type) {\n      case \"directional\":\n        lightNode = new DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      case \"point\":\n        lightNode = new PointLight(color);\n        lightNode.distance = range;\n        break;\n      case \"spot\":\n        lightNode = new SpotLight(color);\n        lightNode.distance = range;\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n    }\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    assignExtrasToUserData(lightNode, lightDef);\n    if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n  getDependency(type, index) {\n    if (type !== \"light\") return;\n    return this._loadLight(index);\n  }\n  createNodeAttachment(nodeIndex) {\n    const self2 = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === void 0) return null;\n    return this._loadLight(lightIndex).then(function(light) {\n      return parser._getNodeRef(self2.cache, lightIndex, light);\n    });\n  }\n}\nlet GLTFMaterialsUnlitExtension$1 = class GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return MeshBasicMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n    }\n    return Promise.all(pending);\n  }\n};\nlet GLTFMaterialsEmissiveStrengthExtension$1 = class GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n    if (emissiveStrength !== void 0) {\n      materialParams.emissiveIntensity = emissiveStrength;\n    }\n    return Promise.resolve();\n  }\n};\nlet GLTFMaterialsClearcoatExtension$1 = class GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.clearcoatFactor !== void 0) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n    if (extension.clearcoatTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n    }\n    if (extension.clearcoatRoughnessFactor !== void 0) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n    if (extension.clearcoatRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n    }\n    if (extension.clearcoatNormalTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n      if (extension.clearcoatNormalTexture.scale !== void 0) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale);\n      }\n    }\n    return Promise.all(pending);\n  }\n};\nlet GLTFMaterialsDispersionExtension$1 = class GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;\n    return Promise.resolve();\n  }\n};\nlet GLTFMaterialsIridescenceExtension$1 = class GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.iridescenceFactor !== void 0) {\n      materialParams.iridescence = extension.iridescenceFactor;\n    }\n    if (extension.iridescenceTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n    }\n    if (extension.iridescenceIor !== void 0) {\n      materialParams.iridescenceIOR = extension.iridescenceIor;\n    }\n    if (materialParams.iridescenceThicknessRange === void 0) {\n      materialParams.iridescenceThicknessRange = [100, 400];\n    }\n    if (extension.iridescenceThicknessMinimum !== void 0) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n    }\n    if (extension.iridescenceThicknessMaximum !== void 0) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n    }\n    if (extension.iridescenceThicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture));\n    }\n    return Promise.all(pending);\n  }\n};\nlet GLTFMaterialsSheenExtension$1 = class GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    materialParams.sheenColor = new Color(0, 0, 0);\n    materialParams.sheenRoughness = 0;\n    materialParams.sheen = 1;\n    const extension = materialDef.extensions[this.name];\n    if (extension.sheenColorFactor !== void 0) {\n      const colorFactor = extension.sheenColorFactor;\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);\n    }\n    if (extension.sheenRoughnessFactor !== void 0) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n    }\n    if (extension.sheenColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, SRGBColorSpace));\n    }\n    if (extension.sheenRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n    }\n    return Promise.all(pending);\n  }\n};\nlet GLTFMaterialsTransmissionExtension$1 = class GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.transmissionFactor !== void 0) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n    if (extension.transmissionTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n    }\n    return Promise.all(pending);\n  }\n};\nlet GLTFMaterialsVolumeExtension$1 = class GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n    if (extension.thicknessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n    }\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n    const colorArray = extension.attenuationColor || [1, 1, 1];\n    materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n    return Promise.all(pending);\n  }\n};\nlet GLTFMaterialsIorExtension$1 = class GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const extension = materialDef.extensions[this.name];\n    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n    return Promise.resolve();\n  }\n};\nlet GLTFMaterialsSpecularExtension$1 = class GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n    if (extension.specularTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n    }\n    const colorArray = extension.specularColorFactor || [1, 1, 1];\n    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n    if (extension.specularColorTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, SRGBColorSpace));\n    }\n    return Promise.all(pending);\n  }\n};\nlet GLTFMaterialsBumpExtension$1 = class GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;\n    if (extension.bumpTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"bumpMap\", extension.bumpTexture));\n    }\n    return Promise.all(pending);\n  }\n};\nlet GLTFMaterialsAnisotropyExtension$1 = class GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n    return MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.anisotropyStrength !== void 0) {\n      materialParams.anisotropy = extension.anisotropyStrength;\n    }\n    if (extension.anisotropyRotation !== void 0) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation;\n    }\n    if (extension.anisotropyTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n    }\n    return Promise.all(pending);\n  }\n};\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[this.name];\n    const loader = parser.options.ktx2Loader;\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      } else {\n        return null;\n      }\n    }\n    return parser.loadTextureImage(textureIndex, extension.source, loader);\n  }\n}\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler2 = parser.options.manager.getHandler(source.uri);\n      if (handler2 !== null) loader = handler2;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler2 = parser.options.manager.getHandler(source.uri);\n      if (handler2 !== null) loader = handler2;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        } else {\n          return null;\n        }\n      }\n      return buffer.then(function(res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const source = new Uint8Array(res, byteOffset, byteLength);\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n            return res2.buffer;\n          });\n        } else {\n          return decoder.ready.then(function() {\n            const result = new ArrayBuffer(count * stride);\n            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n            return result;\n          });\n        }\n      });\n    } else {\n      return null;\n    }\n  }\n}\nlet GLTFMeshGpuInstancing$1 = class GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n    this.parser = parser;\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n      return null;\n    }\n    const meshDef = json.meshes[nodeDef.mesh];\n    for (const primitive of meshDef.primitives) {\n      if (primitive.mode !== WEBGL_CONSTANTS$1.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS$1.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS$1.TRIANGLE_FAN && primitive.mode !== void 0) {\n        return null;\n      }\n    }\n    const extensionDef = nodeDef.extensions[this.name];\n    const attributesDef = extensionDef.attributes;\n    const pending = [];\n    const attributes = {};\n    for (const key in attributesDef) {\n      pending.push(this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor) => {\n        attributes[key] = accessor;\n        return attributes[key];\n      }));\n    }\n    if (pending.length < 1) {\n      return null;\n    }\n    pending.push(this.parser.createNodeMesh(nodeIndex));\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop();\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];\n      const count = results[0].count;\n      const instancedMeshes = [];\n      for (const mesh of meshes) {\n        const m = new Matrix4();\n        const p = new Vector3();\n        const q = new Quaternion();\n        const s = new Vector3(1, 1, 1);\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i);\n          }\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i);\n          }\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i);\n          }\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n        }\n        for (const attributeName in attributes) {\n          if (attributeName === \"_COLOR_0\") {\n            const attr = attributes[attributeName];\n            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);\n          } else if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n          }\n        }\n        Object3D.prototype.copy.call(instancedMesh, mesh);\n        this.parser.assignFinalMaterial(instancedMesh);\n        instancedMeshes.push(instancedMesh);\n      }\n      if (nodeObject.isGroup) {\n        nodeObject.clear();\n        nodeObject.add(...instancedMeshes);\n        return nodeObject;\n      }\n      return instancedMeshes[0];\n    });\n  }\n};\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    const textDecoder = new TextDecoder();\n    this.header = {\n      magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    } else if (this.header.version < 2) {\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    }\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = textDecoder.decode(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n      chunkIndex += chunkLength;\n    }\n    if (this.content === null) {\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n    }\n  }\n}\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    }\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType.name;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n    return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n      return new Promise(function(resolve, reject) {\n        dracoLoader.decodeDracoFile(bufferView, function(geometry) {\n          for (const attributeName in geometry.attributes) {\n            const attribute = geometry.attributes[attributeName];\n            const normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== void 0) attribute.normalized = normalized;\n          }\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);\n      });\n    });\n  }\n}\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(texture, transform) {\n    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n      return texture;\n    }\n    texture = texture.clone();\n    if (transform.texCoord !== void 0) {\n      texture.channel = transform.texCoord;\n    }\n    if (transform.offset !== void 0) {\n      texture.offset.fromArray(transform.offset);\n    }\n    if (transform.rotation !== void 0) {\n      texture.rotation = transform.rotation;\n    }\n    if (transform.scale !== void 0) {\n      texture.repeat.fromArray(transform.scale);\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n  interpolate_(i1, t0, t2, t1) {\n    const result = this.resultBuffer;\n    const values = this.sampleValues;\n    const stride = this.valueSize;\n    const stride2 = stride * 2;\n    const stride3 = stride * 3;\n    const td2 = t1 - t0;\n    const p = (t2 - t0) / td2;\n    const pp = p * p;\n    const ppp = pp * p;\n    const offset1 = i1 * stride3;\n    const offset0 = offset1 - stride3;\n    const s2 = -2 * ppp + 3 * pp;\n    const s3 = ppp - pp;\n    const s0 = 1 - s2;\n    const s1 = s3 - pp + p;\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride];\n      const m0 = values[offset0 + i + stride2] * td2;\n      const p1 = values[offset1 + i + stride];\n      const m1 = values[offset1 + i] * td2;\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n    return result;\n  }\n}\nconst _q = new Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t2, t1) {\n    const result = super.interpolate_(i1, t0, t2, t1);\n    _q.fromArray(result).normalize().toArray(result);\n    return result;\n  }\n}\nconst WEBGL_CONSTANTS$1 = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  \"SCALAR\": 1,\n  \"VEC2\": 2,\n  \"VEC3\": 3,\n  \"VEC4\": 4,\n  \"MAT2\": 4,\n  \"MAT3\": 9,\n  \"MAT4\": 16\n};\nconst ATTRIBUTES = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  TEXCOORD_0: \"uv\",\n  TEXCOORD_1: \"uv1\",\n  TEXCOORD_2: \"uv2\",\n  TEXCOORD_3: \"uv3\",\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES$1 = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: void 0,\n  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache2) {\n  if (cache2[\"DefaultMaterial\"] === void 0) {\n    cache2[\"DefaultMaterial\"] = new MeshStandardMaterial({\n      color: 16777215,\n      emissive: 0,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide\n    });\n  }\n  return cache2[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === void 0) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== void 0) {\n    if (typeof gltfDef.extras === \"object\") {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n    }\n  }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  let hasMorphColor = false;\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== void 0) hasMorphPosition = true;\n    if (target.NORMAL !== void 0) hasMorphNormal = true;\n    if (target.COLOR_0 !== void 0) hasMorphColor = true;\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;\n  }\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  const pendingColorAccessors = [];\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n    if (hasMorphColor) {\n      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n      pendingColorAccessors.push(pendingAccessor);\n    }\n  }\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors)\n  ]).then(function(accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    const morphColors = accessors[2];\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n  if (meshDef.weights !== void 0) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n    }\n  }\n}\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey;\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  if (dracoExtension) {\n    geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n  }\n  if (primitiveDef.targets !== void 0) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n    }\n  }\n  return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n  let attributesKey = \"\";\n  const keys = Object.keys(attributes).sort();\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n  }\n  return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return \"image/jpeg\";\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return \"image/webp\";\n  if (uri.search(/\\.ktx2($|\\?)/i) > 0 || uri.search(/^data\\:image\\/ktx2/) === 0) return \"image/ktx2\";\n  return \"image/png\";\n}\nconst _identityMatrix = new Matrix4();\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n    this.cache = new GLTFRegistry();\n    this.associations = /* @__PURE__ */ new Map();\n    this.primitiveCache = {};\n    this.nodeCache = {};\n    this.meshCache = { refs: {}, uses: {} };\n    this.cameraCache = { refs: {}, uses: {} };\n    this.lightCache = { refs: {}, uses: {} };\n    this.sourceCache = {};\n    this.textureCache = {};\n    this.nodeNamesUsed = {};\n    let isSafari = false;\n    let safariVersion = -1;\n    let isFirefox = false;\n    let firefoxVersion = -1;\n    if (typeof navigator !== \"undefined\") {\n      const userAgent = navigator.userAgent;\n      isSafari = /^((?!chrome|android).)*safari/i.test(userAgent) === true;\n      const safariMatch = userAgent.match(/Version\\/(\\d+)/);\n      safariVersion = isSafari && safariMatch ? parseInt(safariMatch[1], 10) : -1;\n      isFirefox = userAgent.indexOf(\"Firefox\") > -1;\n      firefoxVersion = isFirefox ? userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n    }\n    if (typeof createImageBitmap === \"undefined\" || isSafari && safariVersion < 17 || isFirefox && firefoxVersion < 98) {\n      this.textureLoader = new TextureLoader(this.options.manager);\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager);\n    }\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new FileLoader(this.options.manager);\n    this.fileLoader.setResponseType(\"arraybuffer\");\n    if (this.options.crossOrigin === \"use-credentials\") {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    this.cache.removeAll();\n    this.nodeCache = {};\n    this._invokeAll(function(ext2) {\n      return ext2._markDefs && ext2._markDefs();\n    });\n    Promise.all(this._invokeAll(function(ext2) {\n      return ext2.beforeRoot && ext2.beforeRoot();\n    })).then(function() {\n      return Promise.all([\n        parser.getDependencies(\"scene\"),\n        parser.getDependencies(\"animation\"),\n        parser.getDependencies(\"camera\")\n      ]);\n    }).then(function(dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      return Promise.all(parser._invokeAll(function(ext2) {\n        return ext2.afterRoot && ext2.afterRoot(result);\n      })).then(function() {\n        for (const scene of result.scenes) {\n          scene.updateMatrixWorld();\n        }\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.mesh !== void 0) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n        if (nodeDef.skin !== void 0) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n      if (nodeDef.camera !== void 0) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache2, index) {\n    if (index === void 0) return;\n    if (cache2.refs[index] === void 0) {\n      cache2.refs[index] = cache2.uses[index] = 0;\n    }\n    cache2.refs[index]++;\n  }\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache2, index, object) {\n    if (cache2.refs[index] <= 1) return object;\n    const ref2 = object.clone();\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original);\n      if (mappings != null) {\n        this.associations.set(clone, mappings);\n      }\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i]);\n      }\n    };\n    updateMappings(object, ref2);\n    ref2.name += \"_instance_\" + cache2.uses[index]++;\n    return ref2;\n  }\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result) return result;\n    }\n    return null;\n  }\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result) pending.push(result);\n    }\n    return pending;\n  }\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + \":\" + index;\n    let dependency = this.cache.get(cacheKey);\n    if (!dependency) {\n      switch (type) {\n        case \"scene\":\n          dependency = this.loadScene(index);\n          break;\n        case \"node\":\n          dependency = this._invokeOne(function(ext2) {\n            return ext2.loadNode && ext2.loadNode(index);\n          });\n          break;\n        case \"mesh\":\n          dependency = this._invokeOne(function(ext2) {\n            return ext2.loadMesh && ext2.loadMesh(index);\n          });\n          break;\n        case \"accessor\":\n          dependency = this.loadAccessor(index);\n          break;\n        case \"bufferView\":\n          dependency = this._invokeOne(function(ext2) {\n            return ext2.loadBufferView && ext2.loadBufferView(index);\n          });\n          break;\n        case \"buffer\":\n          dependency = this.loadBuffer(index);\n          break;\n        case \"material\":\n          dependency = this._invokeOne(function(ext2) {\n            return ext2.loadMaterial && ext2.loadMaterial(index);\n          });\n          break;\n        case \"texture\":\n          dependency = this._invokeOne(function(ext2) {\n            return ext2.loadTexture && ext2.loadTexture(index);\n          });\n          break;\n        case \"skin\":\n          dependency = this.loadSkin(index);\n          break;\n        case \"animation\":\n          dependency = this._invokeOne(function(ext2) {\n            return ext2.loadAnimation && ext2.loadAnimation(index);\n          });\n          break;\n        case \"camera\":\n          dependency = this.loadCamera(index);\n          break;\n        default:\n          dependency = this._invokeOne(function(ext2) {\n            return ext2 != this && ext2.getDependency && ext2.getDependency(type, index);\n          });\n          if (!dependency) {\n            throw new Error(\"Unknown type: \" + type);\n          }\n          break;\n      }\n      this.cache.add(cacheKey, dependency);\n    }\n    return dependency;\n  }\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n      dependencies = Promise.all(defs.map(function(def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n    return dependencies;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n      throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n    }\n    if (bufferDef.uri === void 0 && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n    const options = this.options;\n    return new Promise(function(resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const normalized = accessorDef.normalized === true;\n      const array = new TypedArray(accessorDef.count * itemSize);\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));\n    }\n    const pendingBufferViews = [];\n    if (accessorDef.bufferView !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n    if (accessorDef.sparse !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n    }\n    return Promise.all(pendingBufferViews).then(function(bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n      if (byteStride && byteStride !== itemBytes) {\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\n      }\n      if (accessorDef.sparse !== void 0) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n        if (bufferView !== null) {\n          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n        }\n        bufferAttribute.normalized = false;\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5) throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n        bufferAttribute.normalized = normalized;\n      }\n      return bufferAttribute;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const sourceIndex = textureDef.source;\n    const sourceDef = json.images[sourceIndex];\n    let loader = this.textureLoader;\n    if (sourceDef.uri) {\n      const handler2 = options.manager.getHandler(sourceDef.uri);\n      if (handler2 !== null) loader = handler2;\n    }\n    return this.loadTextureImage(textureIndex, sourceIndex, loader);\n  }\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const textureDef = json.textures[textureIndex];\n    const sourceDef = json.images[sourceIndex];\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n    if (this.textureCache[cacheKey]) {\n      return this.textureCache[cacheKey];\n    }\n    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n      texture.flipY = false;\n      texture.name = textureDef.name || sourceDef.name || \"\";\n      if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n        texture.name = sourceDef.uri;\n      }\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\n      texture.generateMipmaps = !texture.isCompressedTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n      parser.associations.set(texture, { textures: textureIndex });\n      return texture;\n    }).catch(function() {\n      return null;\n    });\n    this.textureCache[cacheKey] = promise;\n    return promise;\n  }\n  loadImageSource(sourceIndex, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    if (this.sourceCache[sourceIndex] !== void 0) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone());\n    }\n    const sourceDef = json.images[sourceIndex];\n    const URL2 = self.URL || self.webkitURL;\n    let sourceURI = sourceDef.uri || \"\";\n    let isObjectURL = false;\n    if (sourceDef.bufferView !== void 0) {\n      sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n        isObjectURL = true;\n        const blob2 = new Blob([bufferView], { type: sourceDef.mimeType });\n        sourceURI = URL2.createObjectURL(blob2);\n        return sourceURI;\n      });\n    } else if (sourceDef.uri === void 0) {\n      throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n    }\n    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n      return new Promise(function(resolve, reject) {\n        let onLoad = resolve;\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function(imageBitmap) {\n            const texture = new Texture(imageBitmap);\n            texture.needsUpdate = true;\n            resolve(texture);\n          };\n        }\n        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n      });\n    }).then(function(texture) {\n      if (isObjectURL === true) {\n        URL2.revokeObjectURL(sourceURI);\n      }\n      assignExtrasToUserData(texture, sourceDef);\n      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n      return texture;\n    }).catch(function(error) {\n      console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n      throw error;\n    });\n    this.sourceCache[sourceIndex] = promise;\n    return promise;\n  }\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this;\n    return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n      if (!texture) return null;\n      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n        texture = texture.clone();\n        texture.channel = mapDef.texCoord;\n      }\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n      if (colorSpace !== void 0) {\n        texture.colorSpace = colorSpace;\n      }\n      materialParams[mapName] = texture;\n      return texture;\n    });\n  }\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useDerivativeTangents = geometry.attributes.tangent === void 0;\n    const useVertexColors = geometry.attributes.color !== void 0;\n    const useFlatShading = geometry.attributes.normal === void 0;\n    if (mesh.isPoints) {\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial();\n        Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false;\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial();\n        Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        lineMaterial.map = material.map;\n        this.cache.add(cacheKey, lineMaterial);\n      }\n      material = lineMaterial;\n    }\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n      if (useDerivativeTangents) cacheKey += \"derivative-tangents:\";\n      if (useVertexColors) cacheKey += \"vertex-colors:\";\n      if (useFlatShading) cacheKey += \"flat-shading:\";\n      let cachedMaterial = this.cache.get(cacheKey);\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useVertexColors) cachedMaterial.vertexColors = true;\n        if (useFlatShading) cachedMaterial.flatShading = true;\n        if (useDerivativeTangents) {\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n      material = cachedMaterial;\n    }\n    mesh.material = material;\n  }\n  getMaterialType() {\n    return MeshStandardMaterial;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new Color(1, 1, 1);\n      materialParams.opacity = 1;\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n      }\n      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n      if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n      }\n      materialType = this._invokeOne(function(ext2) {\n        return ext2.getMaterialType && ext2.getMaterialType(materialIndex);\n      });\n      pending.push(Promise.all(this._invokeAll(function(ext2) {\n        return ext2.extendMaterialParams && ext2.extendMaterialParams(materialIndex, materialParams);\n      })));\n    }\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide;\n    }\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n      materialParams.normalScale = new Vector2(1, 1);\n      if (materialDef.normalTexture.scale !== void 0) {\n        const scale = materialDef.normalTexture.scale;\n        materialParams.normalScale.set(scale, scale);\n      }\n    }\n    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n      if (materialDef.occlusionTexture.strength !== void 0) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor;\n      materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);\n    }\n    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, SRGBColorSpace));\n    }\n    return Promise.all(pending).then(function() {\n      const material = new materialType(materialParams);\n      if (materialDef.name) material.name = materialDef.name;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, { materials: materialIndex });\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || \"\");\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0;\n      return sanitizedName;\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache2 = this.primitiveCache;\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n      const cached = cache2[cacheKey];\n      if (cached) {\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);\n        }\n        cache2[cacheKey] = { primitive, promise: geometryPromise };\n        pending.push(geometryPromise);\n      }\n    }\n    return Promise.all(pending);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n      pending.push(material);\n    }\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function(results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n        let mesh;\n        const material = materials[i];\n        if (primitive.mode === WEBGL_CONSTANTS$1.TRIANGLES || primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN || primitive.mode === void 0) {\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);\n          if (mesh.isSkinnedMesh === true) {\n            mesh.normalizeSkinWeights();\n          }\n          if (primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS$1.LINES) {\n          mesh = new LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS$1.LINE_STRIP) {\n          mesh = new Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS$1.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS$1.POINTS) {\n          mesh = new Points(geometry, material);\n        } else {\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n        }\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n        mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i\n        });\n      }\n      if (meshes.length === 1) {\n        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n        return meshes[0];\n      }\n      const group = new Group();\n      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);\n      parser.associations.set(group, { meshes: meshIndex });\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n    if (!params) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    if (cameraDef.type === \"perspective\") {\n      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === \"orthographic\") {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const pending = [];\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]));\n    }\n    if (skinDef.inverseBindMatrices !== void 0) {\n      pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n    } else {\n      pending.push(null);\n    }\n    return Promise.all(pending).then(function(results) {\n      const inverseBindMatrices = results.pop();\n      const jointNodes = results;\n      const bones = [];\n      const boneInverses = [];\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i];\n        if (jointNode) {\n          bones.push(jointNode);\n          const mat = new Matrix4();\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16);\n          }\n          boneInverses.push(mat);\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n        }\n      }\n      return new Skeleton(bones, boneInverses);\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const parser = this;\n    const animationDef = json.animations[animationIndex];\n    const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node;\n      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n      if (target.node === void 0) continue;\n      pendingNodes.push(this.getDependency(\"node\", name));\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets)\n    ]).then(function(dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === void 0) continue;\n        if (node.updateMatrix) {\n          node.updateMatrix();\n        }\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k]);\n          }\n        }\n      }\n      return new AnimationClip(animationName, void 0, tracks);\n    });\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === void 0) return null;\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n      if (nodeDef.weights !== void 0) {\n        node.traverse(function(o) {\n          if (!o.isMesh) return;\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n      return node;\n    });\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    const nodePending = parser._loadNodeShallow(nodeIndex);\n    const childPending = [];\n    const childrenDef = nodeDef.children || [];\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n    }\n    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n    return Promise.all([\n      nodePending,\n      Promise.all(childPending),\n      skeletonPending\n    ]).then(function(results) {\n      const node = results[0];\n      const children = results[1];\n      const skeleton = results[2];\n      if (skeleton !== null) {\n        node.traverse(function(mesh) {\n          if (!mesh.isSkinnedMesh) return;\n          mesh.bind(skeleton, _identityMatrix);\n        });\n      }\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i]);\n      }\n      return node;\n    });\n  }\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    if (this.nodeCache[nodeIndex] !== void 0) {\n      return this.nodeCache[nodeIndex];\n    }\n    const nodeDef = json.nodes[nodeIndex];\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n    const pending = [];\n    const meshPromise = parser._invokeOne(function(ext2) {\n      return ext2.createNodeMesh && ext2.createNodeMesh(nodeIndex);\n    });\n    if (meshPromise) {\n      pending.push(meshPromise);\n    }\n    if (nodeDef.camera !== void 0) {\n      pending.push(parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n      }));\n    }\n    parser._invokeAll(function(ext2) {\n      return ext2.createNodeAttachment && ext2.createNodeAttachment(nodeIndex);\n    }).forEach(function(promise) {\n      pending.push(promise);\n    });\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n      let node;\n      if (nodeDef.isBone === true) {\n        node = new Bone();\n      } else if (objects.length > 1) {\n        node = new Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new Object3D();\n      }\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n      if (nodeDef.matrix !== void 0) {\n        const matrix = new Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== void 0) {\n          node.position.fromArray(nodeDef.translation);\n        }\n        if (nodeDef.rotation !== void 0) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n        if (nodeDef.scale !== void 0) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {});\n      }\n      parser.associations.get(node).nodes = nodeIndex;\n      return node;\n    });\n    return this.nodeCache[nodeIndex];\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n    const scene = new Group();\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency(\"node\", nodeIds[i]));\n    }\n    return Promise.all(pending).then(function(nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i]);\n      }\n      const reduceAssociations = (node) => {\n        const reducedAssociations = /* @__PURE__ */ new Map();\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value);\n          }\n        }\n        node.traverse((node2) => {\n          const mappings = parser.associations.get(node2);\n          if (mappings != null) {\n            reducedAssociations.set(node2, mappings);\n          }\n        });\n        return reducedAssociations;\n      };\n      parser.associations = reduceAssociations(scene);\n      return scene;\n    });\n  }\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = [];\n    const targetName = node.name ? node.name : node.uuid;\n    const targetNames = [];\n    if (PATH_PROPERTIES$1[target.path] === PATH_PROPERTIES$1.weights) {\n      node.traverse(function(object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid);\n        }\n      });\n    } else {\n      targetNames.push(targetName);\n    }\n    let TypedKeyframeTrack;\n    switch (PATH_PROPERTIES$1[target.path]) {\n      case PATH_PROPERTIES$1.weights:\n        TypedKeyframeTrack = NumberKeyframeTrack;\n        break;\n      case PATH_PROPERTIES$1.rotation:\n        TypedKeyframeTrack = QuaternionKeyframeTrack;\n        break;\n      case PATH_PROPERTIES$1.position:\n      case PATH_PROPERTIES$1.scale:\n        TypedKeyframeTrack = VectorKeyframeTrack;\n        break;\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = NumberKeyframeTrack;\n            break;\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack;\n            break;\n        }\n        break;\n    }\n    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;\n    const outputArray = this._getArrayFromAccessor(outputAccessor);\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + \".\" + PATH_PROPERTIES$1[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation\n      );\n      if (sampler.interpolation === \"CUBICSPLINE\") {\n        this._createCubicSplineTrackInterpolant(track);\n      }\n      tracks.push(track);\n    }\n    return tracks;\n  }\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array;\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor);\n      const scaled = new Float32Array(outputArray.length);\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale;\n      }\n      outputArray = scaled;\n    }\n    return outputArray;\n  }\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n    };\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n  }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new Box3();\n  if (attributes.POSITION !== void 0) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max2 = accessor.max;\n    if (min !== void 0 && max2 !== void 0) {\n      box.set(\n        new Vector3(min[0], min[1], min[2]),\n        new Vector3(max2[0], max2[1], max2[2])\n      );\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else {\n    return;\n  }\n  const targets = primitiveDef.targets;\n  if (targets !== void 0) {\n    const maxDisplacement = new Vector3();\n    const vector = new Vector3();\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== void 0) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max2 = accessor.max;\n        if (min !== void 0 && max2 !== void 0) {\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max2[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max2[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max2[2])));\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          }\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n        }\n      }\n    }\n    box.expandByVector(maxDisplacement);\n  }\n  geometry.boundingBox = box;\n  const sphere = new Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n    if (threeAttributeName in geometry.attributes) continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n  if (primitiveDef.indices !== void 0 && !geometry.index) {\n    const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n      geometry.setIndex(accessor2);\n    });\n    pending.push(accessor);\n  }\n  if (ColorManagement.workingColorSpace !== LinearSRGBColorSpace && \"COLOR_0\" in attributes) {\n    console.warn(`THREE.GLTFLoader: Converting vertex colors from \"srgb-linear\" to \"${ColorManagement.workingColorSpace}\" not supported.`);\n  }\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function() {\n    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\nclass MTLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  /**\n   * Loads and parses a MTL asset from a URL.\n   *\n   * @param {String} url - URL to the MTL file.\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\n   * @param {Function} [onProgress] - Callback for download progress.\n   * @param {Function} [onError] - Callback for download errors.\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to load.\n   */\n  load(url2, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === \"\" ? LoaderUtils.extractUrlBase(url2) : this.path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url2, function(text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url2);\n      }\n    }, onProgress, onError);\n  }\n  setMaterialOptions(value) {\n    this.materialOptions = value;\n    return this;\n  }\n  /**\n   * Parses a MTL file.\n   *\n   * @param {String} text - Content of MTL file\n   * @return {MaterialCreator}\n   *\n   * @see setPath setResourcePath\n   *\n   * @note In order for relative texture references to resolve correctly\n   * you must call setResourcePath() explicitly prior to parse.\n   */\n  parse(text, path) {\n    const lines = text.split(\"\\n\");\n    let info = {};\n    const delimiter_pattern = /\\s+/;\n    const materialsInfo = {};\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i];\n      line = line.trim();\n      if (line.length === 0 || line.charAt(0) === \"#\") {\n        continue;\n      }\n      const pos = line.indexOf(\" \");\n      let key = pos >= 0 ? line.substring(0, pos) : line;\n      key = key.toLowerCase();\n      let value = pos >= 0 ? line.substring(pos + 1) : \"\";\n      value = value.trim();\n      if (key === \"newmtl\") {\n        info = { name: value };\n        materialsInfo[value] = info;\n      } else {\n        if (key === \"ka\" || key === \"kd\" || key === \"ks\" || key === \"ke\") {\n          const ss = value.split(delimiter_pattern, 3);\n          info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n        } else {\n          info[key] = value;\n        }\n      }\n    }\n    const materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);\n    materialCreator.setCrossOrigin(this.crossOrigin);\n    materialCreator.setManager(this.manager);\n    materialCreator.setMaterials(materialsInfo);\n    return materialCreator;\n  }\n}\nclass MaterialCreator {\n  constructor(baseUrl = \"\", options = {}) {\n    this.baseUrl = baseUrl;\n    this.options = options;\n    this.materialsInfo = {};\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n    this.crossOrigin = \"anonymous\";\n    this.side = this.options.side !== void 0 ? this.options.side : FrontSide;\n    this.wrap = this.options.wrap !== void 0 ? this.options.wrap : RepeatWrapping;\n  }\n  setCrossOrigin(value) {\n    this.crossOrigin = value;\n    return this;\n  }\n  setManager(value) {\n    this.manager = value;\n  }\n  setMaterials(materialsInfo) {\n    this.materialsInfo = this.convert(materialsInfo);\n    this.materials = {};\n    this.materialsArray = [];\n    this.nameLookup = {};\n  }\n  convert(materialsInfo) {\n    if (!this.options) return materialsInfo;\n    const converted = {};\n    for (const mn in materialsInfo) {\n      const mat = materialsInfo[mn];\n      const covmat = {};\n      converted[mn] = covmat;\n      for (const prop in mat) {\n        let save = true;\n        let value = mat[prop];\n        const lprop = prop.toLowerCase();\n        switch (lprop) {\n          case \"kd\":\n          case \"ka\":\n          case \"ks\":\n            if (this.options && this.options.normalizeRGB) {\n              value = [value[0] / 255, value[1] / 255, value[2] / 255];\n            }\n            if (this.options && this.options.ignoreZeroRGBs) {\n              if (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n                save = false;\n              }\n            }\n            break;\n        }\n        if (save) {\n          covmat[lprop] = value;\n        }\n      }\n    }\n    return converted;\n  }\n  preload() {\n    for (const mn in this.materialsInfo) {\n      this.create(mn);\n    }\n  }\n  getIndex(materialName) {\n    return this.nameLookup[materialName];\n  }\n  getAsArray() {\n    let index = 0;\n    for (const mn in this.materialsInfo) {\n      this.materialsArray[index] = this.create(mn);\n      this.nameLookup[mn] = index;\n      index++;\n    }\n    return this.materialsArray;\n  }\n  create(materialName) {\n    if (this.materials[materialName] === void 0) {\n      this.createMaterial_(materialName);\n    }\n    return this.materials[materialName];\n  }\n  createMaterial_(materialName) {\n    const scope = this;\n    const mat = this.materialsInfo[materialName];\n    const params = {\n      name: materialName,\n      side: this.side\n    };\n    function resolveURL(baseUrl, url2) {\n      if (typeof url2 !== \"string\" || url2 === \"\")\n        return \"\";\n      if (/^https?:\\/\\//i.test(url2)) return url2;\n      return baseUrl + url2;\n    }\n    function setMapForType(mapType, value) {\n      if (params[mapType]) return;\n      const texParams = scope.getTextureParams(value, params);\n      const map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n      map.repeat.copy(texParams.scale);\n      map.offset.copy(texParams.offset);\n      map.wrapS = scope.wrap;\n      map.wrapT = scope.wrap;\n      if (mapType === \"map\" || mapType === \"emissiveMap\") {\n        map.colorSpace = SRGBColorSpace;\n      }\n      params[mapType] = map;\n    }\n    for (const prop in mat) {\n      const value = mat[prop];\n      let n;\n      if (value === \"\") continue;\n      switch (prop.toLowerCase()) {\n        case \"kd\":\n          params.color = ColorManagement.toWorkingColorSpace(new Color().fromArray(value), SRGBColorSpace);\n          break;\n        case \"ks\":\n          params.specular = ColorManagement.toWorkingColorSpace(new Color().fromArray(value), SRGBColorSpace);\n          break;\n        case \"ke\":\n          params.emissive = ColorManagement.toWorkingColorSpace(new Color().fromArray(value), SRGBColorSpace);\n          break;\n        case \"map_kd\":\n          setMapForType(\"map\", value);\n          break;\n        case \"map_ks\":\n          setMapForType(\"specularMap\", value);\n          break;\n        case \"map_ke\":\n          setMapForType(\"emissiveMap\", value);\n          break;\n        case \"norm\":\n          setMapForType(\"normalMap\", value);\n          break;\n        case \"map_bump\":\n        case \"bump\":\n          setMapForType(\"bumpMap\", value);\n          break;\n        case \"map_d\":\n          setMapForType(\"alphaMap\", value);\n          params.transparent = true;\n          break;\n        case \"ns\":\n          params.shininess = parseFloat(value);\n          break;\n        case \"d\":\n          n = parseFloat(value);\n          if (n < 1) {\n            params.opacity = n;\n            params.transparent = true;\n          }\n          break;\n        case \"tr\":\n          n = parseFloat(value);\n          if (this.options && this.options.invertTrProperty) n = 1 - n;\n          if (n > 0) {\n            params.opacity = 1 - n;\n            params.transparent = true;\n          }\n          break;\n      }\n    }\n    this.materials[materialName] = new MeshPhongMaterial(params);\n    return this.materials[materialName];\n  }\n  getTextureParams(value, matParams) {\n    const texParams = {\n      scale: new Vector2(1, 1),\n      offset: new Vector2(0, 0)\n    };\n    const items = value.split(/\\s+/);\n    let pos;\n    pos = items.indexOf(\"-bm\");\n    if (pos >= 0) {\n      matParams.bumpScale = parseFloat(items[pos + 1]);\n      items.splice(pos, 2);\n    }\n    pos = items.indexOf(\"-s\");\n    if (pos >= 0) {\n      texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4);\n    }\n    pos = items.indexOf(\"-o\");\n    if (pos >= 0) {\n      texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n      items.splice(pos, 4);\n    }\n    texParams.url = items.join(\" \").trim();\n    return texParams;\n  }\n  loadTexture(url2, mapping, onLoad, onProgress, onError) {\n    const manager = this.manager !== void 0 ? this.manager : DefaultLoadingManager;\n    let loader = manager.getHandler(url2);\n    if (loader === null) {\n      loader = new TextureLoader(manager);\n    }\n    if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n    const texture = loader.load(url2, onLoad, onProgress, onError);\n    if (mapping !== void 0) texture.mapping = mapping;\n    return texture;\n  }\n}\nconst _object_pattern = /^[og]\\s*(.+)?/;\nconst _material_library_pattern = /^mtllib /;\nconst _material_use_pattern = /^usemtl /;\nconst _map_use_pattern = /^usemap /;\nconst _face_vertex_data_separator_pattern = /\\s+/;\nconst _vA = new Vector3();\nconst _vB = new Vector3();\nconst _vC = new Vector3();\nconst _ab = new Vector3();\nconst _cb = new Vector3();\nconst _color = new Color();\nfunction ParserState() {\n  const state = {\n    objects: [],\n    object: {},\n    vertices: [],\n    normals: [],\n    colors: [],\n    uvs: [],\n    materials: {},\n    materialLibraries: [],\n    startObject: function(name, fromDeclaration) {\n      if (this.object && this.object.fromDeclaration === false) {\n        this.object.name = name;\n        this.object.fromDeclaration = fromDeclaration !== false;\n        return;\n      }\n      const previousMaterial = this.object && typeof this.object.currentMaterial === \"function\" ? this.object.currentMaterial() : void 0;\n      if (this.object && typeof this.object._finalize === \"function\") {\n        this.object._finalize(true);\n      }\n      this.object = {\n        name: name || \"\",\n        fromDeclaration: fromDeclaration !== false,\n        geometry: {\n          vertices: [],\n          normals: [],\n          colors: [],\n          uvs: [],\n          hasUVIndices: false\n        },\n        materials: [],\n        smooth: true,\n        startMaterial: function(name2, libraries) {\n          const previous = this._finalize(false);\n          if (previous && (previous.inherited || previous.groupCount <= 0)) {\n            this.materials.splice(previous.index, 1);\n          }\n          const material = {\n            index: this.materials.length,\n            name: name2 || \"\",\n            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : \"\",\n            smooth: previous !== void 0 ? previous.smooth : this.smooth,\n            groupStart: previous !== void 0 ? previous.groupEnd : 0,\n            groupEnd: -1,\n            groupCount: -1,\n            inherited: false,\n            clone: function(index) {\n              const cloned = {\n                index: typeof index === \"number\" ? index : this.index,\n                name: this.name,\n                mtllib: this.mtllib,\n                smooth: this.smooth,\n                groupStart: 0,\n                groupEnd: -1,\n                groupCount: -1,\n                inherited: false\n              };\n              cloned.clone = this.clone.bind(cloned);\n              return cloned;\n            }\n          };\n          this.materials.push(material);\n          return material;\n        },\n        currentMaterial: function() {\n          if (this.materials.length > 0) {\n            return this.materials[this.materials.length - 1];\n          }\n          return void 0;\n        },\n        _finalize: function(end) {\n          const lastMultiMaterial = this.currentMaterial();\n          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n            lastMultiMaterial.inherited = false;\n          }\n          if (end && this.materials.length > 1) {\n            for (let mi = this.materials.length - 1; mi >= 0; mi--) {\n              if (this.materials[mi].groupCount <= 0) {\n                this.materials.splice(mi, 1);\n              }\n            }\n          }\n          if (end && this.materials.length === 0) {\n            this.materials.push({\n              name: \"\",\n              smooth: this.smooth\n            });\n          }\n          return lastMultiMaterial;\n        }\n      };\n      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === \"function\") {\n        const declared = previousMaterial.clone(0);\n        declared.inherited = true;\n        this.object.materials.push(declared);\n      }\n      this.objects.push(this.object);\n    },\n    finalize: function() {\n      if (this.object && typeof this.object._finalize === \"function\") {\n        this.object._finalize(true);\n      }\n    },\n    parseVertexIndex: function(value, len) {\n      const index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    },\n    parseNormalIndex: function(value, len) {\n      const index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 3) * 3;\n    },\n    parseUVIndex: function(value, len) {\n      const index = parseInt(value, 10);\n      return (index >= 0 ? index - 1 : index + len / 2) * 2;\n    },\n    addVertex: function(a, b, c) {\n      const src = this.vertices;\n      const dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addVertexPoint: function(a) {\n      const src = this.vertices;\n      const dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    },\n    addVertexLine: function(a) {\n      const src = this.vertices;\n      const dst = this.object.geometry.vertices;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n    },\n    addNormal: function(a, b, c) {\n      const src = this.normals;\n      const dst = this.object.geometry.normals;\n      dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addFaceNormal: function(a, b, c) {\n      const src = this.vertices;\n      const dst = this.object.geometry.normals;\n      _vA.fromArray(src, a);\n      _vB.fromArray(src, b);\n      _vC.fromArray(src, c);\n      _cb.subVectors(_vC, _vB);\n      _ab.subVectors(_vA, _vB);\n      _cb.cross(_ab);\n      _cb.normalize();\n      dst.push(_cb.x, _cb.y, _cb.z);\n      dst.push(_cb.x, _cb.y, _cb.z);\n      dst.push(_cb.x, _cb.y, _cb.z);\n    },\n    addColor: function(a, b, c) {\n      const src = this.colors;\n      const dst = this.object.geometry.colors;\n      if (src[a] !== void 0) dst.push(src[a + 0], src[a + 1], src[a + 2]);\n      if (src[b] !== void 0) dst.push(src[b + 0], src[b + 1], src[b + 2]);\n      if (src[c] !== void 0) dst.push(src[c + 0], src[c + 1], src[c + 2]);\n    },\n    addUV: function(a, b, c) {\n      const src = this.uvs;\n      const dst = this.object.geometry.uvs;\n      dst.push(src[a + 0], src[a + 1]);\n      dst.push(src[b + 0], src[b + 1]);\n      dst.push(src[c + 0], src[c + 1]);\n    },\n    addDefaultUV: function() {\n      const dst = this.object.geometry.uvs;\n      dst.push(0, 0);\n      dst.push(0, 0);\n      dst.push(0, 0);\n    },\n    addUVLine: function(a) {\n      const src = this.uvs;\n      const dst = this.object.geometry.uvs;\n      dst.push(src[a + 0], src[a + 1]);\n    },\n    addFace: function(a, b, c, ua, ub, uc, na, nb, nc) {\n      const vLen = this.vertices.length;\n      let ia = this.parseVertexIndex(a, vLen);\n      let ib = this.parseVertexIndex(b, vLen);\n      let ic = this.parseVertexIndex(c, vLen);\n      this.addVertex(ia, ib, ic);\n      this.addColor(ia, ib, ic);\n      if (na !== void 0 && na !== \"\") {\n        const nLen = this.normals.length;\n        ia = this.parseNormalIndex(na, nLen);\n        ib = this.parseNormalIndex(nb, nLen);\n        ic = this.parseNormalIndex(nc, nLen);\n        this.addNormal(ia, ib, ic);\n      } else {\n        this.addFaceNormal(ia, ib, ic);\n      }\n      if (ua !== void 0 && ua !== \"\") {\n        const uvLen = this.uvs.length;\n        ia = this.parseUVIndex(ua, uvLen);\n        ib = this.parseUVIndex(ub, uvLen);\n        ic = this.parseUVIndex(uc, uvLen);\n        this.addUV(ia, ib, ic);\n        this.object.geometry.hasUVIndices = true;\n      } else {\n        this.addDefaultUV();\n      }\n    },\n    addPointGeometry: function(vertices) {\n      this.object.geometry.type = \"Points\";\n      const vLen = this.vertices.length;\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        const index = this.parseVertexIndex(vertices[vi], vLen);\n        this.addVertexPoint(index);\n        this.addColor(index);\n      }\n    },\n    addLineGeometry: function(vertices, uvs) {\n      this.object.geometry.type = \"Line\";\n      const vLen = this.vertices.length;\n      const uvLen = this.uvs.length;\n      for (let vi = 0, l = vertices.length; vi < l; vi++) {\n        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n      }\n      for (let uvi = 0, l = uvs.length; uvi < l; uvi++) {\n        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n      }\n    }\n  };\n  state.startObject(\"\", false);\n  return state;\n}\nclass OBJLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.materials = null;\n  }\n  load(url2, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url2, function(text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url2);\n      }\n    }, onProgress, onError);\n  }\n  setMaterials(materials) {\n    this.materials = materials;\n    return this;\n  }\n  parse(text) {\n    const state = new ParserState();\n    if (text.indexOf(\"\\r\\n\") !== -1) {\n      text = text.replace(/\\r\\n/g, \"\\n\");\n    }\n    if (text.indexOf(\"\\\\\\n\") !== -1) {\n      text = text.replace(/\\\\\\n/g, \"\");\n    }\n    const lines = text.split(\"\\n\");\n    let result = [];\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i].trimStart();\n      if (line.length === 0) continue;\n      const lineFirstChar = line.charAt(0);\n      if (lineFirstChar === \"#\") continue;\n      if (lineFirstChar === \"v\") {\n        const data = line.split(_face_vertex_data_separator_pattern);\n        switch (data[0]) {\n          case \"v\":\n            state.vertices.push(\n              parseFloat(data[1]),\n              parseFloat(data[2]),\n              parseFloat(data[3])\n            );\n            if (data.length >= 7) {\n              _color.setRGB(\n                parseFloat(data[4]),\n                parseFloat(data[5]),\n                parseFloat(data[6]),\n                SRGBColorSpace\n              );\n              state.colors.push(_color.r, _color.g, _color.b);\n            } else {\n              state.colors.push(void 0, void 0, void 0);\n            }\n            break;\n          case \"vn\":\n            state.normals.push(\n              parseFloat(data[1]),\n              parseFloat(data[2]),\n              parseFloat(data[3])\n            );\n            break;\n          case \"vt\":\n            state.uvs.push(\n              parseFloat(data[1]),\n              parseFloat(data[2])\n            );\n            break;\n        }\n      } else if (lineFirstChar === \"f\") {\n        const lineData = line.slice(1).trim();\n        const vertexData = lineData.split(_face_vertex_data_separator_pattern);\n        const faceVertices = [];\n        for (let j = 0, jl = vertexData.length; j < jl; j++) {\n          const vertex2 = vertexData[j];\n          if (vertex2.length > 0) {\n            const vertexParts = vertex2.split(\"/\");\n            faceVertices.push(vertexParts);\n          }\n        }\n        const v1 = faceVertices[0];\n        for (let j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n          const v2 = faceVertices[j];\n          const v3 = faceVertices[j + 1];\n          state.addFace(\n            v1[0],\n            v2[0],\n            v3[0],\n            v1[1],\n            v2[1],\n            v3[1],\n            v1[2],\n            v2[2],\n            v3[2]\n          );\n        }\n      } else if (lineFirstChar === \"l\") {\n        const lineParts = line.substring(1).trim().split(\" \");\n        let lineVertices = [];\n        const lineUVs = [];\n        if (line.indexOf(\"/\") === -1) {\n          lineVertices = lineParts;\n        } else {\n          for (let li = 0, llen = lineParts.length; li < llen; li++) {\n            const parts = lineParts[li].split(\"/\");\n            if (parts[0] !== \"\") lineVertices.push(parts[0]);\n            if (parts[1] !== \"\") lineUVs.push(parts[1]);\n          }\n        }\n        state.addLineGeometry(lineVertices, lineUVs);\n      } else if (lineFirstChar === \"p\") {\n        const lineData = line.slice(1).trim();\n        const pointData = lineData.split(\" \");\n        state.addPointGeometry(pointData);\n      } else if ((result = _object_pattern.exec(line)) !== null) {\n        const name = (\" \" + result[0].slice(1).trim()).slice(1);\n        state.startObject(name);\n      } else if (_material_use_pattern.test(line)) {\n        state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n      } else if (_material_library_pattern.test(line)) {\n        state.materialLibraries.push(line.substring(7).trim());\n      } else if (_map_use_pattern.test(line)) {\n        console.warn('THREE.OBJLoader: Rendering identifier \"usemap\" not supported. Textures must be defined in MTL files.');\n      } else if (lineFirstChar === \"s\") {\n        result = line.split(\" \");\n        if (result.length > 1) {\n          const value = result[1].trim().toLowerCase();\n          state.object.smooth = value !== \"0\" && value !== \"off\";\n        } else {\n          state.object.smooth = true;\n        }\n        const material = state.object.currentMaterial();\n        if (material) material.smooth = state.object.smooth;\n      } else {\n        if (line === \"\\0\") continue;\n        console.warn('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n      }\n    }\n    state.finalize();\n    const container = new Group();\n    container.materialLibraries = [].concat(state.materialLibraries);\n    const hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);\n    if (hasPrimitives === true) {\n      for (let i = 0, l = state.objects.length; i < l; i++) {\n        const object = state.objects[i];\n        const geometry = object.geometry;\n        const materials = object.materials;\n        const isLine = geometry.type === \"Line\";\n        const isPoints = geometry.type === \"Points\";\n        let hasVertexColors = false;\n        if (geometry.vertices.length === 0) continue;\n        const buffergeometry = new BufferGeometry();\n        buffergeometry.setAttribute(\"position\", new Float32BufferAttribute(geometry.vertices, 3));\n        if (geometry.normals.length > 0) {\n          buffergeometry.setAttribute(\"normal\", new Float32BufferAttribute(geometry.normals, 3));\n        }\n        if (geometry.colors.length > 0) {\n          hasVertexColors = true;\n          buffergeometry.setAttribute(\"color\", new Float32BufferAttribute(geometry.colors, 3));\n        }\n        if (geometry.hasUVIndices === true) {\n          buffergeometry.setAttribute(\"uv\", new Float32BufferAttribute(geometry.uvs, 2));\n        }\n        const createdMaterials = [];\n        for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n          const sourceMaterial = materials[mi];\n          const materialHash = sourceMaterial.name + \"_\" + sourceMaterial.smooth + \"_\" + hasVertexColors;\n          let material = state.materials[materialHash];\n          if (this.materials !== null) {\n            material = this.materials.create(sourceMaterial.name);\n            if (isLine && material && !(material instanceof LineBasicMaterial)) {\n              const materialLine = new LineBasicMaterial();\n              Material.prototype.copy.call(materialLine, material);\n              materialLine.color.copy(material.color);\n              material = materialLine;\n            } else if (isPoints && material && !(material instanceof PointsMaterial)) {\n              const materialPoints = new PointsMaterial({ size: 10, sizeAttenuation: false });\n              Material.prototype.copy.call(materialPoints, material);\n              materialPoints.color.copy(material.color);\n              materialPoints.map = material.map;\n              material = materialPoints;\n            }\n          }\n          if (material === void 0) {\n            if (isLine) {\n              material = new LineBasicMaterial();\n            } else if (isPoints) {\n              material = new PointsMaterial({ size: 1, sizeAttenuation: false });\n            } else {\n              material = new MeshPhongMaterial();\n            }\n            material.name = sourceMaterial.name;\n            material.flatShading = sourceMaterial.smooth ? false : true;\n            material.vertexColors = hasVertexColors;\n            state.materials[materialHash] = material;\n          }\n          createdMaterials.push(material);\n        }\n        let mesh;\n        if (createdMaterials.length > 1) {\n          for (let mi = 0, miLen = materials.length; mi < miLen; mi++) {\n            const sourceMaterial = materials[mi];\n            buffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n          }\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials);\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials);\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials);\n          }\n        } else {\n          if (isLine) {\n            mesh = new LineSegments(buffergeometry, createdMaterials[0]);\n          } else if (isPoints) {\n            mesh = new Points(buffergeometry, createdMaterials[0]);\n          } else {\n            mesh = new Mesh(buffergeometry, createdMaterials[0]);\n          }\n        }\n        mesh.name = object.name;\n        container.add(mesh);\n      }\n    } else {\n      if (state.vertices.length > 0) {\n        const material = new PointsMaterial({ size: 1, sizeAttenuation: false });\n        const buffergeometry = new BufferGeometry();\n        buffergeometry.setAttribute(\"position\", new Float32BufferAttribute(state.vertices, 3));\n        if (state.colors.length > 0 && state.colors[0] !== void 0) {\n          buffergeometry.setAttribute(\"color\", new Float32BufferAttribute(state.colors, 3));\n          material.vertexColors = true;\n        }\n        const points = new Points(buffergeometry, material);\n        container.add(points);\n      }\n    }\n    return container;\n  }\n}\nclass STLLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url2, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url2, function(text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url2);\n      }\n    }, onProgress, onError);\n  }\n  parse(data) {\n    function isBinary(data2) {\n      const reader = new DataView(data2);\n      const face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n      const n_faces = reader.getUint32(80, true);\n      const expect = 80 + 32 / 8 + n_faces * face_size;\n      if (expect === reader.byteLength) {\n        return true;\n      }\n      const solid = [115, 111, 108, 105, 100];\n      for (let off = 0; off < 5; off++) {\n        if (matchDataViewAt(solid, reader, off)) return false;\n      }\n      return true;\n    }\n    function matchDataViewAt(query, reader, offset) {\n      for (let i = 0, il = query.length; i < il; i++) {\n        if (query[i] !== reader.getUint8(offset + i)) return false;\n      }\n      return true;\n    }\n    function parseBinary(data2) {\n      const reader = new DataView(data2);\n      const faces = reader.getUint32(80, true);\n      let r, g, b, hasColors = false, colors;\n      let defaultR, defaultG, defaultB, alpha;\n      for (let index = 0; index < 80 - 10; index++) {\n        if (reader.getUint32(index, false) == 1129270351 && reader.getUint8(index + 4) == 82 && reader.getUint8(index + 5) == 61) {\n          hasColors = true;\n          colors = new Float32Array(faces * 3 * 3);\n          defaultR = reader.getUint8(index + 6) / 255;\n          defaultG = reader.getUint8(index + 7) / 255;\n          defaultB = reader.getUint8(index + 8) / 255;\n          alpha = reader.getUint8(index + 9) / 255;\n        }\n      }\n      const dataOffset = 84;\n      const faceLength = 12 * 4 + 2;\n      const geometry = new BufferGeometry();\n      const vertices = new Float32Array(faces * 3 * 3);\n      const normals = new Float32Array(faces * 3 * 3);\n      const color = new Color();\n      for (let face = 0; face < faces; face++) {\n        const start = dataOffset + face * faceLength;\n        const normalX = reader.getFloat32(start, true);\n        const normalY = reader.getFloat32(start + 4, true);\n        const normalZ = reader.getFloat32(start + 8, true);\n        if (hasColors) {\n          const packedColor = reader.getUint16(start + 48, true);\n          if ((packedColor & 32768) === 0) {\n            r = (packedColor & 31) / 31;\n            g = (packedColor >> 5 & 31) / 31;\n            b = (packedColor >> 10 & 31) / 31;\n          } else {\n            r = defaultR;\n            g = defaultG;\n            b = defaultB;\n          }\n        }\n        for (let i = 1; i <= 3; i++) {\n          const vertexstart = start + i * 12;\n          const componentIdx = face * 3 * 3 + (i - 1) * 3;\n          vertices[componentIdx] = reader.getFloat32(vertexstart, true);\n          vertices[componentIdx + 1] = reader.getFloat32(vertexstart + 4, true);\n          vertices[componentIdx + 2] = reader.getFloat32(vertexstart + 8, true);\n          normals[componentIdx] = normalX;\n          normals[componentIdx + 1] = normalY;\n          normals[componentIdx + 2] = normalZ;\n          if (hasColors) {\n            color.setRGB(r, g, b, SRGBColorSpace);\n            colors[componentIdx] = color.r;\n            colors[componentIdx + 1] = color.g;\n            colors[componentIdx + 2] = color.b;\n          }\n        }\n      }\n      geometry.setAttribute(\"position\", new BufferAttribute(vertices, 3));\n      geometry.setAttribute(\"normal\", new BufferAttribute(normals, 3));\n      if (hasColors) {\n        geometry.setAttribute(\"color\", new BufferAttribute(colors, 3));\n        geometry.hasColors = true;\n        geometry.alpha = alpha;\n      }\n      return geometry;\n    }\n    function parseASCII(data2) {\n      const geometry = new BufferGeometry();\n      const patternSolid = /solid([\\s\\S]*?)endsolid/g;\n      const patternFace = /facet([\\s\\S]*?)endfacet/g;\n      const patternName = /solid\\s(.+)/;\n      let faceCounter = 0;\n      const patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n      const patternVertex = new RegExp(\"vertex\" + patternFloat + patternFloat + patternFloat, \"g\");\n      const patternNormal = new RegExp(\"normal\" + patternFloat + patternFloat + patternFloat, \"g\");\n      const vertices = [];\n      const normals = [];\n      const groupNames = [];\n      const normal = new Vector3();\n      let result;\n      let groupCount = 0;\n      let startVertex = 0;\n      let endVertex = 0;\n      while ((result = patternSolid.exec(data2)) !== null) {\n        startVertex = endVertex;\n        const solid = result[0];\n        const name = (result = patternName.exec(solid)) !== null ? result[1] : \"\";\n        groupNames.push(name);\n        while ((result = patternFace.exec(solid)) !== null) {\n          let vertexCountPerFace = 0;\n          let normalCountPerFace = 0;\n          const text = result[0];\n          while ((result = patternNormal.exec(text)) !== null) {\n            normal.x = parseFloat(result[1]);\n            normal.y = parseFloat(result[2]);\n            normal.z = parseFloat(result[3]);\n            normalCountPerFace++;\n          }\n          while ((result = patternVertex.exec(text)) !== null) {\n            vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n            normals.push(normal.x, normal.y, normal.z);\n            vertexCountPerFace++;\n            endVertex++;\n          }\n          if (normalCountPerFace !== 1) {\n            console.error(\"THREE.STLLoader: Something isn't right with the normal of face number \" + faceCounter);\n          }\n          if (vertexCountPerFace !== 3) {\n            console.error(\"THREE.STLLoader: Something isn't right with the vertices of face number \" + faceCounter);\n          }\n          faceCounter++;\n        }\n        const start = startVertex;\n        const count = endVertex - startVertex;\n        geometry.userData.groupNames = groupNames;\n        geometry.addGroup(start, count, groupCount);\n        groupCount++;\n      }\n      geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n      geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n      return geometry;\n    }\n    function ensureString(buffer) {\n      if (typeof buffer !== \"string\") {\n        return new TextDecoder().decode(buffer);\n      }\n      return buffer;\n    }\n    function ensureBinary(buffer) {\n      if (typeof buffer === \"string\") {\n        const array_buffer = new Uint8Array(buffer.length);\n        for (let i = 0; i < buffer.length; i++) {\n          array_buffer[i] = buffer.charCodeAt(i) & 255;\n        }\n        return array_buffer.buffer || array_buffer;\n      } else {\n        return buffer;\n      }\n    }\n    const binData = ensureBinary(data);\n    return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));\n  }\n}\nvar __defProp$f = Object.defineProperty;\nvar __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$f = (obj, key, value) => __defNormalProp$f(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass LoaderManager {\n  constructor(modelManager, eventManager) {\n    __publicField$f(this, \"gltfLoader\");\n    __publicField$f(this, \"objLoader\");\n    __publicField$f(this, \"mtlLoader\");\n    __publicField$f(this, \"fbxLoader\");\n    __publicField$f(this, \"stlLoader\");\n    __publicField$f(this, \"modelManager\");\n    __publicField$f(this, \"eventManager\");\n    this.modelManager = modelManager;\n    this.eventManager = eventManager;\n    this.gltfLoader = new GLTFLoader();\n    this.objLoader = new OBJLoader();\n    this.mtlLoader = new MTLLoader();\n    this.fbxLoader = new FBXLoader();\n    this.stlLoader = new STLLoader();\n  }\n  init() {\n  }\n  dispose() {\n  }\n  async loadModel(url2, originalFileName) {\n    var _a2, _b2, _c;\n    try {\n      this.eventManager.emitEvent(\"modelLoadingStart\", null);\n      this.modelManager.clearModel();\n      this.modelManager.originalURL = url2;\n      let fileExtension;\n      if (originalFileName) {\n        fileExtension = (_a2 = originalFileName.split(\".\").pop()) == null ? void 0 : _a2.toLowerCase();\n        this.modelManager.originalFileName = ((_b2 = originalFileName.split(\"/\").pop()) == null ? void 0 : _b2.split(\".\")[0]) || \"model\";\n      } else {\n        const filename = new URLSearchParams(url2.split(\"?\")[1]).get(\"filename\");\n        fileExtension = (_c = filename == null ? void 0 : filename.split(\".\").pop()) == null ? void 0 : _c.toLowerCase();\n        if (filename) {\n          this.modelManager.originalFileName = filename.split(\".\")[0] || \"model\";\n        } else {\n          this.modelManager.originalFileName = \"model\";\n        }\n      }\n      if (!fileExtension) {\n        useToastStore().addAlert(t(\"toastMessages.couldNotDetermineFileType\"));\n        return;\n      }\n      let model = await this.loadModelInternal(url2, fileExtension);\n      if (model) {\n        await this.modelManager.setupModel(model);\n      }\n      this.eventManager.emitEvent(\"modelLoadingEnd\", null);\n    } catch (error) {\n      this.eventManager.emitEvent(\"modelLoadingEnd\", null);\n      console.error(\"Error loading model:\", error);\n      useToastStore().addAlert(t(\"toastMessages.errorLoadingModel\"));\n    }\n  }\n  async loadModelInternal(url2, fileExtension) {\n    let model = null;\n    const params = new URLSearchParams(url2.split(\"?\")[1]);\n    const filename = params.get(\"filename\");\n    if (!filename) {\n      console.error(\"Missing filename in URL:\", url2);\n      return null;\n    }\n    const loadRootFolder = params.get(\"type\") === \"output\" ? \"output\" : \"input\";\n    const subfolder = params.get(\"subfolder\") ?? \"\";\n    const path = \"api/view?type=\" + loadRootFolder + \"&subfolder=\" + encodeURIComponent(subfolder) + \"&filename=\";\n    switch (fileExtension) {\n      case \"stl\":\n        this.stlLoader.setPath(path);\n        const geometry = await this.stlLoader.loadAsync(filename);\n        this.modelManager.setOriginalModel(geometry);\n        geometry.computeVertexNormals();\n        const mesh = new Mesh(\n          geometry,\n          this.modelManager.standardMaterial\n        );\n        const group = new Group();\n        group.add(mesh);\n        model = group;\n        break;\n      case \"fbx\":\n        this.fbxLoader.setPath(path);\n        const fbxModel = await this.fbxLoader.loadAsync(filename);\n        this.modelManager.setOriginalModel(fbxModel);\n        model = fbxModel;\n        fbxModel.traverse((child) => {\n          if (child instanceof Mesh) {\n            this.modelManager.originalMaterials.set(child, child.material);\n          }\n        });\n        break;\n      case \"obj\":\n        if (this.modelManager.materialMode === \"original\") {\n          try {\n            this.mtlLoader.setPath(path);\n            const mtlFileName = filename.replace(/\\.obj$/, \".mtl\");\n            const materials = await this.mtlLoader.loadAsync(mtlFileName);\n            materials.preload();\n            this.objLoader.setMaterials(materials);\n          } catch (e) {\n            console.log(\n              \"No MTL file found or error loading it, continuing without materials\"\n            );\n          }\n        }\n        this.objLoader.setPath(path);\n        model = await this.objLoader.loadAsync(filename);\n        model.traverse((child) => {\n          if (child instanceof Mesh) {\n            this.modelManager.originalMaterials.set(child, child.material);\n          }\n        });\n        break;\n      case \"gltf\":\n      case \"glb\":\n        this.gltfLoader.setPath(path);\n        const gltf = await this.gltfLoader.loadAsync(filename);\n        this.modelManager.setOriginalModel(gltf);\n        model = gltf.scene;\n        gltf.scene.traverse((child) => {\n          if (child instanceof Mesh) {\n            child.geometry.computeVertexNormals();\n            this.modelManager.originalMaterials.set(child, child.material);\n          }\n        });\n        break;\n    }\n    return model;\n  }\n}\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: [\n    \"byte\",\n    \"byte normalized\",\n    \"unsigned byte\",\n    \"unsigned byte normalized\",\n    \"short\",\n    \"short normalized\",\n    \"unsigned short\",\n    \"unsigned short normalized\"\n  ],\n  NORMAL: [\n    \"byte normalized\",\n    \"short normalized\"\n  ],\n  TANGENT: [\n    \"byte normalized\",\n    \"short normalized\"\n  ],\n  TEXCOORD: [\n    \"byte\",\n    \"byte normalized\",\n    \"unsigned byte\",\n    \"short\",\n    \"short normalized\",\n    \"unsigned short\"\n  ]\n};\nclass GLTFExporter {\n  constructor() {\n    this.textureUtils = null;\n    this.pluginCallbacks = [];\n    this.register(function(writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsUnlitExtension2(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsTransmissionExtension2(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsVolumeExtension2(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsIorExtension2(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsSpecularExtension2(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsClearcoatExtension2(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsDispersionExtension2(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsIridescenceExtension2(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsSheenExtension2(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsAnisotropyExtension2(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension2(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMaterialsBumpExtension2(writer);\n    });\n    this.register(function(writer) {\n      return new GLTFMeshGpuInstancing2(writer);\n    });\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  setTextureUtils(utils) {\n    this.textureUtils = utils;\n    return this;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Function} onError  Callback on errors\n   * @param  {Object} options options\n   */\n  parse(input, onDone, onError, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n    writer.setPlugins(plugins);\n    writer.setTextureUtils(this.textureUtils);\n    writer.writeAsync(input, onDone, options).catch(onError);\n  }\n  parseAsync(input, options) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.parse(input, resolve, reject, options);\n    });\n  }\n}\nconst WEBGL_CONSTANTS = {\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  ARRAY_BUFFER: 34962,\n  ELEMENT_ARRAY_BUFFER: 34963,\n  NEAREST: 9728,\n  LINEAR: 9729,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR_MIPMAP_NEAREST: 9985,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst KHR_MESH_QUANTIZATION = \"KHR_mesh_quantization\";\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  position: \"translation\",\n  quaternion: \"rotation\",\n  morphTargetInfluences: \"weights\"\n};\nconst DEFAULT_SPECULAR_COLOR = new Color();\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 1179937895;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 1313821514;\nconst GLB_CHUNK_TYPE_BIN = 5130562;\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function(element, index) {\n    return element === array2[index];\n  });\n}\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n      if (attribute.itemSize > 4) {\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);\n        else if (a === 1) value = attribute.getY(i);\n        else if (a === 2) value = attribute.getZ(i);\n        else if (a === 3) value = attribute.getW(i);\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === \"undefined\" && typeof OffscreenCanvas !== \"undefined\") {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement(\"canvas\");\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (canvas.toBlob !== void 0) {\n    return new Promise((resolve) => canvas.toBlob(resolve, mimeType));\n  }\n  let quality;\n  if (mimeType === \"image/jpeg\") {\n    quality = 0.92;\n  } else if (mimeType === \"image/webp\") {\n    quality = 0.8;\n  }\n  return canvas.convertToBlob({\n    type: mimeType,\n    quality\n  });\n}\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = /* @__PURE__ */ new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = /* @__PURE__ */ new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: \"2.0\",\n        generator: \"THREE.GLTFExporter r\" + REVISION\n      }\n    };\n    this.cache = {\n      meshes: /* @__PURE__ */ new Map(),\n      attributes: /* @__PURE__ */ new Map(),\n      attributesNormalized: /* @__PURE__ */ new Map(),\n      materials: /* @__PURE__ */ new Map(),\n      textures: /* @__PURE__ */ new Map(),\n      images: /* @__PURE__ */ new Map()\n    };\n    this.textureUtils = null;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  setTextureUtils(utils) {\n    this.textureUtils = utils;\n  }\n  /**\n   * Parse scenes and generate GLTF output\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n   * @param  {Function} onDone  Callback on completed\n   * @param  {Object} options options\n   */\n  async writeAsync(input, onDone, options = {}) {\n    this.options = Object.assign({\n      // default options\n      binary: false,\n      trs: false,\n      onlyVisible: true,\n      maxTextureSize: Infinity,\n      animations: [],\n      includeCustomExtensions: false\n    }, options);\n    if (this.options.animations.length > 0) {\n      this.options.trs = true;\n    }\n    await this.processInputAsync(input);\n    await Promise.all(this.pending);\n    const writer = this;\n    const buffers = writer.buffers;\n    const json = writer.json;\n    options = writer.options;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionsRequired = writer.extensionsRequired;\n    const blob2 = new Blob(buffers, { type: \"application/octet-stream\" });\n    const extensionsUsedList = Object.keys(extensionsUsed);\n    const extensionsRequiredList = Object.keys(extensionsRequired);\n    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;\n    if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList;\n    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob2.size;\n    if (options.binary === true) {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob2);\n      reader.onloadend = function() {\n        const binaryChunk = getPaddedArrayBuffer(reader.result);\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 32);\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n        const header = new ArrayBuffer(GLB_HEADER_BYTES);\n        const headerView = new DataView(header);\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n        headerView.setUint32(4, GLB_VERSION, true);\n        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n        headerView.setUint32(8, totalByteLength, true);\n        const glbBlob = new Blob([\n          header,\n          jsonChunkPrefix,\n          jsonChunk,\n          binaryChunkPrefix,\n          binaryChunk\n        ], { type: \"application/octet-stream\" });\n        const glbReader = new FileReader();\n        glbReader.readAsArrayBuffer(glbBlob);\n        glbReader.onloadend = function() {\n          onDone(glbReader.result);\n        };\n      };\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        const reader = new FileReader();\n        reader.readAsDataURL(blob2);\n        reader.onloadend = function() {\n          const base64data = reader.result;\n          json.buffers[0].uri = base64data;\n          onDone(json);\n        };\n      } else {\n        onDone(json);\n      }\n    }\n  }\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === void 0) objectDef.extensions = {};\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n        delete json.gltfExtensions;\n      }\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' won't be serialized because of JSON.stringify error - \" + error.message);\n    }\n  }\n  /**\n   * Returns ids for buffer attributes.\n   * @param  {Object} object\n   * @return {Integer}\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids2 = /* @__PURE__ */ new Map();\n      uids2.set(true, this.uid++);\n      uids2.set(false, this.uid++);\n      this.uids.set(attribute, uids2);\n    }\n    const uids = this.uids.get(attribute);\n    return uids.get(isRelativeCopy);\n  }\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {Boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache2 = this.cache;\n    if (cache2.attributesNormalized.has(normal)) return false;\n    const v = new Vector3();\n    for (let i = 0, il = normal.count; i < il; i++) {\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4) return false;\n    }\n    return true;\n  }\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache2 = this.cache;\n    if (cache2.attributesNormalized.has(normal)) return cache2.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        v.setX(1);\n      } else {\n        v.normalize();\n      }\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n    cache2.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions[\"KHR_texture_transform\"] = transformDef;\n      this.extensionsUsed[\"KHR_texture_transform\"] = true;\n    }\n  }\n  async buildMetalRoughTextureAsync(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap) return metalnessMap;\n    function getEncodingConversion(map) {\n      if (map.colorSpace === SRGBColorSpace) {\n        return function SRGBToLinear2(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n        };\n      }\n      return function LinearToLinear(c) {\n        return c;\n      };\n    }\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = await this.decompressTextureAsync(metalnessMap);\n    }\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = await this.decompressTextureAsync(roughnessMap);\n    }\n    const metalness = metalnessMap ? metalnessMap.image : null;\n    const roughness = roughnessMap ? roughnessMap.image : null;\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n    const canvas = getCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    context.fillStyle = \"#00ffff\";\n    context.fillRect(0, 0, width, height);\n    const composite = context.getImageData(0, 0, width, height);\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height);\n      const convert = getEncodingConversion(metalnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height);\n      const convert = getEncodingConversion(roughnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    context.putImageData(composite, 0, 0);\n    const reference = metalnessMap || roughnessMap;\n    const texture = reference.clone();\n    texture.source = new Source(canvas);\n    texture.colorSpace = NoColorSpace;\n    texture.channel = (metalnessMap || roughnessMap).channel;\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn(\"THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.\");\n    }\n    console.warn(\"THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.\");\n    return texture;\n  }\n  async decompressTextureAsync(texture, maxTextureSize = Infinity) {\n    if (this.textureUtils === null) {\n      throw new Error(\"THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.\");\n    }\n    return await this.textureUtils.decompress(texture, maxTextureSize);\n  }\n  /**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers) json.buffers = [{ byteLength: 0 }];\n    buffers.push(buffer);\n    return 0;\n  }\n  /**\n   * Process and generate a BufferView\n   * @param  {BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    let componentSize;\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1;\n        break;\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2;\n        break;\n      default:\n        componentSize = 4;\n    }\n    let byteStride = attribute.itemSize * componentSize;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      byteStride = Math.ceil(byteStride / 4) * 4;\n    }\n    const byteLength = getPaddedBufferSize(count * byteStride);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n        if (attribute.itemSize > 4) {\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);\n          else if (a === 1) value = attribute.getY(i);\n          else if (a === 2) value = attribute.getZ(i);\n          else if (a === 3) value = attribute.getW(i);\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array);\n          }\n        }\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n        offset += componentSize;\n      }\n      if (offset % byteStride !== 0) {\n        offset += byteStride - offset % byteStride;\n      }\n    }\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength\n    };\n    if (target !== void 0) bufferViewDef.target = target;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      bufferViewDef.byteStride = byteStride;\n    }\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef);\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n  processBufferViewImage(blob2) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    return new Promise(function(resolve) {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob2);\n      reader.onloadend = function() {\n        const buffer = getPaddedArrayBuffer(reader.result);\n        const bufferViewDef = {\n          buffer: writer.processBuffer(buffer),\n          byteOffset: writer.byteOffset,\n          byteLength: buffer.byteLength\n        };\n        writer.byteOffset += buffer.byteLength;\n        resolve(json.bufferViews.push(bufferViewDef) - 1);\n      };\n    });\n  }\n  /**\n   * Process attribute to generate an accessor\n   * @param  {BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json;\n    const types = {\n      1: \"SCALAR\",\n      2: \"VEC2\",\n      3: \"VEC3\",\n      4: \"VEC4\",\n      9: \"MAT3\",\n      16: \"MAT4\"\n    };\n    let componentType;\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error(\"THREE.GLTFExporter: Unsupported bufferAttribute component type: \" + attribute.array.constructor.name);\n    }\n    if (start === void 0) start = 0;\n    if (count === void 0 || count === Infinity) count = attribute.count;\n    if (count === 0) return null;\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget;\n    if (geometry !== void 0) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType,\n      count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize]\n    };\n    if (attribute.normalized === true) accessorDef.normalized = true;\n    if (!json.accessors) json.accessors = [];\n    return json.accessors.push(accessorDef) - 1;\n  }\n  /**\n   * Process image\n   * @param  {Image} image to process\n   * @param  {Integer} format of the image (RGBAFormat)\n   * @param  {Boolean} flipY before writing out the image\n   * @param  {String} mimeType export format\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = \"image/png\") {\n    if (image !== null) {\n      const writer = this;\n      const cache2 = writer.cache;\n      const json = writer.json;\n      const options = writer.options;\n      const pending = writer.pending;\n      if (!cache2.images.has(image)) cache2.images.set(image, {});\n      const cachedImages = cache2.images.get(image);\n      const key = mimeType + \":flipY/\" + flipY.toString();\n      if (cachedImages[key] !== void 0) return cachedImages[key];\n      if (!json.images) json.images = [];\n      const imageDef = { mimeType };\n      const canvas = getCanvas();\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext(\"2d\", {\n        willReadFrequently: true\n      });\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n      if (image.data !== void 0) {\n        if (format !== RGBAFormat) {\n          console.error(\"GLTFExporter: Only RGBAFormat is supported.\", format);\n        }\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn(\"GLTFExporter: Image size is bigger than maxTextureSize\", image);\n        }\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0];\n          data[i + 1] = image.data[i + 1];\n          data[i + 2] = image.data[i + 2];\n          data[i + 3] = image.data[i + 3];\n        }\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      } else {\n        if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap || typeof OffscreenCanvas !== \"undefined\" && image instanceof OffscreenCanvas) {\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        } else {\n          throw new Error(\"THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.\");\n        }\n      }\n      if (options.binary === true) {\n        pending.push(\n          getToBlobPromise(canvas, mimeType).then((blob2) => writer.processBufferViewImage(blob2)).then((bufferViewIndex) => {\n            imageDef.bufferView = bufferViewIndex;\n          })\n        );\n      } else {\n        if (canvas.toDataURL !== void 0) {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        } else {\n          pending.push(\n            getToBlobPromise(canvas, mimeType).then((blob2) => new FileReader().readAsDataURL(blob2)).then((dataURL) => {\n              imageDef.uri = dataURL;\n            })\n          );\n        }\n      }\n      const index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    } else {\n      throw new Error(\"THREE.GLTFExporter: No valid image data found. Unable to process texture.\");\n    }\n  }\n  /**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers) json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n  /**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer} Index of the processed texture in the \"textures\" array\n   */\n  async processTextureAsync(map) {\n    const writer = this;\n    const options = writer.options;\n    const cache2 = this.cache;\n    const json = this.json;\n    if (cache2.textures.has(map)) return cache2.textures.get(map);\n    if (!json.textures) json.textures = [];\n    if (map instanceof CompressedTexture) {\n      map = await this.decompressTextureAsync(map, options.maxTextureSize);\n    }\n    let mimeType = map.userData.mimeType;\n    if (mimeType === \"image/webp\") mimeType = \"image/png\";\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType)\n    };\n    if (map.name) textureDef.name = map.name;\n    await this._invokeAllAsync(async function(ext2) {\n      ext2.writeTexture && await ext2.writeTexture(map, textureDef);\n    });\n    const index = json.textures.push(textureDef) - 1;\n    cache2.textures.set(map, index);\n    return index;\n  }\n  /**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\n   */\n  async processMaterialAsync(material) {\n    const cache2 = this.cache;\n    const json = this.json;\n    if (cache2.materials.has(material)) return cache2.materials.get(material);\n    if (material.isShaderMaterial) {\n      console.warn(\"GLTFExporter: THREE.ShaderMaterial not supported.\");\n      return null;\n    }\n    if (!json.materials) json.materials = [];\n    const materialDef = { pbrMetallicRoughness: {} };\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn(\"GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.\");\n    }\n    const color = material.color.toArray().concat([material.opacity]);\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 1;\n    }\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = await this.buildMetalRoughTextureAsync(material.metalnessMap, material.roughnessMap);\n      const metalRoughMapDef = {\n        index: await this.processTextureAsync(metalRoughTexture),\n        texCoord: metalRoughTexture.channel\n      };\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n    }\n    if (material.map) {\n      const baseColorMapDef = {\n        index: await this.processTextureAsync(material.map),\n        texCoord: material.map.channel\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n    if (material.emissive) {\n      const emissive = material.emissive;\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray();\n      }\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: await this.processTextureAsync(material.emissiveMap),\n          texCoord: material.emissiveMap.channel\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    }\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: await this.processTextureAsync(material.normalMap),\n        texCoord: material.normalMap.channel\n      };\n      if (material.normalScale && material.normalScale.x !== 1) {\n        normalMapDef.scale = material.normalScale.x;\n      }\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    }\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: await this.processTextureAsync(material.aoMap),\n        texCoord: material.aoMap.channel\n      };\n      if (material.aoMapIntensity !== 1) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    }\n    if (material.transparent) {\n      materialDef.alphaMode = \"BLEND\";\n    } else {\n      if (material.alphaTest > 0) {\n        materialDef.alphaMode = \"MASK\";\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    }\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== \"\") materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n    await this._invokeAllAsync(async function(ext2) {\n      ext2.writeMaterialAsync && await ext2.writeMaterialAsync(material, materialDef);\n    });\n    const index = json.materials.push(materialDef) - 1;\n    cache2.materials.set(material, index);\n    return index;\n  }\n  /**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n   */\n  async processMeshAsync(mesh) {\n    const cache2 = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n    const meshCacheKey = meshCacheKeyParts.join(\":\");\n    if (cache2.meshes.has(meshCacheKey)) return cache2.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode;\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = [];\n    const nameConversion = {\n      uv: \"TEXCOORD_0\",\n      uv1: \"TEXCOORD_1\",\n      uv2: \"TEXCOORD_2\",\n      uv3: \"TEXCOORD_3\",\n      color: \"COLOR_0\",\n      skinWeight: \"WEIGHTS_0\",\n      skinIndex: \"JOINTS_0\"\n    };\n    const originalNormal = geometry.getAttribute(\"normal\");\n    if (originalNormal !== void 0 && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn(\"THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.\");\n      geometry.setAttribute(\"normal\", this.createNormalizedNormalAttribute(originalNormal));\n    }\n    let modifiedAttribute = null;\n    for (let attributeName in geometry.attributes) {\n      if (attributeName.slice(0, 5) === \"morph\") continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName)) attributeName = \"_\" + attributeName;\n      if (cache2.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache2.attributes.get(this.getUID(attribute));\n        continue;\n      }\n      modifiedAttribute = null;\n      const array = attribute.array;\n      if (attributeName === \"JOINTS_0\" && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      } else if ((array instanceof Uint32Array || array instanceof Int32Array) && !attributeName.startsWith(\"_\")) {\n        console.warn(`GLTFExporter: Attribute \"${attributeName}\" converted to type FLOAT.`);\n        modifiedAttribute = GLTFExporter.Utils.toFloat32BufferAttribute(attribute);\n      }\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n      if (accessor !== null) {\n        if (!attributeName.startsWith(\"_\")) {\n          this.detectMeshQuantization(attributeName, attribute);\n        }\n        attributes[attributeName] = accessor;\n        cache2.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n    if (originalNormal !== void 0) geometry.setAttribute(\"normal\", originalNormal);\n    if (Object.keys(attributes).length === 0) return null;\n    if (mesh.morphTargetInfluences !== void 0 && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n      if (mesh.morphTargetDictionary !== void 0) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n        for (const attributeName in geometry.morphAttributes) {\n          if (attributeName !== \"position\" && attributeName !== \"normal\") {\n            if (!warned) {\n              console.warn(\"GLTFExporter: Only POSITION and NORMAL morph are supported.\");\n              warned = true;\n            }\n            continue;\n          }\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase();\n          const baseAttribute = geometry.attributes[attributeName];\n          if (cache2.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache2.attributes.get(this.getUID(attribute, true));\n            continue;\n          }\n          const relativeAttribute = attribute.clone();\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0) relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));\n                if (a === 1) relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));\n                if (a === 2) relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));\n                if (a === 3) relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));\n              }\n            }\n          }\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n          cache2.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n        }\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== void 0) targetNames.push(reverseDictionary[i]);\n      }\n      meshDef.weights = weights;\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n    let didForceIndices = false;\n    if (isMultiMaterial && geometry.index === null) {\n      const indices = [];\n      for (let i = 0, il = geometry.attributes.position.count; i < il; i++) {\n        indices[i] = i;\n      }\n      geometry.setIndex(indices);\n      didForceIndices = true;\n    }\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode,\n        attributes\n      };\n      this.serializeUserData(geometry, primitive);\n      if (targets.length > 0) primitive.targets = targets;\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n        if (groups[i].start !== void 0 || groups[i].count !== void 0) {\n          cacheKey += \":\" + groups[i].start + \":\" + groups[i].count;\n        }\n        if (cache2.attributes.has(cacheKey)) {\n          primitive.indices = cache2.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache2.attributes.set(cacheKey, primitive.indices);\n        }\n        if (primitive.indices === null) delete primitive.indices;\n      }\n      const material = await this.processMaterialAsync(materials[groups[i].materialIndex]);\n      if (material !== null) primitive.material = material;\n      primitives.push(primitive);\n    }\n    if (didForceIndices === true) {\n      geometry.setIndex(null);\n    }\n    meshDef.primitives = primitives;\n    if (!json.meshes) json.meshes = [];\n    await this._invokeAllAsync(function(ext2) {\n      ext2.writeMesh && ext2.writeMesh(mesh, meshDef);\n    });\n    const index = json.meshes.push(meshDef) - 1;\n    cache2.meshes.set(meshCacheKey, index);\n    return index;\n  }\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return;\n    let attrType = void 0;\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = \"byte\";\n        break;\n      case Uint8Array:\n        attrType = \"unsigned byte\";\n        break;\n      case Int16Array:\n        attrType = \"short\";\n        break;\n      case Uint16Array:\n        attrType = \"unsigned short\";\n        break;\n      default:\n        return;\n    }\n    if (attribute.normalized) attrType += \" normalized\";\n    const attrNamePrefix = attributeName.split(\"_\", 1)[0];\n    if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n    }\n  }\n  /**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras) json.cameras = [];\n    const isOrtho = camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? \"orthographic\" : \"perspective\"\n    };\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 1e-3 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    }\n    if (camera.name !== \"\") cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number|null}\n   */\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations) json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n      if (trackBinding.objectName === \"bones\") {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = void 0;\n        }\n      }\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        continue;\n      }\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n      let interpolation;\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = \"CUBICSPLINE\";\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = \"STEP\";\n      } else {\n        interpolation = \"LINEAR\";\n      }\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n    json.animations.push({\n      name: clip.name || \"clip_\" + json.animations.length,\n      samplers,\n      channels\n    });\n    return json.animations.length - 1;\n  }\n  /**\n   * @param {THREE.Object3D} object\n   * @return {number|null}\n   */\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    const node = json.nodes[nodeMap.get(object)];\n    const skeleton = object.skeleton;\n    if (skeleton === void 0) return null;\n    const rootJoint = object.skeleton.bones[0];\n    if (rootJoint === void 0) return null;\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n    }\n    if (json.skins === void 0) json.skins = [];\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints,\n      skeleton: nodeMap.get(rootJoint)\n    });\n    const skinIndex = node.skin = json.skins.length - 1;\n    return skinIndex;\n  }\n  /**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNodeAsync\n   * @return {Integer} Index of the node in the nodes list\n   */\n  async processNodeAsync(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes) json.nodes = [];\n    const nodeDef = {};\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    }\n    if (object.name !== \"\") nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = await this.processMeshAsync(object);\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n    if (object.isSkinnedMesh) this.skins.push(object);\n    if (object.children.length > 0) {\n      const children = [];\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          const nodeIndex2 = await this.processNodeAsync(child);\n          if (nodeIndex2 !== null) children.push(nodeIndex2);\n        }\n      }\n      if (children.length > 0) nodeDef.children = children;\n    }\n    await this._invokeAllAsync(function(ext2) {\n      ext2.writeNode && ext2.writeNode(object, nodeDef);\n    });\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    return nodeIndex;\n  }\n  /**\n   * Process Scene\n   * @param  {Scene} node Scene to process\n   */\n  async processSceneAsync(scene) {\n    const json = this.json;\n    const options = this.options;\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n    const sceneDef = {};\n    if (scene.name !== \"\") sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = await this.processNodeAsync(child);\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n  async processObjectsAsync(objects) {\n    const scene = new Scene();\n    scene.name = \"AuxScene\";\n    for (let i = 0; i < objects.length; i++) {\n      scene.children.push(objects[i]);\n    }\n    await this.processSceneAsync(scene);\n  }\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  async processInputAsync(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n    await this._invokeAllAsync(function(ext2) {\n      ext2.beforeParse && ext2.beforeParse(input);\n    });\n    const objectsWithoutScene = [];\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        await this.processSceneAsync(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n    if (objectsWithoutScene.length > 0) {\n      await this.processObjectsAsync(objectsWithoutScene);\n    }\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n    await this._invokeAllAsync(function(ext2) {\n      ext2.afterParse && ext2.afterParse(input);\n    });\n  }\n  async _invokeAllAsync(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      await func(this.plugins[i]);\n    }\n  }\n}\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_lights_punctual\";\n  }\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn(\"THREE.GLTFExporter: Only directional, point, and spot lights are supported.\", light);\n      return;\n    }\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name) lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n    if (light.isDirectionalLight) {\n      lightDef.type = \"directional\";\n    } else if (light.isPointLight) {\n      lightDef.type = \"point\";\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = \"spot\";\n      if (light.distance > 0) lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (1 - light.penumbra) * light.angle;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n    if (light.decay !== void 0 && light.decay !== 2) {\n      console.warn(\"THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2.\");\n    }\n    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn(\"THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.\");\n    }\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = { lights: [] };\n      extensionsUsed[this.name] = true;\n    }\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = { light: lights.length - 1 };\n  }\n}\nclass GLTFMaterialsUnlitExtension2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_unlit\";\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n}\nclass GLTFMaterialsClearcoatExtension2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_clearcoat\";\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.clearcoatFactor = material.clearcoat;\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: await writer.processTextureAsync(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel\n      };\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n      extensionDef.clearcoatTexture = clearcoatMapDef;\n    }\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: await writer.processTextureAsync(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel\n      };\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n    }\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: await writer.processTextureAsync(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel\n      };\n      if (material.clearcoatNormalScale.x !== 1) clearcoatNormalMapDef.scale = material.clearcoatNormalScale.x;\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsDispersionExtension2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_dispersion\";\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.dispersion === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.dispersion = material.dispersion;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIridescenceExtension2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_iridescence\";\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.iridescenceFactor = material.iridescence;\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: await writer.processTextureAsync(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel\n      };\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n      extensionDef.iridescenceTexture = iridescenceMapDef;\n    }\n    extensionDef.iridescenceIor = material.iridescenceIOR;\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: await writer.processTextureAsync(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel\n      };\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsTransmissionExtension2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_transmission\";\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: await writer.processTextureAsync(material.transmissionMap),\n        texCoord: material.transmissionMap.channel\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsVolumeExtension2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_volume\";\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thicknessFactor = material.thickness;\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: await writer.processTextureAsync(material.thicknessMap),\n        texCoord: material.thicknessMap.channel\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n    if (material.attenuationDistance !== Infinity) {\n      extensionDef.attenuationDistance = material.attenuationDistance;\n    }\n    extensionDef.attenuationColor = material.attenuationColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsIorExtension2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_ior\";\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.ior = material.ior;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSpecularExtension2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_specular\";\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorMap) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: await writer.processTextureAsync(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel\n      };\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n      extensionDef.specularTexture = specularIntensityMapDef;\n    }\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: await writer.processTextureAsync(material.specularColorMap),\n        texCoord: material.specularColorMap.channel\n      };\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n      extensionDef.specularColorTexture = specularColorMapDef;\n    }\n    extensionDef.specularFactor = material.specularIntensity;\n    extensionDef.specularColorFactor = material.specularColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsSheenExtension2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_sheen\";\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: await writer.processTextureAsync(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel\n      };\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n    }\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: await writer.processTextureAsync(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel\n      };\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n      extensionDef.sheenColorTexture = sheenColorMapDef;\n    }\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n    extensionDef.sheenColorFactor = material.sheenColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsAnisotropyExtension2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_anisotropy\";\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = { index: await writer.processTextureAsync(material.anisotropyMap) };\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n      extensionDef.anisotropyTexture = anisotropyMapDef;\n    }\n    extensionDef.anisotropyStrength = material.anisotropy;\n    extensionDef.anisotropyRotation = material.anisotropyRotation;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsEmissiveStrengthExtension2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"KHR_materials_emissive_strength\";\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.emissiveStrength = material.emissiveIntensity;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMaterialsBumpExtension2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"EXT_materials_bump\";\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.bumpScale === 1 && !material.bumpMap) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.bumpMap) {\n      const bumpMapDef = {\n        index: await writer.processTextureAsync(material.bumpMap),\n        texCoord: material.bumpMap.channel\n      };\n      writer.applyTextureTransform(bumpMapDef, material.bumpMap);\n      extensionDef.bumpTexture = bumpMapDef;\n    }\n    extensionDef.bumpFactor = material.bumpScale;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\nclass GLTFMeshGpuInstancing2 {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = \"EXT_mesh_gpu_instancing\";\n  }\n  writeNode(object, nodeDef) {\n    if (!object.isInstancedMesh) return;\n    const writer = this.writer;\n    const mesh = object;\n    const translationAttr = new Float32Array(mesh.count * 3);\n    const rotationAttr = new Float32Array(mesh.count * 4);\n    const scaleAttr = new Float32Array(mesh.count * 3);\n    const matrix = new Matrix4();\n    const position = new Vector3();\n    const quaternion = new Quaternion();\n    const scale = new Vector3();\n    for (let i = 0; i < mesh.count; i++) {\n      mesh.getMatrixAt(i, matrix);\n      matrix.decompose(position, quaternion, scale);\n      position.toArray(translationAttr, i * 3);\n      quaternion.toArray(rotationAttr, i * 4);\n      scale.toArray(scaleAttr, i * 3);\n    }\n    const attributes = {\n      TRANSLATION: writer.processAccessor(new BufferAttribute(translationAttr, 3)),\n      ROTATION: writer.processAccessor(new BufferAttribute(rotationAttr, 4)),\n      SCALE: writer.processAccessor(new BufferAttribute(scaleAttr, 3))\n    };\n    if (mesh.instanceColor)\n      attributes._COLOR_0 = writer.processAccessor(mesh.instanceColor);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = { attributes };\n    writer.extensionsUsed[this.name] = true;\n    writer.extensionsRequired[this.name] = true;\n  }\n}\nGLTFExporter.Utils = {\n  insertKeyframe: function(track, time) {\n    const tolerance = 1e-3;\n    const valueSize = track.getValueSize();\n    const times = new track.TimeBufferType(track.times.length + 1);\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function(clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== \"morphTargetInfluences\" || sourceTrackBinding.propertyIndex === void 0) {\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          throw new Error(\"THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.\");\n        }\n        console.warn(\"THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.\");\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === void 0) {\n        throw new Error(\"THREE.GLTFExporter: Morph target name not found: \" + sourceTrackBinding.propertyIndex);\n      }\n      let mergedTrack;\n      if (mergedTracks[sourceTrackNode.uuid] === void 0) {\n        mergedTrack = sourceTrack.clone();\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n        mergedTrack.name = (sourceTrackBinding.nodeName || \"\") + \".morphTargetInfluences\";\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      }\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  },\n  toFloat32BufferAttribute: function(srcAttribute) {\n    const dstAttribute = new BufferAttribute(new Float32Array(srcAttribute.count * srcAttribute.itemSize), srcAttribute.itemSize, false);\n    if (!srcAttribute.normalized && !srcAttribute.isInterleavedBufferAttribute) {\n      dstAttribute.array.set(srcAttribute.array);\n      return dstAttribute;\n    }\n    for (let i = 0, il = srcAttribute.count; i < il; i++) {\n      for (let j = 0; j < srcAttribute.itemSize; j++) {\n        dstAttribute.setComponent(i, j, srcAttribute.getComponent(i, j));\n      }\n    }\n    return dstAttribute;\n  }\n};\nclass OBJExporter {\n  parse(object) {\n    let output = \"\";\n    let indexVertex = 0;\n    let indexVertexUvs = 0;\n    let indexNormals = 0;\n    const vertex2 = new Vector3();\n    const color = new Color();\n    const normal = new Vector3();\n    const uv = new Vector2();\n    const face = [];\n    function parseMesh(mesh) {\n      let nbVertex = 0;\n      let nbNormals = 0;\n      let nbVertexUvs = 0;\n      const geometry = mesh.geometry;\n      const normalMatrixWorld = new Matrix3();\n      const vertices = geometry.getAttribute(\"position\");\n      const normals = geometry.getAttribute(\"normal\");\n      const uvs = geometry.getAttribute(\"uv\");\n      const indices = geometry.getIndex();\n      output += \"o \" + mesh.name + \"\\n\";\n      if (mesh.material && mesh.material.name) {\n        output += \"usemtl \" + mesh.material.name + \"\\n\";\n      }\n      if (vertices !== void 0) {\n        for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex2.fromBufferAttribute(vertices, i);\n          vertex2.applyMatrix4(mesh.matrixWorld);\n          output += \"v \" + vertex2.x + \" \" + vertex2.y + \" \" + vertex2.z + \"\\n\";\n        }\n      }\n      if (uvs !== void 0) {\n        for (let i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n          uv.fromBufferAttribute(uvs, i);\n          output += \"vt \" + uv.x + \" \" + uv.y + \"\\n\";\n        }\n      }\n      if (normals !== void 0) {\n        normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n        for (let i = 0, l = normals.count; i < l; i++, nbNormals++) {\n          normal.fromBufferAttribute(normals, i);\n          normal.applyMatrix3(normalMatrixWorld).normalize();\n          output += \"vn \" + normal.x + \" \" + normal.y + \" \" + normal.z + \"\\n\";\n        }\n      }\n      if (indices !== null) {\n        for (let i = 0, l = indices.count; i < l; i += 3) {\n          for (let m = 0; m < 3; m++) {\n            const j = indices.getX(i + m) + 1;\n            face[m] = indexVertex + j + (normals || uvs ? \"/\" + (uvs ? indexVertexUvs + j : \"\") + (normals ? \"/\" + (indexNormals + j) : \"\") : \"\");\n          }\n          output += \"f \" + face.join(\" \") + \"\\n\";\n        }\n      } else {\n        for (let i = 0, l = vertices.count; i < l; i += 3) {\n          for (let m = 0; m < 3; m++) {\n            const j = i + m + 1;\n            face[m] = indexVertex + j + (normals || uvs ? \"/\" + (uvs ? indexVertexUvs + j : \"\") + (normals ? \"/\" + (indexNormals + j) : \"\") : \"\");\n          }\n          output += \"f \" + face.join(\" \") + \"\\n\";\n        }\n      }\n      indexVertex += nbVertex;\n      indexVertexUvs += nbVertexUvs;\n      indexNormals += nbNormals;\n    }\n    function parseLine(line) {\n      let nbVertex = 0;\n      const geometry = line.geometry;\n      const type = line.type;\n      const vertices = geometry.getAttribute(\"position\");\n      output += \"o \" + line.name + \"\\n\";\n      if (vertices !== void 0) {\n        for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex2.fromBufferAttribute(vertices, i);\n          vertex2.applyMatrix4(line.matrixWorld);\n          output += \"v \" + vertex2.x + \" \" + vertex2.y + \" \" + vertex2.z + \"\\n\";\n        }\n      }\n      if (type === \"Line\") {\n        output += \"l \";\n        for (let j = 1, l = vertices.count; j <= l; j++) {\n          output += indexVertex + j + \" \";\n        }\n        output += \"\\n\";\n      }\n      if (type === \"LineSegments\") {\n        for (let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n          output += \"l \" + (indexVertex + j) + \" \" + (indexVertex + k) + \"\\n\";\n        }\n      }\n      indexVertex += nbVertex;\n    }\n    function parsePoints(points) {\n      let nbVertex = 0;\n      const geometry = points.geometry;\n      const vertices = geometry.getAttribute(\"position\");\n      const colors = geometry.getAttribute(\"color\");\n      output += \"o \" + points.name + \"\\n\";\n      if (vertices !== void 0) {\n        for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n          vertex2.fromBufferAttribute(vertices, i);\n          vertex2.applyMatrix4(points.matrixWorld);\n          output += \"v \" + vertex2.x + \" \" + vertex2.y + \" \" + vertex2.z;\n          if (colors !== void 0) {\n            color.fromBufferAttribute(colors, i);\n            ColorManagement.fromWorkingColorSpace(color, SRGBColorSpace);\n            output += \" \" + color.r + \" \" + color.g + \" \" + color.b;\n          }\n          output += \"\\n\";\n        }\n        output += \"p \";\n        for (let j = 1, l = vertices.count; j <= l; j++) {\n          output += indexVertex + j + \" \";\n        }\n        output += \"\\n\";\n      }\n      indexVertex += nbVertex;\n    }\n    object.traverse(function(child) {\n      if (child.isMesh === true) {\n        parseMesh(child);\n      }\n      if (child.isLine === true) {\n        parseLine(child);\n      }\n      if (child.isPoints === true) {\n        parsePoints(child);\n      }\n    });\n    return output;\n  }\n}\nclass STLExporter {\n  parse(scene, options = {}) {\n    options = Object.assign({\n      binary: false\n    }, options);\n    const binary = options.binary;\n    const objects = [];\n    let triangles = 0;\n    scene.traverse(function(object) {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n        const index = geometry.index;\n        const positionAttribute = geometry.getAttribute(\"position\");\n        triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n        objects.push({\n          object3d: object,\n          geometry\n        });\n      }\n    });\n    let output;\n    let offset = 80;\n    if (binary === true) {\n      const bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      output = new DataView(arrayBuffer);\n      output.setUint32(offset, triangles, true);\n      offset += 4;\n    } else {\n      output = \"\";\n      output += \"solid exported\\n\";\n    }\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const cb = new Vector3();\n    const ab = new Vector3();\n    const normal = new Vector3();\n    for (let i = 0, il = objects.length; i < il; i++) {\n      const object = objects[i].object3d;\n      const geometry = objects[i].geometry;\n      const index = geometry.index;\n      const positionAttribute = geometry.getAttribute(\"position\");\n      if (index !== null) {\n        for (let j = 0; j < index.count; j += 3) {\n          const a = index.getX(j + 0);\n          const b = index.getX(j + 1);\n          const c = index.getX(j + 2);\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      } else {\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          const a = j + 0;\n          const b = j + 1;\n          const c = j + 2;\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      }\n    }\n    if (binary === false) {\n      output += \"endsolid exported\\n\";\n    }\n    return output;\n    function writeFace(a, b, c, positionAttribute, object) {\n      vA.fromBufferAttribute(positionAttribute, a);\n      vB.fromBufferAttribute(positionAttribute, b);\n      vC.fromBufferAttribute(positionAttribute, c);\n      if (object.isSkinnedMesh === true) {\n        object.applyBoneTransform(a, vA);\n        object.applyBoneTransform(b, vB);\n        object.applyBoneTransform(c, vC);\n      }\n      vA.applyMatrix4(object.matrixWorld);\n      vB.applyMatrix4(object.matrixWorld);\n      vC.applyMatrix4(object.matrixWorld);\n      writeNormal(vA, vB, vC);\n      writeVertex(vA);\n      writeVertex(vB);\n      writeVertex(vC);\n      if (binary === true) {\n        output.setUint16(offset, 0, true);\n        offset += 2;\n      } else {\n        output += \"\t\tendloop\\n\";\n        output += \"\tendfacet\\n\";\n      }\n    }\n    function writeNormal(vA2, vB2, vC2) {\n      cb.subVectors(vC2, vB2);\n      ab.subVectors(vA2, vB2);\n      cb.cross(ab).normalize();\n      normal.copy(cb).normalize();\n      if (binary === true) {\n        output.setFloat32(offset, normal.x, true);\n        offset += 4;\n        output.setFloat32(offset, normal.y, true);\n        offset += 4;\n        output.setFloat32(offset, normal.z, true);\n        offset += 4;\n      } else {\n        output += \"\tfacet normal \" + normal.x + \" \" + normal.y + \" \" + normal.z + \"\\n\";\n        output += \"\t\touter loop\\n\";\n      }\n    }\n    function writeVertex(vertex2) {\n      if (binary === true) {\n        output.setFloat32(offset, vertex2.x, true);\n        offset += 4;\n        output.setFloat32(offset, vertex2.y, true);\n        offset += 4;\n        output.setFloat32(offset, vertex2.z, true);\n        offset += 4;\n      } else {\n        output += \"\t\t\tvertex \" + vertex2.x + \" \" + vertex2.y + \" \" + vertex2.z + \"\\n\";\n      }\n    }\n  }\n}\nclass ModelExporter {\n  static detectFormatFromURL(url2) {\n    var _a2;\n    try {\n      const filenameParam = new URLSearchParams(url2.split(\"?\")[1]).get(\n        \"filename\"\n      );\n      if (filenameParam) {\n        const extension = (_a2 = filenameParam.split(\".\").pop()) == null ? void 0 : _a2.toLowerCase();\n        return extension || null;\n      }\n    } catch (e) {\n      console.error(\"Error parsing URL:\", e);\n    }\n    return null;\n  }\n  static canUseDirectURL(url2, format) {\n    if (!url2) return false;\n    const urlFormat = ModelExporter.detectFormatFromURL(url2);\n    if (!urlFormat) return false;\n    return urlFormat.toLowerCase() === format.toLowerCase();\n  }\n  static async downloadFromURL(url2, desiredFilename) {\n    try {\n      const response = await fetch(url2);\n      const blob2 = await response.blob();\n      const link = document.createElement(\"a\");\n      link.href = URL.createObjectURL(blob2);\n      link.download = desiredFilename;\n      link.click();\n      URL.revokeObjectURL(link.href);\n    } catch (error) {\n      console.error(\"Error downloading from URL:\", error);\n      useToastStore().addAlert(t(\"toastMessages.failedToDownloadFile\"));\n      throw error;\n    }\n  }\n  static async exportGLB(model, filename = \"model.glb\", originalURL) {\n    if (originalURL && ModelExporter.canUseDirectURL(originalURL, \"glb\")) {\n      console.log(\"Using direct URL download for GLB\");\n      return ModelExporter.downloadFromURL(originalURL, filename);\n    }\n    const exporter = new GLTFExporter();\n    try {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      const result = await new Promise((resolve, reject) => {\n        exporter.parse(\n          model,\n          (gltf) => {\n            resolve(gltf);\n          },\n          (error) => {\n            reject(error);\n          },\n          { binary: true }\n        );\n      });\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      ModelExporter.saveArrayBuffer(result, filename);\n    } catch (error) {\n      console.error(\"Error exporting GLB:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToExportModel\", { format: \"GLB\" })\n      );\n      throw error;\n    }\n  }\n  static async exportOBJ(model, filename = \"model.obj\", originalURL) {\n    if (originalURL && ModelExporter.canUseDirectURL(originalURL, \"obj\")) {\n      console.log(\"Using direct URL download for OBJ\");\n      return ModelExporter.downloadFromURL(originalURL, filename);\n    }\n    const exporter = new OBJExporter();\n    try {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      const result = exporter.parse(model);\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      ModelExporter.saveString(result, filename);\n    } catch (error) {\n      console.error(\"Error exporting OBJ:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToExportModel\", { format: \"OBJ\" })\n      );\n      throw error;\n    }\n  }\n  static async exportSTL(model, filename = \"model.stl\", originalURL) {\n    if (originalURL && ModelExporter.canUseDirectURL(originalURL, \"stl\")) {\n      console.log(\"Using direct URL download for STL\");\n      return ModelExporter.downloadFromURL(originalURL, filename);\n    }\n    const exporter = new STLExporter();\n    try {\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      const result = exporter.parse(model);\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      ModelExporter.saveString(result, filename);\n    } catch (error) {\n      console.error(\"Error exporting STL:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToExportModel\", { format: \"STL\" })\n      );\n      throw error;\n    }\n  }\n  static saveArrayBuffer(buffer, filename) {\n    const blob2 = new Blob([buffer], { type: \"application/octet-stream\" });\n    const link = document.createElement(\"a\");\n    link.href = URL.createObjectURL(blob2);\n    link.download = filename;\n    link.click();\n    URL.revokeObjectURL(link.href);\n  }\n  static saveString(text, filename) {\n    const blob2 = new Blob([text], { type: \"text/plain\" });\n    const link = document.createElement(\"a\");\n    link.href = URL.createObjectURL(blob2);\n    link.download = filename;\n    link.click();\n    URL.revokeObjectURL(link.href);\n  }\n}\nvar __defProp$e = Object.defineProperty;\nvar __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$e = (obj, key, value) => __defNormalProp$e(obj, key + \"\", value);\nclass NodeStorage {\n  constructor(node = {}) {\n    __publicField$e(this, \"node\");\n    this.node = node;\n  }\n  storeNodeProperty(name, value) {\n    if (this.node && this.node.properties) {\n      this.node.properties[name] = value;\n    }\n  }\n  loadNodeProperty(name, defaultValue) {\n    if (!this.node || !this.node.properties || !(name in this.node.properties)) {\n      return defaultValue;\n    }\n    return this.node.properties[name];\n  }\n  setNode(node) {\n    this.node = node;\n  }\n}\nvar __defProp$d = Object.defineProperty;\nvar __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$d = (obj, key, value) => __defNormalProp$d(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass PreviewManager {\n  constructor(scene, getActiveCamera, getControls, getRenderer, eventManager, backgroundScene, backgroundCamera) {\n    __publicField$d(this, \"previewCamera\");\n    __publicField$d(this, \"previewContainer\", null);\n    __publicField$d(this, \"showPreview\", true);\n    __publicField$d(this, \"previewWidth\", 120);\n    __publicField$d(this, \"targetWidth\", 1024);\n    __publicField$d(this, \"targetHeight\", 1024);\n    __publicField$d(this, \"scene\");\n    __publicField$d(this, \"getActiveCamera\");\n    __publicField$d(this, \"getControls\");\n    __publicField$d(this, \"eventManager\");\n    __publicField$d(this, \"getRenderer\");\n    __publicField$d(this, \"previewBackgroundScene\");\n    __publicField$d(this, \"previewBackgroundCamera\");\n    __publicField$d(this, \"previewBackgroundMesh\", null);\n    __publicField$d(this, \"previewBackgroundTexture\", null);\n    __publicField$d(this, \"previewBackgroundColorMaterial\", null);\n    __publicField$d(this, \"currentBackgroundColor\", new Color(2631720));\n    this.scene = scene;\n    this.getActiveCamera = getActiveCamera;\n    this.getControls = getControls;\n    this.getRenderer = getRenderer;\n    this.eventManager = eventManager;\n    this.previewCamera = this.getActiveCamera().clone();\n    this.previewBackgroundScene = backgroundScene.clone();\n    this.previewBackgroundCamera = backgroundCamera.clone();\n    this.initPreviewBackgroundScene();\n  }\n  initPreviewBackgroundScene() {\n    const planeGeometry = new PlaneGeometry(2, 2);\n    this.previewBackgroundColorMaterial = new MeshBasicMaterial({\n      color: this.currentBackgroundColor.clone(),\n      transparent: false,\n      depthWrite: false,\n      depthTest: false,\n      side: DoubleSide\n    });\n    this.previewBackgroundMesh = new Mesh(\n      planeGeometry,\n      this.previewBackgroundColorMaterial\n    );\n    this.previewBackgroundMesh.position.set(0, 0, 0);\n    this.previewBackgroundScene.add(this.previewBackgroundMesh);\n  }\n  init() {\n  }\n  dispose() {\n    if (this.previewBackgroundTexture) {\n      this.previewBackgroundTexture.dispose();\n    }\n    if (this.previewBackgroundColorMaterial) {\n      this.previewBackgroundColorMaterial.dispose();\n    }\n    if (this.previewBackgroundMesh) {\n      this.previewBackgroundMesh.geometry.dispose();\n      if (this.previewBackgroundMesh.material instanceof Material) {\n        this.previewBackgroundMesh.material.dispose();\n      }\n    }\n  }\n  createCapturePreview(container) {\n    this.previewContainer = document.createElement(\"div\");\n    this.previewContainer.style.cssText = `\n      position: absolute;\n      right: 0;\n      bottom: 0;\n      background: rgba(0, 0, 0, 0.2);\n      display: block;\n      transition: border-color 0.1s ease;\n    `;\n    const MIN_PREVIEW_WIDTH = 120;\n    const MAX_PREVIEW_WIDTH = 240;\n    this.previewContainer.addEventListener(\"wheel\", (event) => {\n      event.preventDefault();\n      event.stopPropagation();\n      const delta = event.deltaY;\n      const oldWidth = this.previewWidth;\n      if (delta > 0) {\n        this.previewWidth = Math.max(MIN_PREVIEW_WIDTH, this.previewWidth - 10);\n      } else {\n        this.previewWidth = Math.min(MAX_PREVIEW_WIDTH, this.previewWidth + 10);\n      }\n      if (oldWidth !== this.previewWidth && (this.previewWidth === MIN_PREVIEW_WIDTH || this.previewWidth === MAX_PREVIEW_WIDTH)) {\n        this.flashPreviewBorder();\n      }\n      this.updatePreviewSize();\n    });\n    this.previewContainer.style.display = this.showPreview ? \"block\" : \"none\";\n    container.appendChild(this.previewContainer);\n    this.updatePreviewSize();\n  }\n  flashPreviewBorder() {\n    const originalBorder = this.previewContainer.style.border;\n    const originalBoxShadow = this.previewContainer.style.boxShadow;\n    this.previewContainer.style.border = \"2px solid rgba(255, 255, 255, 0.8)\";\n    this.previewContainer.style.boxShadow = \"0 0 8px rgba(255, 255, 255, 0.5)\";\n    setTimeout(() => {\n      this.previewContainer.style.border = originalBorder;\n      this.previewContainer.style.boxShadow = originalBoxShadow;\n    }, 100);\n  }\n  updatePreviewSize() {\n    if (!this.previewContainer) return;\n    const previewHeight = this.previewWidth * this.targetHeight / this.targetWidth;\n    this.previewContainer.style.width = `${this.previewWidth}px`;\n    this.previewContainer.style.height = `${previewHeight}px`;\n  }\n  getPreviewViewport() {\n    if (!this.showPreview || !this.previewContainer) {\n      return null;\n    }\n    const renderer = this.getRenderer();\n    const canvas = renderer.domElement;\n    const containerRect = this.previewContainer.getBoundingClientRect();\n    const canvasRect = canvas.getBoundingClientRect();\n    if (containerRect.bottom < canvasRect.top || containerRect.top > canvasRect.bottom || containerRect.right < canvasRect.left || containerRect.left > canvasRect.right) {\n      return null;\n    }\n    const width = parseFloat(this.previewContainer.style.width);\n    const height = parseFloat(this.previewContainer.style.height);\n    const left = this.getRenderer().domElement.clientWidth - width;\n    const bottom = 0;\n    return { left, bottom, width, height };\n  }\n  renderPreview() {\n    const viewport = this.getPreviewViewport();\n    if (!viewport) return;\n    const renderer = this.getRenderer();\n    const originalClearColor = renderer.getClearColor(new Color());\n    const originalClearAlpha = renderer.getClearAlpha();\n    if (!this.previewCamera || this.getActiveCamera() instanceof PerspectiveCamera && !(this.previewCamera instanceof PerspectiveCamera) || this.getActiveCamera() instanceof OrthographicCamera && !(this.previewCamera instanceof OrthographicCamera)) {\n      this.previewCamera = this.getActiveCamera().clone();\n    }\n    this.previewCamera.position.copy(this.getActiveCamera().position);\n    this.previewCamera.rotation.copy(this.getActiveCamera().rotation);\n    const aspect2 = this.targetWidth / this.targetHeight;\n    if (this.getActiveCamera() instanceof OrthographicCamera) {\n      const activeOrtho = this.getActiveCamera();\n      const previewOrtho = this.previewCamera;\n      const frustumHeight = (activeOrtho.top - activeOrtho.bottom) / activeOrtho.zoom;\n      const frustumWidth = frustumHeight * aspect2;\n      previewOrtho.top = frustumHeight / 2;\n      previewOrtho.left = -frustumWidth / 2;\n      previewOrtho.right = frustumWidth / 2;\n      previewOrtho.bottom = -frustumHeight / 2;\n      previewOrtho.zoom = 1;\n      previewOrtho.updateProjectionMatrix();\n    } else {\n      const activePerspective = this.getActiveCamera();\n      const previewPerspective = this.previewCamera;\n      previewPerspective.fov = activePerspective.fov;\n      previewPerspective.zoom = activePerspective.zoom;\n      previewPerspective.aspect = aspect2;\n      previewPerspective.updateProjectionMatrix();\n    }\n    this.previewCamera.lookAt(this.getControls().target);\n    renderer.setViewport(\n      viewport.left,\n      viewport.bottom,\n      viewport.width,\n      viewport.height\n    );\n    renderer.setScissor(\n      viewport.left,\n      viewport.bottom,\n      viewport.width,\n      viewport.height\n    );\n    renderer.setClearColor(0, 0);\n    renderer.clear();\n    this.renderPreviewBackground(renderer);\n    renderer.render(this.scene, this.previewCamera);\n    renderer.setClearColor(originalClearColor, originalClearAlpha);\n  }\n  renderPreviewBackground(renderer) {\n    if (this.previewBackgroundMesh) {\n      const currentToneMapping = renderer.toneMapping;\n      const currentExposure = renderer.toneMappingExposure;\n      renderer.toneMapping = NoToneMapping;\n      renderer.render(this.previewBackgroundScene, this.previewBackgroundCamera);\n      renderer.toneMapping = currentToneMapping;\n      renderer.toneMappingExposure = currentExposure;\n    }\n  }\n  setPreviewBackgroundColor(color) {\n    this.currentBackgroundColor.set(color);\n    if (!this.previewBackgroundMesh || !this.previewBackgroundColorMaterial) {\n      this.initPreviewBackgroundScene();\n    }\n    this.previewBackgroundColorMaterial.color.copy(this.currentBackgroundColor);\n    if (this.previewBackgroundMesh) {\n      this.previewBackgroundMesh.material = this.previewBackgroundColorMaterial;\n    }\n    if (this.previewBackgroundTexture) {\n      this.previewBackgroundTexture.dispose();\n      this.previewBackgroundTexture = null;\n    }\n  }\n  togglePreview(showPreview) {\n    this.showPreview = showPreview;\n    if (this.previewContainer) {\n      this.previewContainer.style.display = this.showPreview ? \"block\" : \"none\";\n    }\n    this.eventManager.emitEvent(\"showPreviewChange\", showPreview);\n  }\n  setTargetSize(width, height) {\n    const oldAspect = this.targetWidth / this.targetHeight;\n    this.targetWidth = width;\n    this.targetHeight = height;\n    this.updatePreviewSize();\n    const newAspect = width / height;\n    if (Math.abs(oldAspect - newAspect) > 1e-3) {\n      this.updateBackgroundSize(\n        this.previewBackgroundTexture,\n        this.previewBackgroundMesh,\n        width,\n        height\n      );\n    }\n    if (this.previewCamera) {\n      if (this.previewCamera instanceof PerspectiveCamera) {\n        this.previewCamera.aspect = width / height;\n        this.previewCamera.updateProjectionMatrix();\n      } else if (this.previewCamera instanceof OrthographicCamera) {\n        const frustumSize = 10;\n        const aspect2 = width / height;\n        this.previewCamera.left = -frustumSize * aspect2 / 2;\n        this.previewCamera.right = frustumSize * aspect2 / 2;\n        this.previewCamera.updateProjectionMatrix();\n      }\n    }\n  }\n  handleResize() {\n    this.updatePreviewSize();\n  }\n  updateBackgroundTexture(texture) {\n    if (texture) {\n      if (this.previewBackgroundTexture) {\n        this.previewBackgroundTexture.dispose();\n      }\n      this.previewBackgroundTexture = texture;\n      if (this.previewBackgroundMesh) {\n        const imageMaterial = new MeshBasicMaterial({\n          map: texture,\n          transparent: true,\n          depthWrite: false,\n          depthTest: false,\n          side: DoubleSide\n        });\n        if (this.previewBackgroundMesh.material instanceof Material && this.previewBackgroundMesh.material !== this.previewBackgroundColorMaterial) {\n          this.previewBackgroundMesh.material.dispose();\n        }\n        this.previewBackgroundMesh.material = imageMaterial;\n        this.previewBackgroundMesh.position.set(0, 0, 0);\n        this.updateBackgroundSize(\n          this.previewBackgroundTexture,\n          this.previewBackgroundMesh,\n          this.targetWidth,\n          this.targetHeight\n        );\n      }\n    } else {\n      this.setPreviewBackgroundColor(this.currentBackgroundColor);\n    }\n  }\n  updateBackgroundSize(backgroundTexture, backgroundMesh, targetWidth, targetHeight) {\n    if (!backgroundTexture || !backgroundMesh) return;\n    const material = backgroundMesh.material;\n    if (!material.map) return;\n    const imageAspect = backgroundTexture.image.width / backgroundTexture.image.height;\n    const targetAspect = targetWidth / targetHeight;\n    if (imageAspect > targetAspect) {\n      backgroundMesh.scale.set(imageAspect / targetAspect, 1, 1);\n    } else {\n      backgroundMesh.scale.set(1, targetAspect / imageAspect, 1);\n    }\n    material.needsUpdate = true;\n  }\n  reset() {\n  }\n}\nvar __defProp$c = Object.defineProperty;\nvar __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$c = (obj, key, value) => __defNormalProp$c(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass RecordingManager {\n  constructor(scene, renderer, eventManager) {\n    __publicField$c(this, \"mediaRecorder\", null);\n    __publicField$c(this, \"recordedChunks\", []);\n    __publicField$c(this, \"isRecording\", false);\n    __publicField$c(this, \"recordingStream\", null);\n    __publicField$c(this, \"recordingIndicator\", null);\n    __publicField$c(this, \"scene\");\n    __publicField$c(this, \"renderer\");\n    __publicField$c(this, \"eventManager\");\n    __publicField$c(this, \"recordingStartTime\", 0);\n    __publicField$c(this, \"recordingDuration\", 0);\n    __publicField$c(this, \"recordingCanvas\", null);\n    this.scene = scene;\n    this.renderer = renderer;\n    this.eventManager = eventManager;\n    this.setupRecordingIndicator();\n  }\n  setupRecordingIndicator() {\n    const map = new TextureLoader().load(\n      \"data:image/svg+xml;base64,\" + btoa(`<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"64\" height=\"64\" viewBox=\"0 0 64 64\">\n        <circle cx=\"32\" cy=\"32\" r=\"24\" fill=\"#4CAF50\" opacity=\"0.8\" />\n        <circle cx=\"32\" cy=\"32\" r=\"16\" fill=\"#2E7D32\" opacity=\"0.8\" />\n      </svg>`)\n    );\n    const material = new SpriteMaterial({\n      map,\n      transparent: true,\n      depthTest: false,\n      depthWrite: false\n    });\n    this.recordingIndicator = new Sprite(material);\n    this.recordingIndicator.scale.set(0.5, 0.5, 0.5);\n    this.recordingIndicator.position.set(-0.8, 0.8, 0);\n    this.recordingIndicator.visible = false;\n    this.scene.add(this.recordingIndicator);\n  }\n  async startRecording() {\n    if (this.isRecording) {\n      return;\n    }\n    try {\n      this.recordingCanvas = this.renderer.domElement;\n      this.recordingStream = this.recordingCanvas.captureStream(30);\n      if (!this.recordingStream) {\n        throw new Error(\"Failed to capture stream from canvas\");\n      }\n      this.mediaRecorder = new MediaRecorder(this.recordingStream, {\n        mimeType: \"video/webm;codecs=vp9\",\n        videoBitsPerSecond: 5e6\n      });\n      this.recordedChunks = [];\n      this.mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          this.recordedChunks.push(event.data);\n        }\n      };\n      this.mediaRecorder.onstop = () => {\n        this.recordingIndicator.visible = false;\n        this.isRecording = false;\n        this.recordingStream = null;\n        this.eventManager.emitEvent(\"recordingStopped\", {\n          duration: this.recordingDuration,\n          hasRecording: this.recordedChunks.length > 0\n        });\n      };\n      if (this.recordingIndicator) {\n        this.recordingIndicator.visible = true;\n      }\n      this.mediaRecorder.start(100);\n      this.isRecording = true;\n      this.recordingStartTime = Date.now();\n      this.eventManager.emitEvent(\"recordingStarted\", null);\n    } catch (error) {\n      console.error(\"Error starting recording:\", error);\n      this.eventManager.emitEvent(\"recordingError\", error);\n    }\n  }\n  stopRecording() {\n    if (!this.isRecording || !this.mediaRecorder) {\n      return;\n    }\n    this.recordingDuration = (Date.now() - this.recordingStartTime) / 1e3;\n    this.mediaRecorder.stop();\n    if (this.recordingStream) {\n      this.recordingStream.getTracks().forEach((track) => track.stop());\n    }\n  }\n  getIsRecording() {\n    return this.isRecording;\n  }\n  hasRecording() {\n    return this.recordedChunks.length > 0;\n  }\n  getRecordingDuration() {\n    return this.recordingDuration;\n  }\n  getRecordingData() {\n    if (this.recordedChunks.length !== 0) {\n      const blob2 = new Blob(this.recordedChunks, { type: \"video/webm\" });\n      return URL.createObjectURL(blob2);\n    }\n    return null;\n  }\n  exportRecording(filename = \"scene-recording.mp4\") {\n    if (this.recordedChunks.length === 0) {\n      this.eventManager.emitEvent(\n        \"recordingError\",\n        new Error(\"No recording available to export\")\n      );\n      return;\n    }\n    this.eventManager.emitEvent(\"exportingRecording\", null);\n    try {\n      const blob2 = new Blob(this.recordedChunks, { type: \"video/webm\" });\n      const url2 = URL.createObjectURL(blob2);\n      const a = document.createElement(\"a\");\n      document.body.appendChild(a);\n      a.style.display = \"none\";\n      a.href = url2;\n      a.download = filename;\n      a.click();\n      window.URL.revokeObjectURL(url2);\n      document.body.removeChild(a);\n      this.eventManager.emitEvent(\"recordingExported\", null);\n    } catch (error) {\n      console.error(\"Error exporting recording:\", error);\n      this.eventManager.emitEvent(\"recordingError\", error);\n    }\n  }\n  clearRecording() {\n    this.recordedChunks = [];\n    this.recordingDuration = 0;\n    this.eventManager.emitEvent(\"recordingCleared\", null);\n  }\n  dispose() {\n    var _a2;\n    this.stopRecording();\n    this.clearRecording();\n    if (this.recordingIndicator) {\n      this.scene.remove(this.recordingIndicator);\n      (_a2 = this.recordingIndicator.material.map) == null ? void 0 : _a2.dispose();\n      this.recordingIndicator.material.dispose();\n    }\n  }\n}\nclass Load3dUtils {\n  static async uploadTempImage(imageData, prefix, fileType = \"png\") {\n    const blob2 = await fetch(imageData).then((r) => r.blob());\n    const name = `${prefix}_${Date.now()}.${fileType}`;\n    const file2 = new File([blob2], name, {\n      type: fileType === \"mp4\" ? \"video/mp4\" : \"image/png\"\n    });\n    const body = new FormData();\n    body.append(\"image\", file2);\n    body.append(\"subfolder\", \"threed\");\n    body.append(\"type\", \"temp\");\n    const resp = await api.fetchApi(\"/upload/image\", {\n      method: \"POST\",\n      body\n    });\n    if (resp.status !== 200) {\n      const err2 = `Error uploading temp file: ${resp.status} - ${resp.statusText}`;\n      useToastStore().addAlert(err2);\n      throw new Error(err2);\n    }\n    return await resp.json();\n  }\n  static async uploadFile(file2, subfolder) {\n    let uploadPath;\n    try {\n      const body = new FormData();\n      body.append(\"image\", file2);\n      body.append(\"subfolder\", subfolder);\n      const resp = await api.fetchApi(\"/upload/image\", {\n        method: \"POST\",\n        body\n      });\n      if (resp.status === 200) {\n        const data = await resp.json();\n        let path = data.name;\n        if (data.subfolder) {\n          path = data.subfolder + \"/\" + path;\n        }\n        uploadPath = path;\n      } else {\n        useToastStore().addAlert(resp.status + \" - \" + resp.statusText);\n      }\n    } catch (error) {\n      console.error(\"Upload error:\", error);\n      useToastStore().addAlert(\n        error instanceof Error ? error.message : t(\"toastMessages.fileUploadFailed\")\n      );\n    }\n    return uploadPath;\n  }\n  static splitFilePath(path) {\n    const folder_separator = path.lastIndexOf(\"/\");\n    if (folder_separator === -1) {\n      return [\"\", path];\n    }\n    return [\n      path.substring(0, folder_separator),\n      path.substring(folder_separator + 1)\n    ];\n  }\n  static getResourceURL(subfolder, filename, type = \"input\") {\n    const params = [\n      \"filename=\" + encodeURIComponent(filename),\n      \"type=\" + type,\n      \"subfolder=\" + subfolder,\n      app.getRandParam().substring(1)\n    ].join(\"&\");\n    return `/view?${params}`;\n  }\n  static async uploadMultipleFiles(files, subfolder = \"3d\") {\n    const uploadPromises = Array.from(files).map(\n      (file2) => this.uploadFile(file2, subfolder)\n    );\n    await Promise.all(uploadPromises);\n  }\n}\nvar __defProp$b = Object.defineProperty;\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$b = (obj, key, value) => __defNormalProp$b(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass SceneManager {\n  constructor(renderer, getActiveCamera, getControls, eventManager) {\n    __publicField$b(this, \"scene\");\n    __publicField$b(this, \"gridHelper\");\n    __publicField$b(this, \"backgroundScene\");\n    __publicField$b(this, \"backgroundCamera\");\n    __publicField$b(this, \"backgroundMesh\", null);\n    __publicField$b(this, \"backgroundTexture\", null);\n    __publicField$b(this, \"backgroundColorMaterial\", null);\n    __publicField$b(this, \"currentBackgroundType\", \"color\");\n    __publicField$b(this, \"currentBackgroundColor\", \"#282828\");\n    __publicField$b(this, \"eventManager\");\n    __publicField$b(this, \"renderer\");\n    __publicField$b(this, \"getActiveCamera\");\n    __publicField$b(this, \"getControls\");\n    this.renderer = renderer;\n    this.eventManager = eventManager;\n    this.scene = new Scene();\n    this.getActiveCamera = getActiveCamera;\n    this.getControls = getControls;\n    this.gridHelper = new GridHelper(20, 20);\n    this.gridHelper.position.set(0, 0, 0);\n    this.scene.add(this.gridHelper);\n    this.backgroundScene = new Scene();\n    this.backgroundCamera = new OrthographicCamera(-1, 1, 1, -1, -1, 1);\n    this.initBackgroundScene();\n  }\n  initBackgroundScene() {\n    const planeGeometry = new PlaneGeometry(2, 2);\n    this.backgroundColorMaterial = new MeshBasicMaterial({\n      color: new Color(this.currentBackgroundColor),\n      transparent: false,\n      depthWrite: false,\n      depthTest: false,\n      side: DoubleSide\n    });\n    this.backgroundMesh = new Mesh(\n      planeGeometry,\n      this.backgroundColorMaterial\n    );\n    this.backgroundMesh.position.set(0, 0, 0);\n    this.backgroundScene.add(this.backgroundMesh);\n    this.renderer.setClearColor(0, 0);\n  }\n  init() {\n  }\n  dispose() {\n    if (this.backgroundTexture) {\n      this.backgroundTexture.dispose();\n    }\n    if (this.backgroundColorMaterial) {\n      this.backgroundColorMaterial.dispose();\n    }\n    if (this.backgroundMesh) {\n      this.backgroundMesh.geometry.dispose();\n      if (this.backgroundMesh.material instanceof Material) {\n        this.backgroundMesh.material.dispose();\n      }\n    }\n    this.scene.clear();\n  }\n  toggleGrid(showGrid) {\n    if (this.gridHelper) {\n      this.gridHelper.visible = showGrid;\n    }\n    this.eventManager.emitEvent(\"showGridChange\", showGrid);\n  }\n  setBackgroundColor(color) {\n    this.currentBackgroundColor = color;\n    this.currentBackgroundType = \"color\";\n    if (!this.backgroundMesh || !this.backgroundColorMaterial) {\n      this.initBackgroundScene();\n    }\n    this.backgroundColorMaterial.color.set(color);\n    this.backgroundColorMaterial.map = null;\n    this.backgroundColorMaterial.transparent = false;\n    this.backgroundColorMaterial.needsUpdate = true;\n    if (this.backgroundMesh) {\n      this.backgroundMesh.material = this.backgroundColorMaterial;\n    }\n    if (this.backgroundTexture) {\n      this.backgroundTexture.dispose();\n      this.backgroundTexture = null;\n    }\n    this.eventManager.emitEvent(\"backgroundColorChange\", color);\n  }\n  async setBackgroundImage(uploadPath) {\n    if (uploadPath === \"\") {\n      this.setBackgroundColor(this.currentBackgroundColor);\n      return;\n    }\n    this.eventManager.emitEvent(\"backgroundImageLoadingStart\", null);\n    let imageUrl = Load3dUtils.getResourceURL(\n      ...Load3dUtils.splitFilePath(uploadPath)\n    );\n    if (!imageUrl.startsWith(\"/api\")) {\n      imageUrl = \"/api\" + imageUrl;\n    }\n    try {\n      const textureLoader = new TextureLoader();\n      const texture = await new Promise((resolve, reject) => {\n        textureLoader.load(imageUrl, resolve, void 0, reject);\n      });\n      if (this.backgroundTexture) {\n        this.backgroundTexture.dispose();\n      }\n      texture.colorSpace = SRGBColorSpace;\n      this.backgroundTexture = texture;\n      this.currentBackgroundType = \"image\";\n      if (!this.backgroundMesh) {\n        this.initBackgroundScene();\n      }\n      const imageMaterial = new MeshBasicMaterial({\n        map: texture,\n        transparent: true,\n        depthWrite: false,\n        depthTest: false,\n        side: DoubleSide\n      });\n      if (this.backgroundMesh) {\n        if (this.backgroundMesh.material !== this.backgroundColorMaterial && this.backgroundMesh.material instanceof Material) {\n          this.backgroundMesh.material.dispose();\n        }\n        this.backgroundMesh.material = imageMaterial;\n        this.backgroundMesh.position.set(0, 0, 0);\n      }\n      this.updateBackgroundSize(\n        this.backgroundTexture,\n        this.backgroundMesh,\n        this.renderer.domElement.width,\n        this.renderer.domElement.height\n      );\n      this.eventManager.emitEvent(\"backgroundImageChange\", uploadPath);\n      this.eventManager.emitEvent(\"backgroundImageLoadingEnd\", null);\n    } catch (error) {\n      this.eventManager.emitEvent(\"backgroundImageLoadingEnd\", null);\n      console.error(\"Error loading background image:\", error);\n      this.setBackgroundColor(this.currentBackgroundColor);\n    }\n  }\n  removeBackgroundImage() {\n    this.setBackgroundColor(this.currentBackgroundColor);\n    this.eventManager.emitEvent(\"backgroundImageLoadingEnd\", null);\n  }\n  updateBackgroundSize(backgroundTexture, backgroundMesh, targetWidth, targetHeight) {\n    if (!backgroundTexture || !backgroundMesh) return;\n    const material = backgroundMesh.material;\n    if (!material.map) return;\n    const imageAspect = backgroundTexture.image.width / backgroundTexture.image.height;\n    const targetAspect = targetWidth / targetHeight;\n    if (imageAspect > targetAspect) {\n      backgroundMesh.scale.set(imageAspect / targetAspect, 1, 1);\n    } else {\n      backgroundMesh.scale.set(1, targetAspect / imageAspect, 1);\n    }\n    material.needsUpdate = true;\n  }\n  handleResize(width, height) {\n    if (this.backgroundTexture && this.backgroundMesh && this.currentBackgroundType === \"image\") {\n      this.updateBackgroundSize(\n        this.backgroundTexture,\n        this.backgroundMesh,\n        width,\n        height\n      );\n    }\n  }\n  renderBackground() {\n    if (this.backgroundMesh) {\n      const currentToneMapping = this.renderer.toneMapping;\n      const currentExposure = this.renderer.toneMappingExposure;\n      this.renderer.toneMapping = NoToneMapping;\n      this.renderer.render(this.backgroundScene, this.backgroundCamera);\n      this.renderer.toneMapping = currentToneMapping;\n      this.renderer.toneMappingExposure = currentExposure;\n    }\n  }\n  getCurrentBackgroundInfo() {\n    return {\n      type: this.currentBackgroundType,\n      value: this.currentBackgroundType === \"color\" ? this.currentBackgroundColor : \"\"\n    };\n  }\n  captureScene(width, height) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        const originalWidth = this.renderer.domElement.width;\n        const originalHeight = this.renderer.domElement.height;\n        const originalClearColor = this.renderer.getClearColor(\n          new Color()\n        );\n        const originalClearAlpha = this.renderer.getClearAlpha();\n        const originalOutputColorSpace = this.renderer.outputColorSpace;\n        this.renderer.setSize(width, height);\n        if (this.getActiveCamera() instanceof PerspectiveCamera) {\n          const perspectiveCamera = this.getActiveCamera();\n          perspectiveCamera.aspect = width / height;\n          perspectiveCamera.updateProjectionMatrix();\n        } else {\n          const orthographicCamera = this.getActiveCamera();\n          const frustumSize = 10;\n          const aspect2 = width / height;\n          orthographicCamera.left = -frustumSize * aspect2 / 2;\n          orthographicCamera.right = frustumSize * aspect2 / 2;\n          orthographicCamera.top = frustumSize / 2;\n          orthographicCamera.bottom = -frustumSize / 2;\n          orthographicCamera.updateProjectionMatrix();\n        }\n        if (this.backgroundTexture && this.backgroundMesh && this.currentBackgroundType === \"image\") {\n          this.updateBackgroundSize(\n            this.backgroundTexture,\n            this.backgroundMesh,\n            width,\n            height\n          );\n        }\n        const originalMaterials = /* @__PURE__ */ new Map();\n        this.renderer.clear();\n        this.renderBackground();\n        this.renderer.render(this.scene, this.getActiveCamera());\n        const sceneData = this.renderer.domElement.toDataURL(\"image/png\");\n        this.renderer.setClearColor(0, 0);\n        this.renderer.clear();\n        this.renderer.render(this.scene, this.getActiveCamera());\n        const maskData = this.renderer.domElement.toDataURL(\"image/png\");\n        this.scene.traverse((child) => {\n          if (child instanceof Mesh) {\n            originalMaterials.set(child, child.material);\n            child.material = new MeshNormalMaterial({\n              flatShading: false,\n              side: DoubleSide,\n              normalScale: new Vector2(1, 1)\n            });\n          }\n        });\n        const gridVisible = this.gridHelper.visible;\n        this.gridHelper.visible = false;\n        this.renderer.setClearColor(0, 1);\n        this.renderer.clear();\n        this.renderer.render(this.scene, this.getActiveCamera());\n        const normalData = this.renderer.domElement.toDataURL(\"image/png\");\n        this.scene.traverse((child) => {\n          if (child instanceof Mesh) {\n            const originalMaterial = originalMaterials.get(child);\n            if (originalMaterial) {\n              child.material = originalMaterial;\n            }\n          }\n        });\n        let lineartModel = null;\n        const originalSceneVisible = /* @__PURE__ */ new Map();\n        this.scene.traverse((child) => {\n          var _a2;\n          if (child instanceof Group && child.name === \"lineartModel\") {\n            lineartModel = child;\n          }\n          if (child instanceof Mesh && !(((_a2 = child.parent) == null ? void 0 : _a2.name) === \"lineartModel\")) {\n            originalSceneVisible.set(child, child.visible);\n            child.visible = false;\n          }\n        });\n        this.renderer.setClearColor(16777215, 1);\n        this.renderer.clear();\n        if (lineartModel !== null) {\n          lineartModel = lineartModel;\n          const originalLineartVisibleMap = /* @__PURE__ */ new Map();\n          lineartModel.traverse((child) => {\n            if (child instanceof Mesh) {\n              originalLineartVisibleMap.set(child, child.visible);\n              child.visible = true;\n            }\n          });\n          const originalLineartVisible = lineartModel.visible;\n          lineartModel.visible = true;\n          this.renderer.render(this.scene, this.getActiveCamera());\n          lineartModel.visible = originalLineartVisible;\n          originalLineartVisibleMap.forEach((visible, object) => {\n            object.visible = visible;\n          });\n        }\n        const lineartData = this.renderer.domElement.toDataURL(\"image/png\");\n        originalSceneVisible.forEach((visible, object) => {\n          object.visible = visible;\n        });\n        this.gridHelper.visible = gridVisible;\n        this.renderer.setClearColor(originalClearColor, originalClearAlpha);\n        this.renderer.setSize(originalWidth, originalHeight);\n        this.renderer.outputColorSpace = originalOutputColorSpace;\n        this.handleResize(originalWidth, originalHeight);\n        resolve({\n          scene: sceneData,\n          mask: maskData,\n          normal: normalData,\n          lineart: lineartData\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  reset() {\n  }\n}\nUniformsLib.line = {\n  worldUnits: { value: 1 },\n  linewidth: { value: 1 },\n  resolution: { value: new Vector2(1, 1) },\n  dashOffset: { value: 0 },\n  dashScale: { value: 1 },\n  dashSize: { value: 1 },\n  gapSize: { value: 1 }\n  // todo FIX - maybe change to totalSize\n};\nShaderLib[\"line\"] = {\n  uniforms: UniformsUtils.merge([\n    UniformsLib.common,\n    UniformsLib.fog,\n    UniformsLib.line\n  ]),\n  vertexShader: (\n    /* glsl */\n    `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n  )\n};\nclass LineMaterial extends ShaderMaterial {\n  static get type() {\n    return \"LineMaterial\";\n  }\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.clone(ShaderLib[\"line\"].uniforms),\n      vertexShader: ShaderLib[\"line\"].vertexShader,\n      fragmentShader: ShaderLib[\"line\"].fragmentShader,\n      clipping: true\n      // required for clipping support\n    });\n    this.isLineMaterial = true;\n    this.setValues(parameters);\n  }\n  get color() {\n    return this.uniforms.diffuse.value;\n  }\n  set color(value) {\n    this.uniforms.diffuse.value = value;\n  }\n  get worldUnits() {\n    return \"WORLD_UNITS\" in this.defines;\n  }\n  set worldUnits(value) {\n    if (value === true) {\n      this.defines.WORLD_UNITS = \"\";\n    } else {\n      delete this.defines.WORLD_UNITS;\n    }\n  }\n  get linewidth() {\n    return this.uniforms.linewidth.value;\n  }\n  set linewidth(value) {\n    if (!this.uniforms.linewidth) return;\n    this.uniforms.linewidth.value = value;\n  }\n  get dashed() {\n    return \"USE_DASH\" in this.defines;\n  }\n  set dashed(value) {\n    if (value === true !== this.dashed) {\n      this.needsUpdate = true;\n    }\n    if (value === true) {\n      this.defines.USE_DASH = \"\";\n    } else {\n      delete this.defines.USE_DASH;\n    }\n  }\n  get dashScale() {\n    return this.uniforms.dashScale.value;\n  }\n  set dashScale(value) {\n    this.uniforms.dashScale.value = value;\n  }\n  get dashSize() {\n    return this.uniforms.dashSize.value;\n  }\n  set dashSize(value) {\n    this.uniforms.dashSize.value = value;\n  }\n  get dashOffset() {\n    return this.uniforms.dashOffset.value;\n  }\n  set dashOffset(value) {\n    this.uniforms.dashOffset.value = value;\n  }\n  get gapSize() {\n    return this.uniforms.gapSize.value;\n  }\n  set gapSize(value) {\n    this.uniforms.gapSize.value = value;\n  }\n  get opacity() {\n    return this.uniforms.opacity.value;\n  }\n  set opacity(value) {\n    if (!this.uniforms) return;\n    this.uniforms.opacity.value = value;\n  }\n  get resolution() {\n    return this.uniforms.resolution.value;\n  }\n  set resolution(value) {\n    this.uniforms.resolution.value.copy(value);\n  }\n  get alphaToCoverage() {\n    return \"USE_ALPHA_TO_COVERAGE\" in this.defines;\n  }\n  set alphaToCoverage(value) {\n    if (!this.defines) return;\n    if (value === true !== this.alphaToCoverage) {\n      this.needsUpdate = true;\n    }\n    if (value === true) {\n      this.defines.USE_ALPHA_TO_COVERAGE = \"\";\n    } else {\n      delete this.defines.USE_ALPHA_TO_COVERAGE;\n    }\n  }\n}\nconst _box$1 = new Box3();\nconst _vector = new Vector3();\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.isLineSegmentsGeometry = true;\n    this.type = \"LineSegmentsGeometry\";\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  setPositions(array) {\n    let lineSegments;\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);\n    this.setAttribute(\"instanceStart\", new InterleavedBufferAttribute(instanceBuffer, 3, 0));\n    this.setAttribute(\"instanceEnd\", new InterleavedBufferAttribute(instanceBuffer, 3, 3));\n    this.instanceCount = this.attributes.instanceStart.count;\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n  setColors(array) {\n    let colors;\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1);\n    this.setAttribute(\"instanceColorStart\", new InterleavedBufferAttribute(instanceColorBuffer, 3, 0));\n    this.setAttribute(\"instanceColorEnd\", new InterleavedBufferAttribute(instanceColorBuffer, 3, 3));\n    return this;\n  }\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));\n    return this;\n  }\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      this.boundingBox.setFromBufferAttribute(start);\n      _box$1.setFromBufferAttribute(end);\n      this.boundingBox.union(_box$1);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n        _vector.fromBufferAttribute(end, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\"THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.\", this);\n      }\n    }\n  }\n  toJSON() {\n  }\n  applyMatrix(matrix) {\n    console.warn(\"THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n}\nconst _viewport = new Vector4();\nconst _start = new Vector3();\nconst _end = new Vector3();\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\nlet _ray, _lineWidth;\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  _clipToWorldVector.set(0, 0, -distance, 1).applyMatrix4(camera.projectionMatrix);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\nfunction raycastWorldUnits(lineSegments, intersects2) {\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i);\n    _line.end.fromBufferAttribute(instanceEnd, i);\n    _line.applyMatrix4(matrixWorld);\n    const pointOnLine = new Vector3();\n    const point = new Vector3();\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n    if (isInside) {\n      intersects2.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv1: null\n      });\n    }\n  }\n}\nfunction raycastScreenSpace(lineSegments, camera, intersects2) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  const near = -camera.near;\n  _ray.at(1, _ssOrigin);\n  _ssOrigin.w = 1;\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n  _ssOrigin.applyMatrix4(projectionMatrix);\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n  _ssOrigin3.copy(_ssOrigin);\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n    _end4.fromBufferAttribute(instanceEnd, i);\n    _start4.w = 1;\n    _end4.w = 1;\n    _start4.applyMatrix4(_mvMatrix);\n    _end4.applyMatrix4(_mvMatrix);\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n    if (isBehindCameraNear) {\n      continue;\n    }\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t2 = (_start4.z - near) / deltaDist;\n      _start4.lerp(_end4, t2);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t2 = (_end4.z - near) / deltaDist;\n      _end4.lerp(_start4, t2);\n    }\n    _start4.applyMatrix4(projectionMatrix);\n    _end4.applyMatrix4(projectionMatrix);\n    _start4.multiplyScalar(1 / _start4.w);\n    _end4.multiplyScalar(1 / _end4.w);\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2;\n    _line.start.copy(_start4);\n    _line.start.z = 0;\n    _line.end.copy(_end4);\n    _line.end.z = 0;\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n    _line.at(param, _closestPoint);\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n      _line.end.fromBufferAttribute(instanceEnd, i);\n      _line.start.applyMatrix4(matrixWorld);\n      _line.end.applyMatrix4(matrixWorld);\n      const pointOnLine = new Vector3();\n      const point = new Vector3();\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n      intersects2.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv1: null\n      });\n    }\n  }\n}\nclass LineSegments2 extends Mesh {\n  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {\n    super(geometry, material);\n    this.isLineSegments2 = true;\n    this.type = \"LineSegments2\";\n  }\n  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n  computeLineDistances() {\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n      _end.fromBufferAttribute(instanceEnd, i);\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);\n    geometry.setAttribute(\"instanceDistanceStart\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));\n    geometry.setAttribute(\"instanceDistanceEnd\", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));\n    return this;\n  }\n  raycast(raycaster, intersects2) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n    if (camera === null && !worldUnits) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n    }\n    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n    let sphereMargin;\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n    _sphere.radius += sphereMargin;\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    }\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n    let boxMargin;\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n    _box.expandByScalar(boxMargin);\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects2);\n    } else {\n      raycastScreenSpace(this, camera, intersects2);\n    }\n  }\n  onBeforeRender(renderer) {\n    const uniforms2 = this.material.uniforms;\n    if (uniforms2 && uniforms2.resolution) {\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n    }\n  }\n}\nclass ColoredShadowMaterial extends ShaderMaterial {\n  get color() {\n    return this.uniforms.diffuse.value;\n  }\n  get shadowColor() {\n    return this.uniforms.shadowColor.value;\n  }\n  set shininess(v) {\n    this.uniforms.shininess.value = v;\n  }\n  get shininess() {\n    return this.uniforms.shininess.value;\n  }\n  constructor(options) {\n    super({\n      uniforms: UniformsUtils.merge([\n        ShaderLib.phong.uniforms,\n        {\n          shadowColor: {\n            value: new Color(16711680)\n          }\n        }\n      ]),\n      vertexShader: `\n\t\t\t\t#define PHONG\n\t\t\t\tvarying vec3 vViewPosition;\n\t\t\t\t#ifndef FLAT_SHADED\n\t\t\t\t\tvarying vec3 vNormal;\n\t\t\t\t#endif\n\t\t\t\t#include <common>\n\t\t\t\t#include <uv_pars_vertex>\n\t\t\t\t#include <uv2_pars_vertex>\n\t\t\t\t#include <displacementmap_pars_vertex>\n\t\t\t\t#include <envmap_pars_vertex>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <uv_vertex>\n\t\t\t\t\t#include <uv2_vertex>\n\t\t\t\t\t#include <color_vertex>\n\t\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t\t#include <morphnormal_vertex>\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <skinnormal_vertex>\n\t\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#ifndef FLAT_SHADED\n\t\t\t\t\tvNormal = normalize( transformedNormal );\n\t\t\t\t#endif\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <displacementmap_vertex>\n\t\t\t\t\t#include <project_vertex>\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\tvViewPosition = - mvPosition.xyz;\n\t\t\t\t\t#include <worldpos_vertex>\n\t\t\t\t\t#include <envmap_vertex>\n\t\t\t\t\t#include <shadowmap_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t`,\n      fragmentShader: `\n\t\t\t\t#define PHONG\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform vec3 emissive;\n\t\t\t\tuniform vec3 specular;\n\t\t\t\tuniform float shininess;\n\t\t\t\tuniform float opacity;\n\t\t\t\tuniform vec3 shadowColor;\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <dithering_pars_fragment>\n\t\t\t\t#include <color_pars_fragment>\n\t\t\t\t#include <uv_pars_fragment>\n\t\t\t\t#include <uv2_pars_fragment>\n\t\t\t\t#include <map_pars_fragment>\n\t\t\t\t#include <alphamap_pars_fragment>\n\t\t\t\t#include <aomap_pars_fragment>\n\t\t\t\t#include <lightmap_pars_fragment>\n\t\t\t\t#include <emissivemap_pars_fragment>\n\t\t\t\t#include <envmap_common_pars_fragment>\n\t\t\t\t#include <envmap_pars_fragment>\n\t\t\t\t#include <cube_uv_reflection_fragment>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <lights_phong_pars_fragment>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <bumpmap_pars_fragment>\n\t\t\t\t#include <normalmap_pars_fragment>\n\t\t\t\t#include <specularmap_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\t\tvec4 diffuseColor = vec4( 1.0, 1.0, 1.0, opacity );\n\t\t\t\t\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t\t\t\t\tvec3 totalEmissiveRadiance = emissive;\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\t#include <map_fragment>\n\t\t\t\t\t#include <color_fragment>\n\t\t\t\t\t#include <alphamap_fragment>\n\t\t\t\t\t#include <alphatest_fragment>\n\t\t\t\t\t#include <specularmap_fragment>\n\t\t\t\t\t#include <normal_fragment_begin>\n\t\t\t\t\t#include <normal_fragment_maps>\n\t\t\t\t\t#include <emissivemap_fragment>\n\t\t\t\t\t#include <lights_phong_fragment>\n\t\t\t\t\t#include <lights_fragment_begin>\n\t\t\t\t\t#include <lights_fragment_maps>\n\t\t\t\t\t#include <lights_fragment_end>\n\t\t\t\t\t#include <aomap_fragment>\n\t\t\t\t\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t\t\t\t\t#include <envmap_fragment>\n\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t\t\t#include <dithering_fragment>\n\n\t\t\t\t\tgl_FragColor.rgb = mix(\n\t\t\t\t\t\tshadowColor.rgb,\n\t\t\t\t\t\tdiffuse.rgb,\n\t\t\t\t\t\tmin( gl_FragColor.r, 1.0 )\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t`\n    });\n    Object.defineProperties(this, {\n      opacity: {\n        set(v) {\n          this.uniforms.opacity.value = v;\n        },\n        get() {\n          return this.uniforms.opacity.value;\n        }\n      }\n    });\n    this.setValues(options);\n    this.lights = true;\n  }\n}\nconst vec0 = new Vector3();\nconst vec1 = new Vector3();\nconst vec2 = new Vector3();\nconst vec3 = new Vector3();\nconst vec4 = new Vector3();\nconst triangle0 = new Triangle();\nconst triangle1 = new Triangle();\nconst normal0 = new Vector3();\nconst normal1 = new Vector3();\nclass ConditionalEdgesGeometry extends BufferGeometry {\n  constructor(geometry) {\n    super();\n    const edgeInfo = {};\n    const position = geometry.attributes.position;\n    let index;\n    if (geometry.index) {\n      index = geometry.index;\n    } else {\n      const arr = new Array(position.count / 3).fill().map((_, i) => i);\n      index = new BufferAttribute(new Uint32Array(arr), 1, false);\n    }\n    for (let i = 0, l = index.count; i < l; i += 3) {\n      const indices = [index.getX(i + 0), index.getX(i + 1), index.getX(i + 2)];\n      for (let j = 0; j < 3; j++) {\n        const index0 = indices[j];\n        const index1 = indices[(j + 1) % 3];\n        const hash = `${index0}_${index1}`;\n        const reverseHash = `${index1}_${index0}`;\n        if (reverseHash in edgeInfo) {\n          edgeInfo[reverseHash].controlIndex1 = indices[(j + 2) % 3];\n          edgeInfo[reverseHash].tri1 = i / 3;\n        } else {\n          edgeInfo[hash] = {\n            index0,\n            index1,\n            controlIndex0: indices[(j + 2) % 3],\n            controlIndex1: null,\n            tri0: i / 3,\n            tri1: null\n          };\n        }\n      }\n    }\n    const edgePositions = [];\n    const edgeDirections = [];\n    const edgeControl0 = [];\n    const edgeControl1 = [];\n    for (const key in edgeInfo) {\n      const { index0, index1, controlIndex0, controlIndex1, tri0, tri1 } = edgeInfo[key];\n      if (controlIndex1 === null) {\n        continue;\n      }\n      triangle0.a.fromBufferAttribute(position, index.getX(tri0 * 3 + 0));\n      triangle0.b.fromBufferAttribute(position, index.getX(tri0 * 3 + 1));\n      triangle0.c.fromBufferAttribute(position, index.getX(tri0 * 3 + 2));\n      triangle1.a.fromBufferAttribute(position, index.getX(tri1 * 3 + 0));\n      triangle1.b.fromBufferAttribute(position, index.getX(tri1 * 3 + 1));\n      triangle1.c.fromBufferAttribute(position, index.getX(tri1 * 3 + 2));\n      triangle0.getNormal(normal0).normalize();\n      triangle1.getNormal(normal1).normalize();\n      if (normal0.dot(normal1) < 0.01) {\n        continue;\n      }\n      vec0.fromBufferAttribute(position, index0);\n      vec1.fromBufferAttribute(position, index1);\n      vec2.subVectors(vec0, vec1);\n      vec3.fromBufferAttribute(position, controlIndex0);\n      vec4.fromBufferAttribute(position, controlIndex1);\n      edgePositions.push(vec0.x, vec0.y, vec0.z);\n      edgeDirections.push(vec2.x, vec2.y, vec2.z);\n      edgeControl0.push(vec3.x, vec3.y, vec3.z);\n      edgeControl1.push(vec4.x, vec4.y, vec4.z);\n      edgePositions.push(vec1.x, vec1.y, vec1.z);\n      edgeDirections.push(vec2.x, vec2.y, vec2.z);\n      edgeControl0.push(vec3.x, vec3.y, vec3.z);\n      edgeControl1.push(vec4.x, vec4.y, vec4.z);\n    }\n    this.setAttribute(\n      \"position\",\n      new BufferAttribute(new Float32Array(edgePositions), 3, false)\n    );\n    this.setAttribute(\n      \"direction\",\n      new BufferAttribute(new Float32Array(edgeDirections), 3, false)\n    );\n    this.setAttribute(\n      \"control0\",\n      new BufferAttribute(new Float32Array(edgeControl0), 3, false)\n    );\n    this.setAttribute(\n      \"control1\",\n      new BufferAttribute(new Float32Array(edgeControl1), 3, false)\n    );\n  }\n}\nconst ConditionalEdgesShader = {\n  uniforms: {\n    diffuse: {\n      value: new Color()\n    },\n    opacity: {\n      value: 1\n    }\n  },\n  vertexShader: (\n    /* glsl */\n    `\n\t\tattribute vec3 control0;\n\t\tattribute vec3 control1;\n\t\tattribute vec3 direction;\n\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\t\tvoid main() {\n\n\t\t\t#include <color_vertex>\n\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\tc0 /= c0.w;\n\t\t\tc1 /= c1.w;\n\t\t\tp0 /= p0.w;\n\t\t\tp1 /= p1.w;\n\n\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t// Get control point directions from the line\n\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t// from the line segment then the line should not be drawn.\n\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\tfloat discardFlag = float( sign( d0 ) != sign( d1 ) );\n\t\t\tgl_Position = discardFlag > 0.5 ? c0 : gl_Position;\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t`\n  )\n};\nconst uniforms = {\n  linewidth: { value: 1 },\n  resolution: { value: new Vector2(1, 1) },\n  dashScale: { value: 1 },\n  dashSize: { value: 1 },\n  gapSize: { value: 1 },\n  // todo FIX - maybe change to totalSize\n  opacity: { value: 1 }\n};\nconst shader = {\n  uniforms: UniformsUtils.merge([\n    UniformsLib.common,\n    UniformsLib.fog,\n    uniforms\n  ]),\n  vertexShader: (\n    /* glsl */\n    `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 control0;\n\t\tattribute vec3 control1;\n\t\tattribute vec3 direction;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t\t// conditional logic\n\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( instanceStart + direction, 1.0 );\n\n\t\t\tc0 /= c0.w;\n\t\t\tc1 /= c1.w;\n\t\t\tp0 /= p0.w;\n\t\t\tp1 /= p1.w;\n\n\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\tvec2 segDir = p1.xy - p0.xy;\n\t\t\tvec2 norm = vec2( - segDir.y, segDir.x );\n\n\t\t\t// Get control point directions from the line\n\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t// from the line segment then the line should not be drawn.\n\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\tfloat discardFlag = float( sign( d0 ) != sign( d1 ) );\n\t\t\tgl_Position = discardFlag > 0.5 ? c0 : gl_Position;\n\t\t\t// end conditional line logic\n\n\t\t}\n\t\t`\n  ),\n  fragmentShader: (\n    /* glsl */\n    `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n  )\n};\nclass ConditionalLineMaterial extends LineMaterial {\n  constructor(parameters) {\n    super({\n      type: \"ConditionalLineMaterial\",\n      uniforms: UniformsUtils.clone(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      clipping: true\n      // required for clipping support\n    });\n    this.dashed = false;\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.diffuse.value;\n        },\n        set: function(value) {\n          this.uniforms.diffuse.value = value;\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.linewidth.value;\n        },\n        set: function(value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.dashScale.value;\n        },\n        set: function(value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.dashSize.value;\n        },\n        set: function(value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.gapSize.value;\n        },\n        set: function(value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.opacity.value;\n        },\n        set: function(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function() {\n          return this.uniforms.resolution.value;\n        },\n        set: function(value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n}\nConditionalLineMaterial.prototype.isConditionalLineMaterial = true;\nclass ConditionalLineSegmentsGeometry extends LineSegmentsGeometry {\n  fromConditionalEdgesGeometry(geometry) {\n    super.fromEdgesGeometry(geometry);\n    const { direction, control0, control1 } = geometry.attributes;\n    this.setAttribute(\n      \"direction\",\n      new InterleavedBufferAttribute(\n        new InstancedInterleavedBuffer(direction.array, 6, 1),\n        3,\n        0\n      )\n    );\n    this.setAttribute(\n      \"control0\",\n      new InterleavedBufferAttribute(\n        new InstancedInterleavedBuffer(control0.array, 6, 1),\n        3,\n        0\n      )\n    );\n    this.setAttribute(\n      \"control1\",\n      new InterleavedBufferAttribute(\n        new InstancedInterleavedBuffer(control1.array, 6, 1),\n        3,\n        0\n      )\n    );\n    return this;\n  }\n}\nvar __defProp$a = Object.defineProperty;\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$a = (obj, key, value) => __defNormalProp$a(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass SceneModelManager {\n  constructor(scene, renderer, eventManager, getActiveCamera, setupCamera, options) {\n    var _a2, _b2;\n    __publicField$a(this, \"currentModel\", null);\n    __publicField$a(this, \"originalModel\", null);\n    __publicField$a(this, \"originalRotation\", null);\n    __publicField$a(this, \"currentUpDirection\", \"original\");\n    __publicField$a(this, \"materialMode\", \"original\");\n    __publicField$a(this, \"originalMaterials\", /* @__PURE__ */ new WeakMap());\n    __publicField$a(this, \"normalMaterial\");\n    __publicField$a(this, \"standardMaterial\");\n    __publicField$a(this, \"wireframeMaterial\");\n    __publicField$a(this, \"depthMaterial\");\n    __publicField$a(this, \"originalFileName\", null);\n    __publicField$a(this, \"originalURL\", null);\n    __publicField$a(this, \"appliedTexture\", null);\n    __publicField$a(this, \"textureLoader\");\n    __publicField$a(this, \"scene\");\n    __publicField$a(this, \"renderer\");\n    __publicField$a(this, \"eventManager\");\n    __publicField$a(this, \"activeCamera\");\n    __publicField$a(this, \"setupCamera\");\n    __publicField$a(this, \"lineartModel\");\n    __publicField$a(this, \"createLineartModel\", false);\n    __publicField$a(this, \"LIGHT_MODEL\", 16777215);\n    __publicField$a(this, \"LIGHT_LINES\", 4545124);\n    __publicField$a(this, \"conditionalModel\", null);\n    __publicField$a(this, \"edgesModel\", null);\n    __publicField$a(this, \"backgroundModel\", null);\n    __publicField$a(this, \"shadowModel\", null);\n    __publicField$a(this, \"depthModel\", null);\n    this.scene = scene;\n    this.renderer = renderer;\n    this.eventManager = eventManager;\n    this.activeCamera = getActiveCamera();\n    this.setupCamera = setupCamera;\n    this.textureLoader = new TextureLoader();\n    if (options && !((_a2 = options.inputSpec) == null ? void 0 : _a2.isPreview) && !((_b2 = options.inputSpec) == null ? void 0 : _b2.isAnimation)) {\n      this.createLineartModel = true;\n    }\n    this.normalMaterial = new MeshNormalMaterial({\n      flatShading: false,\n      side: DoubleSide,\n      normalScale: new Vector2(1, 1),\n      transparent: false,\n      opacity: 1\n    });\n    this.wireframeMaterial = new MeshBasicMaterial({\n      color: 16777215,\n      wireframe: true,\n      transparent: false,\n      opacity: 1\n    });\n    this.depthMaterial = new MeshDepthMaterial({\n      depthPacking: BasicDepthPacking,\n      side: DoubleSide\n    });\n    this.standardMaterial = this.createSTLMaterial();\n    this.lineartModel = new Group();\n    this.lineartModel.name = \"lineartModel\";\n  }\n  init() {\n  }\n  dispose() {\n    this.clearModel();\n    this.normalMaterial.dispose();\n    this.standardMaterial.dispose();\n    this.wireframeMaterial.dispose();\n    this.depthMaterial.dispose();\n    if (this.appliedTexture) {\n      this.appliedTexture.dispose();\n      this.appliedTexture = null;\n    }\n    this.disposeLineartModel();\n  }\n  createSTLMaterial() {\n    return new MeshStandardMaterial({\n      color: 8421504,\n      metalness: 0.1,\n      roughness: 0.8,\n      flatShading: false,\n      side: DoubleSide\n    });\n  }\n  disposeLineartModel() {\n    this.disposeEdgesModel();\n    this.disposeShadowModel();\n    this.disposeBackgroundModel();\n    this.disposeDepthModel();\n    this.disposeConditionalModel();\n  }\n  disposeEdgesModel() {\n    if (this.edgesModel) {\n      if (this.edgesModel.parent) {\n        this.edgesModel.parent.remove(this.edgesModel);\n      }\n      this.edgesModel.traverse((child) => {\n        if (child instanceof Mesh) {\n          if (Array.isArray(child.material)) {\n            child.material.forEach((m) => m.dispose());\n          } else {\n            child.material.dispose();\n          }\n        }\n      });\n    }\n  }\n  initEdgesModel() {\n    this.disposeEdgesModel();\n    if (!this.currentModel) {\n      return;\n    }\n    this.edgesModel = this.currentModel.clone();\n    this.lineartModel.add(this.edgesModel);\n    const meshes = [];\n    this.edgesModel.traverse((child) => {\n      if (child instanceof Mesh) {\n        meshes.push(child);\n      }\n    });\n    for (const key in meshes) {\n      const mesh = meshes[key];\n      const parent = mesh.parent;\n      let lineGeom = new EdgesGeometry(mesh.geometry, 85);\n      const line = new LineSegments(\n        lineGeom,\n        new LineBasicMaterial({ color: this.LIGHT_LINES })\n      );\n      line.position.copy(mesh.position);\n      line.scale.copy(mesh.scale);\n      line.rotation.copy(mesh.rotation);\n      const thickLineGeom = new LineSegmentsGeometry().fromEdgesGeometry(\n        lineGeom\n      );\n      const thickLines = new LineSegments2(\n        thickLineGeom,\n        new LineMaterial({ color: this.LIGHT_LINES, linewidth: 13 })\n      );\n      thickLines.position.copy(mesh.position);\n      thickLines.scale.copy(mesh.scale);\n      thickLines.rotation.copy(mesh.rotation);\n      parent == null ? void 0 : parent.remove(mesh);\n      parent == null ? void 0 : parent.add(line);\n      parent == null ? void 0 : parent.add(thickLines);\n    }\n    this.edgesModel.traverse((child) => {\n      if (child instanceof Mesh && child.material && child.material.resolution) {\n        this.renderer.getSize(child.material.resolution);\n        child.material.resolution.multiplyScalar(window.devicePixelRatio);\n        child.material.linewidth = 1;\n      }\n    });\n  }\n  setEdgeThreshold(threshold) {\n    if (!this.edgesModel || !this.currentModel) {\n      return;\n    }\n    const linesToRemove = [];\n    this.edgesModel.traverse((child) => {\n      if (child instanceof LineSegments || child instanceof LineSegments2) {\n        linesToRemove.push(child);\n      }\n    });\n    for (const line of linesToRemove) {\n      if (line.parent) {\n        line.parent.remove(line);\n      }\n    }\n    const meshes = [];\n    this.currentModel.traverse((child) => {\n      if (child instanceof Mesh) {\n        meshes.push(child);\n      }\n    });\n    for (const mesh of meshes) {\n      const meshClone = mesh.clone();\n      let lineGeom = new EdgesGeometry(meshClone.geometry, threshold);\n      const line = new LineSegments(\n        lineGeom,\n        new LineBasicMaterial({ color: this.LIGHT_LINES })\n      );\n      line.position.copy(mesh.position);\n      line.scale.copy(mesh.scale);\n      line.rotation.copy(mesh.rotation);\n      const thickLineGeom = new LineSegmentsGeometry().fromEdgesGeometry(\n        lineGeom\n      );\n      const thickLines = new LineSegments2(\n        thickLineGeom,\n        new LineMaterial({ color: this.LIGHT_LINES, linewidth: 13 })\n      );\n      thickLines.position.copy(mesh.position);\n      thickLines.scale.copy(mesh.scale);\n      thickLines.rotation.copy(mesh.rotation);\n      this.edgesModel.add(line);\n      this.edgesModel.add(thickLines);\n    }\n    this.edgesModel.traverse((child) => {\n      if (child instanceof Mesh && child.material && child.material.resolution) {\n        this.renderer.getSize(child.material.resolution);\n        child.material.resolution.multiplyScalar(window.devicePixelRatio);\n        child.material.linewidth = 1;\n      }\n    });\n    this.eventManager.emitEvent(\"edgeThresholdChange\", threshold);\n  }\n  disposeBackgroundModel() {\n    if (this.backgroundModel) {\n      if (this.backgroundModel.parent) {\n        this.backgroundModel.parent.remove(this.backgroundModel);\n      }\n      this.backgroundModel.traverse((child) => {\n        if (child instanceof Mesh) {\n          child.material.dispose();\n        }\n      });\n    }\n  }\n  disposeShadowModel() {\n    if (this.shadowModel) {\n      if (this.shadowModel.parent) {\n        this.shadowModel.parent.remove(this.shadowModel);\n      }\n      this.shadowModel.traverse((child) => {\n        if (child instanceof Mesh) {\n          child.material.dispose();\n        }\n      });\n    }\n  }\n  disposeDepthModel() {\n    if (this.depthModel) {\n      if (this.depthModel.parent) {\n        this.depthModel.parent.remove(this.depthModel);\n      }\n      this.depthModel.traverse((child) => {\n        if (child instanceof Mesh) {\n          child.material.dispose();\n        }\n      });\n    }\n  }\n  disposeConditionalModel() {\n    if (this.conditionalModel) {\n      if (this.conditionalModel.parent) {\n        this.conditionalModel.parent.remove(this.conditionalModel);\n      }\n      this.conditionalModel.traverse((child) => {\n        if (child instanceof Mesh) {\n          child.material.dispose();\n        }\n      });\n    }\n  }\n  initBackgroundModel() {\n    this.disposeBackgroundModel();\n    this.disposeShadowModel();\n    this.disposeDepthModel();\n    if (!this.currentModel) {\n      return;\n    }\n    this.backgroundModel = this.currentModel.clone();\n    this.backgroundModel.visible = true;\n    this.backgroundModel.traverse((child) => {\n      if (child instanceof Mesh) {\n        child.material = new MeshBasicMaterial({\n          color: this.LIGHT_MODEL\n        });\n        child.material.polygonOffset = true;\n        child.material.polygonOffsetFactor = 1;\n        child.material.polygonOffsetUnits = 1;\n        child.renderOrder = 2;\n        child.material.transparent = false;\n        child.material.opacity = 0.25;\n      }\n    });\n    this.lineartModel.add(this.backgroundModel);\n    this.shadowModel = this.currentModel.clone();\n    this.shadowModel.visible = false;\n    this.shadowModel.traverse((child) => {\n      if (child instanceof Mesh) {\n        child.material = new ColoredShadowMaterial({\n          color: this.LIGHT_MODEL,\n          shininess: 1\n        });\n        child.material.polygonOffset = true;\n        child.material.polygonOffsetFactor = 1;\n        child.material.polygonOffsetUnits = 1;\n        child.receiveShadow = true;\n        child.renderOrder = 2;\n      }\n    });\n    this.lineartModel.add(this.shadowModel);\n    this.depthModel = this.currentModel.clone();\n    this.depthModel.visible = true;\n    this.depthModel.traverse((child) => {\n      if (child instanceof Mesh) {\n        child.material = new MeshBasicMaterial({\n          color: this.LIGHT_MODEL\n        });\n        child.material.polygonOffset = true;\n        child.material.polygonOffsetFactor = 1;\n        child.material.polygonOffsetUnits = 1;\n        child.material.colorWrite = false;\n        child.renderOrder = 1;\n      }\n    });\n    this.lineartModel.add(this.depthModel);\n  }\n  initConditionalModel() {\n    this.disposeConditionalModel();\n    if (!this.currentModel) {\n      return;\n    }\n    this.conditionalModel = this.currentModel.clone();\n    this.lineartModel.add(this.conditionalModel);\n    this.conditionalModel.visible = true;\n    const meshes = [];\n    this.conditionalModel.traverse((child) => {\n      if (child instanceof Mesh) {\n        meshes.push(child);\n      }\n    });\n    for (const key in meshes) {\n      const mesh = meshes[key];\n      const parent = mesh.parent;\n      const mergedGeom = mesh.geometry.clone();\n      for (const key2 in mergedGeom.attributes) {\n        if (key2 !== \"position\") {\n          mergedGeom.deleteAttribute(key2);\n        }\n      }\n      const lineGeom = new ConditionalEdgesGeometry(mergeVertices(mergedGeom));\n      const material = new ShaderMaterial(ConditionalEdgesShader);\n      material.uniforms.diffuse.value.set(this.LIGHT_LINES);\n      const line = new LineSegments(lineGeom, material);\n      line.position.copy(mesh.position);\n      line.scale.copy(mesh.scale);\n      line.rotation.copy(mesh.rotation);\n      const thickLineGeom = new ConditionalLineSegmentsGeometry().fromConditionalEdgesGeometry(\n        lineGeom\n      );\n      const conditionalLineMaterial = new ConditionalLineMaterial({\n        color: this.LIGHT_LINES,\n        linewidth: 2\n      });\n      const thickLines = new LineSegments2(\n        thickLineGeom,\n        conditionalLineMaterial\n      );\n      thickLines.position.copy(mesh.position);\n      thickLines.scale.copy(mesh.scale);\n      thickLines.rotation.copy(mesh.rotation);\n      parent == null ? void 0 : parent.remove(mesh);\n      parent == null ? void 0 : parent.add(line);\n      parent == null ? void 0 : parent.add(thickLines);\n    }\n    this.conditionalModel.traverse((child) => {\n      if (child instanceof Mesh && child.material && child.material.resolution) {\n        this.renderer.getSize(child.material.resolution);\n        child.material.resolution.multiplyScalar(window.devicePixelRatio);\n        child.material.linewidth = 1;\n      }\n    });\n  }\n  setMaterialMode(mode) {\n    if (!this.currentModel || mode === this.materialMode) {\n      return;\n    }\n    this.materialMode = mode;\n    if (mode === \"depth\") {\n      this.renderer.outputColorSpace = LinearSRGBColorSpace;\n    } else {\n      this.renderer.outputColorSpace = SRGBColorSpace;\n    }\n    if (this.currentModel) {\n      this.currentModel.visible = mode !== \"lineart\";\n    }\n    if (this.lineartModel) {\n      this.lineartModel.visible = mode === \"lineart\";\n    }\n    this.currentModel.traverse((child) => {\n      if (child instanceof Mesh) {\n        switch (mode) {\n          case \"depth\":\n            if (!this.originalMaterials.has(child)) {\n              this.originalMaterials.set(child, child.material);\n            }\n            const depthMat = new MeshDepthMaterial({\n              depthPacking: BasicDepthPacking,\n              side: DoubleSide\n            });\n            depthMat.onBeforeCompile = (shader2) => {\n              shader2.uniforms.cameraType = {\n                value: this.activeCamera instanceof OrthographicCamera ? 1 : 0\n              };\n              shader2.fragmentShader = `\n                uniform float cameraType;\n                ${shader2.fragmentShader}\n              `;\n              shader2.fragmentShader = shader2.fragmentShader.replace(\n                /gl_FragColor\\s*=\\s*vec4\\(\\s*vec3\\(\\s*1.0\\s*-\\s*fragCoordZ\\s*\\)\\s*,\\s*opacity\\s*\\)\\s*;/,\n                `\n                  float depth = 1.0 - fragCoordZ;\n                  if (cameraType > 0.5) {\n                    depth = pow(depth, 400.0);\n                  } else {\n                    depth = pow(depth, 0.6);\n                  }\n                  gl_FragColor = vec4(vec3(depth), opacity);\n                `\n              );\n            };\n            depthMat.customProgramCacheKey = () => {\n              return this.activeCamera instanceof OrthographicCamera ? \"ortho\" : \"persp\";\n            };\n            child.material = depthMat;\n            break;\n          case \"normal\":\n            if (!this.originalMaterials.has(child)) {\n              this.originalMaterials.set(child, child.material);\n            }\n            child.material = new MeshNormalMaterial({\n              flatShading: false,\n              side: DoubleSide,\n              normalScale: new Vector2(1, 1),\n              transparent: false,\n              opacity: 1\n            });\n            break;\n          case \"wireframe\":\n            if (!this.originalMaterials.has(child)) {\n              this.originalMaterials.set(child, child.material);\n            }\n            child.material = new MeshBasicMaterial({\n              color: 16777215,\n              wireframe: true,\n              transparent: false,\n              opacity: 1\n            });\n            break;\n          case \"original\":\n            const originalMaterial = this.originalMaterials.get(child);\n            if (originalMaterial) {\n              child.material = originalMaterial;\n            } else {\n              if (this.appliedTexture) {\n                child.material = new MeshStandardMaterial({\n                  map: this.appliedTexture,\n                  metalness: 0.1,\n                  roughness: 0.8,\n                  side: DoubleSide\n                });\n              } else {\n                child.material = this.standardMaterial;\n              }\n            }\n            break;\n        }\n      }\n    });\n    this.eventManager.emitEvent(\"materialModeChange\", mode);\n  }\n  setupModelMaterials(model) {\n    model.traverse((child) => {\n      if (child instanceof Mesh) {\n        this.originalMaterials.set(child, child.material);\n      }\n    });\n    this.setMaterialMode(\"original\");\n  }\n  clearModel() {\n    const objectsToRemove = [];\n    this.scene.traverse((object) => {\n      const isEnvironmentObject = object instanceof GridHelper || object instanceof Light || object instanceof Camera;\n      if (!isEnvironmentObject) {\n        objectsToRemove.push(object);\n      }\n    });\n    objectsToRemove.forEach((obj) => {\n      var _a2, _b2;\n      if (obj.parent && obj.parent !== this.scene) {\n        obj.parent.remove(obj);\n      } else {\n        this.scene.remove(obj);\n      }\n      if (obj instanceof Mesh) {\n        (_a2 = obj.geometry) == null ? void 0 : _a2.dispose();\n        if (Array.isArray(obj.material)) {\n          obj.material.forEach((material) => material.dispose());\n        } else {\n          (_b2 = obj.material) == null ? void 0 : _b2.dispose();\n        }\n      }\n    });\n    this.reset();\n  }\n  reset() {\n    this.currentModel = null;\n    this.originalRotation = null;\n    this.currentUpDirection = \"original\";\n    this.setMaterialMode(\"original\");\n    this.originalFileName = null;\n    this.originalURL = null;\n    if (this.appliedTexture) {\n      this.appliedTexture.dispose();\n      this.appliedTexture = null;\n    }\n    this.originalMaterials = /* @__PURE__ */ new WeakMap();\n  }\n  addModelToScene(model) {\n    this.currentModel = model;\n    this.scene.add(this.currentModel);\n  }\n  async setupModel(model) {\n    this.currentModel = model;\n    const box = new Box3().setFromObject(model);\n    const size = box.getSize(new Vector3());\n    const center = box.getCenter(new Vector3());\n    const maxDim = Math.max(size.x, size.y, size.z);\n    const targetSize = 5;\n    const scale = targetSize / maxDim;\n    model.scale.multiplyScalar(scale);\n    box.setFromObject(model);\n    box.getCenter(center);\n    box.getSize(size);\n    model.position.set(-center.x, -box.min.y, -center.z);\n    this.scene.add(model);\n    if (this.materialMode !== \"original\") {\n      this.setMaterialMode(this.materialMode);\n    }\n    if (this.currentUpDirection !== \"original\") {\n      this.setUpDirection(this.currentUpDirection);\n    }\n    this.setupModelMaterials(model);\n    this.setupCamera(size);\n    if (this.createLineartModel) {\n      this.setupLineartModel();\n    }\n  }\n  setupLineartModel() {\n    this.scene.add(this.lineartModel);\n    this.initEdgesModel();\n    this.initBackgroundModel();\n    this.initConditionalModel();\n    this.lineartModel.visible = false;\n  }\n  setOriginalModel(model) {\n    this.originalModel = model;\n  }\n  setUpDirection(direction) {\n    if (!this.currentModel) return;\n    if (!this.originalRotation && this.currentModel.rotation) {\n      this.originalRotation = this.currentModel.rotation.clone();\n    }\n    this.currentUpDirection = direction;\n    if (this.originalRotation) {\n      this.currentModel.rotation.copy(this.originalRotation);\n      this.lineartModel.rotation.copy(this.originalRotation);\n    }\n    switch (direction) {\n      case \"original\":\n        break;\n      case \"-x\":\n        this.currentModel.rotation.z = Math.PI / 2;\n        break;\n      case \"+x\":\n        this.currentModel.rotation.z = -Math.PI / 2;\n        break;\n      case \"-y\":\n        this.currentModel.rotation.x = Math.PI;\n        break;\n      case \"+y\":\n        break;\n      case \"-z\":\n        this.currentModel.rotation.x = Math.PI / 2;\n        break;\n      case \"+z\":\n        this.currentModel.rotation.x = -Math.PI / 2;\n        break;\n    }\n    this.lineartModel.rotation.copy(this.currentModel.rotation);\n    this.eventManager.emitEvent(\"upDirectionChange\", direction);\n  }\n}\nclass ViewHelper extends Object3D {\n  constructor(camera, domElement) {\n    super();\n    this.isViewHelper = true;\n    this.animating = false;\n    this.center = new Vector3();\n    const color1 = new Color(\"#ff4466\");\n    const color2 = new Color(\"#88ff44\");\n    const color3 = new Color(\"#4488ff\");\n    const color4 = new Color(\"#000000\");\n    const options = {};\n    const interactiveObjects = [];\n    const raycaster = new Raycaster();\n    const mouse = new Vector2();\n    const dummy = new Object3D();\n    const orthoCamera = new OrthographicCamera(-2, 2, 2, -2, 0, 4);\n    orthoCamera.position.set(0, 0, 2);\n    const geometry = new CylinderGeometry(0.04, 0.04, 0.8, 5).rotateZ(-Math.PI / 2).translate(0.4, 0, 0);\n    const xAxis = new Mesh(geometry, getAxisMaterial(color1));\n    const yAxis = new Mesh(geometry, getAxisMaterial(color2));\n    const zAxis = new Mesh(geometry, getAxisMaterial(color3));\n    yAxis.rotation.z = Math.PI / 2;\n    zAxis.rotation.y = -Math.PI / 2;\n    this.add(xAxis);\n    this.add(zAxis);\n    this.add(yAxis);\n    const spriteMaterial1 = getSpriteMaterial(color1);\n    const spriteMaterial2 = getSpriteMaterial(color2);\n    const spriteMaterial3 = getSpriteMaterial(color3);\n    const spriteMaterial4 = getSpriteMaterial(color4);\n    const posXAxisHelper = new Sprite(spriteMaterial1);\n    const posYAxisHelper = new Sprite(spriteMaterial2);\n    const posZAxisHelper = new Sprite(spriteMaterial3);\n    const negXAxisHelper = new Sprite(spriteMaterial4);\n    const negYAxisHelper = new Sprite(spriteMaterial4);\n    const negZAxisHelper = new Sprite(spriteMaterial4);\n    posXAxisHelper.position.x = 1;\n    posYAxisHelper.position.y = 1;\n    posZAxisHelper.position.z = 1;\n    negXAxisHelper.position.x = -1;\n    negYAxisHelper.position.y = -1;\n    negZAxisHelper.position.z = -1;\n    negXAxisHelper.material.opacity = 0.2;\n    negYAxisHelper.material.opacity = 0.2;\n    negZAxisHelper.material.opacity = 0.2;\n    posXAxisHelper.userData.type = \"posX\";\n    posYAxisHelper.userData.type = \"posY\";\n    posZAxisHelper.userData.type = \"posZ\";\n    negXAxisHelper.userData.type = \"negX\";\n    negYAxisHelper.userData.type = \"negY\";\n    negZAxisHelper.userData.type = \"negZ\";\n    this.add(posXAxisHelper);\n    this.add(posYAxisHelper);\n    this.add(posZAxisHelper);\n    this.add(negXAxisHelper);\n    this.add(negYAxisHelper);\n    this.add(negZAxisHelper);\n    interactiveObjects.push(posXAxisHelper);\n    interactiveObjects.push(posYAxisHelper);\n    interactiveObjects.push(posZAxisHelper);\n    interactiveObjects.push(negXAxisHelper);\n    interactiveObjects.push(negYAxisHelper);\n    interactiveObjects.push(negZAxisHelper);\n    const point = new Vector3();\n    const dim = 128;\n    const turnRate = 2 * Math.PI;\n    this.render = function(renderer) {\n      this.quaternion.copy(camera.quaternion).invert();\n      this.updateMatrixWorld();\n      point.set(0, 0, 1);\n      point.applyQuaternion(camera.quaternion);\n      const x = domElement.offsetWidth - dim;\n      renderer.clearDepth();\n      renderer.getViewport(viewport);\n      renderer.setViewport(x, 0, dim, dim);\n      renderer.render(this, orthoCamera);\n      renderer.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);\n    };\n    const targetPosition = new Vector3();\n    const targetQuaternion = new Quaternion();\n    const q1 = new Quaternion();\n    const q2 = new Quaternion();\n    const viewport = new Vector4();\n    let radius = 0;\n    this.handleClick = function(event) {\n      if (this.animating === true) return false;\n      const rect = domElement.getBoundingClientRect();\n      const offsetX = rect.left + (domElement.offsetWidth - dim);\n      const offsetY = rect.top + (domElement.offsetHeight - dim);\n      mouse.x = (event.clientX - offsetX) / (rect.right - offsetX) * 2 - 1;\n      mouse.y = -((event.clientY - offsetY) / (rect.bottom - offsetY)) * 2 + 1;\n      raycaster.setFromCamera(mouse, orthoCamera);\n      const intersects2 = raycaster.intersectObjects(interactiveObjects);\n      if (intersects2.length > 0) {\n        const intersection = intersects2[0];\n        const object = intersection.object;\n        prepareAnimationData(object, this.center);\n        this.animating = true;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    this.setLabels = function(labelX, labelY, labelZ) {\n      options.labelX = labelX;\n      options.labelY = labelY;\n      options.labelZ = labelZ;\n      updateLabels();\n    };\n    this.setLabelStyle = function(font, color, radius2) {\n      options.font = font;\n      options.color = color;\n      options.radius = radius2;\n      updateLabels();\n    };\n    this.update = function(delta) {\n      const step = delta * turnRate;\n      q1.rotateTowards(q2, step);\n      camera.position.set(0, 0, 1).applyQuaternion(q1).multiplyScalar(radius).add(this.center);\n      camera.quaternion.rotateTowards(targetQuaternion, step);\n      if (q1.angleTo(q2) === 0) {\n        this.animating = false;\n      }\n    };\n    this.dispose = function() {\n      geometry.dispose();\n      xAxis.material.dispose();\n      yAxis.material.dispose();\n      zAxis.material.dispose();\n      posXAxisHelper.material.map.dispose();\n      posYAxisHelper.material.map.dispose();\n      posZAxisHelper.material.map.dispose();\n      negXAxisHelper.material.map.dispose();\n      negYAxisHelper.material.map.dispose();\n      negZAxisHelper.material.map.dispose();\n      posXAxisHelper.material.dispose();\n      posYAxisHelper.material.dispose();\n      posZAxisHelper.material.dispose();\n      negXAxisHelper.material.dispose();\n      negYAxisHelper.material.dispose();\n      negZAxisHelper.material.dispose();\n    };\n    function prepareAnimationData(object, focusPoint) {\n      switch (object.userData.type) {\n        case \"posX\":\n          targetPosition.set(1, 0, 0);\n          targetQuaternion.setFromEuler(new Euler(0, Math.PI * 0.5, 0));\n          break;\n        case \"posY\":\n          targetPosition.set(0, 1, 0);\n          targetQuaternion.setFromEuler(new Euler(-Math.PI * 0.5, 0, 0));\n          break;\n        case \"posZ\":\n          targetPosition.set(0, 0, 1);\n          targetQuaternion.setFromEuler(new Euler());\n          break;\n        case \"negX\":\n          targetPosition.set(-1, 0, 0);\n          targetQuaternion.setFromEuler(new Euler(0, -Math.PI * 0.5, 0));\n          break;\n        case \"negY\":\n          targetPosition.set(0, -1, 0);\n          targetQuaternion.setFromEuler(new Euler(Math.PI * 0.5, 0, 0));\n          break;\n        case \"negZ\":\n          targetPosition.set(0, 0, -1);\n          targetQuaternion.setFromEuler(new Euler(0, Math.PI, 0));\n          break;\n        default:\n          console.error(\"ViewHelper: Invalid axis.\");\n      }\n      radius = camera.position.distanceTo(focusPoint);\n      targetPosition.multiplyScalar(radius).add(focusPoint);\n      dummy.position.copy(focusPoint);\n      dummy.lookAt(camera.position);\n      q1.copy(dummy.quaternion);\n      dummy.lookAt(targetPosition);\n      q2.copy(dummy.quaternion);\n    }\n    function getAxisMaterial(color) {\n      return new MeshBasicMaterial({ color, toneMapped: false });\n    }\n    function getSpriteMaterial(color, text) {\n      const { font = \"24px Arial\", color: labelColor = \"#000000\", radius: radius2 = 14 } = options;\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = 64;\n      canvas.height = 64;\n      const context = canvas.getContext(\"2d\");\n      context.beginPath();\n      context.arc(32, 32, radius2, 0, 2 * Math.PI);\n      context.closePath();\n      context.fillStyle = color.getStyle();\n      context.fill();\n      if (text) {\n        context.font = font;\n        context.textAlign = \"center\";\n        context.fillStyle = labelColor;\n        context.fillText(text, 32, 41);\n      }\n      const texture = new CanvasTexture(canvas);\n      texture.colorSpace = SRGBColorSpace;\n      return new SpriteMaterial({ map: texture, toneMapped: false });\n    }\n    function updateLabels() {\n      posXAxisHelper.material.map.dispose();\n      posYAxisHelper.material.map.dispose();\n      posZAxisHelper.material.map.dispose();\n      posXAxisHelper.material.dispose();\n      posYAxisHelper.material.dispose();\n      posZAxisHelper.material.dispose();\n      posXAxisHelper.material = getSpriteMaterial(color1, options.labelX);\n      posYAxisHelper.material = getSpriteMaterial(color2, options.labelY);\n      posZAxisHelper.material = getSpriteMaterial(color3, options.labelZ);\n    }\n  }\n}\nvar __defProp$9 = Object.defineProperty;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$9 = (obj, key, value) => __defNormalProp$9(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass ViewHelperManager {\n  constructor(renderer, getActiveCamera, getControls, nodeStorage) {\n    __publicField$9(this, \"viewHelper\", {});\n    __publicField$9(this, \"viewHelperContainer\", {});\n    __publicField$9(this, \"getActiveCamera\");\n    __publicField$9(this, \"getControls\");\n    __publicField$9(this, \"nodeStorage\");\n    __publicField$9(this, \"renderer\");\n    this.renderer = renderer;\n    this.getActiveCamera = getActiveCamera;\n    this.getControls = getControls;\n    this.nodeStorage = nodeStorage;\n  }\n  init() {\n  }\n  dispose() {\n    if (this.viewHelper) {\n      this.viewHelper.dispose();\n    }\n    if (this.viewHelperContainer && this.viewHelperContainer.parentNode) {\n      this.viewHelperContainer.parentNode.removeChild(this.viewHelperContainer);\n    }\n  }\n  createViewHelper(container) {\n    this.viewHelperContainer = document.createElement(\"div\");\n    this.viewHelperContainer.style.position = \"absolute\";\n    this.viewHelperContainer.style.bottom = \"0\";\n    this.viewHelperContainer.style.left = \"0\";\n    this.viewHelperContainer.style.width = \"128px\";\n    this.viewHelperContainer.style.height = \"128px\";\n    this.viewHelperContainer.addEventListener(\"pointerup\", (event) => {\n      event.stopPropagation();\n      this.viewHelper.handleClick(event);\n    });\n    this.viewHelperContainer.addEventListener(\"pointerdown\", (event) => {\n      event.stopPropagation();\n    });\n    container.appendChild(this.viewHelperContainer);\n    this.viewHelper = new ViewHelper(\n      this.getActiveCamera(),\n      this.viewHelperContainer\n    );\n    this.viewHelper.center = this.getControls().target;\n  }\n  update(delta) {\n    if (this.viewHelper.animating) {\n      this.viewHelper.update(delta);\n      if (!this.viewHelper.animating) {\n        this.nodeStorage.storeNodeProperty(\"Camera Info\", {\n          position: this.getActiveCamera().position.clone(),\n          target: this.getControls().target.clone(),\n          zoom: this.getActiveCamera() instanceof OrthographicCamera ? this.getActiveCamera().zoom : this.getActiveCamera().zoom,\n          cameraType: this.getActiveCamera() instanceof PerspectiveCamera ? \"perspective\" : \"orthographic\"\n        });\n      }\n    }\n  }\n  handleResize() {\n  }\n  visibleViewHelper(visible) {\n    if (visible) {\n      this.viewHelper.visible = true;\n      this.viewHelperContainer.style.display = \"block\";\n    } else {\n      this.viewHelper.visible = false;\n      this.viewHelperContainer.style.display = \"none\";\n    }\n  }\n  recreateViewHelper() {\n    if (this.viewHelper) {\n      this.viewHelper.dispose();\n    }\n    this.viewHelper = new ViewHelper(\n      this.getActiveCamera(),\n      this.viewHelperContainer\n    );\n    this.viewHelper.center = this.getControls().target;\n  }\n  reset() {\n  }\n}\nvar __defProp$8 = Object.defineProperty;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$8 = (obj, key, value) => __defNormalProp$8(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass Load3d {\n  constructor(container, options = {\n    node: {},\n    inputSpec: {}\n  }) {\n    var _a2, _b2, _c;\n    __publicField$8(this, \"renderer\");\n    __publicField$8(this, \"clock\");\n    __publicField$8(this, \"animationFrameId\", null);\n    __publicField$8(this, \"node\");\n    __publicField$8(this, \"eventManager\");\n    __publicField$8(this, \"nodeStorage\");\n    __publicField$8(this, \"sceneManager\");\n    __publicField$8(this, \"cameraManager\");\n    __publicField$8(this, \"controlsManager\");\n    __publicField$8(this, \"lightingManager\");\n    __publicField$8(this, \"viewHelperManager\");\n    __publicField$8(this, \"previewManager\");\n    __publicField$8(this, \"loaderManager\");\n    __publicField$8(this, \"modelManager\");\n    __publicField$8(this, \"recordingManager\");\n    __publicField$8(this, \"STATUS_MOUSE_ON_NODE\");\n    __publicField$8(this, \"STATUS_MOUSE_ON_SCENE\");\n    __publicField$8(this, \"STATUS_MOUSE_ON_VIEWER\");\n    __publicField$8(this, \"INITIAL_RENDER_DONE\", false);\n    __publicField$8(this, \"targetWidth\", 512);\n    __publicField$8(this, \"targetHeight\", 512);\n    __publicField$8(this, \"targetAspectRatio\", 1);\n    __publicField$8(this, \"isViewerMode\", false);\n    this.node = options.node || {};\n    this.clock = new Clock();\n    this.isViewerMode = options.isViewerMode || false;\n    const widthWidget = (_a2 = this.node.widgets) == null ? void 0 : _a2.find((w) => w.name === \"width\");\n    const heightWidget = (_b2 = this.node.widgets) == null ? void 0 : _b2.find((w) => w.name === \"height\");\n    if (widthWidget && heightWidget) {\n      this.targetWidth = widthWidget.value;\n      this.targetHeight = heightWidget.value;\n      this.targetAspectRatio = this.targetWidth / this.targetHeight;\n    }\n    this.renderer = new WebGLRenderer({ alpha: true, antialias: true });\n    this.renderer.setSize(300, 300);\n    this.renderer.setClearColor(2631720);\n    this.renderer.autoClear = false;\n    this.renderer.outputColorSpace = SRGBColorSpace;\n    container.appendChild(this.renderer.domElement);\n    this.eventManager = new EventManager();\n    this.nodeStorage = new NodeStorage(this.node);\n    this.sceneManager = new SceneManager(\n      this.renderer,\n      this.getActiveCamera.bind(this),\n      this.getControls.bind(this),\n      this.eventManager\n    );\n    this.cameraManager = new CameraManager(\n      this.renderer,\n      this.eventManager,\n      this.nodeStorage\n    );\n    this.controlsManager = new ControlsManager(\n      this.renderer,\n      this.cameraManager.activeCamera,\n      this.eventManager,\n      this.nodeStorage\n    );\n    this.cameraManager.setControls(this.controlsManager.controls);\n    this.lightingManager = new LightingManager(\n      this.sceneManager.scene,\n      this.eventManager\n    );\n    this.viewHelperManager = new ViewHelperManager(\n      this.renderer,\n      this.getActiveCamera.bind(this),\n      this.getControls.bind(this),\n      this.nodeStorage\n    );\n    this.previewManager = new PreviewManager(\n      this.sceneManager.scene,\n      this.getActiveCamera.bind(this),\n      this.getControls.bind(this),\n      () => this.renderer,\n      this.eventManager,\n      this.sceneManager.backgroundScene,\n      this.sceneManager.backgroundCamera\n    );\n    if (options.disablePreview) {\n      this.previewManager.togglePreview(false);\n    }\n    this.modelManager = new SceneModelManager(\n      this.sceneManager.scene,\n      this.renderer,\n      this.eventManager,\n      this.getActiveCamera.bind(this),\n      this.setupCamera.bind(this),\n      options\n    );\n    this.loaderManager = new LoaderManager(this.modelManager, this.eventManager);\n    this.recordingManager = new RecordingManager(\n      this.sceneManager.scene,\n      this.renderer,\n      this.eventManager\n    );\n    this.sceneManager.init();\n    this.cameraManager.init();\n    this.controlsManager.init();\n    this.lightingManager.init();\n    this.loaderManager.init();\n    this.loaderManager.init();\n    this.viewHelperManager.createViewHelper(container);\n    this.viewHelperManager.init();\n    if (options && !((_c = options.inputSpec) == null ? void 0 : _c.isPreview)) {\n      this.previewManager.createCapturePreview(container);\n      this.previewManager.init();\n    }\n    this.STATUS_MOUSE_ON_NODE = false;\n    this.STATUS_MOUSE_ON_SCENE = false;\n    this.STATUS_MOUSE_ON_VIEWER = false;\n    this.handleResize();\n    this.startAnimation();\n    setTimeout(() => {\n      this.forceRender();\n    }, 100);\n  }\n  getEventManager() {\n    return this.eventManager;\n  }\n  getNodeStorage() {\n    return this.nodeStorage;\n  }\n  getSceneManager() {\n    return this.sceneManager;\n  }\n  getCameraManager() {\n    return this.cameraManager;\n  }\n  getControlsManager() {\n    return this.controlsManager;\n  }\n  getLightingManager() {\n    return this.lightingManager;\n  }\n  getViewHelperManager() {\n    return this.viewHelperManager;\n  }\n  getPreviewManager() {\n    return this.previewManager;\n  }\n  getLoaderManager() {\n    return this.loaderManager;\n  }\n  getModelManager() {\n    return this.modelManager;\n  }\n  getRecordingManager() {\n    return this.recordingManager;\n  }\n  forceRender() {\n    const delta = this.clock.getDelta();\n    this.viewHelperManager.update(delta);\n    this.controlsManager.update();\n    this.renderMainScene();\n    if (this.previewManager.showPreview) {\n      this.previewManager.renderPreview();\n    }\n    this.resetViewport();\n    if (this.viewHelperManager.viewHelper.render) {\n      this.viewHelperManager.viewHelper.render(this.renderer);\n    }\n    this.INITIAL_RENDER_DONE = true;\n  }\n  renderMainScene() {\n    const containerWidth = this.renderer.domElement.clientWidth;\n    const containerHeight = this.renderer.domElement.clientHeight;\n    if (this.isViewerMode) {\n      const containerAspectRatio = containerWidth / containerHeight;\n      let renderWidth;\n      let renderHeight;\n      let offsetX = 0;\n      let offsetY = 0;\n      if (containerAspectRatio > this.targetAspectRatio) {\n        renderHeight = containerHeight;\n        renderWidth = renderHeight * this.targetAspectRatio;\n        offsetX = (containerWidth - renderWidth) / 2;\n      } else {\n        renderWidth = containerWidth;\n        renderHeight = renderWidth / this.targetAspectRatio;\n        offsetY = (containerHeight - renderHeight) / 2;\n      }\n      this.renderer.setViewport(0, 0, containerWidth, containerHeight);\n      this.renderer.setScissor(0, 0, containerWidth, containerHeight);\n      this.renderer.setScissorTest(true);\n      this.renderer.setClearColor(657930);\n      this.renderer.clear();\n      this.renderer.setViewport(offsetX, offsetY, renderWidth, renderHeight);\n      this.renderer.setScissor(offsetX, offsetY, renderWidth, renderHeight);\n      const renderAspectRatio = renderWidth / renderHeight;\n      this.cameraManager.updateAspectRatio(renderAspectRatio);\n    } else {\n      this.renderer.setViewport(0, 0, containerWidth, containerHeight);\n      this.renderer.setScissor(0, 0, containerWidth, containerHeight);\n      this.renderer.setScissorTest(true);\n    }\n    this.sceneManager.renderBackground();\n    this.renderer.render(\n      this.sceneManager.scene,\n      this.cameraManager.activeCamera\n    );\n  }\n  resetViewport() {\n    const width = this.renderer.domElement.clientWidth;\n    const height = this.renderer.domElement.clientHeight;\n    this.renderer.setViewport(0, 0, width, height);\n    this.renderer.setScissor(0, 0, width, height);\n    this.renderer.setScissorTest(false);\n  }\n  getActiveCamera() {\n    return this.cameraManager.activeCamera;\n  }\n  getControls() {\n    return this.controlsManager.controls;\n  }\n  setupCamera(size) {\n    this.cameraManager.setupForModel(size);\n  }\n  startAnimation() {\n    const animate = () => {\n      this.animationFrameId = requestAnimationFrame(animate);\n      if (!this.isActive()) {\n        return;\n      }\n      const delta = this.clock.getDelta();\n      this.viewHelperManager.update(delta);\n      this.controlsManager.update();\n      this.renderMainScene();\n      if (this.previewManager.showPreview) {\n        this.previewManager.renderPreview();\n      }\n      this.resetViewport();\n      if (this.viewHelperManager.viewHelper.render) {\n        this.viewHelperManager.viewHelper.render(this.renderer);\n      }\n    };\n    animate();\n  }\n  updateStatusMouseOnNode(onNode) {\n    this.STATUS_MOUSE_ON_NODE = onNode;\n  }\n  updateStatusMouseOnScene(onScene) {\n    this.STATUS_MOUSE_ON_SCENE = onScene;\n  }\n  updateStatusMouseOnViewer(onViewer) {\n    this.STATUS_MOUSE_ON_VIEWER = onViewer;\n  }\n  isActive() {\n    return this.STATUS_MOUSE_ON_NODE || this.STATUS_MOUSE_ON_SCENE || this.STATUS_MOUSE_ON_VIEWER || this.isRecording() || !this.INITIAL_RENDER_DONE;\n  }\n  async exportModel(format) {\n    if (!this.modelManager.currentModel) {\n      throw new Error(\"No model to export\");\n    }\n    const exportMessage = `Exporting as ${format.toUpperCase()}...`;\n    this.eventManager.emitEvent(\"exportLoadingStart\", exportMessage);\n    try {\n      const model = this.modelManager.currentModel.clone();\n      const originalFileName = this.modelManager.originalFileName || \"model\";\n      const filename = `${originalFileName}.${format}`;\n      const originalURL = this.modelManager.originalURL;\n      await new Promise((resolve) => setTimeout(resolve, 10));\n      switch (format) {\n        case \"glb\":\n          await ModelExporter.exportGLB(model, filename, originalURL);\n          break;\n        case \"obj\":\n          await ModelExporter.exportOBJ(model, filename, originalURL);\n          break;\n        case \"stl\":\n          await ModelExporter.exportSTL(model, filename), originalURL;\n          break;\n        default:\n          throw new Error(`Unsupported export format: ${format}`);\n      }\n      await new Promise((resolve) => setTimeout(resolve, 10));\n    } catch (error) {\n      console.error(`Error exporting model as ${format}:`, error);\n      throw error;\n    } finally {\n      this.eventManager.emitEvent(\"exportLoadingEnd\", null);\n    }\n  }\n  setBackgroundColor(color) {\n    this.sceneManager.setBackgroundColor(color);\n    this.previewManager.setPreviewBackgroundColor(color);\n    this.forceRender();\n  }\n  async setBackgroundImage(uploadPath) {\n    await this.sceneManager.setBackgroundImage(uploadPath);\n    this.previewManager.updateBackgroundTexture(\n      this.sceneManager.backgroundTexture\n    );\n    if (this.isViewerMode && this.sceneManager.backgroundTexture && this.sceneManager.backgroundMesh) {\n      const containerWidth = this.renderer.domElement.clientWidth;\n      const containerHeight = this.renderer.domElement.clientHeight;\n      const containerAspectRatio = containerWidth / containerHeight;\n      let renderWidth;\n      let renderHeight;\n      if (containerAspectRatio > this.targetAspectRatio) {\n        renderHeight = containerHeight;\n        renderWidth = renderHeight * this.targetAspectRatio;\n      } else {\n        renderWidth = containerWidth;\n        renderHeight = renderWidth / this.targetAspectRatio;\n      }\n      this.sceneManager.updateBackgroundSize(\n        this.sceneManager.backgroundTexture,\n        this.sceneManager.backgroundMesh,\n        renderWidth,\n        renderHeight\n      );\n    }\n    this.forceRender();\n  }\n  removeBackgroundImage() {\n    this.sceneManager.removeBackgroundImage();\n    this.previewManager.setPreviewBackgroundColor(\n      this.sceneManager.currentBackgroundColor\n    );\n    this.forceRender();\n  }\n  toggleGrid(showGrid) {\n    this.sceneManager.toggleGrid(showGrid);\n    this.forceRender();\n  }\n  toggleCamera(cameraType) {\n    this.cameraManager.toggleCamera(cameraType);\n    this.controlsManager.updateCamera(this.cameraManager.activeCamera);\n    this.viewHelperManager.recreateViewHelper();\n    this.handleResize();\n    this.forceRender();\n  }\n  getCurrentCameraType() {\n    return this.cameraManager.getCurrentCameraType();\n  }\n  getCurrentModel() {\n    return this.modelManager.currentModel;\n  }\n  setCameraState(state) {\n    this.cameraManager.setCameraState(state);\n    this.forceRender();\n  }\n  getCameraState() {\n    return this.cameraManager.getCameraState();\n  }\n  setFOV(fov2) {\n    this.cameraManager.setFOV(fov2);\n    this.forceRender();\n  }\n  setEdgeThreshold(threshold) {\n    this.modelManager.setEdgeThreshold(threshold);\n    this.forceRender();\n  }\n  setMaterialMode(mode) {\n    this.modelManager.setMaterialMode(mode);\n    this.forceRender();\n  }\n  async loadModel(url2, originalFileName) {\n    this.cameraManager.reset();\n    this.controlsManager.reset();\n    this.modelManager.reset();\n    await this.loaderManager.loadModel(url2, originalFileName);\n    this.handleResize();\n    this.forceRender();\n  }\n  clearModel() {\n    this.modelManager.clearModel();\n    this.forceRender();\n  }\n  setUpDirection(direction) {\n    this.modelManager.setUpDirection(direction);\n    this.forceRender();\n  }\n  setLightIntensity(intensity) {\n    this.lightingManager.setLightIntensity(intensity);\n    this.forceRender();\n  }\n  togglePreview(showPreview) {\n    this.previewManager.togglePreview(showPreview);\n    this.forceRender();\n  }\n  setTargetSize(width, height) {\n    this.targetWidth = width;\n    this.targetHeight = height;\n    this.targetAspectRatio = width / height;\n    this.previewManager.setTargetSize(width, height);\n    this.forceRender();\n  }\n  addEventListener(event, callback) {\n    this.eventManager.addEventListener(event, callback);\n  }\n  removeEventListener(event, callback) {\n    this.eventManager.removeEventListener(event, callback);\n  }\n  refreshViewport() {\n    this.handleResize();\n    this.forceRender();\n  }\n  handleResize() {\n    var _a2, _b2;\n    const parentElement = (_b2 = (_a2 = this.renderer) == null ? void 0 : _a2.domElement) == null ? void 0 : _b2.parentElement;\n    if (!parentElement) {\n      console.warn(\"Parent element not found\");\n      return;\n    }\n    const containerWidth = parentElement.clientWidth;\n    const containerHeight = parentElement.clientHeight;\n    if (this.isViewerMode) {\n      const containerAspectRatio = containerWidth / containerHeight;\n      let renderWidth;\n      let renderHeight;\n      if (containerAspectRatio > this.targetAspectRatio) {\n        renderHeight = containerHeight;\n        renderWidth = renderHeight * this.targetAspectRatio;\n      } else {\n        renderWidth = containerWidth;\n        renderHeight = renderWidth / this.targetAspectRatio;\n      }\n      this.cameraManager.handleResize(renderWidth, renderHeight);\n      this.sceneManager.handleResize(renderWidth, renderHeight);\n    } else {\n      this.cameraManager.handleResize(containerWidth, containerHeight);\n      this.sceneManager.handleResize(containerWidth, containerHeight);\n    }\n    this.renderer.setSize(containerWidth, containerHeight);\n    this.previewManager.handleResize();\n    this.forceRender();\n  }\n  captureScene(width, height) {\n    return this.sceneManager.captureScene(width, height);\n  }\n  loadNodeProperty(name, defaultValue) {\n    return this.nodeStorage.loadNodeProperty(name, defaultValue);\n  }\n  async startRecording() {\n    this.viewHelperManager.visibleViewHelper(false);\n    return this.recordingManager.startRecording();\n  }\n  stopRecording() {\n    this.viewHelperManager.visibleViewHelper(true);\n    this.recordingManager.stopRecording();\n    this.eventManager.emitEvent(\"recordingStatusChange\", false);\n  }\n  isRecording() {\n    return this.recordingManager.getIsRecording();\n  }\n  getRecordingDuration() {\n    return this.recordingManager.getRecordingDuration();\n  }\n  getRecordingData() {\n    return this.recordingManager.getRecordingData();\n  }\n  exportRecording(filename) {\n    this.recordingManager.exportRecording(filename);\n  }\n  clearRecording() {\n    this.recordingManager.clearRecording();\n  }\n  remove() {\n    this.renderer.forceContextLoss();\n    const canvas = this.renderer.domElement;\n    const event = new Event(\"webglcontextlost\", {\n      bubbles: true,\n      cancelable: true\n    });\n    canvas.dispatchEvent(event);\n    if (this.animationFrameId !== null) {\n      cancelAnimationFrame(this.animationFrameId);\n    }\n    this.sceneManager.dispose();\n    this.cameraManager.dispose();\n    this.controlsManager.dispose();\n    this.lightingManager.dispose();\n    this.viewHelperManager.dispose();\n    this.previewManager.dispose();\n    this.loaderManager.dispose();\n    this.modelManager.dispose();\n    this.recordingManager.dispose();\n    this.renderer.dispose();\n    this.renderer.domElement.remove();\n  }\n}\nconst useLoad3dViewer = (node) => {\n  const backgroundColor = ref(\"\");\n  const showGrid = ref(true);\n  const cameraType = ref(\"perspective\");\n  const fov2 = ref(75);\n  const lightIntensity = ref(1);\n  const backgroundImage = ref(\"\");\n  const hasBackgroundImage = ref(false);\n  const upDirection = ref(\"original\");\n  const materialMode = ref(\"original\");\n  const edgeThreshold = ref(85);\n  const needApplyChanges = ref(true);\n  let load3d = null;\n  let sourceLoad3d = null;\n  const initialState = ref({\n    backgroundColor: \"#282828\",\n    showGrid: true,\n    cameraType: \"perspective\",\n    fov: 75,\n    lightIntensity: 1,\n    cameraState: null,\n    backgroundImage: \"\",\n    upDirection: \"original\",\n    materialMode: \"original\",\n    edgeThreshold: 85\n  });\n  watch(backgroundColor, (newColor) => {\n    if (!load3d) return;\n    try {\n      load3d.setBackgroundColor(newColor);\n    } catch (error) {\n      console.error(\"Error updating background color:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToUpdateBackgroundColor\", { color: newColor })\n      );\n    }\n  });\n  watch(showGrid, (newValue) => {\n    if (!load3d) return;\n    try {\n      load3d.toggleGrid(newValue);\n    } catch (error) {\n      console.error(\"Error toggling grid:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToToggleGrid\", { show: newValue ? \"on\" : \"off\" })\n      );\n    }\n  });\n  watch(cameraType, (newCameraType) => {\n    if (!load3d) return;\n    try {\n      load3d.toggleCamera(newCameraType);\n    } catch (error) {\n      console.error(\"Error toggling camera:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToToggleCamera\", { camera: newCameraType })\n      );\n    }\n  });\n  watch(fov2, (newFov) => {\n    if (!load3d) return;\n    try {\n      load3d.setFOV(Number(newFov));\n    } catch (error) {\n      console.error(\"Error updating FOV:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToUpdateFOV\", { fov: newFov })\n      );\n    }\n  });\n  watch(lightIntensity, (newValue) => {\n    if (!load3d) return;\n    try {\n      load3d.setLightIntensity(Number(newValue));\n    } catch (error) {\n      console.error(\"Error updating light intensity:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToUpdateLightIntensity\", { intensity: newValue })\n      );\n    }\n  });\n  watch(backgroundImage, async (newValue) => {\n    if (!load3d) return;\n    try {\n      await load3d.setBackgroundImage(newValue);\n      hasBackgroundImage.value = !!newValue;\n    } catch (error) {\n      console.error(\"Error updating background image:\", error);\n      useToastStore().addAlert(t(\"toastMessages.failedToUpdateBackgroundImage\"));\n    }\n  });\n  watch(upDirection, (newValue) => {\n    if (!load3d) return;\n    try {\n      load3d.setUpDirection(newValue);\n    } catch (error) {\n      console.error(\"Error updating up direction:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToUpdateUpDirection\", { direction: newValue })\n      );\n    }\n  });\n  watch(materialMode, (newValue) => {\n    if (!load3d) return;\n    try {\n      load3d.setMaterialMode(newValue);\n    } catch (error) {\n      console.error(\"Error updating material mode:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToUpdateMaterialMode\", { mode: newValue })\n      );\n    }\n  });\n  watch(edgeThreshold, (newValue) => {\n    if (!load3d) return;\n    try {\n      load3d.setEdgeThreshold(Number(newValue));\n    } catch (error) {\n      console.error(\"Error updating edge threshold:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToUpdateEdgeThreshold\", { threshold: newValue })\n      );\n    }\n  });\n  const initializeViewer = async (containerRef, source) => {\n    var _a2, _b2;\n    if (!containerRef) return;\n    sourceLoad3d = source;\n    try {\n      load3d = new Load3d(containerRef, {\n        node,\n        disablePreview: true,\n        isViewerMode: true\n      });\n      await useLoad3dService().copyLoad3dState(source, load3d);\n      const sourceCameraType = source.getCurrentCameraType();\n      const sourceCameraState = source.getCameraState();\n      cameraType.value = sourceCameraType;\n      backgroundColor.value = source.sceneManager.currentBackgroundColor;\n      showGrid.value = source.sceneManager.gridHelper.visible;\n      lightIntensity.value = node.properties[\"Light Intensity\"] || 1;\n      const backgroundInfo = source.sceneManager.getCurrentBackgroundInfo();\n      if (backgroundInfo.type === \"image\" && node.properties[\"Background Image\"]) {\n        backgroundImage.value = node.properties[\"Background Image\"];\n        hasBackgroundImage.value = true;\n      } else {\n        backgroundImage.value = \"\";\n        hasBackgroundImage.value = false;\n      }\n      if (sourceCameraType === \"perspective\") {\n        fov2.value = source.cameraManager.perspectiveCamera.fov;\n      }\n      upDirection.value = source.modelManager.currentUpDirection;\n      materialMode.value = source.modelManager.materialMode;\n      edgeThreshold.value = node.properties[\"Edge Threshold\"] || 85;\n      initialState.value = {\n        backgroundColor: backgroundColor.value,\n        showGrid: showGrid.value,\n        cameraType: cameraType.value,\n        fov: fov2.value,\n        lightIntensity: lightIntensity.value,\n        cameraState: sourceCameraState,\n        backgroundImage: backgroundImage.value,\n        upDirection: upDirection.value,\n        materialMode: materialMode.value,\n        edgeThreshold: edgeThreshold.value\n      };\n      const width = (_a2 = node.widgets) == null ? void 0 : _a2.find((w) => w.name === \"width\");\n      const height = (_b2 = node.widgets) == null ? void 0 : _b2.find((w) => w.name === \"height\");\n      if (width && height) {\n        load3d.setTargetSize(\n          toRaw(width).value,\n          toRaw(height).value\n        );\n      }\n    } catch (error) {\n      console.error(\"Error initializing Load3d viewer:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToInitializeLoad3dViewer\")\n      );\n    }\n  };\n  const exportModel = async (format) => {\n    if (!load3d) return;\n    try {\n      await load3d.exportModel(format);\n    } catch (error) {\n      console.error(\"Error exporting model:\", error);\n      useToastStore().addAlert(\n        t(\"toastMessages.failedToExportModel\", { format: format.toUpperCase() })\n      );\n    }\n  };\n  const handleResize = () => {\n    load3d == null ? void 0 : load3d.handleResize();\n  };\n  const handleMouseEnter = () => {\n    load3d == null ? void 0 : load3d.updateStatusMouseOnViewer(true);\n  };\n  const handleMouseLeave = () => {\n    load3d == null ? void 0 : load3d.updateStatusMouseOnViewer(false);\n  };\n  const restoreInitialState = () => {\n    const nodeValue = node;\n    needApplyChanges.value = false;\n    if (nodeValue.properties) {\n      nodeValue.properties[\"Background Color\"] = initialState.value.backgroundColor;\n      nodeValue.properties[\"Show Grid\"] = initialState.value.showGrid;\n      nodeValue.properties[\"Camera Type\"] = initialState.value.cameraType;\n      nodeValue.properties[\"FOV\"] = initialState.value.fov;\n      nodeValue.properties[\"Light Intensity\"] = initialState.value.lightIntensity;\n      nodeValue.properties[\"Camera Info\"] = initialState.value.cameraState;\n      nodeValue.properties[\"Background Image\"] = initialState.value.backgroundImage;\n    }\n  };\n  const applyChanges = async () => {\n    if (!sourceLoad3d || !load3d) return false;\n    const viewerCameraState = load3d.getCameraState();\n    const nodeValue = node;\n    if (nodeValue.properties) {\n      nodeValue.properties[\"Background Color\"] = backgroundColor.value;\n      nodeValue.properties[\"Show Grid\"] = showGrid.value;\n      nodeValue.properties[\"Camera Type\"] = cameraType.value;\n      nodeValue.properties[\"FOV\"] = fov2.value;\n      nodeValue.properties[\"Light Intensity\"] = lightIntensity.value;\n      nodeValue.properties[\"Camera Info\"] = viewerCameraState;\n      nodeValue.properties[\"Background Image\"] = backgroundImage.value;\n    }\n    await useLoad3dService().copyLoad3dState(load3d, sourceLoad3d);\n    if (backgroundImage.value) {\n      await sourceLoad3d.setBackgroundImage(backgroundImage.value);\n    }\n    sourceLoad3d.forceRender();\n    if (nodeValue.graph) {\n      nodeValue.graph.setDirtyCanvas(true, true);\n    }\n    return true;\n  };\n  const refreshViewport = () => {\n    useLoad3dService().handleViewportRefresh(load3d);\n  };\n  const handleBackgroundImageUpdate = async (file2) => {\n    if (!file2) {\n      backgroundImage.value = \"\";\n      hasBackgroundImage.value = false;\n      return;\n    }\n    try {\n      const resourceFolder = node.properties[\"Resource Folder\"] || \"\";\n      const subfolder = resourceFolder.trim() ? `3d/${resourceFolder.trim()}` : \"3d\";\n      const uploadPath = await Load3dUtils.uploadFile(file2, subfolder);\n      if (uploadPath) {\n        backgroundImage.value = uploadPath;\n        hasBackgroundImage.value = true;\n      }\n    } catch (error) {\n      console.error(\"Error uploading background image:\", error);\n      useToastStore().addAlert(t(\"toastMessages.failedToUploadBackgroundImage\"));\n    }\n  };\n  const cleanup = () => {\n    load3d == null ? void 0 : load3d.remove();\n    load3d = null;\n    sourceLoad3d = null;\n  };\n  return {\n    // State\n    backgroundColor,\n    showGrid,\n    cameraType,\n    fov: fov2,\n    lightIntensity,\n    backgroundImage,\n    hasBackgroundImage,\n    upDirection,\n    materialMode,\n    edgeThreshold,\n    needApplyChanges,\n    // Methods\n    initializeViewer,\n    exportModel,\n    handleResize,\n    handleMouseEnter,\n    handleMouseLeave,\n    restoreInitialState,\n    applyChanges,\n    refreshViewport,\n    handleBackgroundImageUpdate,\n    cleanup\n  };\n};\nvar __defProp$7 = Object.defineProperty;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$7 = (obj, key, value) => __defNormalProp$7(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nclass AnimationManager {\n  constructor(eventManager, getCurrentModel) {\n    __publicField$7(this, \"currentAnimation\", null);\n    __publicField$7(this, \"animationActions\", []);\n    __publicField$7(this, \"animationClips\", []);\n    __publicField$7(this, \"selectedAnimationIndex\", 0);\n    __publicField$7(this, \"isAnimationPlaying\", false);\n    __publicField$7(this, \"animationSpeed\", 1);\n    __publicField$7(this, \"eventManager\");\n    __publicField$7(this, \"getCurrentModel\");\n    this.eventManager = eventManager;\n    this.getCurrentModel = getCurrentModel;\n  }\n  init() {\n  }\n  dispose() {\n    if (this.currentAnimation) {\n      this.animationActions.forEach((action) => {\n        action.stop();\n      });\n      this.currentAnimation = null;\n    }\n    this.animationActions = [];\n    this.animationClips = [];\n    this.selectedAnimationIndex = 0;\n    this.isAnimationPlaying = false;\n    this.animationSpeed = 1;\n    this.eventManager.emitEvent(\"animationListChange\", []);\n  }\n  setupModelAnimations(model, originalModel) {\n    var _a2;\n    if (this.currentAnimation) {\n      this.currentAnimation.stopAllAction();\n      this.animationActions = [];\n    }\n    let animations = [];\n    if (((_a2 = model.animations) == null ? void 0 : _a2.length) > 0) {\n      animations = model.animations;\n    } else if (originalModel && \"animations\" in originalModel) {\n      animations = originalModel.animations;\n    }\n    if (animations.length > 0) {\n      this.animationClips = animations;\n      if (model.type === \"Scene\") {\n        this.currentAnimation = new AnimationMixer(model);\n      } else {\n        this.currentAnimation = new AnimationMixer(\n          this.getCurrentModel()\n        );\n      }\n      if (this.animationClips.length > 0) {\n        this.updateSelectedAnimation(0);\n      }\n    }\n    this.updateAnimationList();\n  }\n  updateAnimationList() {\n    let updatedAnimationList = [];\n    if (this.animationClips.length > 0) {\n      updatedAnimationList = this.animationClips.map((clip, index) => ({\n        name: clip.name || `Animation ${index + 1}`,\n        index\n      }));\n    }\n    this.eventManager.emitEvent(\"animationListChange\", updatedAnimationList);\n  }\n  setAnimationSpeed(speed) {\n    this.animationSpeed = speed;\n    this.animationActions.forEach((action) => {\n      action.setEffectiveTimeScale(speed);\n    });\n  }\n  updateSelectedAnimation(index) {\n    if (!this.currentAnimation || !this.animationClips || index >= this.animationClips.length) {\n      console.warn(\"Invalid animation update request\");\n      return;\n    }\n    this.animationActions.forEach((action2) => {\n      action2.stop();\n    });\n    this.currentAnimation.stopAllAction();\n    this.animationActions = [];\n    this.selectedAnimationIndex = index;\n    const clip = this.animationClips[index];\n    const action = this.currentAnimation.clipAction(clip);\n    action.setEffectiveTimeScale(this.animationSpeed);\n    action.reset();\n    action.clampWhenFinished = false;\n    action.loop = LoopRepeat;\n    if (this.isAnimationPlaying) {\n      action.play();\n    } else {\n      action.play();\n      action.paused = true;\n    }\n    this.animationActions = [action];\n  }\n  toggleAnimation(play) {\n    if (!this.currentAnimation || this.animationActions.length === 0) {\n      console.warn(\"No animation to toggle\");\n      return;\n    }\n    this.isAnimationPlaying = play ?? !this.isAnimationPlaying;\n    this.animationActions.forEach((action) => {\n      if (this.isAnimationPlaying) {\n        action.paused = false;\n        if (action.time === 0 || action.time === action.getClip().duration) {\n          action.reset();\n        }\n      } else {\n        action.paused = true;\n      }\n    });\n  }\n  update(delta) {\n    if (this.currentAnimation && this.isAnimationPlaying) {\n      this.currentAnimation.update(delta);\n    }\n  }\n  reset() {\n  }\n}\nvar __defProp$6 = Object.defineProperty;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$6 = (obj, key, value) => __defNormalProp$6(obj, key + \"\", value);\nclass Load3dAnimation extends Load3d {\n  constructor(container, options = {\n    node: {}\n  }) {\n    super(container, options);\n    __publicField$6(this, \"animationManager\");\n    this.animationManager = new AnimationManager(\n      this.eventManager,\n      this.getCurrentModel.bind(this)\n    );\n    this.animationManager.init();\n    this.overrideAnimationLoop();\n  }\n  overrideAnimationLoop() {\n    if (this.animationFrameId !== null) {\n      cancelAnimationFrame(this.animationFrameId);\n    }\n    const animate = () => {\n      this.animationFrameId = requestAnimationFrame(animate);\n      if (!this.isActive()) {\n        return;\n      }\n      const delta = this.clock.getDelta();\n      this.animationManager.update(delta);\n      this.viewHelperManager.update(delta);\n      this.controlsManager.update();\n      this.renderMainScene();\n      if (this.previewManager.showPreview) {\n        this.previewManager.renderPreview();\n      }\n      this.resetViewport();\n      if (this.viewHelperManager.viewHelper.render) {\n        this.viewHelperManager.viewHelper.render(this.renderer);\n      }\n    };\n    animate();\n  }\n  async loadModel(url2, originalFileName) {\n    await super.loadModel(url2, originalFileName);\n    if (this.modelManager.currentModel) {\n      this.animationManager.setupModelAnimations(\n        this.modelManager.currentModel,\n        this.modelManager.originalModel\n      );\n    }\n  }\n  clearModel() {\n    this.animationManager.dispose();\n    super.clearModel();\n  }\n  updateAnimationList() {\n    this.animationManager.updateAnimationList();\n  }\n  setAnimationSpeed(speed) {\n    this.animationManager.setAnimationSpeed(speed);\n  }\n  updateSelectedAnimation(index) {\n    this.animationManager.updateSelectedAnimation(index);\n  }\n  toggleAnimation(play) {\n    this.animationManager.toggleAnimation(play);\n  }\n  get isAnimationPlaying() {\n    return this.animationManager.isAnimationPlaying;\n  }\n  get animationSpeed() {\n    return this.animationManager.animationSpeed;\n  }\n  get selectedAnimationIndex() {\n    return this.animationManager.selectedAnimationIndex;\n  }\n  get animationClips() {\n    return this.animationManager.animationClips;\n  }\n  get animationActions() {\n    return this.animationManager.animationActions;\n  }\n  get currentAnimation() {\n    return this.animationManager.currentAnimation;\n  }\n  remove() {\n    this.animationManager.dispose();\n    super.remove();\n  }\n}\nvar __defProp$5 = Object.defineProperty;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$5 = (obj, key, value) => __defNormalProp$5(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nconst viewerInstances = /* @__PURE__ */ new Map();\nconst _Load3dService = class _Load3dService2 {\n  constructor() {\n    __publicField$5(this, \"nodeToLoad3dMap\", /* @__PURE__ */ new Map());\n    __publicField$5(this, \"pendingCallbacks\", /* @__PURE__ */ new Map());\n  }\n  static getInstance() {\n    if (!_Load3dService2.instance) {\n      _Load3dService2.instance = new _Load3dService2();\n    }\n    return _Load3dService2.instance;\n  }\n  registerLoad3d(node, container, inputSpec) {\n    const rawNode = toRaw(node);\n    if (this.nodeToLoad3dMap.has(rawNode)) {\n      this.removeLoad3d(rawNode);\n    }\n    const type = inputSpec.type;\n    const isAnimation = type.includes(\"Animation\");\n    const Load3dClass = isAnimation ? Load3dAnimation : Load3d;\n    const instance = new Load3dClass(container, {\n      node: rawNode,\n      inputSpec\n    });\n    rawNode.onMouseEnter = function() {\n      instance.refreshViewport();\n      instance.updateStatusMouseOnNode(true);\n    };\n    rawNode.onMouseLeave = function() {\n      instance.updateStatusMouseOnNode(false);\n    };\n    rawNode.onResize = function() {\n      instance.handleResize();\n    };\n    rawNode.onDrawBackground = function() {\n      instance.renderer.domElement.hidden = this.flags.collapsed ?? false;\n    };\n    this.nodeToLoad3dMap.set(rawNode, instance);\n    const callbacks = this.pendingCallbacks.get(rawNode);\n    if (callbacks) {\n      callbacks.forEach((callback) => callback(instance));\n      this.pendingCallbacks.delete(rawNode);\n    }\n    return instance;\n  }\n  getLoad3d(node) {\n    const rawNode = toRaw(node);\n    return this.nodeToLoad3dMap.get(rawNode) || null;\n  }\n  waitForLoad3d(node, callback) {\n    const rawNode = toRaw(node);\n    const existingInstance = this.nodeToLoad3dMap.get(rawNode);\n    if (existingInstance) {\n      callback(existingInstance);\n      return;\n    }\n    if (!this.pendingCallbacks.has(rawNode)) {\n      this.pendingCallbacks.set(rawNode, []);\n    }\n    this.pendingCallbacks.get(rawNode).push(callback);\n  }\n  getNodeByLoad3d(load3d) {\n    for (const [node, instance] of this.nodeToLoad3dMap) {\n      if (instance === load3d) {\n        return node;\n      }\n    }\n    return null;\n  }\n  removeLoad3d(node) {\n    const rawNode = toRaw(node);\n    const instance = this.nodeToLoad3dMap.get(rawNode);\n    if (instance) {\n      instance.remove();\n      this.nodeToLoad3dMap.delete(rawNode);\n    }\n    this.pendingCallbacks.delete(rawNode);\n  }\n  clear() {\n    for (const [node] of this.nodeToLoad3dMap) {\n      this.removeLoad3d(node);\n    }\n    this.pendingCallbacks.clear();\n  }\n  getOrCreateViewer(node) {\n    if (!viewerInstances.has(node.id)) {\n      viewerInstances.set(node.id, useLoad3dViewer(node));\n    }\n    return viewerInstances.get(node.id);\n  }\n  removeViewer(node) {\n    const viewer = viewerInstances.get(node.id);\n    if (viewer) {\n      viewer.cleanup();\n    }\n    viewerInstances.delete(node.id);\n  }\n  async copyLoad3dState(source, target) {\n    var _a2, _b2, _c;\n    const sourceModel = source.modelManager.currentModel;\n    if (sourceModel) {\n      const modelClone = sourceModel.clone();\n      target.getModelManager().currentModel = modelClone;\n      target.getSceneManager().scene.add(modelClone);\n      target.getModelManager().materialMode = source.getModelManager().materialMode;\n      target.getModelManager().currentUpDirection = source.getModelManager().currentUpDirection;\n      target.setMaterialMode(source.getModelManager().materialMode);\n      target.setUpDirection(source.getModelManager().currentUpDirection);\n      if (source.getModelManager().appliedTexture) {\n        target.getModelManager().appliedTexture = source.getModelManager().appliedTexture;\n      }\n    }\n    const sourceCameraType = source.getCurrentCameraType();\n    const sourceCameraState = source.getCameraState();\n    target.toggleCamera(sourceCameraType);\n    target.setCameraState(sourceCameraState);\n    target.setBackgroundColor(source.getSceneManager().currentBackgroundColor);\n    target.toggleGrid(source.getSceneManager().gridHelper.visible);\n    const sourceBackgroundInfo = source.getSceneManager().getCurrentBackgroundInfo();\n    if (sourceBackgroundInfo.type === \"image\") {\n      const sourceNode2 = this.getNodeByLoad3d(source);\n      const backgroundPath = (_a2 = sourceNode2 == null ? void 0 : sourceNode2.properties) == null ? void 0 : _a2[\"Background Image\"];\n      if (backgroundPath) {\n        await target.setBackgroundImage(backgroundPath);\n      }\n    }\n    target.setLightIntensity(\n      ((_b2 = source.getLightingManager().lights[1]) == null ? void 0 : _b2.intensity) || 1\n    );\n    if (sourceCameraType === \"perspective\") {\n      target.setFOV(source.getCameraManager().perspectiveCamera.fov);\n    }\n    const sourceNode = this.getNodeByLoad3d(source);\n    if ((_c = sourceNode == null ? void 0 : sourceNode.properties) == null ? void 0 : _c[\"Edge Threshold\"]) {\n      target.setEdgeThreshold(sourceNode.properties[\"Edge Threshold\"]);\n    }\n  }\n  handleViewportRefresh(load3d) {\n    if (!load3d) return;\n    load3d.handleResize();\n    const currentType = load3d.getCurrentCameraType();\n    load3d.toggleCamera(\n      currentType === \"perspective\" ? \"orthographic\" : \"perspective\"\n    );\n    load3d.toggleCamera(currentType);\n    load3d.getControlsManager().controls.update();\n  }\n  async handleViewerClose(node) {\n    const viewer = useLoad3dService().getOrCreateViewer(node);\n    if (viewer.needApplyChanges.value) {\n      await viewer.applyChanges();\n    }\n    useLoad3dService().removeViewer(node);\n  }\n};\n__publicField$5(_Load3dService, \"instance\");\nlet Load3dService = _Load3dService;\nconst useLoad3dService = () => {\n  return Load3dService.getInstance();\n};\nconst _sfc_main$c = /* @__PURE__ */ defineComponent({\n  __name: \"Load3DScene\",\n  props: {\n    node: {},\n    inputSpec: {},\n    backgroundColor: {},\n    showGrid: { type: Boolean },\n    lightIntensity: {},\n    fov: {},\n    cameraType: {},\n    showPreview: { type: Boolean },\n    backgroundImage: {},\n    upDirection: {},\n    materialMode: {},\n    edgeThreshold: {},\n    extraListeners: {}\n  },\n  emits: [\"materialModeChange\", \"backgroundColorChange\", \"lightIntensityChange\", \"fovChange\", \"cameraTypeChange\", \"showGridChange\", \"showPreviewChange\", \"backgroundImageChange\", \"upDirectionChange\", \"edgeThresholdChange\", \"recordingStatusChange\"],\n  setup(__props, { expose: __expose, emit: __emit }) {\n    const props = __props;\n    const container = ref(null);\n    const node = ref(props.node);\n    const load3d = ref(null);\n    const loadingOverlayRef = ref(null);\n    const eventConfig = {\n      materialModeChange: (value) => emit(\"materialModeChange\", value),\n      backgroundColorChange: (value) => emit(\"backgroundColorChange\", value),\n      lightIntensityChange: (value) => emit(\"lightIntensityChange\", value),\n      fovChange: (value) => emit(\"fovChange\", value),\n      cameraTypeChange: (value) => emit(\"cameraTypeChange\", value),\n      showGridChange: (value) => emit(\"showGridChange\", value),\n      showPreviewChange: (value) => emit(\"showPreviewChange\", value),\n      backgroundImageChange: (value) => emit(\"backgroundImageChange\", value),\n      backgroundImageLoadingStart: () => {\n        var _a2;\n        return (_a2 = loadingOverlayRef.value) == null ? void 0 : _a2.startLoading(t(\"load3d.loadingBackgroundImage\"));\n      },\n      backgroundImageLoadingEnd: () => {\n        var _a2;\n        return (_a2 = loadingOverlayRef.value) == null ? void 0 : _a2.endLoading();\n      },\n      upDirectionChange: (value) => emit(\"upDirectionChange\", value),\n      edgeThresholdChange: (value) => emit(\"edgeThresholdChange\", value),\n      modelLoadingStart: () => {\n        var _a2;\n        return (_a2 = loadingOverlayRef.value) == null ? void 0 : _a2.startLoading(t(\"load3d.loadingModel\"));\n      },\n      modelLoadingEnd: () => {\n        var _a2;\n        return (_a2 = loadingOverlayRef.value) == null ? void 0 : _a2.endLoading();\n      },\n      materialLoadingStart: () => {\n        var _a2;\n        return (_a2 = loadingOverlayRef.value) == null ? void 0 : _a2.startLoading(t(\"load3d.switchingMaterialMode\"));\n      },\n      materialLoadingEnd: () => {\n        var _a2;\n        return (_a2 = loadingOverlayRef.value) == null ? void 0 : _a2.endLoading();\n      },\n      exportLoadingStart: (message) => {\n        var _a2;\n        (_a2 = loadingOverlayRef.value) == null ? void 0 : _a2.startLoading(message || t(\"load3d.exportingModel\"));\n      },\n      exportLoadingEnd: () => {\n        var _a2;\n        (_a2 = loadingOverlayRef.value) == null ? void 0 : _a2.endLoading();\n      },\n      recordingStatusChange: (value) => emit(\"recordingStatusChange\", value)\n    };\n    watch(\n      () => props.showPreview,\n      (newValue) => {\n        if (load3d.value) {\n          const rawLoad3d = toRaw(load3d.value);\n          rawLoad3d.togglePreview(newValue);\n        }\n      }\n    );\n    watch(\n      () => props.cameraType,\n      (newValue) => {\n        if (load3d.value) {\n          const rawLoad3d = toRaw(load3d.value);\n          rawLoad3d.toggleCamera(newValue);\n        }\n      }\n    );\n    watch(\n      () => props.fov,\n      (newValue) => {\n        if (load3d.value) {\n          const rawLoad3d = toRaw(load3d.value);\n          rawLoad3d.setFOV(newValue);\n        }\n      }\n    );\n    watch(\n      () => props.lightIntensity,\n      (newValue) => {\n        if (load3d.value) {\n          const rawLoad3d = toRaw(load3d.value);\n          rawLoad3d.setLightIntensity(newValue);\n        }\n      }\n    );\n    watch(\n      () => props.showGrid,\n      (newValue) => {\n        if (load3d.value) {\n          const rawLoad3d = toRaw(load3d.value);\n          rawLoad3d.toggleGrid(newValue);\n        }\n      }\n    );\n    watch(\n      () => props.backgroundColor,\n      (newValue) => {\n        if (load3d.value) {\n          const rawLoad3d = toRaw(load3d.value);\n          rawLoad3d.setBackgroundColor(newValue);\n        }\n      }\n    );\n    watch(\n      () => props.backgroundImage,\n      async (newValue) => {\n        if (load3d.value) {\n          const rawLoad3d = toRaw(load3d.value);\n          await rawLoad3d.setBackgroundImage(newValue);\n        }\n      }\n    );\n    watch(\n      () => props.upDirection,\n      (newValue) => {\n        if (load3d.value) {\n          const rawLoad3d = toRaw(load3d.value);\n          rawLoad3d.setUpDirection(newValue);\n        }\n      }\n    );\n    watch(\n      () => props.materialMode,\n      (newValue) => {\n        if (load3d.value) {\n          const rawLoad3d = toRaw(load3d.value);\n          rawLoad3d.setMaterialMode(newValue);\n        }\n      }\n    );\n    watch(\n      () => props.edgeThreshold,\n      (newValue) => {\n        if (load3d.value && newValue) {\n          const rawLoad3d = toRaw(load3d.value);\n          rawLoad3d.setEdgeThreshold(newValue);\n        }\n      }\n    );\n    const emit = __emit;\n    const handleEvents = (action) => {\n      if (!load3d.value) return;\n      Object.entries(eventConfig).forEach(([event, handler2]) => {\n        var _a2;\n        const method = `${action}EventListener`;\n        (_a2 = load3d.value) == null ? void 0 : _a2[method](event, handler2);\n      });\n      if (props.extraListeners) {\n        Object.entries(props.extraListeners).forEach(([event, handler2]) => {\n          var _a2;\n          const method = `${action}EventListener`;\n          (_a2 = load3d.value) == null ? void 0 : _a2[method](event, handler2);\n        });\n      }\n    };\n    onMounted(() => {\n      if (container.value) {\n        load3d.value = useLoad3dService().registerLoad3d(\n          node.value,\n          container.value,\n          props.inputSpec\n        );\n      }\n      handleEvents(\"add\");\n    });\n    onUnmounted(() => {\n      handleEvents(\"remove\");\n      useLoad3dService().removeLoad3d(node.value);\n    });\n    __expose({\n      load3d\n    });\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"container\",\n        ref: container,\n        class: \"w-full h-full relative comfy-load-3d\"\n      }, [\n        createVNode(LoadingOverlay, {\n          ref_key: \"loadingOverlayRef\",\n          ref: loadingOverlayRef\n        }, null, 512)\n      ], 512);\n    };\n  }\n});\nconst _hoisted_1$8 = { class: \"relative bg-gray-700 bg-opacity-30 rounded-lg\" };\nconst _hoisted_2$5 = { class: \"flex flex-col gap-2\" };\nconst _hoisted_3$3 = { class: \"pi pi-window-maximize text-white text-lg\" };\nconst _hoisted_4$2 = { class: \"pi pi-download text-white text-lg\" };\nconst _hoisted_5$2 = { class: \"pi pi-trash text-white text-lg\" };\nconst _hoisted_6$1 = {\n  key: 2,\n  class: \"text-xs text-white text-center mt-1\"\n};\nconst _sfc_main$b = /* @__PURE__ */ defineComponent({\n  __name: \"RecordingControls\",\n  props: {\n    hasRecording: { type: Boolean },\n    isRecording: { type: Boolean },\n    node: {},\n    recordingDuration: {}\n  },\n  emits: [\"startRecording\", \"stopRecording\", \"exportRecording\", \"clearRecording\"],\n  setup(__props, { emit: __emit }) {\n    const vTooltip = Tooltip;\n    const emit = __emit;\n    const resizeNodeMatchOutput = () => {\n      var _a2, _b2, _c, _d;\n      const outputWidth = (_a2 = __props.node.widgets) == null ? void 0 : _a2.find((w) => w.name === \"width\");\n      const outputHeight = (_b2 = __props.node.widgets) == null ? void 0 : _b2.find((w) => w.name === \"height\");\n      if (outputWidth && outputHeight && outputHeight.value && outputWidth.value) {\n        const [oldWidth, oldHeight] = __props.node.size;\n        const scene = (_c = __props.node.widgets) == null ? void 0 : _c.find((w) => w.name === \"image\");\n        const sceneHeight = scene == null ? void 0 : scene.computedHeight;\n        if (sceneHeight) {\n          const sceneWidth = oldWidth - 20;\n          const outputRatio = Number(outputHeight.value) / Number(outputWidth.value);\n          const expectSceneHeight = sceneWidth * outputRatio;\n          __props.node.setSize([oldWidth, oldHeight + (expectSceneHeight - sceneHeight)]);\n          (_d = __props.node.graph) == null ? void 0 : _d.setDirtyCanvas(true, true);\n          const load3d = useLoad3dService().getLoad3d(__props.node);\n          if (load3d) {\n            load3d.refreshViewport();\n          }\n        }\n      }\n    };\n    const toggleRecording = () => {\n      if (__props.isRecording) {\n        emit(\"stopRecording\");\n      } else {\n        emit(\"startRecording\");\n      }\n    };\n    const exportRecording = () => {\n      emit(\"exportRecording\");\n    };\n    const clearRecording = () => {\n      emit(\"clearRecording\");\n    };\n    const formatDuration = (seconds) => {\n      const minutes = Math.floor(seconds / 60);\n      const remainingSeconds = Math.floor(seconds % 60);\n      return `${minutes.toString().padStart(2, \"0\")}:${remainingSeconds.toString().padStart(2, \"0\")}`;\n    };\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", _hoisted_1$8, [\n        createElementVNode(\"div\", _hoisted_2$5, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text\",\n            onClick: resizeNodeMatchOutput\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_3$3, null, 512), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: unref(t)(\"load3d.resizeNodeMatchOutput\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          }),\n          createVNode(unref(Button), {\n            class: normalizeClass([\"p-button-rounded p-button-text\", {\n              \"p-button-danger\": _ctx.isRecording,\n              \"recording-button-blink\": _ctx.isRecording\n            }]),\n            onClick: toggleRecording\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", {\n                class: normalizeClass([\n                  \"pi\",\n                  _ctx.isRecording ? \"pi-circle-fill\" : \"pi-video\",\n                  \"text-white text-lg\"\n                ])\n              }, null, 2), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: _ctx.isRecording ? unref(t)(\"load3d.stopRecording\") : unref(t)(\"load3d.startRecording\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          }, 8, [\"class\"]),\n          _ctx.hasRecording && !_ctx.isRecording ? (openBlock(), createBlock(unref(Button), {\n            key: 0,\n            class: \"p-button-rounded p-button-text\",\n            onClick: exportRecording\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_4$2, null, 512), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: unref(t)(\"load3d.exportRecording\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          })) : createCommentVNode(\"\", true),\n          _ctx.hasRecording && !_ctx.isRecording ? (openBlock(), createBlock(unref(Button), {\n            key: 1,\n            class: \"p-button-rounded p-button-text\",\n            onClick: clearRecording\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_5$2, null, 512), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: unref(t)(\"load3d.clearRecording\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          })) : createCommentVNode(\"\", true),\n          _ctx.recordingDuration > 0 && !_ctx.isRecording ? (openBlock(), createElementBlock(\"div\", _hoisted_6$1, toDisplayString(formatDuration(_ctx.recordingDuration)), 1)) : createCommentVNode(\"\", true)\n        ])\n      ]);\n    };\n  }\n});\nconst RecordingControls = /* @__PURE__ */ _export_sfc(_sfc_main$b, [[\"__scopeId\", \"data-v-f84f9a0f\"]]);\nconst _hoisted_1$7 = { class: \"space-y-4\" };\nconst _hoisted_2$4 = {\n  key: 0,\n  class: \"space-y-4\"\n};\nconst _sfc_main$a = /* @__PURE__ */ defineComponent({\n  __name: \"CameraControls\",\n  props: {\n    \"cameraType\": {},\n    \"cameraTypeModifiers\": {},\n    \"fov\": {},\n    \"fovModifiers\": {}\n  },\n  emits: [\"update:cameraType\", \"update:fov\"],\n  setup(__props) {\n    const cameras = [\n      { title: t(\"load3d.cameraType.perspective\"), value: \"perspective\" },\n      { title: t(\"load3d.cameraType.orthographic\"), value: \"orthographic\" }\n    ];\n    const cameraType = useModel(__props, \"cameraType\");\n    const fov2 = useModel(__props, \"fov\");\n    const showFOVButton = computed(() => cameraType.value === \"perspective\");\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(Fragment, null, [\n        createElementVNode(\"div\", _hoisted_1$7, [\n          createElementVNode(\"label\", null, toDisplayString(unref(t)(\"load3d.viewer.cameraType\")), 1),\n          createVNode(unref(Select), {\n            modelValue: cameraType.value,\n            \"onUpdate:modelValue\": _cache2[0] || (_cache2[0] = ($event) => cameraType.value = $event),\n            options: cameras,\n            \"option-label\": \"title\",\n            \"option-value\": \"value\"\n          }, null, 8, [\"modelValue\"])\n        ]),\n        showFOVButton.value ? (openBlock(), createElementBlock(\"div\", _hoisted_2$4, [\n          createElementVNode(\"label\", null, toDisplayString(unref(t)(\"load3d.fov\")), 1),\n          createVNode(unref(Slider), {\n            modelValue: fov2.value,\n            \"onUpdate:modelValue\": _cache2[1] || (_cache2[1] = ($event) => fov2.value = $event),\n            min: 10,\n            max: 150,\n            step: 1,\n            \"aria-label\": \"fov\"\n          }, null, 8, [\"modelValue\"])\n        ])) : createCommentVNode(\"\", true)\n      ], 64);\n    };\n  }\n});\nconst _sfc_main$9 = /* @__PURE__ */ defineComponent({\n  __name: \"ExportControls\",\n  emits: [\"exportModel\"],\n  setup(__props, { emit: __emit }) {\n    const emit = __emit;\n    const exportFormats = [\n      { label: \"GLB\", value: \"glb\" },\n      { label: \"OBJ\", value: \"obj\" },\n      { label: \"STL\", value: \"stl\" }\n    ];\n    const exportFormat = ref(\"obj\");\n    const exportModel = (format) => {\n      emit(\"exportModel\", format);\n    };\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(Fragment, null, [\n        createVNode(unref(Select), {\n          modelValue: exportFormat.value,\n          \"onUpdate:modelValue\": _cache2[0] || (_cache2[0] = ($event) => exportFormat.value = $event),\n          options: exportFormats,\n          \"option-label\": \"label\",\n          \"option-value\": \"value\"\n        }, null, 8, [\"modelValue\"]),\n        createVNode(unref(Button), {\n          severity: \"secondary\",\n          text: \"\",\n          rounded: \"\",\n          onClick: _cache2[1] || (_cache2[1] = ($event) => exportModel(exportFormat.value))\n        }, {\n          default: withCtx(() => [\n            createTextVNode(toDisplayString(unref(t)(\"load3d.export\")), 1)\n          ]),\n          _: 1\n        })\n      ], 64);\n    };\n  }\n});\nconst _sfc_main$8 = /* @__PURE__ */ defineComponent({\n  __name: \"LightControls\",\n  props: {\n    \"lightIntensity\": {},\n    \"lightIntensityModifiers\": {}\n  },\n  emits: [\"update:lightIntensity\"],\n  setup(__props) {\n    const lightIntensity = useModel(__props, \"lightIntensity\");\n    const lightIntensityMaximum = useSettingStore().get(\n      \"Comfy.Load3D.LightIntensityMaximum\"\n    );\n    const lightIntensityMinimum = useSettingStore().get(\n      \"Comfy.Load3D.LightIntensityMinimum\"\n    );\n    const lightAdjustmentIncrement = useSettingStore().get(\n      \"Comfy.Load3D.LightAdjustmentIncrement\"\n    );\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(Fragment, null, [\n        createElementVNode(\"label\", null, toDisplayString(unref(t)(\"load3d.lightIntensity\")), 1),\n        createVNode(unref(Slider), {\n          modelValue: lightIntensity.value,\n          \"onUpdate:modelValue\": _cache2[0] || (_cache2[0] = ($event) => lightIntensity.value = $event),\n          class: \"w-full\",\n          min: unref(lightIntensityMinimum),\n          max: unref(lightIntensityMaximum),\n          step: unref(lightAdjustmentIncrement)\n        }, null, 8, [\"modelValue\", \"min\", \"max\", \"step\"])\n      ], 64);\n    };\n  }\n});\nconst _hoisted_1$6 = { class: \"space-y-4\" };\nconst _sfc_main$7 = /* @__PURE__ */ defineComponent({\n  __name: \"ModelControls\",\n  props: {\n    \"upDirection\": {},\n    \"upDirectionModifiers\": {},\n    \"materialMode\": {},\n    \"materialModeModifiers\": {}\n  },\n  emits: [\"update:upDirection\", \"update:materialMode\"],\n  setup(__props) {\n    const upDirection = useModel(__props, \"upDirection\");\n    const materialMode = useModel(__props, \"materialMode\");\n    const upDirectionOptions = [\n      { label: t(\"load3d.upDirections.original\"), value: \"original\" },\n      { label: \"-X\", value: \"-x\" },\n      { label: \"+X\", value: \"+x\" },\n      { label: \"-Y\", value: \"-y\" },\n      { label: \"+Y\", value: \"+y\" },\n      { label: \"-Z\", value: \"-z\" },\n      { label: \"+Z\", value: \"+z\" }\n    ];\n    const materialModeOptions = computed(() => {\n      return [\n        { label: t(\"load3d.materialModes.original\"), value: \"original\" },\n        { label: t(\"load3d.materialModes.normal\"), value: \"normal\" },\n        { label: t(\"load3d.materialModes.wireframe\"), value: \"wireframe\" }\n      ];\n    });\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", _hoisted_1$6, [\n        createElementVNode(\"div\", null, [\n          createElementVNode(\"label\", null, toDisplayString(unref(t)(\"load3d.upDirection\")), 1),\n          createVNode(unref(Select), {\n            modelValue: upDirection.value,\n            \"onUpdate:modelValue\": _cache2[0] || (_cache2[0] = ($event) => upDirection.value = $event),\n            options: upDirectionOptions,\n            \"option-label\": \"label\",\n            \"option-value\": \"value\"\n          }, null, 8, [\"modelValue\"])\n        ]),\n        createElementVNode(\"div\", null, [\n          createElementVNode(\"label\", null, toDisplayString(unref(t)(\"load3d.materialMode\")), 1),\n          createVNode(unref(Select), {\n            modelValue: materialMode.value,\n            \"onUpdate:modelValue\": _cache2[1] || (_cache2[1] = ($event) => materialMode.value = $event),\n            options: materialModeOptions.value,\n            \"option-label\": \"label\",\n            \"option-value\": \"value\"\n          }, null, 8, [\"modelValue\", \"options\"])\n        ])\n      ]);\n    };\n  }\n});\nconst _hoisted_1$5 = { class: \"space-y-4\" };\nconst _hoisted_2$3 = { key: 0 };\nconst _hoisted_3$2 = {\n  for: \"showGrid\",\n  class: \"pl-2\"\n};\nconst _hoisted_4$1 = { key: 1 };\nconst _hoisted_5$1 = {\n  key: 2,\n  class: \"space-y-2\"\n};\nconst _sfc_main$6 = /* @__PURE__ */ defineComponent({\n  __name: \"SceneControls\",\n  props: /* @__PURE__ */ mergeModels({\n    hasBackgroundImage: { type: Boolean }\n  }, {\n    \"backgroundColor\": {},\n    \"backgroundColorModifiers\": {},\n    \"showGrid\": { type: Boolean },\n    \"showGridModifiers\": {}\n  }),\n  emits: /* @__PURE__ */ mergeModels([\"updateBackgroundImage\"], [\"update:backgroundColor\", \"update:showGrid\"]),\n  setup(__props, { emit: __emit }) {\n    const backgroundColor = useModel(__props, \"backgroundColor\");\n    const showGrid = useModel(__props, \"showGrid\");\n    const emit = __emit;\n    const imagePickerRef = ref(null);\n    const openImagePicker = () => {\n      var _a2;\n      (_a2 = imagePickerRef.value) == null ? void 0 : _a2.click();\n    };\n    const handleImageUpload = (event) => {\n      const input = event.target;\n      if (input.files && input.files[0]) {\n        emit(\"updateBackgroundImage\", input.files[0]);\n      }\n      input.value = \"\";\n    };\n    const removeBackgroundImage = () => {\n      emit(\"updateBackgroundImage\", null);\n    };\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", _hoisted_1$5, [\n        !_ctx.hasBackgroundImage ? (openBlock(), createElementBlock(\"div\", _hoisted_2$3, [\n          createElementVNode(\"label\", null, toDisplayString(unref(t)(\"load3d.backgroundColor\")), 1),\n          withDirectives(createElementVNode(\"input\", {\n            \"onUpdate:modelValue\": _cache2[0] || (_cache2[0] = ($event) => backgroundColor.value = $event),\n            type: \"color\",\n            class: \"w-full\"\n          }, null, 512), [\n            [vModelText, backgroundColor.value]\n          ])\n        ])) : createCommentVNode(\"\", true),\n        createElementVNode(\"div\", null, [\n          createVNode(unref(Checkbox), {\n            modelValue: showGrid.value,\n            \"onUpdate:modelValue\": _cache2[1] || (_cache2[1] = ($event) => showGrid.value = $event),\n            \"input-id\": \"showGrid\",\n            binary: \"\",\n            name: \"showGrid\"\n          }, null, 8, [\"modelValue\"]),\n          createElementVNode(\"label\", _hoisted_3$2, toDisplayString(unref(t)(\"load3d.showGrid\")), 1)\n        ]),\n        !_ctx.hasBackgroundImage ? (openBlock(), createElementBlock(\"div\", _hoisted_4$1, [\n          createVNode(unref(Button), {\n            severity: \"secondary\",\n            label: unref(t)(\"load3d.uploadBackgroundImage\"),\n            icon: \"pi pi-image\",\n            class: \"w-full\",\n            onClick: openImagePicker\n          }, null, 8, [\"label\"]),\n          createElementVNode(\"input\", {\n            ref_key: \"imagePickerRef\",\n            ref: imagePickerRef,\n            type: \"file\",\n            accept: \"image/*\",\n            class: \"hidden\",\n            onChange: handleImageUpload\n          }, null, 544)\n        ])) : createCommentVNode(\"\", true),\n        _ctx.hasBackgroundImage ? (openBlock(), createElementBlock(\"div\", _hoisted_5$1, [\n          createVNode(unref(Button), {\n            severity: \"secondary\",\n            label: unref(t)(\"load3d.removeBackgroundImage\"),\n            icon: \"pi pi-times\",\n            class: \"w-full\",\n            onClick: removeBackgroundImage\n          }, null, 8, [\"label\"])\n        ])) : createCommentVNode(\"\", true)\n      ]);\n    };\n  }\n});\nconst _hoisted_1$4 = { class: \"w-72 flex flex-col\" };\nconst _hoisted_2$2 = { class: \"flex-1 overflow-y-auto p-4\" };\nconst _hoisted_3$1 = { class: \"space-y-2\" };\nconst _hoisted_4 = { class: \"p-2 space-y-4\" };\nconst _hoisted_5 = { class: \"p-2 space-y-4\" };\nconst _hoisted_6 = { class: \"p-2 space-y-4\" };\nconst _hoisted_7 = { class: \"p-2 space-y-4\" };\nconst _hoisted_8 = { class: \"p-2 space-y-4\" };\nconst _hoisted_9 = { class: \"p-4\" };\nconst _hoisted_10 = { class: \"flex gap-2\" };\nconst _sfc_main$5 = /* @__PURE__ */ defineComponent({\n  __name: \"Load3dViewerContent\",\n  props: {\n    node: {}\n  },\n  setup(__props) {\n    const props = __props;\n    const viewerContentRef = ref();\n    const containerRef = ref();\n    const mainContentRef = ref();\n    const maximized = ref(false);\n    const mutationObserver = ref(null);\n    const viewer = useLoad3dService().getOrCreateViewer(toRaw(props.node));\n    onMounted(async () => {\n      const source = useLoad3dService().getLoad3d(props.node);\n      if (source && containerRef.value) {\n        await viewer.initializeViewer(containerRef.value, source);\n      }\n      if (viewerContentRef.value) {\n        mutationObserver.value = new MutationObserver((mutations) => {\n          mutations.forEach((mutation) => {\n            if (mutation.type === \"attributes\" && mutation.attributeName === \"maximized\") {\n              maximized.value = mutation.target.getAttribute(\"maximized\") === \"true\";\n              setTimeout(() => {\n                viewer.refreshViewport();\n              }, 0);\n            }\n          });\n        });\n        mutationObserver.value.observe(viewerContentRef.value, {\n          attributes: true,\n          attributeFilter: [\"maximized\"]\n        });\n      }\n      window.addEventListener(\"resize\", viewer.handleResize);\n    });\n    const handleCancel = () => {\n      viewer.restoreInitialState();\n      useDialogStore().closeDialog();\n    };\n    onBeforeUnmount(() => {\n      window.removeEventListener(\"resize\", viewer.handleResize);\n      if (mutationObserver.value) {\n        mutationObserver.value.disconnect();\n        mutationObserver.value = null;\n      }\n    });\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"viewerContentRef\",\n        ref: viewerContentRef,\n        class: normalizeClass([\"flex w-full\", [maximized.value ? \"h-full\" : \"h-[70vh]\"]]),\n        onMouseenter: _cache2[8] || (_cache2[8] = //@ts-ignore\n        (...args) => unref(viewer).handleMouseEnter && unref(viewer).handleMouseEnter(...args)),\n        onMouseleave: _cache2[9] || (_cache2[9] = //@ts-ignore\n        (...args) => unref(viewer).handleMouseLeave && unref(viewer).handleMouseLeave(...args))\n      }, [\n        createElementVNode(\"div\", {\n          ref_key: \"mainContentRef\",\n          ref: mainContentRef,\n          class: \"flex-1 relative\"\n        }, [\n          createElementVNode(\"div\", {\n            ref_key: \"containerRef\",\n            ref: containerRef,\n            class: \"absolute w-full h-full comfy-load-3d-viewer\",\n            onResize: _cache2[0] || (_cache2[0] = //@ts-ignore\n            (...args) => unref(viewer).handleResize && unref(viewer).handleResize(...args))\n          }, null, 544)\n        ], 512),\n        createElementVNode(\"div\", _hoisted_1$4, [\n          createElementVNode(\"div\", _hoisted_2$2, [\n            createElementVNode(\"div\", _hoisted_3$1, [\n              createElementVNode(\"div\", _hoisted_4, [\n                createVNode(_sfc_main$6, {\n                  \"background-color\": unref(viewer).backgroundColor.value,\n                  \"onUpdate:backgroundColor\": _cache2[1] || (_cache2[1] = ($event) => unref(viewer).backgroundColor.value = $event),\n                  \"show-grid\": unref(viewer).showGrid.value,\n                  \"onUpdate:showGrid\": _cache2[2] || (_cache2[2] = ($event) => unref(viewer).showGrid.value = $event),\n                  \"has-background-image\": unref(viewer).hasBackgroundImage.value,\n                  onUpdateBackgroundImage: unref(viewer).handleBackgroundImageUpdate\n                }, null, 8, [\"background-color\", \"show-grid\", \"has-background-image\", \"onUpdateBackgroundImage\"])\n              ]),\n              createElementVNode(\"div\", _hoisted_5, [\n                createVNode(_sfc_main$7, {\n                  \"up-direction\": unref(viewer).upDirection.value,\n                  \"onUpdate:upDirection\": _cache2[3] || (_cache2[3] = ($event) => unref(viewer).upDirection.value = $event),\n                  \"material-mode\": unref(viewer).materialMode.value,\n                  \"onUpdate:materialMode\": _cache2[4] || (_cache2[4] = ($event) => unref(viewer).materialMode.value = $event)\n                }, null, 8, [\"up-direction\", \"material-mode\"])\n              ]),\n              createElementVNode(\"div\", _hoisted_6, [\n                createVNode(_sfc_main$a, {\n                  \"camera-type\": unref(viewer).cameraType.value,\n                  \"onUpdate:cameraType\": _cache2[5] || (_cache2[5] = ($event) => unref(viewer).cameraType.value = $event),\n                  fov: unref(viewer).fov.value,\n                  \"onUpdate:fov\": _cache2[6] || (_cache2[6] = ($event) => unref(viewer).fov.value = $event)\n                }, null, 8, [\"camera-type\", \"fov\"])\n              ]),\n              createElementVNode(\"div\", _hoisted_7, [\n                createVNode(_sfc_main$8, {\n                  \"light-intensity\": unref(viewer).lightIntensity.value,\n                  \"onUpdate:lightIntensity\": _cache2[7] || (_cache2[7] = ($event) => unref(viewer).lightIntensity.value = $event)\n                }, null, 8, [\"light-intensity\"])\n              ]),\n              createElementVNode(\"div\", _hoisted_8, [\n                createVNode(_sfc_main$9, {\n                  onExportModel: unref(viewer).exportModel\n                }, null, 8, [\"onExportModel\"])\n              ])\n            ])\n          ]),\n          createElementVNode(\"div\", _hoisted_9, [\n            createElementVNode(\"div\", _hoisted_10, [\n              createVNode(unref(Button), {\n                icon: \"pi pi-times\",\n                severity: \"secondary\",\n                label: unref(t)(\"g.cancel\"),\n                onClick: handleCancel\n              }, null, 8, [\"label\"])\n            ])\n          ])\n        ])\n      ], 34);\n    };\n  }\n});\nconst Load3DViewerContent = /* @__PURE__ */ _export_sfc(_sfc_main$5, [[\"__scopeId\", \"data-v-a5b1f8dd\"]]);\nconst _hoisted_1$3 = { class: \"relative bg-gray-700 bg-opacity-30 rounded-lg\" };\nconst _hoisted_2$1 = { class: \"flex flex-col gap-2\" };\nconst _hoisted_3 = { class: \"pi pi-expand text-white text-lg\" };\nconst _sfc_main$4 = /* @__PURE__ */ defineComponent({\n  __name: \"ViewerControls\",\n  props: {\n    node: {}\n  },\n  setup(__props) {\n    const vTooltip = Tooltip;\n    const openIn3DViewer = () => {\n      const props = { node: __props.node };\n      useDialogStore().showDialog({\n        key: \"global-load3d-viewer\",\n        title: t(\"load3d.viewer.title\"),\n        component: Load3DViewerContent,\n        props,\n        dialogComponentProps: {\n          style: \"width: 80vw; height: 80vh;\",\n          maximizable: true,\n          onClose: async () => {\n            await useLoad3dService().handleViewerClose(props.node);\n          }\n        }\n      });\n    };\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", _hoisted_1$3, [\n        createElementVNode(\"div\", _hoisted_2$1, [\n          createVNode(unref(Button), {\n            class: \"p-button-rounded p-button-text\",\n            onClick: openIn3DViewer\n          }, {\n            default: withCtx(() => [\n              withDirectives(createElementVNode(\"i\", _hoisted_3, null, 512), [\n                [\n                  unref(vTooltip),\n                  {\n                    value: unref(t)(\"load3d.openIn3DViewer\"),\n                    showDelay: 300\n                  },\n                  void 0,\n                  { right: true }\n                ]\n              ])\n            ]),\n            _: 1\n          })\n        ])\n      ]);\n    };\n  }\n});\nconst _hoisted_1$2 = {\n  key: 0,\n  class: \"absolute top-12 right-2 z-20 pointer-events-auto\"\n};\nconst _sfc_main$3 = /* @__PURE__ */ defineComponent({\n  __name: \"Load3D\",\n  props: {\n    widget: {}\n  },\n  setup(__props) {\n    const { t: t2 } = useI18n();\n    const inputSpec = __props.widget.inputSpec;\n    const node = __props.widget.node;\n    const type = inputSpec.type;\n    const backgroundColor = ref(\"#000000\");\n    const showGrid = ref(true);\n    const showPreview = ref(false);\n    const lightIntensity = ref(5);\n    const showLightIntensityButton = ref(true);\n    const fov2 = ref(75);\n    const showFOVButton = ref(true);\n    const cameraType = ref(\"perspective\");\n    const hasBackgroundImage = ref(false);\n    const backgroundImage = ref(\"\");\n    const upDirection = ref(\"original\");\n    const materialMode = ref(\"original\");\n    const edgeThreshold = ref(85);\n    const load3DSceneRef = ref(null);\n    const isRecording = ref(false);\n    const hasRecording = ref(false);\n    const recordingDuration = ref(0);\n    const showRecordingControls = ref(!inputSpec.isPreview);\n    const enable3DViewer = computed(\n      () => useSettingStore().get(\"Comfy.Load3D.3DViewerEnable\")\n    );\n    const showPreviewButton = computed(() => {\n      return !type.includes(\"Preview\");\n    });\n    const handleMouseEnter = () => {\n      var _a2;\n      if ((_a2 = load3DSceneRef.value) == null ? void 0 : _a2.load3d) {\n        load3DSceneRef.value.load3d.updateStatusMouseOnScene(true);\n      }\n    };\n    const handleMouseLeave = () => {\n      var _a2;\n      if ((_a2 = load3DSceneRef.value) == null ? void 0 : _a2.load3d) {\n        load3DSceneRef.value.load3d.updateStatusMouseOnScene(false);\n      }\n    };\n    const handleStartRecording = async () => {\n      var _a2;\n      if ((_a2 = load3DSceneRef.value) == null ? void 0 : _a2.load3d) {\n        await load3DSceneRef.value.load3d.startRecording();\n        isRecording.value = true;\n      }\n    };\n    const handleStopRecording = () => {\n      var _a2;\n      if ((_a2 = load3DSceneRef.value) == null ? void 0 : _a2.load3d) {\n        load3DSceneRef.value.load3d.stopRecording();\n        isRecording.value = false;\n        recordingDuration.value = load3DSceneRef.value.load3d.getRecordingDuration();\n        hasRecording.value = recordingDuration.value > 0;\n      }\n    };\n    const handleExportRecording = () => {\n      var _a2;\n      if ((_a2 = load3DSceneRef.value) == null ? void 0 : _a2.load3d) {\n        const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, \"-\");\n        const filename = `${timestamp}-scene-recording.mp4`;\n        load3DSceneRef.value.load3d.exportRecording(filename);\n      }\n    };\n    const handleClearRecording = () => {\n      var _a2;\n      if ((_a2 = load3DSceneRef.value) == null ? void 0 : _a2.load3d) {\n        load3DSceneRef.value.load3d.clearRecording();\n        hasRecording.value = false;\n        recordingDuration.value = 0;\n      }\n    };\n    const switchCamera = () => {\n      cameraType.value = cameraType.value === \"perspective\" ? \"orthographic\" : \"perspective\";\n      showFOVButton.value = cameraType.value === \"perspective\";\n      node.properties[\"Camera Type\"] = cameraType.value;\n    };\n    const togglePreview = (value) => {\n      showPreview.value = value;\n      node.properties[\"Show Preview\"] = showPreview.value;\n    };\n    const toggleGrid = (value) => {\n      showGrid.value = value;\n      node.properties[\"Show Grid\"] = showGrid.value;\n    };\n    const handleUpdateLightIntensity = (value) => {\n      lightIntensity.value = value;\n      node.properties[\"Light Intensity\"] = lightIntensity.value;\n    };\n    const handleBackgroundImageUpdate = async (file2) => {\n      if (!file2) {\n        hasBackgroundImage.value = false;\n        backgroundImage.value = \"\";\n        node.properties[\"Background Image\"] = \"\";\n        return;\n      }\n      const resourceFolder = node.properties[\"Resource Folder\"] || \"\";\n      const subfolder = resourceFolder.trim() ? `3d/${resourceFolder.trim()}` : \"3d\";\n      backgroundImage.value = await Load3dUtils.uploadFile(file2, subfolder);\n      node.properties[\"Background Image\"] = backgroundImage.value;\n    };\n    const handleUpdateFOV = (value) => {\n      fov2.value = value;\n      node.properties[\"FOV\"] = fov2.value;\n    };\n    const handleUpdateEdgeThreshold = (value) => {\n      edgeThreshold.value = value;\n      node.properties[\"Edge Threshold\"] = edgeThreshold.value;\n    };\n    const handleBackgroundColorChange = (value) => {\n      backgroundColor.value = value;\n      node.properties[\"Background Color\"] = value;\n    };\n    const handleUpdateUpDirection = (value) => {\n      upDirection.value = value;\n      node.properties[\"Up Direction\"] = value;\n    };\n    const handleUpdateMaterialMode = (value) => {\n      materialMode.value = value;\n      node.properties[\"Material Mode\"] = value;\n    };\n    const handleExportModel = async (format) => {\n      var _a2;\n      if (!((_a2 = load3DSceneRef.value) == null ? void 0 : _a2.load3d)) {\n        useToastStore().addAlert(t2(\"toastMessages.no3dSceneToExport\"));\n        return;\n      }\n      try {\n        await load3DSceneRef.value.load3d.exportModel(format);\n      } catch (error) {\n        console.error(\"Error exporting model:\", error);\n        useToastStore().addAlert(\n          t2(\"toastMessages.failedToExportModel\", {\n            format: format.toUpperCase()\n          })\n        );\n      }\n    };\n    const listenMaterialModeChange = (mode) => {\n      materialMode.value = mode;\n      showLightIntensityButton.value = mode === \"original\";\n    };\n    const listenUpDirectionChange = (value) => {\n      upDirection.value = value;\n    };\n    const listenEdgeThresholdChange = (value) => {\n      edgeThreshold.value = value;\n    };\n    const listenRecordingStatusChange = (value) => {\n      var _a2;\n      isRecording.value = value;\n      if (!value && ((_a2 = load3DSceneRef.value) == null ? void 0 : _a2.load3d)) {\n        recordingDuration.value = load3DSceneRef.value.load3d.getRecordingDuration();\n        hasRecording.value = recordingDuration.value > 0;\n      }\n    };\n    const listenBackgroundColorChange = (value) => {\n      backgroundColor.value = value;\n    };\n    const listenLightIntensityChange = (value) => {\n      lightIntensity.value = value;\n    };\n    const listenFOVChange = (value) => {\n      fov2.value = value;\n    };\n    const listenCameraTypeChange = (value) => {\n      cameraType.value = value;\n      showFOVButton.value = cameraType.value === \"perspective\";\n    };\n    const listenShowGridChange = (value) => {\n      showGrid.value = value;\n    };\n    const listenShowPreviewChange = (value) => {\n      showPreview.value = value;\n    };\n    const listenBackgroundImageChange = (value) => {\n      backgroundImage.value = value;\n      if (backgroundImage.value && backgroundImage.value !== \"\") {\n        hasBackgroundImage.value = true;\n      }\n    };\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", {\n        class: \"relative w-full h-full\",\n        onMouseenter: handleMouseEnter,\n        onMouseleave: handleMouseLeave\n      }, [\n        createVNode(_sfc_main$c, {\n          ref_key: \"load3DSceneRef\",\n          ref: load3DSceneRef,\n          node: unref(node),\n          \"input-spec\": unref(inputSpec),\n          \"background-color\": backgroundColor.value,\n          \"show-grid\": showGrid.value,\n          \"light-intensity\": lightIntensity.value,\n          fov: fov2.value,\n          \"camera-type\": cameraType.value,\n          \"show-preview\": showPreview.value,\n          \"background-image\": backgroundImage.value,\n          \"up-direction\": upDirection.value,\n          \"material-mode\": materialMode.value,\n          \"edge-threshold\": edgeThreshold.value,\n          onMaterialModeChange: listenMaterialModeChange,\n          onBackgroundColorChange: listenBackgroundColorChange,\n          onLightIntensityChange: listenLightIntensityChange,\n          onFovChange: listenFOVChange,\n          onCameraTypeChange: listenCameraTypeChange,\n          onShowGridChange: listenShowGridChange,\n          onShowPreviewChange: listenShowPreviewChange,\n          onBackgroundImageChange: listenBackgroundImageChange,\n          onUpDirectionChange: listenUpDirectionChange,\n          onEdgeThresholdChange: listenEdgeThresholdChange,\n          onRecordingStatusChange: listenRecordingStatusChange\n        }, null, 8, [\"node\", \"input-spec\", \"background-color\", \"show-grid\", \"light-intensity\", \"fov\", \"camera-type\", \"show-preview\", \"background-image\", \"up-direction\", \"material-mode\", \"edge-threshold\"]),\n        createVNode(_sfc_main$e, {\n          \"input-spec\": unref(inputSpec),\n          \"background-color\": backgroundColor.value,\n          \"show-grid\": showGrid.value,\n          \"show-preview\": showPreview.value,\n          \"light-intensity\": lightIntensity.value,\n          \"show-light-intensity-button\": showLightIntensityButton.value,\n          fov: fov2.value,\n          \"show-f-o-v-button\": showFOVButton.value,\n          \"show-preview-button\": showPreviewButton.value,\n          \"camera-type\": cameraType.value,\n          \"has-background-image\": hasBackgroundImage.value,\n          \"up-direction\": upDirection.value,\n          \"material-mode\": materialMode.value,\n          \"edge-threshold\": edgeThreshold.value,\n          onUpdateBackgroundImage: handleBackgroundImageUpdate,\n          onSwitchCamera: switchCamera,\n          onToggleGrid: toggleGrid,\n          onUpdateBackgroundColor: handleBackgroundColorChange,\n          onUpdateLightIntensity: handleUpdateLightIntensity,\n          onTogglePreview: togglePreview,\n          onUpdateFOV: handleUpdateFOV,\n          onUpdateUpDirection: handleUpdateUpDirection,\n          onUpdateMaterialMode: handleUpdateMaterialMode,\n          onUpdateEdgeThreshold: handleUpdateEdgeThreshold,\n          onExportModel: handleExportModel\n        }, null, 8, [\"input-spec\", \"background-color\", \"show-grid\", \"show-preview\", \"light-intensity\", \"show-light-intensity-button\", \"fov\", \"show-f-o-v-button\", \"show-preview-button\", \"camera-type\", \"has-background-image\", \"up-direction\", \"material-mode\", \"edge-threshold\"]),\n        enable3DViewer.value ? (openBlock(), createElementBlock(\"div\", _hoisted_1$2, [\n          createVNode(_sfc_main$4, { node: unref(node) }, null, 8, [\"node\"])\n        ])) : createCommentVNode(\"\", true),\n        showRecordingControls.value ? (openBlock(), createElementBlock(\"div\", {\n          key: 1,\n          class: normalizeClass([\"absolute right-2 z-20 pointer-events-auto\", {\n            \"top-12\": !enable3DViewer.value,\n            \"top-24\": enable3DViewer.value\n          }])\n        }, [\n          createVNode(RecordingControls, {\n            node: unref(node),\n            \"is-recording\": isRecording.value,\n            \"has-recording\": hasRecording.value,\n            \"recording-duration\": recordingDuration.value,\n            onStartRecording: handleStartRecording,\n            onStopRecording: handleStopRecording,\n            onExportRecording: handleExportRecording,\n            onClearRecording: handleClearRecording\n          }, null, 8, [\"node\", \"is-recording\", \"has-recording\", \"recording-duration\"])\n        ], 2)) : createCommentVNode(\"\", true)\n      ], 32);\n    };\n  }\n});\nconst _hoisted_1$1 = {\n  key: 0,\n  class: \"absolute top-0 left-0 w-full flex justify-center pt-2 gap-2 items-center pointer-events-auto z-10\"\n};\nconst _sfc_main$2 = /* @__PURE__ */ defineComponent({\n  __name: \"Load3DAnimationControls\",\n  props: {\n    animations: {},\n    playing: { type: Boolean }\n  },\n  emits: [\"togglePlay\", \"speedChange\", \"animationChange\"],\n  setup(__props, { emit: __emit }) {\n    const props = __props;\n    const emit = __emit;\n    const animations = ref(props.animations);\n    const playing = ref(props.playing);\n    const selectedSpeed = ref(1);\n    const selectedAnimation = ref(0);\n    const speedOptions = [\n      { name: \"0.1x\", value: 0.1 },\n      { name: \"0.5x\", value: 0.5 },\n      { name: \"1x\", value: 1 },\n      { name: \"1.5x\", value: 1.5 },\n      { name: \"2x\", value: 2 }\n    ];\n    watch(\n      () => props.animations,\n      (newVal) => {\n        animations.value = newVal;\n      }\n    );\n    const togglePlay = () => {\n      playing.value = !playing.value;\n      emit(\"togglePlay\", playing.value);\n    };\n    const speedChange = () => {\n      emit(\"speedChange\", selectedSpeed.value);\n    };\n    const animationChange = () => {\n      emit(\"animationChange\", selectedAnimation.value);\n    };\n    return (_ctx, _cache2) => {\n      return animations.value && animations.value.length > 0 ? (openBlock(), createElementBlock(\"div\", _hoisted_1$1, [\n        createVNode(unref(Button), {\n          class: \"p-button-rounded p-button-text\",\n          onClick: togglePlay\n        }, {\n          default: withCtx(() => [\n            createElementVNode(\"i\", {\n              class: normalizeClass([\"pi\", playing.value ? \"pi-pause\" : \"pi-play\", \"text-white text-lg\"])\n            }, null, 2)\n          ]),\n          _: 1\n        }),\n        createVNode(unref(Select), {\n          modelValue: selectedSpeed.value,\n          \"onUpdate:modelValue\": _cache2[0] || (_cache2[0] = ($event) => selectedSpeed.value = $event),\n          options: speedOptions,\n          \"option-label\": \"name\",\n          \"option-value\": \"value\",\n          class: \"w-24\",\n          onChange: speedChange\n        }, null, 8, [\"modelValue\"]),\n        createVNode(unref(Select), {\n          modelValue: selectedAnimation.value,\n          \"onUpdate:modelValue\": _cache2[1] || (_cache2[1] = ($event) => selectedAnimation.value = $event),\n          options: animations.value,\n          \"option-label\": \"name\",\n          \"option-value\": \"index\",\n          class: \"w-32\",\n          onChange: animationChange\n        }, null, 8, [\"modelValue\", \"options\"])\n      ])) : createCommentVNode(\"\", true);\n    };\n  }\n});\nconst _sfc_main$1 = /* @__PURE__ */ defineComponent({\n  __name: \"Load3DAnimationScene\",\n  props: {\n    node: {},\n    inputSpec: {},\n    backgroundColor: {},\n    showGrid: { type: Boolean },\n    lightIntensity: {},\n    fov: {},\n    cameraType: {},\n    showPreview: { type: Boolean },\n    materialMode: {},\n    upDirection: {},\n    showFOVButton: { type: Boolean },\n    showLightIntensityButton: { type: Boolean },\n    playing: { type: Boolean },\n    selectedSpeed: {},\n    selectedAnimation: {},\n    backgroundImage: {}\n  },\n  emits: [\"animationListChange\", \"materialModeChange\", \"backgroundColorChange\", \"lightIntensityChange\", \"fovChange\", \"cameraTypeChange\", \"showGridChange\", \"showPreviewChange\", \"upDirectionChange\", \"recording-status-change\"],\n  setup(__props, { expose: __expose, emit: __emit }) {\n    const props = __props;\n    const node = ref(props.node);\n    const backgroundColor = ref(props.backgroundColor);\n    const showPreview = ref(props.showPreview);\n    const fov2 = ref(props.fov);\n    const lightIntensity = ref(props.lightIntensity);\n    const cameraType = ref(props.cameraType);\n    const showGrid = ref(props.showGrid);\n    const upDirection = ref(props.upDirection);\n    const materialMode = ref(props.materialMode);\n    const showFOVButton = ref(props.showFOVButton);\n    const showLightIntensityButton = ref(props.showLightIntensityButton);\n    const load3DSceneRef = ref(null);\n    watch(\n      () => props.cameraType,\n      (newValue) => {\n        cameraType.value = newValue;\n      }\n    );\n    watch(\n      () => props.showGrid,\n      (newValue) => {\n        showGrid.value = newValue;\n      }\n    );\n    watch(\n      () => props.backgroundColor,\n      (newValue) => {\n        backgroundColor.value = newValue;\n      }\n    );\n    watch(\n      () => props.lightIntensity,\n      (newValue) => {\n        lightIntensity.value = newValue;\n      }\n    );\n    watch(\n      () => props.fov,\n      (newValue) => {\n        fov2.value = newValue;\n      }\n    );\n    watch(\n      () => props.upDirection,\n      (newValue) => {\n        upDirection.value = newValue;\n      }\n    );\n    watch(\n      () => props.materialMode,\n      (newValue) => {\n        materialMode.value = newValue;\n      }\n    );\n    watch(\n      () => props.showPreview,\n      (newValue) => {\n        showPreview.value = newValue;\n      }\n    );\n    watch(\n      () => props.playing,\n      (newValue) => {\n        var _a2;\n        const load3d = (_a2 = load3DSceneRef.value) == null ? void 0 : _a2.load3d;\n        load3d == null ? void 0 : load3d.toggleAnimation(newValue);\n      }\n    );\n    watch(\n      () => props.selectedSpeed,\n      (newValue) => {\n        var _a2;\n        const load3d = (_a2 = load3DSceneRef.value) == null ? void 0 : _a2.load3d;\n        load3d == null ? void 0 : load3d.setAnimationSpeed(newValue);\n      }\n    );\n    watch(\n      () => props.selectedAnimation,\n      (newValue) => {\n        var _a2;\n        const load3d = (_a2 = load3DSceneRef.value) == null ? void 0 : _a2.load3d;\n        load3d == null ? void 0 : load3d.updateSelectedAnimation(newValue);\n      }\n    );\n    const emit = __emit;\n    const listenMaterialModeChange = (mode) => {\n      materialMode.value = mode;\n      showLightIntensityButton.value = mode === \"original\";\n    };\n    const listenBackgroundColorChange = (value) => {\n      backgroundColor.value = value;\n    };\n    const listenLightIntensityChange = (value) => {\n      lightIntensity.value = value;\n    };\n    const listenFOVChange = (value) => {\n      fov2.value = value;\n    };\n    const listenCameraTypeChange = (value) => {\n      cameraType.value = value;\n      showFOVButton.value = cameraType.value === \"perspective\";\n    };\n    const listenShowGridChange = (value) => {\n      showGrid.value = value;\n    };\n    const listenShowPreviewChange = (value) => {\n      showPreview.value = value;\n    };\n    const listenRecordingStatusChange = (value) => {\n      emit(\"recording-status-change\", value);\n    };\n    const animationListeners = {\n      animationListChange: (newValue) => {\n        emit(\"animationListChange\", newValue);\n      }\n    };\n    __expose({\n      load3DSceneRef\n    });\n    return (_ctx, _cache2) => {\n      return openBlock(), createBlock(_sfc_main$c, {\n        ref_key: \"load3DSceneRef\",\n        ref: load3DSceneRef,\n        node: node.value,\n        \"input-spec\": _ctx.inputSpec,\n        \"background-color\": backgroundColor.value,\n        \"show-grid\": showGrid.value,\n        \"light-intensity\": lightIntensity.value,\n        fov: fov2.value,\n        \"camera-type\": cameraType.value,\n        \"show-preview\": showPreview.value,\n        \"extra-listeners\": animationListeners,\n        \"background-image\": _ctx.backgroundImage,\n        \"up-direction\": upDirection.value,\n        \"material-mode\": materialMode.value,\n        onMaterialModeChange: listenMaterialModeChange,\n        onBackgroundColorChange: listenBackgroundColorChange,\n        onLightIntensityChange: listenLightIntensityChange,\n        onFovChange: listenFOVChange,\n        onCameraTypeChange: listenCameraTypeChange,\n        onShowGridChange: listenShowGridChange,\n        onShowPreviewChange: listenShowPreviewChange,\n        onRecordingStatusChange: listenRecordingStatusChange\n      }, null, 8, [\"node\", \"input-spec\", \"background-color\", \"show-grid\", \"light-intensity\", \"fov\", \"camera-type\", \"show-preview\", \"background-image\", \"up-direction\", \"material-mode\"]);\n    };\n  }\n});\nconst _hoisted_1 = { class: \"absolute top-0 left-0 w-full h-full pointer-events-none\" };\nconst _hoisted_2 = {\n  key: 0,\n  class: \"absolute top-12 right-2 z-20 pointer-events-auto\"\n};\nconst _sfc_main = /* @__PURE__ */ defineComponent({\n  __name: \"Load3DAnimation\",\n  props: {\n    widget: {}\n  },\n  setup(__props) {\n    const inputSpec = __props.widget.inputSpec;\n    const node = __props.widget.node;\n    const type = inputSpec.type;\n    const backgroundColor = ref(\"#000000\");\n    const showGrid = ref(true);\n    const showPreview = ref(false);\n    const lightIntensity = ref(5);\n    const showLightIntensityButton = ref(true);\n    const fov2 = ref(75);\n    const showFOVButton = ref(true);\n    const cameraType = ref(\"perspective\");\n    const hasBackgroundImage = ref(false);\n    const animations = ref([]);\n    const playing = ref(false);\n    const selectedSpeed = ref(1);\n    const selectedAnimation = ref(0);\n    const backgroundImage = ref(\"\");\n    const isRecording = ref(false);\n    const hasRecording = ref(false);\n    const recordingDuration = ref(0);\n    const showRecordingControls = ref(!inputSpec.isPreview);\n    const showPreviewButton = computed(() => {\n      return !type.includes(\"Preview\");\n    });\n    const load3DAnimationSceneRef = ref(null);\n    const handleMouseEnter = () => {\n      var _a2;\n      const sceneRef = (_a2 = load3DAnimationSceneRef.value) == null ? void 0 : _a2.load3DSceneRef;\n      if (sceneRef == null ? void 0 : sceneRef.load3d) {\n        sceneRef.load3d.updateStatusMouseOnScene(true);\n      }\n    };\n    const handleMouseLeave = () => {\n      var _a2;\n      const sceneRef = (_a2 = load3DAnimationSceneRef.value) == null ? void 0 : _a2.load3DSceneRef;\n      if (sceneRef == null ? void 0 : sceneRef.load3d) {\n        sceneRef.load3d.updateStatusMouseOnScene(false);\n      }\n    };\n    const handleStartRecording = async () => {\n      var _a2;\n      const sceneRef = (_a2 = load3DAnimationSceneRef.value) == null ? void 0 : _a2.load3DSceneRef;\n      if (sceneRef == null ? void 0 : sceneRef.load3d) {\n        await sceneRef.load3d.startRecording();\n        isRecording.value = true;\n      }\n    };\n    const handleStopRecording = () => {\n      var _a2;\n      const sceneRef = (_a2 = load3DAnimationSceneRef.value) == null ? void 0 : _a2.load3DSceneRef;\n      if (sceneRef == null ? void 0 : sceneRef.load3d) {\n        sceneRef.load3d.stopRecording();\n        isRecording.value = false;\n        recordingDuration.value = sceneRef.load3d.getRecordingDuration();\n        hasRecording.value = recordingDuration.value > 0;\n      }\n    };\n    const handleExportRecording = () => {\n      var _a2;\n      const sceneRef = (_a2 = load3DAnimationSceneRef.value) == null ? void 0 : _a2.load3DSceneRef;\n      if (sceneRef == null ? void 0 : sceneRef.load3d) {\n        const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, \"-\");\n        const filename = `${timestamp}-animation-recording.mp4`;\n        sceneRef.load3d.exportRecording(filename);\n      }\n    };\n    const handleClearRecording = () => {\n      var _a2;\n      const sceneRef = (_a2 = load3DAnimationSceneRef.value) == null ? void 0 : _a2.load3DSceneRef;\n      if (sceneRef == null ? void 0 : sceneRef.load3d) {\n        sceneRef.load3d.clearRecording();\n        hasRecording.value = false;\n        recordingDuration.value = 0;\n      }\n    };\n    const listenRecordingStatusChange = (value) => {\n      var _a2;\n      isRecording.value = value;\n      if (!value) {\n        const sceneRef = (_a2 = load3DAnimationSceneRef.value) == null ? void 0 : _a2.load3DSceneRef;\n        if (sceneRef == null ? void 0 : sceneRef.load3d) {\n          recordingDuration.value = sceneRef.load3d.getRecordingDuration();\n          hasRecording.value = recordingDuration.value > 0;\n        }\n      }\n    };\n    const switchCamera = () => {\n      cameraType.value = cameraType.value === \"perspective\" ? \"orthographic\" : \"perspective\";\n      showFOVButton.value = cameraType.value === \"perspective\";\n      node.properties[\"Camera Type\"] = cameraType.value;\n    };\n    const togglePreview = (value) => {\n      showPreview.value = value;\n      node.properties[\"Show Preview\"] = showPreview.value;\n    };\n    const toggleGrid = (value) => {\n      showGrid.value = value;\n      node.properties[\"Show Grid\"] = showGrid.value;\n    };\n    const handleUpdateLightIntensity = (value) => {\n      lightIntensity.value = value;\n      node.properties[\"Light Intensity\"] = lightIntensity.value;\n    };\n    const handleBackgroundImageUpdate = async (file2) => {\n      if (!file2) {\n        hasBackgroundImage.value = false;\n        backgroundImage.value = \"\";\n        node.properties[\"Background Image\"] = \"\";\n        return;\n      }\n      const resourceFolder = node.properties[\"Resource Folder\"] || \"\";\n      const subfolder = resourceFolder.trim() ? `3d/${resourceFolder.trim()}` : \"3d\";\n      backgroundImage.value = await Load3dUtils.uploadFile(file2, subfolder);\n      node.properties[\"Background Image\"] = backgroundImage.value;\n    };\n    const handleUpdateFOV = (value) => {\n      fov2.value = value;\n      node.properties[\"FOV\"] = fov2.value;\n    };\n    const materialMode = ref(\"original\");\n    const upDirection = ref(\"original\");\n    const handleUpdateUpDirection = (value) => {\n      upDirection.value = value;\n      node.properties[\"Up Direction\"] = value;\n    };\n    const handleUpdateMaterialMode = (value) => {\n      materialMode.value = value;\n      node.properties[\"Material Mode\"] = value;\n    };\n    const handleBackgroundColorChange = (value) => {\n      backgroundColor.value = value;\n      node.properties[\"Background Color\"] = value;\n    };\n    const togglePlay = (value) => {\n      playing.value = value;\n    };\n    const speedChange = (value) => {\n      selectedSpeed.value = value;\n    };\n    const animationChange = (value) => {\n      selectedAnimation.value = value;\n    };\n    const animationListChange = (value) => {\n      animations.value = value;\n    };\n    const listenMaterialModeChange = (mode) => {\n      materialMode.value = mode;\n      showLightIntensityButton.value = mode === \"original\";\n    };\n    const listenUpDirectionChange = (value) => {\n      upDirection.value = value;\n    };\n    const listenBackgroundColorChange = (value) => {\n      backgroundColor.value = value;\n    };\n    const listenLightIntensityChange = (value) => {\n      lightIntensity.value = value;\n    };\n    const listenFOVChange = (value) => {\n      fov2.value = value;\n    };\n    const listenCameraTypeChange = (value) => {\n      cameraType.value = value;\n      showFOVButton.value = cameraType.value === \"perspective\";\n    };\n    const listenShowGridChange = (value) => {\n      showGrid.value = value;\n    };\n    const listenShowPreviewChange = (value) => {\n      showPreview.value = value;\n    };\n    const listenBackgroundImageChange = (value) => {\n      backgroundImage.value = value;\n      if (backgroundImage.value && backgroundImage.value !== \"\") {\n        hasBackgroundImage.value = true;\n      }\n    };\n    return (_ctx, _cache2) => {\n      return openBlock(), createElementBlock(\"div\", {\n        class: \"relative w-full h-full\",\n        onMouseenter: handleMouseEnter,\n        onMouseleave: handleMouseLeave\n      }, [\n        createVNode(_sfc_main$1, {\n          ref_key: \"load3DAnimationSceneRef\",\n          ref: load3DAnimationSceneRef,\n          node: unref(node),\n          \"input-spec\": unref(inputSpec),\n          \"background-color\": backgroundColor.value,\n          \"show-grid\": showGrid.value,\n          \"light-intensity\": lightIntensity.value,\n          fov: fov2.value,\n          \"camera-type\": cameraType.value,\n          \"show-preview\": showPreview.value,\n          \"show-f-o-v-button\": showFOVButton.value,\n          \"show-light-intensity-button\": showLightIntensityButton.value,\n          playing: playing.value,\n          \"selected-speed\": selectedSpeed.value,\n          \"selected-animation\": selectedAnimation.value,\n          \"background-image\": backgroundImage.value,\n          \"up-direction\": upDirection.value,\n          \"material-mode\": materialMode.value,\n          onMaterialModeChange: listenMaterialModeChange,\n          onBackgroundColorChange: listenBackgroundColorChange,\n          onLightIntensityChange: listenLightIntensityChange,\n          onFovChange: listenFOVChange,\n          onCameraTypeChange: listenCameraTypeChange,\n          onShowGridChange: listenShowGridChange,\n          onShowPreviewChange: listenShowPreviewChange,\n          onBackgroundImageChange: listenBackgroundImageChange,\n          onAnimationListChange: animationListChange,\n          onUpDirectionChange: listenUpDirectionChange,\n          onRecordingStatusChange: listenRecordingStatusChange\n        }, null, 8, [\"node\", \"input-spec\", \"background-color\", \"show-grid\", \"light-intensity\", \"fov\", \"camera-type\", \"show-preview\", \"show-f-o-v-button\", \"show-light-intensity-button\", \"playing\", \"selected-speed\", \"selected-animation\", \"background-image\", \"up-direction\", \"material-mode\"]),\n        createElementVNode(\"div\", _hoisted_1, [\n          createVNode(_sfc_main$e, {\n            \"input-spec\": unref(inputSpec),\n            \"background-color\": backgroundColor.value,\n            \"show-grid\": showGrid.value,\n            \"show-preview\": showPreview.value,\n            \"light-intensity\": lightIntensity.value,\n            \"show-light-intensity-button\": showLightIntensityButton.value,\n            fov: fov2.value,\n            \"show-f-o-v-button\": showFOVButton.value,\n            \"show-preview-button\": showPreviewButton.value,\n            \"camera-type\": cameraType.value,\n            \"has-background-image\": hasBackgroundImage.value,\n            \"up-direction\": upDirection.value,\n            \"material-mode\": materialMode.value,\n            onUpdateBackgroundImage: handleBackgroundImageUpdate,\n            onSwitchCamera: switchCamera,\n            onToggleGrid: toggleGrid,\n            onUpdateBackgroundColor: handleBackgroundColorChange,\n            onUpdateLightIntensity: handleUpdateLightIntensity,\n            onTogglePreview: togglePreview,\n            onUpdateFOV: handleUpdateFOV,\n            onUpdateUpDirection: handleUpdateUpDirection,\n            onUpdateMaterialMode: handleUpdateMaterialMode\n          }, null, 8, [\"input-spec\", \"background-color\", \"show-grid\", \"show-preview\", \"light-intensity\", \"show-light-intensity-button\", \"fov\", \"show-f-o-v-button\", \"show-preview-button\", \"camera-type\", \"has-background-image\", \"up-direction\", \"material-mode\"]),\n          createVNode(_sfc_main$2, {\n            animations: animations.value,\n            playing: playing.value,\n            onTogglePlay: togglePlay,\n            onSpeedChange: speedChange,\n            onAnimationChange: animationChange\n          }, null, 8, [\"animations\", \"playing\"])\n        ]),\n        showRecordingControls.value ? (openBlock(), createElementBlock(\"div\", _hoisted_2, [\n          createVNode(RecordingControls, {\n            node: unref(node),\n            \"is-recording\": isRecording.value,\n            \"has-recording\": hasRecording.value,\n            \"recording-duration\": recordingDuration.value,\n            onStartRecording: handleStartRecording,\n            onStopRecording: handleStopRecording,\n            onExportRecording: handleExportRecording,\n            onClearRecording: handleClearRecording\n          }, null, 8, [\"node\", \"is-recording\", \"has-recording\", \"recording-duration\"])\n        ])) : createCommentVNode(\"\", true)\n      ], 32);\n    };\n  }\n});\nclass Load3DConfiguration {\n  constructor(load3d) {\n    this.load3d = load3d;\n  }\n  configureForSaveMesh(loadFolder, filePath) {\n    this.setupModelHandlingForSaveMesh(filePath, loadFolder);\n    this.setupDefaultProperties();\n  }\n  configure(loadFolder, modelWidget, cameraState, width = null, height = null) {\n    this.setupModelHandling(modelWidget, loadFolder, cameraState);\n    this.setupTargetSize(width, height);\n    this.setupDefaultProperties();\n  }\n  setupTargetSize(width, height) {\n    if (width && height) {\n      this.load3d.setTargetSize(width.value, height.value);\n      width.callback = (value) => {\n        this.load3d.setTargetSize(value, height.value);\n      };\n      height.callback = (value) => {\n        this.load3d.setTargetSize(width.value, value);\n      };\n    }\n  }\n  setupModelHandlingForSaveMesh(filePath, loadFolder) {\n    const onModelWidgetUpdate = this.createModelUpdateHandler(loadFolder);\n    if (filePath) {\n      onModelWidgetUpdate(filePath);\n    }\n  }\n  setupModelHandling(modelWidget, loadFolder, cameraState) {\n    const onModelWidgetUpdate = this.createModelUpdateHandler(\n      loadFolder,\n      cameraState\n    );\n    if (modelWidget.value) {\n      onModelWidgetUpdate(modelWidget.value);\n    }\n    modelWidget.callback = (value) => {\n      this.load3d.node.properties[\"Texture\"] = void 0;\n      onModelWidgetUpdate(value);\n    };\n  }\n  setupDefaultProperties() {\n    const cameraType = this.load3d.loadNodeProperty(\n      \"Camera Type\",\n      useSettingStore().get(\"Comfy.Load3D.CameraType\")\n    );\n    this.load3d.toggleCamera(cameraType);\n    const showGrid = this.load3d.loadNodeProperty(\n      \"Show Grid\",\n      useSettingStore().get(\"Comfy.Load3D.ShowGrid\")\n    );\n    this.load3d.toggleGrid(showGrid);\n    const showPreview = this.load3d.loadNodeProperty(\n      \"Show Preview\",\n      useSettingStore().get(\"Comfy.Load3D.ShowPreview\")\n    );\n    this.load3d.togglePreview(showPreview);\n    const bgColor = this.load3d.loadNodeProperty(\n      \"Background Color\",\n      \"#\" + useSettingStore().get(\"Comfy.Load3D.BackgroundColor\")\n    );\n    this.load3d.setBackgroundColor(bgColor);\n    const lightIntensity = Number(\n      this.load3d.loadNodeProperty(\n        \"Light Intensity\",\n        useSettingStore().get(\"Comfy.Load3D.LightIntensity\")\n      )\n    );\n    this.load3d.setLightIntensity(lightIntensity);\n    const fov2 = Number(this.load3d.loadNodeProperty(\"FOV\", 35));\n    this.load3d.setFOV(fov2);\n    const backgroundImage = this.load3d.loadNodeProperty(\"Background Image\", \"\");\n    this.load3d.setBackgroundImage(backgroundImage);\n  }\n  createModelUpdateHandler(loadFolder, cameraState) {\n    let isFirstLoad = true;\n    return async (value) => {\n      if (!value) return;\n      const filename = value;\n      this.setResourceFolder(filename);\n      const modelUrl = api.apiURL(\n        Load3dUtils.getResourceURL(\n          ...Load3dUtils.splitFilePath(filename),\n          loadFolder\n        )\n      );\n      await this.load3d.loadModel(modelUrl, filename);\n      const upDirection = this.load3d.loadNodeProperty(\n        \"Up Direction\",\n        \"original\"\n      );\n      this.load3d.setUpDirection(upDirection);\n      const materialMode = this.load3d.loadNodeProperty(\n        \"Material Mode\",\n        \"original\"\n      );\n      this.load3d.setMaterialMode(materialMode);\n      const edgeThreshold = Number(\n        this.load3d.loadNodeProperty(\"Edge Threshold\", 85)\n      );\n      this.load3d.setEdgeThreshold(edgeThreshold);\n      if (isFirstLoad && cameraState && typeof cameraState === \"object\") {\n        try {\n          this.load3d.setCameraState(cameraState);\n        } catch (error) {\n          console.warn(\"Failed to restore camera state:\", error);\n        }\n        isFirstLoad = false;\n      }\n    };\n  }\n  setResourceFolder(filename) {\n    const pathParts = filename.split(\"/\").filter((part) => part.trim());\n    if (pathParts.length <= 2) {\n      return;\n    }\n    const subfolderParts = pathParts.slice(1, -1);\n    const subfolder = subfolderParts.join(\"/\");\n    if (subfolder) {\n      this.load3d.node.properties[\"Resource Folder\"] = subfolder;\n    }\n  }\n}\nasync function handleModelUpload(files, node) {\n  var _a2, _b2, _c, _d, _e, _f;\n  if (!(files == null ? void 0 : files.length)) return;\n  const modelWidget = (_a2 = node.widgets) == null ? void 0 : _a2.find(\n    (w) => w.name === \"model_file\"\n  );\n  try {\n    const resourceFolder = node.properties[\"Resource Folder\"] || \"\";\n    const subfolder = resourceFolder.trim() ? `3d/${resourceFolder.trim()}` : \"3d\";\n    const uploadPath = await Load3dUtils.uploadFile(files[0], subfolder);\n    if (!uploadPath) {\n      useToastStore().addAlert(t(\"toastMessages.fileUploadFailed\"));\n      return;\n    }\n    const modelUrl = api.apiURL(\n      Load3dUtils.getResourceURL(\n        ...Load3dUtils.splitFilePath(uploadPath),\n        \"input\"\n      )\n    );\n    await ((_b2 = useLoad3dService().getLoad3d(node)) == null ? void 0 : _b2.loadModel(modelUrl));\n    if (uploadPath && modelWidget) {\n      if (!((_d = (_c = modelWidget.options) == null ? void 0 : _c.values) == null ? void 0 : _d.includes(uploadPath))) {\n        (_f = (_e = modelWidget.options) == null ? void 0 : _e.values) == null ? void 0 : _f.push(uploadPath);\n      }\n      modelWidget.value = uploadPath;\n    }\n  } catch (error) {\n    console.error(\"Model upload failed:\", error);\n    useToastStore().addAlert(t(\"toastMessages.fileUploadFailed\"));\n  }\n}\nasync function handleResourcesUpload(files, node) {\n  if (!(files == null ? void 0 : files.length)) return;\n  try {\n    const resourceFolder = node.properties[\"Resource Folder\"] || \"\";\n    const subfolder = resourceFolder.trim() ? `3d/${resourceFolder.trim()}` : \"3d\";\n    await Load3dUtils.uploadMultipleFiles(files, subfolder);\n  } catch (error) {\n    console.error(\"Extra resources upload failed:\", error);\n    useToastStore().addAlert(t(\"toastMessages.extraResourcesUploadFailed\"));\n  }\n}\nfunction createFileInput(accept, multiple = false) {\n  const input = document.createElement(\"input\");\n  input.type = \"file\";\n  input.accept = accept;\n  input.multiple = multiple;\n  input.style.display = \"none\";\n  return input;\n}\nuseExtensionService().registerExtension({\n  name: \"Comfy.Load3D\",\n  settings: [\n    {\n      id: \"Comfy.Load3D.ShowGrid\",\n      category: [\"3D\", \"Scene\", \"Initial Grid Visibility\"],\n      name: \"Initial Grid Visibility\",\n      tooltip: \"Controls whether the grid is visible by default when a new 3D widget is created. This default can still be toggled individually for each widget after creation.\",\n      type: \"boolean\",\n      defaultValue: true,\n      experimental: true\n    },\n    {\n      id: \"Comfy.Load3D.ShowPreview\",\n      category: [\"3D\", \"Scene\", \"Initial Preview Visibility\"],\n      name: \"Initial Preview Visibility\",\n      tooltip: \"Controls whether the preview screen is visible by default when a new 3D widget is created. This default can still be toggled individually for each widget after creation.\",\n      type: \"boolean\",\n      defaultValue: true,\n      experimental: true\n    },\n    {\n      id: \"Comfy.Load3D.BackgroundColor\",\n      category: [\"3D\", \"Scene\", \"Initial Background Color\"],\n      name: \"Initial Background Color\",\n      tooltip: \"Controls the default background color of the 3D scene. This setting determines the background appearance when a new 3D widget is created, but can be adjusted individually for each widget after creation.\",\n      type: \"color\",\n      defaultValue: \"282828\",\n      experimental: true\n    },\n    {\n      id: \"Comfy.Load3D.CameraType\",\n      category: [\"3D\", \"Camera\", \"Initial Camera Type\"],\n      name: \"Initial Camera Type\",\n      tooltip: \"Controls whether the camera is perspective or orthographic by default when a new 3D widget is created. This default can still be toggled individually for each widget after creation.\",\n      type: \"combo\",\n      options: [\"perspective\", \"orthographic\"],\n      defaultValue: \"perspective\",\n      experimental: true\n    },\n    {\n      id: \"Comfy.Load3D.LightIntensity\",\n      category: [\"3D\", \"Light\", \"Initial Light Intensity\"],\n      name: \"Initial Light Intensity\",\n      tooltip: \"Sets the default brightness level of lighting in the 3D scene. This value determines how intensely lights illuminate objects when a new 3D widget is created, but can be adjusted individually for each widget after creation.\",\n      type: \"number\",\n      defaultValue: 3,\n      experimental: true\n    },\n    {\n      id: \"Comfy.Load3D.LightIntensityMaximum\",\n      category: [\"3D\", \"Light\", \"Light Intensity Maximum\"],\n      name: \"Light Intensity Maximum\",\n      tooltip: \"Sets the maximum allowable light intensity value for 3D scenes. This defines the upper brightness limit that can be set when adjusting lighting in any 3D widget.\",\n      type: \"number\",\n      defaultValue: 10,\n      experimental: true\n    },\n    {\n      id: \"Comfy.Load3D.LightIntensityMinimum\",\n      category: [\"3D\", \"Light\", \"Light Intensity Minimum\"],\n      name: \"Light Intensity Minimum\",\n      tooltip: \"Sets the minimum allowable light intensity value for 3D scenes. This defines the lower brightness limit that can be set when adjusting lighting in any 3D widget.\",\n      type: \"number\",\n      defaultValue: 1,\n      experimental: true\n    },\n    {\n      id: \"Comfy.Load3D.LightAdjustmentIncrement\",\n      category: [\"3D\", \"Light\", \"Light Adjustment Increment\"],\n      name: \"Light Adjustment Increment\",\n      tooltip: \"Controls the increment size when adjusting light intensity in 3D scenes. A smaller step value allows for finer control over lighting adjustments, while a larger value results in more noticeable changes per adjustment.\",\n      type: \"slider\",\n      attrs: {\n        min: 0.1,\n        max: 1,\n        step: 0.1\n      },\n      defaultValue: 0.5,\n      experimental: true\n    },\n    {\n      id: \"Comfy.Load3D.3DViewerEnable\",\n      category: [\"3D\", \"3DViewer\", \"Enable\"],\n      name: \"Enable 3D Viewer (Beta)\",\n      tooltip: \"Enables the 3D Viewer (Beta) for selected nodes. This feature allows you to visualize and interact with 3D models directly within the full size 3d viewer.\",\n      type: \"boolean\",\n      defaultValue: false,\n      experimental: true\n    }\n  ],\n  commands: [\n    {\n      id: \"Comfy.3DViewer.Open3DViewer\",\n      icon: \"pi pi-pencil\",\n      label: \"Open 3D Viewer (Beta) for Selected Node\",\n      function: () => {\n        const selectedNodes = app.canvas.selected_nodes;\n        if (!selectedNodes || Object.keys(selectedNodes).length !== 1) return;\n        const selectedNode = selectedNodes[Object.keys(selectedNodes)[0]];\n        if (!isLoad3dNode(selectedNode)) return;\n        ComfyApp.copyToClipspace(selectedNode);\n        ComfyApp.clipspace_return_node = selectedNode;\n        const props = { node: selectedNode };\n        useDialogStore().showDialog({\n          key: \"global-load3d-viewer\",\n          title: t(\"load3d.viewer.title\"),\n          component: Load3DViewerContent,\n          props,\n          dialogComponentProps: {\n            style: \"width: 80vw; height: 80vh;\",\n            maximizable: true,\n            onClose: async () => {\n              await useLoad3dService().handleViewerClose(props.node);\n            }\n          }\n        });\n      }\n    }\n  ],\n  getCustomWidgets() {\n    return {\n      LOAD_3D(node) {\n        const fileInput = createFileInput(\".gltf,.glb,.obj,.fbx,.stl\", false);\n        node.properties[\"Resource Folder\"] = \"\";\n        fileInput.onchange = async () => {\n          await handleModelUpload(fileInput.files, node);\n        };\n        node.addWidget(\"button\", \"upload 3d model\", \"upload3dmodel\", () => {\n          fileInput.click();\n        });\n        const resourcesInput = createFileInput(\"*\", true);\n        resourcesInput.onchange = async () => {\n          await handleResourcesUpload(resourcesInput.files, node);\n          resourcesInput.value = \"\";\n        };\n        node.addWidget(\n          \"button\",\n          \"upload extra resources\",\n          \"uploadExtraResources\",\n          () => {\n            resourcesInput.click();\n          }\n        );\n        node.addWidget(\"button\", \"clear\", \"clear\", () => {\n          var _a2, _b2;\n          (_a2 = useLoad3dService().getLoad3d(node)) == null ? void 0 : _a2.clearModel();\n          const modelWidget = (_b2 = node.widgets) == null ? void 0 : _b2.find((w) => w.name === \"model_file\");\n          if (modelWidget) {\n            modelWidget.value = \"\";\n          }\n        });\n        const inputSpec = {\n          name: \"image\",\n          type: \"Load3D\",\n          isAnimation: false,\n          isPreview: false\n        };\n        const widget = new ComponentWidgetImpl({\n          node,\n          name: inputSpec.name,\n          component: _sfc_main$3,\n          inputSpec,\n          options: {}\n        });\n        addWidget(node, widget);\n        return { widget };\n      }\n    };\n  },\n  async nodeCreated(node) {\n    if (node.constructor.comfyClass !== \"Load3D\") return;\n    const [oldWidth, oldHeight] = node.size;\n    node.setSize([Math.max(oldWidth, 300), Math.max(oldHeight, 600)]);\n    await nextTick();\n    useLoad3dService().waitForLoad3d(node, (load3d) => {\n      var _a2, _b2, _c, _d;\n      let cameraState = node.properties[\"Camera Info\"];\n      const config = new Load3DConfiguration(load3d);\n      const modelWidget = (_a2 = node.widgets) == null ? void 0 : _a2.find((w) => w.name === \"model_file\");\n      const width = (_b2 = node.widgets) == null ? void 0 : _b2.find((w) => w.name === \"width\");\n      const height = (_c = node.widgets) == null ? void 0 : _c.find((w) => w.name === \"height\");\n      const sceneWidget = (_d = node.widgets) == null ? void 0 : _d.find((w) => w.name === \"image\");\n      if (modelWidget && width && height && sceneWidget) {\n        config.configure(\"input\", modelWidget, cameraState, width, height);\n        sceneWidget.serializeValue = async () => {\n          node.properties[\"Camera Info\"] = load3d.getCameraState();\n          load3d.stopRecording();\n          const {\n            scene: imageData,\n            mask: maskData,\n            normal: normalData,\n            lineart: lineartData\n          } = await load3d.captureScene(\n            width.value,\n            height.value\n          );\n          const [data, dataMask, dataNormal, dataLineart] = await Promise.all([\n            Load3dUtils.uploadTempImage(imageData, \"scene\"),\n            Load3dUtils.uploadTempImage(maskData, \"scene_mask\"),\n            Load3dUtils.uploadTempImage(normalData, \"scene_normal\"),\n            Load3dUtils.uploadTempImage(lineartData, \"scene_lineart\")\n          ]);\n          load3d.handleResize();\n          const returnVal = {\n            image: `threed/${data.name} [temp]`,\n            mask: `threed/${dataMask.name} [temp]`,\n            normal: `threed/${dataNormal.name} [temp]`,\n            lineart: `threed/${dataLineart.name} [temp]`,\n            camera_info: node.properties[\"Camera Info\"],\n            recording: \"\"\n          };\n          const recordingData = load3d.getRecordingData();\n          if (recordingData) {\n            const [recording] = await Promise.all([\n              Load3dUtils.uploadTempImage(recordingData, \"recording\", \"mp4\")\n            ]);\n            returnVal[\"recording\"] = `threed/${recording.name} [temp]`;\n          }\n          return returnVal;\n        };\n      }\n    });\n  }\n});\nuseExtensionService().registerExtension({\n  name: \"Comfy.Load3DAnimation\",\n  getCustomWidgets() {\n    return {\n      LOAD_3D_ANIMATION(node) {\n        const fileInput = createFileInput(\".gltf,.glb,.fbx\", false);\n        node.properties[\"Resource Folder\"] = \"\";\n        fileInput.onchange = async () => {\n          await handleModelUpload(fileInput.files, node);\n        };\n        node.addWidget(\"button\", \"upload 3d model\", \"upload3dmodel\", () => {\n          fileInput.click();\n        });\n        const resourcesInput = createFileInput(\"*\", true);\n        resourcesInput.onchange = async () => {\n          await handleResourcesUpload(resourcesInput.files, node);\n          resourcesInput.value = \"\";\n        };\n        node.addWidget(\n          \"button\",\n          \"upload extra resources\",\n          \"uploadExtraResources\",\n          () => {\n            resourcesInput.click();\n          }\n        );\n        node.addWidget(\"button\", \"clear\", \"clear\", () => {\n          var _a2, _b2;\n          (_a2 = useLoad3dService().getLoad3d(node)) == null ? void 0 : _a2.clearModel();\n          const modelWidget = (_b2 = node.widgets) == null ? void 0 : _b2.find((w) => w.name === \"model_file\");\n          if (modelWidget) {\n            modelWidget.value = \"\";\n          }\n        });\n        const inputSpec = {\n          name: \"image\",\n          type: \"Load3DAnimation\",\n          isAnimation: true,\n          isPreview: false\n        };\n        const widget = new ComponentWidgetImpl({\n          node,\n          name: inputSpec.name,\n          component: _sfc_main,\n          inputSpec,\n          options: {}\n        });\n        addWidget(node, widget);\n        return { widget };\n      }\n    };\n  },\n  async nodeCreated(node) {\n    if (node.constructor.comfyClass !== \"Load3DAnimation\") return;\n    const [oldWidth, oldHeight] = node.size;\n    node.setSize([Math.max(oldWidth, 400), Math.max(oldHeight, 700)]);\n    await nextTick();\n    useLoad3dService().waitForLoad3d(node, (load3d) => {\n      var _a2, _b2, _c, _d;\n      const sceneWidget = (_a2 = node.widgets) == null ? void 0 : _a2.find((w) => w.name === \"image\");\n      const modelWidget = (_b2 = node.widgets) == null ? void 0 : _b2.find((w) => w.name === \"model_file\");\n      let cameraState = node.properties[\"Camera Info\"];\n      const width = (_c = node.widgets) == null ? void 0 : _c.find((w) => w.name === \"width\");\n      const height = (_d = node.widgets) == null ? void 0 : _d.find((w) => w.name === \"height\");\n      if (modelWidget && width && height && sceneWidget && load3d) {\n        const config = new Load3DConfiguration(load3d);\n        config.configure(\"input\", modelWidget, cameraState, width, height);\n        sceneWidget.serializeValue = async () => {\n          node.properties[\"Camera Info\"] = load3d.getCameraState();\n          const load3dAnimation = load3d;\n          load3dAnimation.toggleAnimation(false);\n          if (load3dAnimation.isRecording()) {\n            load3dAnimation.stopRecording();\n          }\n          const {\n            scene: imageData,\n            mask: maskData,\n            normal: normalData\n          } = await load3dAnimation.captureScene(\n            width.value,\n            height.value\n          );\n          const [data, dataMask, dataNormal] = await Promise.all([\n            Load3dUtils.uploadTempImage(imageData, \"scene\"),\n            Load3dUtils.uploadTempImage(maskData, \"scene_mask\"),\n            Load3dUtils.uploadTempImage(normalData, \"scene_normal\")\n          ]);\n          load3dAnimation.handleResize();\n          const returnVal = {\n            image: `threed/${data.name} [temp]`,\n            mask: `threed/${dataMask.name} [temp]`,\n            normal: `threed/${dataNormal.name} [temp]`,\n            camera_info: node.properties[\"Camera Info\"],\n            recording: \"\"\n          };\n          const recordingData = load3dAnimation.getRecordingData();\n          if (recordingData) {\n            const [recording] = await Promise.all([\n              Load3dUtils.uploadTempImage(recordingData, \"recording\", \"mp4\")\n            ]);\n            returnVal[\"recording\"] = `threed/${recording.name} [temp]`;\n          }\n          return returnVal;\n        };\n      }\n    });\n  }\n});\nuseExtensionService().registerExtension({\n  name: \"Comfy.Preview3D\",\n  async beforeRegisterNodeDef(_nodeType, nodeData) {\n    if (\"Preview3D\" === nodeData.name) {\n      nodeData.input.required.image = [\"PREVIEW_3D\"];\n    }\n  },\n  getCustomWidgets() {\n    return {\n      PREVIEW_3D(node) {\n        const inputSpec = {\n          name: \"image\",\n          type: \"Preview3D\",\n          isAnimation: false,\n          isPreview: true\n        };\n        const widget = new ComponentWidgetImpl({\n          node,\n          name: inputSpec.name,\n          component: _sfc_main$3,\n          inputSpec,\n          options: {}\n        });\n        addWidget(node, widget);\n        return { widget };\n      }\n    };\n  },\n  async nodeCreated(node) {\n    if (node.constructor.comfyClass !== \"Preview3D\") return;\n    const [oldWidth, oldHeight] = node.size;\n    node.setSize([Math.max(oldWidth, 400), Math.max(oldHeight, 550)]);\n    await nextTick();\n    const onExecuted = node.onExecuted;\n    useLoad3dService().waitForLoad3d(node, (load3d) => {\n      var _a2;\n      const config = new Load3DConfiguration(load3d);\n      const modelWidget = (_a2 = node.widgets) == null ? void 0 : _a2.find((w) => w.name === \"model_file\");\n      if (modelWidget) {\n        const lastTimeModelFile = node.properties[\"Last Time Model File\"];\n        if (lastTimeModelFile) {\n          modelWidget.value = lastTimeModelFile;\n          const cameraState = node.properties[\"Camera Info\"];\n          config.configure(\"output\", modelWidget, cameraState);\n        }\n        node.onExecuted = function(message) {\n          onExecuted == null ? void 0 : onExecuted.apply(this, arguments);\n          let filePath = message.result[0];\n          if (!filePath) {\n            const msg = t(\"toastMessages.unableToGetModelFilePath\");\n            console.error(msg);\n            useToastStore().addAlert(msg);\n          }\n          let cameraState = message.result[1];\n          modelWidget.value = filePath.replaceAll(\"\\\\\", \"/\");\n          node.properties[\"Last Time Model File\"] = modelWidget.value;\n          config.configure(\"output\", modelWidget, cameraState);\n        };\n      }\n    });\n  }\n});\nuseExtensionService().registerExtension({\n  name: \"Comfy.Preview3DAnimation\",\n  async beforeRegisterNodeDef(_nodeType, nodeData) {\n    if (\"Preview3DAnimation\" === nodeData.name) {\n      nodeData.input.required.image = [\"PREVIEW_3D_ANIMATION\"];\n    }\n  },\n  getCustomWidgets() {\n    return {\n      PREVIEW_3D_ANIMATION(node) {\n        const inputSpec = {\n          name: \"image\",\n          type: \"Preview3DAnimation\",\n          isAnimation: true,\n          isPreview: true\n        };\n        const widget = new ComponentWidgetImpl({\n          node,\n          name: inputSpec.name,\n          component: _sfc_main,\n          inputSpec,\n          options: {}\n        });\n        addWidget(node, widget);\n        return { widget };\n      }\n    };\n  },\n  async nodeCreated(node) {\n    if (node.constructor.comfyClass !== \"Preview3DAnimation\") return;\n    const [oldWidth, oldHeight] = node.size;\n    node.setSize([Math.max(oldWidth, 300), Math.max(oldHeight, 550)]);\n    await nextTick();\n    const onExecuted = node.onExecuted;\n    useLoad3dService().waitForLoad3d(node, (load3d) => {\n      var _a2;\n      const config = new Load3DConfiguration(load3d);\n      const modelWidget = (_a2 = node.widgets) == null ? void 0 : _a2.find((w) => w.name === \"model_file\");\n      if (modelWidget) {\n        const lastTimeModelFile = node.properties[\"Last Time Model File\"];\n        if (lastTimeModelFile) {\n          modelWidget.value = lastTimeModelFile;\n          const cameraState = node.properties[\"Camera Info\"];\n          config.configure(\"output\", modelWidget, cameraState);\n        }\n        node.onExecuted = function(message) {\n          onExecuted == null ? void 0 : onExecuted.apply(this, arguments);\n          let filePath = message.result[0];\n          if (!filePath) {\n            const msg = t(\"toastMessages.unableToGetModelFilePath\");\n            console.error(msg);\n            useToastStore().addAlert(msg);\n          }\n          let cameraState = message.result[1];\n          modelWidget.value = filePath.replaceAll(\"\\\\\", \"/\");\n          node.properties[\"Last Time Model File\"] = modelWidget.value;\n          config.configure(\"output\", modelWidget, cameraState);\n        };\n      }\n    });\n  }\n});\nconst paintedMaskedImagePrefix = \"clipspace-painted-masked-\";\nconst imageLayerFilenamesByTimestamp = (timestamp) => ({\n  maskedImage: `clipspace-mask-${timestamp}.png`,\n  paint: `clipspace-paint-${timestamp}.png`,\n  paintedImage: `clipspace-painted-${timestamp}.png`,\n  paintedMaskedImage: `${paintedMaskedImagePrefix}${timestamp}.png`\n});\nconst imageLayerFilenamesIfApplicable = (inputImageFilename) => {\n  const isPaintedMaskedImageFilename = inputImageFilename.startsWith(\n    paintedMaskedImagePrefix\n  );\n  if (!isPaintedMaskedImageFilename) return void 0;\n  const suffix = inputImageFilename.slice(paintedMaskedImagePrefix.length);\n  const timestamp = parseInt(suffix.split(\".\")[0], 10);\n  return imageLayerFilenamesByTimestamp(timestamp);\n};\nvar __defProp$4 = Object.defineProperty;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$4 = (obj, key, value) => __defNormalProp$4(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nfunction dataURLToBlob(dataURL) {\n  const parts = dataURL.split(\";base64,\");\n  const contentType = parts[0].split(\":\")[1];\n  const byteString = atob(parts[1]);\n  const arrayBuffer = new ArrayBuffer(byteString.length);\n  const uint8Array = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < byteString.length; i++) {\n    uint8Array[i] = byteString.charCodeAt(i);\n  }\n  return new Blob([arrayBuffer], { type: contentType });\n}\nfunction loadImage(imagePath) {\n  return new Promise((resolve) => {\n    const image = new Image();\n    image.onload = function() {\n      resolve(image);\n    };\n    image.src = imagePath;\n  });\n}\nasync function uploadMask(filepath, formData) {\n  await api.fetchApi(\"/upload/mask\", {\n    method: \"POST\",\n    body: formData\n  }).catch((error) => {\n    console.error(\"Error:\", error);\n  });\n  ComfyApp.clipspace.imgs[ComfyApp.clipspace[\"selectedIndex\"]] = new Image();\n  ComfyApp.clipspace.imgs[ComfyApp.clipspace[\"selectedIndex\"]].src = api.apiURL(\n    \"/view?\" + new URLSearchParams(filepath).toString() + app.getPreviewFormatParam() + app.getRandParam()\n  );\n  if (ComfyApp.clipspace.images)\n    ComfyApp.clipspace.images[ComfyApp.clipspace[\"selectedIndex\"]] = filepath;\n  ClipspaceDialog.invalidatePreview();\n}\nfunction prepare_mask(image, maskCanvas, maskCtx, maskColor) {\n  maskCtx.drawImage(image, 0, 0, maskCanvas.width, maskCanvas.height);\n  const maskData = maskCtx.getImageData(\n    0,\n    0,\n    maskCanvas.width,\n    maskCanvas.height\n  );\n  for (let i = 0; i < maskData.data.length; i += 4) {\n    if (maskData.data[i + 3] == 255) maskData.data[i + 3] = 0;\n    else maskData.data[i + 3] = 255;\n    maskData.data[i] = maskColor.r;\n    maskData.data[i + 1] = maskColor.g;\n    maskData.data[i + 2] = maskColor.b;\n  }\n  maskCtx.globalCompositeOperation = \"source-over\";\n  maskCtx.putImageData(maskData, 0, 0);\n}\nconst _MaskEditorDialogOld = class _MaskEditorDialogOld2 extends ComfyDialog {\n  constructor() {\n    super();\n    __publicField$4(this, \"brush\");\n    __publicField$4(this, \"maskCtx\");\n    __publicField$4(this, \"maskCanvas\");\n    __publicField$4(this, \"brush_size_slider\");\n    __publicField$4(this, \"brush_opacity_slider\");\n    __publicField$4(this, \"colorButton\");\n    __publicField$4(this, \"saveButton\");\n    __publicField$4(this, \"zoom_ratio\");\n    __publicField$4(this, \"pan_x\");\n    __publicField$4(this, \"pan_y\");\n    __publicField$4(this, \"imgCanvas\");\n    __publicField$4(this, \"last_display_style\");\n    __publicField$4(this, \"is_visible\");\n    __publicField$4(this, \"image\");\n    __publicField$4(this, \"handler_registered\");\n    __publicField$4(this, \"brush_slider_input\");\n    __publicField$4(this, \"cursorX\");\n    __publicField$4(this, \"cursorY\");\n    __publicField$4(this, \"mousedown_pan_x\");\n    __publicField$4(this, \"mousedown_pan_y\");\n    __publicField$4(this, \"last_pressure\");\n    __publicField$4(this, \"pointer_type\");\n    __publicField$4(this, \"brush_pointer_type_select\");\n    __publicField$4(this, \"is_layout_created\", false);\n    __publicField$4(this, \"brush_opacity\", 0.7);\n    __publicField$4(this, \"brush_size\", 10);\n    __publicField$4(this, \"brush_color_mode\", \"black\");\n    __publicField$4(this, \"drawing_mode\", false);\n    __publicField$4(this, \"lastx\", -1);\n    __publicField$4(this, \"lasty\", -1);\n    __publicField$4(this, \"lasttime\", 0);\n    this.element = $el(\"div.comfy-modal\", { parent: document.body }, [\n      $el(\"div.comfy-modal-content\", [...this.createButtons()])\n    ]);\n  }\n  static getInstance() {\n    if (!_MaskEditorDialogOld2.instance) {\n      _MaskEditorDialogOld2.instance = new _MaskEditorDialogOld2();\n    }\n    return _MaskEditorDialogOld2.instance;\n  }\n  createButtons() {\n    return [];\n  }\n  // @ts-expect-error fixme ts strict error\n  createButton(name, callback) {\n    var button = document.createElement(\"button\");\n    button.style.pointerEvents = \"auto\";\n    button.innerText = name;\n    button.addEventListener(\"click\", callback);\n    return button;\n  }\n  // @ts-expect-error fixme ts strict error\n  createLeftButton(name, callback) {\n    var button = this.createButton(name, callback);\n    button.style.cssFloat = \"left\";\n    button.style.marginRight = \"4px\";\n    return button;\n  }\n  // @ts-expect-error fixme ts strict error\n  createRightButton(name, callback) {\n    var button = this.createButton(name, callback);\n    button.style.cssFloat = \"right\";\n    button.style.marginLeft = \"4px\";\n    return button;\n  }\n  // @ts-expect-error fixme ts strict error\n  createLeftSlider(self2, name, callback) {\n    const divElement = document.createElement(\"div\");\n    divElement.id = \"maskeditor-slider\";\n    divElement.style.cssFloat = \"left\";\n    divElement.style.fontFamily = \"sans-serif\";\n    divElement.style.marginRight = \"4px\";\n    divElement.style.color = \"var(--input-text)\";\n    divElement.style.backgroundColor = \"var(--comfy-input-bg)\";\n    divElement.style.borderRadius = \"8px\";\n    divElement.style.borderColor = \"var(--border-color)\";\n    divElement.style.borderStyle = \"solid\";\n    divElement.style.fontSize = \"15px\";\n    divElement.style.height = \"25px\";\n    divElement.style.padding = \"1px 6px\";\n    divElement.style.display = \"flex\";\n    divElement.style.position = \"relative\";\n    divElement.style.top = \"2px\";\n    divElement.style.pointerEvents = \"auto\";\n    self2.brush_slider_input = document.createElement(\"input\");\n    self2.brush_slider_input.setAttribute(\"type\", \"range\");\n    self2.brush_slider_input.setAttribute(\"min\", \"1\");\n    self2.brush_slider_input.setAttribute(\"max\", \"100\");\n    self2.brush_slider_input.setAttribute(\"value\", \"10\");\n    const labelElement = document.createElement(\"label\");\n    labelElement.textContent = name;\n    divElement.appendChild(labelElement);\n    divElement.appendChild(self2.brush_slider_input);\n    self2.brush_slider_input.addEventListener(\"change\", callback);\n    return divElement;\n  }\n  // @ts-expect-error fixme ts strict error\n  createOpacitySlider(self2, name, callback) {\n    const divElement = document.createElement(\"div\");\n    divElement.id = \"maskeditor-opacity-slider\";\n    divElement.style.cssFloat = \"left\";\n    divElement.style.fontFamily = \"sans-serif\";\n    divElement.style.marginRight = \"4px\";\n    divElement.style.color = \"var(--input-text)\";\n    divElement.style.backgroundColor = \"var(--comfy-input-bg)\";\n    divElement.style.borderRadius = \"8px\";\n    divElement.style.borderColor = \"var(--border-color)\";\n    divElement.style.borderStyle = \"solid\";\n    divElement.style.fontSize = \"15px\";\n    divElement.style.height = \"25px\";\n    divElement.style.padding = \"1px 6px\";\n    divElement.style.display = \"flex\";\n    divElement.style.position = \"relative\";\n    divElement.style.top = \"2px\";\n    divElement.style.pointerEvents = \"auto\";\n    self2.opacity_slider_input = document.createElement(\"input\");\n    self2.opacity_slider_input.setAttribute(\"type\", \"range\");\n    self2.opacity_slider_input.setAttribute(\"min\", \"0.1\");\n    self2.opacity_slider_input.setAttribute(\"max\", \"1.0\");\n    self2.opacity_slider_input.setAttribute(\"step\", \"0.01\");\n    self2.opacity_slider_input.setAttribute(\"value\", \"0.7\");\n    const labelElement = document.createElement(\"label\");\n    labelElement.textContent = name;\n    divElement.appendChild(labelElement);\n    divElement.appendChild(self2.opacity_slider_input);\n    self2.opacity_slider_input.addEventListener(\"input\", callback);\n    return divElement;\n  }\n  createPointerTypeSelect(self2) {\n    const divElement = document.createElement(\"div\");\n    divElement.id = \"maskeditor-pointer-type\";\n    divElement.style.cssFloat = \"left\";\n    divElement.style.fontFamily = \"sans-serif\";\n    divElement.style.marginRight = \"4px\";\n    divElement.style.color = \"var(--input-text)\";\n    divElement.style.backgroundColor = \"var(--comfy-input-bg)\";\n    divElement.style.borderRadius = \"8px\";\n    divElement.style.borderColor = \"var(--border-color)\";\n    divElement.style.borderStyle = \"solid\";\n    divElement.style.fontSize = \"15px\";\n    divElement.style.height = \"25px\";\n    divElement.style.padding = \"1px 6px\";\n    divElement.style.display = \"flex\";\n    divElement.style.position = \"relative\";\n    divElement.style.top = \"2px\";\n    divElement.style.pointerEvents = \"auto\";\n    const labelElement = document.createElement(\"label\");\n    labelElement.textContent = \"Pointer Type:\";\n    const selectElement = document.createElement(\"select\");\n    selectElement.style.borderRadius = \"0\";\n    selectElement.style.borderColor = \"transparent\";\n    selectElement.style.borderStyle = \"unset\";\n    selectElement.style.fontSize = \"0.9em\";\n    const optionArc = document.createElement(\"option\");\n    optionArc.value = \"arc\";\n    optionArc.text = \"Circle\";\n    optionArc.selected = true;\n    const optionRect = document.createElement(\"option\");\n    optionRect.value = \"rect\";\n    optionRect.text = \"Square\";\n    selectElement.appendChild(optionArc);\n    selectElement.appendChild(optionRect);\n    selectElement.addEventListener(\"change\", (event) => {\n      const target = event.target;\n      self2.pointer_type = target.value;\n      this.setBrushBorderRadius(self2);\n    });\n    divElement.appendChild(labelElement);\n    divElement.appendChild(selectElement);\n    return divElement;\n  }\n  setBrushBorderRadius(self2) {\n    if (self2.pointer_type === \"rect\") {\n      this.brush.style.borderRadius = \"0%\";\n      this.brush.style.MozBorderRadius = \"0%\";\n      this.brush.style.WebkitBorderRadius = \"0%\";\n    } else {\n      this.brush.style.borderRadius = \"50%\";\n      this.brush.style.MozBorderRadius = \"50%\";\n      this.brush.style.WebkitBorderRadius = \"50%\";\n    }\n  }\n  setlayout(imgCanvas, maskCanvas) {\n    const self2 = this;\n    self2.pointer_type = \"arc\";\n    var bottom_panel = document.createElement(\"div\");\n    bottom_panel.style.position = \"absolute\";\n    bottom_panel.style.bottom = \"0px\";\n    bottom_panel.style.left = \"20px\";\n    bottom_panel.style.right = \"20px\";\n    bottom_panel.style.height = \"50px\";\n    bottom_panel.style.pointerEvents = \"none\";\n    var brush = document.createElement(\"div\");\n    brush.id = \"brush\";\n    brush.style.backgroundColor = \"transparent\";\n    brush.style.outline = \"1px dashed black\";\n    brush.style.boxShadow = \"0 0 0 1px white\";\n    brush.style.position = \"absolute\";\n    brush.style.zIndex = \"8889\";\n    brush.style.pointerEvents = \"none\";\n    this.brush = brush;\n    this.setBrushBorderRadius(self2);\n    this.element.appendChild(imgCanvas);\n    this.element.appendChild(maskCanvas);\n    this.element.appendChild(bottom_panel);\n    document.body.appendChild(brush);\n    var clearButton = this.createLeftButton(\"Clear\", () => {\n      self2.maskCtx.clearRect(\n        0,\n        0,\n        self2.maskCanvas.width,\n        self2.maskCanvas.height\n      );\n    });\n    this.brush_size_slider = this.createLeftSlider(\n      self2,\n      \"Thickness\",\n      // @ts-expect-error fixme ts strict error\n      (event) => {\n        self2.brush_size = event.target.value;\n        self2.updateBrushPreview(self2);\n      }\n    );\n    this.brush_opacity_slider = this.createOpacitySlider(\n      self2,\n      \"Opacity\",\n      // @ts-expect-error fixme ts strict error\n      (event) => {\n        self2.brush_opacity = event.target.value;\n        if (self2.brush_color_mode !== \"negative\") {\n          self2.maskCanvas.style.opacity = self2.brush_opacity.toString();\n        }\n      }\n    );\n    this.brush_pointer_type_select = this.createPointerTypeSelect(self2);\n    this.colorButton = this.createLeftButton(this.getColorButtonText(), () => {\n      if (self2.brush_color_mode === \"black\") {\n        self2.brush_color_mode = \"white\";\n      } else if (self2.brush_color_mode === \"white\") {\n        self2.brush_color_mode = \"negative\";\n      } else {\n        self2.brush_color_mode = \"black\";\n      }\n      self2.updateWhenBrushColorModeChanged();\n    });\n    var cancelButton = this.createRightButton(\"Cancel\", () => {\n      document.removeEventListener(\"keydown\", _MaskEditorDialogOld2.handleKeyDown);\n      self2.close();\n    });\n    this.saveButton = this.createRightButton(\"Save\", () => {\n      document.removeEventListener(\"keydown\", _MaskEditorDialogOld2.handleKeyDown);\n      self2.save();\n    });\n    this.element.appendChild(imgCanvas);\n    this.element.appendChild(maskCanvas);\n    this.element.appendChild(bottom_panel);\n    bottom_panel.appendChild(clearButton);\n    bottom_panel.appendChild(this.saveButton);\n    bottom_panel.appendChild(cancelButton);\n    bottom_panel.appendChild(this.brush_size_slider);\n    bottom_panel.appendChild(this.brush_opacity_slider);\n    bottom_panel.appendChild(this.brush_pointer_type_select);\n    bottom_panel.appendChild(this.colorButton);\n    imgCanvas.style.position = \"absolute\";\n    maskCanvas.style.position = \"absolute\";\n    imgCanvas.style.top = \"200\";\n    imgCanvas.style.left = \"0\";\n    maskCanvas.style.top = imgCanvas.style.top;\n    maskCanvas.style.left = imgCanvas.style.left;\n    const maskCanvasStyle = this.getMaskCanvasStyle();\n    maskCanvas.style.mixBlendMode = maskCanvasStyle.mixBlendMode;\n    maskCanvas.style.opacity = maskCanvasStyle.opacity.toString();\n  }\n  async show() {\n    this.zoom_ratio = 1;\n    this.pan_x = 0;\n    this.pan_y = 0;\n    if (!this.is_layout_created) {\n      const imgCanvas = document.createElement(\"canvas\");\n      const maskCanvas = document.createElement(\"canvas\");\n      imgCanvas.id = \"imageCanvas\";\n      maskCanvas.id = \"maskCanvas\";\n      this.setlayout(imgCanvas, maskCanvas);\n      this.imgCanvas = imgCanvas;\n      this.maskCanvas = maskCanvas;\n      this.maskCtx = maskCanvas.getContext(\"2d\", { willReadFrequently: true });\n      this.setEventHandler(maskCanvas);\n      this.is_layout_created = true;\n      const self2 = this;\n      const observer = new MutationObserver(function(mutations) {\n        mutations.forEach(function(mutation) {\n          if (mutation.type === \"attributes\" && mutation.attributeName === \"style\") {\n            if (self2.last_display_style && self2.last_display_style != \"none\" && self2.element.style.display == \"none\") {\n              self2.brush.style.display = \"none\";\n              ComfyApp.onClipspaceEditorClosed();\n            }\n            self2.last_display_style = self2.element.style.display;\n          }\n        });\n      });\n      const config = { attributes: true };\n      observer.observe(this.element, config);\n    }\n    document.addEventListener(\"keydown\", _MaskEditorDialogOld2.handleKeyDown);\n    if (ComfyApp.clipspace_return_node) {\n      this.saveButton.innerText = \"Save to node\";\n    } else {\n      this.saveButton.innerText = \"Save\";\n    }\n    this.saveButton.disabled = false;\n    this.element.style.display = \"block\";\n    this.element.style.width = \"85%\";\n    this.element.style.margin = \"0 7.5%\";\n    this.element.style.height = \"100vh\";\n    this.element.style.top = \"50%\";\n    this.element.style.left = \"42%\";\n    this.element.style.zIndex = \"8888\";\n    await this.setImages(this.imgCanvas);\n    this.is_visible = true;\n  }\n  isOpened() {\n    return this.element.style.display == \"block\";\n  }\n  // @ts-expect-error fixme ts strict error\n  invalidateCanvas(orig_image, mask_image) {\n    this.imgCanvas.width = orig_image.width;\n    this.imgCanvas.height = orig_image.height;\n    this.maskCanvas.width = orig_image.width;\n    this.maskCanvas.height = orig_image.height;\n    let imgCtx = this.imgCanvas.getContext(\"2d\", { willReadFrequently: true });\n    let maskCtx = this.maskCanvas.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    imgCtx.drawImage(orig_image, 0, 0, orig_image.width, orig_image.height);\n    prepare_mask(mask_image, this.maskCanvas, maskCtx, this.getMaskColor());\n  }\n  // @ts-expect-error fixme ts strict error\n  async setImages(imgCanvas) {\n    let self2 = this;\n    const imgCtx = imgCanvas.getContext(\"2d\", { willReadFrequently: true });\n    const maskCtx = this.maskCtx;\n    const maskCanvas = this.maskCanvas;\n    imgCtx.clearRect(0, 0, this.imgCanvas.width, this.imgCanvas.height);\n    maskCtx.clearRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);\n    const alpha_url = new URL(\n      // @ts-expect-error fixme ts strict error\n      ComfyApp.clipspace.imgs[ComfyApp.clipspace[\"selectedIndex\"]].src\n    );\n    alpha_url.searchParams.delete(\"channel\");\n    alpha_url.searchParams.delete(\"preview\");\n    alpha_url.searchParams.set(\"channel\", \"a\");\n    let mask_image = await loadImage(alpha_url);\n    const rgb_url = new URL(\n      // @ts-expect-error fixme ts strict error\n      ComfyApp.clipspace.imgs[ComfyApp.clipspace[\"selectedIndex\"]].src\n    );\n    rgb_url.searchParams.delete(\"channel\");\n    rgb_url.searchParams.set(\"channel\", \"rgb\");\n    this.image = new Image();\n    this.image.onload = function() {\n      maskCanvas.width = self2.image.width;\n      maskCanvas.height = self2.image.height;\n      self2.invalidateCanvas(self2.image, mask_image);\n      self2.initializeCanvasPanZoom();\n    };\n    this.image.src = rgb_url.toString();\n  }\n  initializeCanvasPanZoom() {\n    let drawWidth = this.image.width;\n    let drawHeight = this.image.height;\n    let width = this.element.clientWidth;\n    let height = this.element.clientHeight;\n    if (this.image.width > width) {\n      drawWidth = width;\n      drawHeight = drawWidth / this.image.width * this.image.height;\n    }\n    if (drawHeight > height) {\n      drawHeight = height;\n      drawWidth = drawHeight / this.image.height * this.image.width;\n    }\n    this.zoom_ratio = drawWidth / this.image.width;\n    const canvasX = (width - drawWidth) / 2;\n    const canvasY = (height - drawHeight) / 2;\n    this.pan_x = canvasX;\n    this.pan_y = canvasY;\n    this.invalidatePanZoom();\n  }\n  invalidatePanZoom() {\n    let raw_width = this.image.width * this.zoom_ratio;\n    let raw_height = this.image.height * this.zoom_ratio;\n    if (this.pan_x + raw_width < 10) {\n      this.pan_x = 10 - raw_width;\n    }\n    if (this.pan_y + raw_height < 10) {\n      this.pan_y = 10 - raw_height;\n    }\n    let width = `${raw_width}px`;\n    let height = `${raw_height}px`;\n    let left = `${this.pan_x}px`;\n    let top = `${this.pan_y}px`;\n    this.maskCanvas.style.width = width;\n    this.maskCanvas.style.height = height;\n    this.maskCanvas.style.left = left;\n    this.maskCanvas.style.top = top;\n    this.imgCanvas.style.width = width;\n    this.imgCanvas.style.height = height;\n    this.imgCanvas.style.left = left;\n    this.imgCanvas.style.top = top;\n  }\n  // @ts-expect-error fixme ts strict error\n  setEventHandler(maskCanvas) {\n    const self2 = this;\n    if (!this.handler_registered) {\n      maskCanvas.addEventListener(\"contextmenu\", (event) => {\n        event.preventDefault();\n      });\n      this.element.addEventListener(\n        \"wheel\",\n        (event) => this.handleWheelEvent(self2, event)\n      );\n      this.element.addEventListener(\n        \"pointermove\",\n        (event) => this.pointMoveEvent(self2, event)\n      );\n      this.element.addEventListener(\n        \"touchmove\",\n        (event) => this.pointMoveEvent(self2, event)\n      );\n      this.element.addEventListener(\"dragstart\", (event) => {\n        if (event.ctrlKey) {\n          event.preventDefault();\n        }\n      });\n      maskCanvas.addEventListener(\n        \"pointerdown\",\n        (event) => this.handlePointerDown(self2, event)\n      );\n      maskCanvas.addEventListener(\n        \"pointermove\",\n        (event) => this.draw_move(self2, event)\n      );\n      maskCanvas.addEventListener(\n        \"touchmove\",\n        (event) => this.draw_move(self2, event)\n      );\n      maskCanvas.addEventListener(\"pointerover\", () => {\n        this.brush.style.display = \"block\";\n      });\n      maskCanvas.addEventListener(\"pointerleave\", () => {\n        this.brush.style.display = \"none\";\n      });\n      document.addEventListener(\n        \"pointerup\",\n        _MaskEditorDialogOld2.handlePointerUp\n      );\n      this.handler_registered = true;\n    }\n  }\n  getMaskCanvasStyle() {\n    if (this.brush_color_mode === \"negative\") {\n      return {\n        mixBlendMode: \"difference\",\n        opacity: \"1\"\n      };\n    } else {\n      return {\n        mixBlendMode: \"initial\",\n        opacity: this.brush_opacity\n      };\n    }\n  }\n  getMaskColor() {\n    if (this.brush_color_mode === \"black\") {\n      return { r: 0, g: 0, b: 0 };\n    }\n    if (this.brush_color_mode === \"white\") {\n      return { r: 255, g: 255, b: 255 };\n    }\n    if (this.brush_color_mode === \"negative\") {\n      return { r: 255, g: 255, b: 255 };\n    }\n    return { r: 0, g: 0, b: 0 };\n  }\n  getMaskFillStyle() {\n    const maskColor = this.getMaskColor();\n    return \"rgb(\" + maskColor.r + \",\" + maskColor.g + \",\" + maskColor.b + \")\";\n  }\n  getColorButtonText() {\n    let colorCaption = \"unknown\";\n    if (this.brush_color_mode === \"black\") {\n      colorCaption = \"black\";\n    } else if (this.brush_color_mode === \"white\") {\n      colorCaption = \"white\";\n    } else if (this.brush_color_mode === \"negative\") {\n      colorCaption = \"negative\";\n    }\n    return \"Color: \" + colorCaption;\n  }\n  updateWhenBrushColorModeChanged() {\n    this.colorButton.innerText = this.getColorButtonText();\n    const maskCanvasStyle = this.getMaskCanvasStyle();\n    this.maskCanvas.style.mixBlendMode = maskCanvasStyle.mixBlendMode;\n    this.maskCanvas.style.opacity = maskCanvasStyle.opacity.toString();\n    const maskColor = this.getMaskColor();\n    const maskData = this.maskCtx.getImageData(\n      0,\n      0,\n      this.maskCanvas.width,\n      this.maskCanvas.height\n    );\n    for (let i = 0; i < maskData.data.length; i += 4) {\n      maskData.data[i] = maskColor.r;\n      maskData.data[i + 1] = maskColor.g;\n      maskData.data[i + 2] = maskColor.b;\n    }\n    this.maskCtx.putImageData(maskData, 0, 0);\n  }\n  // @ts-expect-error fixme ts strict error\n  static handleKeyDown(event) {\n    const self2 = _MaskEditorDialogOld2.instance;\n    if (event.key === \"]\") {\n      self2.brush_size = Math.min(self2.brush_size + 2, 100);\n      self2.brush_slider_input.value = self2.brush_size;\n    } else if (event.key === \"[\") {\n      self2.brush_size = Math.max(self2.brush_size - 2, 1);\n      self2.brush_slider_input.value = self2.brush_size;\n    } else if (event.key === \"Enter\") {\n      self2.save();\n    }\n    self2.updateBrushPreview(self2);\n  }\n  // @ts-expect-error fixme ts strict error\n  static handlePointerUp(event) {\n    event.preventDefault();\n    this.mousedown_x = null;\n    this.mousedown_y = null;\n    _MaskEditorDialogOld2.instance.drawing_mode = false;\n  }\n  // @ts-expect-error fixme ts strict error\n  updateBrushPreview(self2) {\n    const brush = self2.brush;\n    var centerX = self2.cursorX;\n    var centerY = self2.cursorY;\n    brush.style.width = self2.brush_size * 2 * this.zoom_ratio + \"px\";\n    brush.style.height = self2.brush_size * 2 * this.zoom_ratio + \"px\";\n    brush.style.left = centerX - self2.brush_size * this.zoom_ratio + \"px\";\n    brush.style.top = centerY - self2.brush_size * this.zoom_ratio + \"px\";\n  }\n  // @ts-expect-error fixme ts strict error\n  handleWheelEvent(_, event) {\n    event.preventDefault();\n    if (event.ctrlKey) {\n      if (event.deltaY < 0) {\n        this.zoom_ratio = Math.min(10, this.zoom_ratio + 0.2);\n      } else {\n        this.zoom_ratio = Math.max(0.2, this.zoom_ratio - 0.2);\n      }\n      this.invalidatePanZoom();\n    } else {\n      if (event.deltaY < 0) this.brush_size = Math.min(this.brush_size + 2, 100);\n      else this.brush_size = Math.max(this.brush_size - 2, 1);\n      this.brush_slider_input.value = this.brush_size.toString();\n      this.updateBrushPreview(this);\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  pointMoveEvent(self2, event) {\n    this.cursorX = event.pageX;\n    this.cursorY = event.pageY;\n    self2.updateBrushPreview(self2);\n    if (event.ctrlKey) {\n      event.preventDefault();\n      self2.pan_move(self2, event);\n    }\n    let left_button_down = window.TouchEvent && event instanceof TouchEvent || event.buttons == 1;\n    if (event.shiftKey && left_button_down) {\n      self2.drawing_mode = false;\n      const y = event.clientY;\n      let delta = (self2.zoom_lasty - y) * 5e-3;\n      self2.zoom_ratio = Math.max(\n        Math.min(10, self2.last_zoom_ratio - delta),\n        0.2\n      );\n      this.invalidatePanZoom();\n      return;\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  pan_move(self2, event) {\n    if (event.buttons == 1) {\n      if (_MaskEditorDialogOld2.mousedown_x) {\n        let deltaX = _MaskEditorDialogOld2.mousedown_x - event.clientX;\n        let deltaY = _MaskEditorDialogOld2.mousedown_y - event.clientY;\n        self2.pan_x = this.mousedown_pan_x - deltaX;\n        self2.pan_y = this.mousedown_pan_y - deltaY;\n        self2.invalidatePanZoom();\n      }\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  draw_move(self2, event) {\n    if (event.ctrlKey || event.shiftKey) {\n      return;\n    }\n    event.preventDefault();\n    this.cursorX = event.pageX;\n    this.cursorY = event.pageY;\n    self2.updateBrushPreview(self2);\n    let left_button_down = window.TouchEvent && event instanceof TouchEvent || event.buttons == 1;\n    let right_button_down = [2, 5, 32].includes(event.buttons);\n    if (!event.altKey && left_button_down) {\n      var diff = performance.now() - self2.lasttime;\n      const maskRect = self2.maskCanvas.getBoundingClientRect();\n      var x = event.offsetX;\n      var y = event.offsetY;\n      if (event.offsetX == null) {\n        x = event.targetTouches[0].clientX - maskRect.left;\n      }\n      if (event.offsetY == null) {\n        y = event.targetTouches[0].clientY - maskRect.top;\n      }\n      x /= self2.zoom_ratio;\n      y /= self2.zoom_ratio;\n      var brush_size = this.brush_size;\n      if (event instanceof PointerEvent && event.pointerType == \"pen\") {\n        brush_size *= event.pressure;\n        this.last_pressure = event.pressure;\n      } else if (window.TouchEvent && event instanceof TouchEvent && diff < 20) {\n        brush_size *= this.last_pressure;\n      } else {\n        brush_size = this.brush_size;\n      }\n      if (diff > 20 && !this.drawing_mode)\n        requestAnimationFrame(() => {\n          self2.init_shape(\n            self2,\n            \"source-over\"\n            /* SourceOver */\n          );\n          self2.draw_shape(self2, x, y, brush_size);\n          self2.lastx = x;\n          self2.lasty = y;\n        });\n      else\n        requestAnimationFrame(() => {\n          self2.init_shape(\n            self2,\n            \"source-over\"\n            /* SourceOver */\n          );\n          var dx = x - self2.lastx;\n          var dy = y - self2.lasty;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          var directionX = dx / distance;\n          var directionY = dy / distance;\n          for (var i = 0; i < distance; i += 5) {\n            var px = self2.lastx + directionX * i;\n            var py = self2.lasty + directionY * i;\n            self2.draw_shape(self2, px, py, brush_size);\n          }\n          self2.lastx = x;\n          self2.lasty = y;\n        });\n      self2.lasttime = performance.now();\n    } else if (event.altKey && left_button_down || right_button_down) {\n      const maskRect = self2.maskCanvas.getBoundingClientRect();\n      const x2 = (event.offsetX || event.targetTouches[0].clientX - maskRect.left) / self2.zoom_ratio;\n      const y2 = (event.offsetY || event.targetTouches[0].clientY - maskRect.top) / self2.zoom_ratio;\n      var brush_size = this.brush_size;\n      if (event instanceof PointerEvent && event.pointerType == \"pen\") {\n        brush_size *= event.pressure;\n        this.last_pressure = event.pressure;\n      } else if (window.TouchEvent && event instanceof TouchEvent && // @ts-expect-error fixme ts strict error\n      diff < 20) {\n        brush_size *= this.last_pressure;\n      } else {\n        brush_size = this.brush_size;\n      }\n      if (diff > 20 && !this.drawing_mode)\n        requestAnimationFrame(() => {\n          self2.init_shape(\n            self2,\n            \"destination-out\"\n            /* DestinationOut */\n          );\n          self2.draw_shape(self2, x2, y2, brush_size);\n          self2.lastx = x2;\n          self2.lasty = y2;\n        });\n      else\n        requestAnimationFrame(() => {\n          self2.init_shape(\n            self2,\n            \"destination-out\"\n            /* DestinationOut */\n          );\n          var dx = x2 - self2.lastx;\n          var dy = y2 - self2.lasty;\n          var distance = Math.sqrt(dx * dx + dy * dy);\n          var directionX = dx / distance;\n          var directionY = dy / distance;\n          for (var i = 0; i < distance; i += 5) {\n            var px = self2.lastx + directionX * i;\n            var py = self2.lasty + directionY * i;\n            self2.draw_shape(self2, px, py, brush_size);\n          }\n          self2.lastx = x2;\n          self2.lasty = y2;\n        });\n      self2.lasttime = performance.now();\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  handlePointerDown(self2, event) {\n    if (event.ctrlKey) {\n      if (event.buttons == 1) {\n        _MaskEditorDialogOld2.mousedown_x = event.clientX;\n        _MaskEditorDialogOld2.mousedown_y = event.clientY;\n        this.mousedown_pan_x = this.pan_x;\n        this.mousedown_pan_y = this.pan_y;\n      }\n      return;\n    }\n    var brush_size = this.brush_size;\n    if (event instanceof PointerEvent && event.pointerType == \"pen\") {\n      brush_size *= event.pressure;\n      this.last_pressure = event.pressure;\n    }\n    if ([0, 2, 5].includes(event.button)) {\n      self2.drawing_mode = true;\n      event.preventDefault();\n      if (event.shiftKey) {\n        self2.zoom_lasty = event.clientY;\n        self2.last_zoom_ratio = self2.zoom_ratio;\n        return;\n      }\n      const maskRect = self2.maskCanvas.getBoundingClientRect();\n      const x = (event.offsetX || event.targetTouches[0].clientX - maskRect.left) / self2.zoom_ratio;\n      const y = (event.offsetY || event.targetTouches[0].clientY - maskRect.top) / self2.zoom_ratio;\n      if (!event.altKey && event.button == 0) {\n        self2.init_shape(\n          self2,\n          \"source-over\"\n          /* SourceOver */\n        );\n      } else {\n        self2.init_shape(\n          self2,\n          \"destination-out\"\n          /* DestinationOut */\n        );\n      }\n      self2.draw_shape(self2, x, y, brush_size);\n      self2.lastx = x;\n      self2.lasty = y;\n      self2.lasttime = performance.now();\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  init_shape(self2, compositionOperation) {\n    self2.maskCtx.beginPath();\n    if (compositionOperation == \"source-over\") {\n      self2.maskCtx.fillStyle = this.getMaskFillStyle();\n      self2.maskCtx.globalCompositeOperation = \"source-over\";\n    } else if (compositionOperation == \"destination-out\") {\n      self2.maskCtx.globalCompositeOperation = \"destination-out\";\n    }\n  }\n  // @ts-expect-error fixme ts strict error\n  draw_shape(self2, x, y, brush_size) {\n    if (self2.pointer_type === \"rect\") {\n      self2.maskCtx.rect(\n        x - brush_size,\n        y - brush_size,\n        brush_size * 2,\n        brush_size * 2\n      );\n    } else {\n      self2.maskCtx.arc(x, y, brush_size, 0, Math.PI * 2, false);\n    }\n    self2.maskCtx.fill();\n  }\n  async save() {\n    const backupCanvas = document.createElement(\"canvas\");\n    const backupCtx = backupCanvas.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    backupCanvas.width = this.image.width;\n    backupCanvas.height = this.image.height;\n    backupCtx.clearRect(0, 0, backupCanvas.width, backupCanvas.height);\n    backupCtx.drawImage(\n      this.maskCanvas,\n      0,\n      0,\n      this.maskCanvas.width,\n      this.maskCanvas.height,\n      0,\n      0,\n      backupCanvas.width,\n      backupCanvas.height\n    );\n    const backupData = backupCtx.getImageData(\n      0,\n      0,\n      backupCanvas.width,\n      backupCanvas.height\n    );\n    for (let i = 0; i < backupData.data.length; i += 4) {\n      if (backupData.data[i + 3] == 255) backupData.data[i + 3] = 0;\n      else backupData.data[i + 3] = 255;\n      backupData.data[i] = 0;\n      backupData.data[i + 1] = 0;\n      backupData.data[i + 2] = 0;\n    }\n    backupCtx.globalCompositeOperation = \"source-over\";\n    backupCtx.putImageData(backupData, 0, 0);\n    const formData = new FormData();\n    const filename = \"clipspace-mask-\" + performance.now() + \".png\";\n    const item = {\n      filename,\n      subfolder: \"clipspace\",\n      type: \"input\"\n    };\n    if (ComfyApp.clipspace.images) ComfyApp.clipspace.images[0] = item;\n    if (ComfyApp.clipspace.widgets) {\n      const index = ComfyApp.clipspace.widgets.findIndex(\n        (obj) => obj.name === \"image\"\n      );\n      if (index >= 0) ComfyApp.clipspace.widgets[index].value = item;\n    }\n    const dataURL = backupCanvas.toDataURL();\n    const blob2 = dataURLToBlob(dataURL);\n    let original_url = new URL(this.image.src);\n    const original_ref = {\n      // @ts-expect-error fixme ts strict error\n      filename: original_url.searchParams.get(\"filename\")\n    };\n    let original_subfolder = original_url.searchParams.get(\"subfolder\");\n    if (original_subfolder) original_ref.subfolder = original_subfolder;\n    let original_type = original_url.searchParams.get(\"type\");\n    if (original_type) original_ref.type = original_type;\n    formData.append(\"image\", blob2, filename);\n    formData.append(\"original_ref\", JSON.stringify(original_ref));\n    formData.append(\"type\", \"input\");\n    formData.append(\"subfolder\", \"clipspace\");\n    this.saveButton.innerText = \"Saving...\";\n    this.saveButton.disabled = true;\n    await uploadMask(item, formData);\n    ComfyApp.onClipspaceEditorSave();\n    this.close();\n  }\n};\n__publicField$4(_MaskEditorDialogOld, \"instance\", null);\n__publicField$4(_MaskEditorDialogOld, \"mousedown_x\", null);\n__publicField$4(_MaskEditorDialogOld, \"mousedown_y\", null);\nlet MaskEditorDialogOld = _MaskEditorDialogOld;\nvar __defProp$3 = Object.defineProperty;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$3 = (obj, key, value) => __defNormalProp$3(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar styles = `\n  #maskEditorContainer {\n    display: fixed;\n  }\n  #maskEditor_brush {\n    position: absolute;\n    backgroundColor: transparent;\n    z-index: 8889;\n    pointer-events: none;\n    border-radius: 50%;\n    overflow: visible;\n    outline: 1px dashed black;\n    box-shadow: 0 0 0 1px white;\n  }\n  #maskEditor_brushPreviewGradient {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    border-radius: 50%;\n    display: none;\n  }\n  #maskEditor {\n    display: block;\n    width: 100%;\n    height: 100vh;\n    left: 0;\n    z-index: 8888;\n    position: fixed;\n    background: rgba(50,50,50,0.75);\n    backdrop-filter: blur(10px);\n    overflow: hidden;\n    user-select: none;\n    --mask-editor-top-bar-height: 44px;\n  }\n  #maskEditor_sidePanelContainer {\n    height: 100%;\n    width: 220px;\n    z-index: 8888;\n    display: flex;\n    flex-direction: column;\n  }\n  #maskEditor_sidePanel {\n    background: var(--comfy-menu-bg);\n    height: 100%;\n    display: flex;\n    align-items: center;\n    overflow-y: auto;\n    width: 220px;\n    padding: 0 10px;\n  }\n  #maskEditor_sidePanelContent {\n    width: 100%;\n  }\n  #maskEditor_sidePanelShortcuts {\n    display: flex;\n    flex-direction: row;\n    width: 100%;\n    margin-top: 10px;\n    gap: 10px;\n    justify-content: center;\n  }\n  .maskEditor_sidePanelIconButton {\n    width: 40px;\n    height: 40px;\n    pointer-events: auto;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    transition: background-color 0.1s;\n  }\n  .maskEditor_sidePanelIconButton:hover {\n    background-color: rgba(0, 0, 0, 0.2);\n  }\n  #maskEditor_sidePanelBrushSettings {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    width: 100%;\n    padding: 10px;\n  }\n  .maskEditor_sidePanelTitle {\n    text-align: center;\n    font-size: 15px;\n    font-family: sans-serif;\n    color: var(--descrip-text);\n    margin-top: 10px;\n  }\n  #maskEditor_sidePanelBrushShapeContainer {\n    display: flex;\n    width: 180px;\n    height: 50px;\n    border: 1px solid var(--border-color);\n    pointer-events: auto;\n    background: rgba(0, 0, 0, 0.2);\n  }\n  #maskEditor_sidePanelBrushShapeCircle {\n    width: 35px;\n    height: 35px;\n    border-radius: 50%;\n    border: 1px solid var(--border-color);\n    pointer-events: auto;\n    transition: background 0.1s;\n    margin-left: 7.5px;\n  }\n  .maskEditor_sidePanelBrushRange {\n    width: 180px;\n    -webkit-appearance: none;\n    appearance: none;\n    background: transparent;\n    cursor: pointer;\n  }\n  .maskEditor_sidePanelBrushRange::-webkit-slider-thumb {\n    height: 20px;\n    width: 20px;\n    border-radius: 50%;\n    cursor: grab;\n    margin-top: -8px;\n    background: var(--p-surface-700);\n    border: 1px solid var(--border-color);\n  }\n  .maskEditor_sidePanelBrushRange::-moz-range-thumb {\n    height: 20px;\n    width: 20px;\n    border-radius: 50%;\n    cursor: grab;\n    background: var(--p-surface-800);\n    border: 1px solid var(--border-color);\n  }\n  .maskEditor_sidePanelBrushRange::-webkit-slider-runnable-track {\n    background: var(--p-surface-700);\n    height: 3px;\n  }\n  .maskEditor_sidePanelBrushRange::-moz-range-track {\n    background: var(--p-surface-700);\n    height: 3px;\n  }\n\n  #maskEditor_sidePanelBrushShapeSquare {\n    width: 35px;\n    height: 35px;\n    margin: 5px;\n    border: 1px solid var(--border-color);\n    pointer-events: auto;\n    transition: background 0.1s;\n  }\n\n  .maskEditor_brushShape_dark {\n    background: transparent;\n  }\n\n  .maskEditor_brushShape_dark:hover {\n    background: var(--p-surface-900);\n  }\n\n  .maskEditor_brushShape_light {\n    background: transparent;\n  }\n\n  .maskEditor_brushShape_light:hover {\n    background: var(--comfy-menu-bg);\n  }\n\n  #maskEditor_sidePanelImageLayerSettings {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    width: 100%;\n    align-items: center;\n  }\n  .maskEditor_sidePanelLayer {\n    display: flex;\n    width: 100%;\n    height: 50px;\n  }\n  .maskEditor_sidePanelLayerVisibilityContainer {\n    width: 50px;\n    height: 50px;\n    border-radius: 8px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  .maskEditor_sidePanelVisibilityToggle {\n    width: 12px;\n    height: 12px;\n    border-radius: 50%;\n    pointer-events: auto;\n  }\n  .maskEditor_sidePanelLayerIconContainer {\n    width: 60px;\n    height: 50px;\n    border-radius: 8px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    fill: var(--input-text);\n  }\n  .maskEditor_sidePanelLayerIconContainer svg {\n    width: 30px;\n    height: 30px;\n  }\n  #maskEditor_sidePanelMaskLayerBlendingContainer {\n    width: 80px;\n    height: 50px;\n    border-radius: 8px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  #maskEditor_sidePanelMaskLayerBlendingSelect {\n    width: 80px;\n    height: 30px;\n    border: 1px solid var(--border-color);\n    background-color: rgba(0, 0, 0, 0.2);\n    color: var(--input-text);\n    font-family: sans-serif;\n    font-size: 15px;\n    pointer-events: auto;\n    transition: background-color border 0.1s;\n  }\n  #maskEditor_sidePanelClearCanvasButton:hover {\n    background-color: var(--p-overlaybadge-outline-color);\n    border: none;\n  }\n  #maskEditor_sidePanelClearCanvasButton {\n    width: 180px;\n    height: 30px;\n    border: none;\n    background: rgba(0, 0, 0, 0.2);\n    border: 1px solid var(--border-color);\n    color: var(--input-text);\n    font-family: sans-serif;\n    font-size: 15px;\n    pointer-events: auto;\n    transition: background-color 0.1s;\n  }\n  #maskEditor_sidePanelClearCanvasButton:hover {\n    background-color: var(--p-overlaybadge-outline-color);\n  }\n  #maskEditor_sidePanelHorizontalButtonContainer {\n    display: flex;\n    gap: 10px;\n    height: 40px;\n  }\n  .maskEditor_sidePanelBigButton {\n    width: 85px;\n    height: 30px;\n    border: none;\n    background: rgba(0, 0, 0, 0.2);\n    border: 1px solid var(--border-color);\n    color: var(--input-text);\n    font-family: sans-serif;\n    font-size: 15px;\n    pointer-events: auto;\n    transition: background-color border 0.1s;\n  }\n  .maskEditor_sidePanelBigButton:hover {\n    background-color: var(--p-overlaybadge-outline-color);\n    border: none;\n  }\n  #maskEditor_toolPanel {\n    height: 100%;\n    width: 4rem;\n    z-index: 8888;\n    background: var(--comfy-menu-bg);\n    display: flex;\n    flex-direction: column;\n  }\n  .maskEditor_toolPanelContainer {\n    width: 4rem;\n    height: 4rem;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    position: relative;\n    transition: background-color 0.2s;\n  }\n  .maskEditor_toolPanelContainerSelected svg {\n    fill: var(--p-button-text-primary-color) !important;\n  }\n  .maskEditor_toolPanelContainerSelected .maskEditor_toolPanelIndicator {\n    display: block;\n  }\n  .maskEditor_toolPanelContainer svg {\n    width: 75%;\n    aspect-ratio: 1/1;\n    fill: var(--p-button-text-secondary-color);\n  }\n\n  .maskEditor_toolPanelContainerDark:hover {\n    background-color: var(--p-surface-800);\n  }\n\n  .maskEditor_toolPanelContainerLight:hover {\n    background-color: var(--p-surface-300);\n  }\n\n  .maskEditor_toolPanelIndicator {\n    display: none;\n    height: 100%;\n    width: 4px;\n    position: absolute;\n    left: 0;\n    background: var(--p-button-text-primary-color);\n  }\n  #maskEditor_sidePanelPaintBucketSettings {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    width: 100%;\n    padding: 10px;\n  }\n  #canvasBackground {\n    background: white;\n    width: 100%;\n    height: 100%;\n  }\n  #maskEditor_sidePanelButtonsContainer {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    margin-top: 10px;\n  }\n  .maskEditor_sidePanelSeparator {\n    width: 100%;\n    height: 2px;\n    background: var(--border-color);\n    margin-top: 1.5em;\n    margin-bottom: 5px;\n  }\n  #maskEditor_pointerZone {\n    width: calc(100% - 4rem - 220px);\n    height: 100%;\n  }\n  #maskEditor_uiContainer {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    z-index: 8888;\n    display: flex;\n    flex-direction: column;\n  }\n  #maskEditorCanvasContainer {\n    position: absolute;\n    width: 1000px;\n    height: 667px;\n    left: 359px;\n    top: 280px;\n  }\n  #imageCanvas {\n    width: 100%;\n    height: 100%;\n  }\n  #maskCanvas {\n    width: 100%;\n    height: 100%;\n  }\n  #maskEditor_uiHorizontalContainer {\n    width: 100%;\n    height: calc(100% - var(--mask-editor-top-bar-height));\n    display: flex;\n  }\n  #maskEditor_topBar {\n    display: flex;\n    height: var(--mask-editor-top-bar-height);\n    align-items: center;\n    background: var(--comfy-menu-bg);\n    flex-shrink: 0;\n  }\n  #maskEditor_topBarTitle {\n    margin: 0;\n    margin-left: 0.5rem;\n    margin-right: 0.5rem;\n    font-size: 1.2em;\n  }\n  #maskEditor_topBarButtonContainer {\n    display: flex;\n    gap: 10px;\n    margin-right: 0.5rem;\n    position: absolute;\n    right: 0;\n    width: 100%;\n  }\n  #maskEditor_topBarShortcutsContainer {\n    display: flex;\n    gap: 10px;\n    margin-left: 5px;\n  }\n\n  .maskEditor_topPanelIconButton_dark {\n    width: 50px;\n    height: 30px;\n    pointer-events: auto;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    transition: background-color 0.1s;\n    background: var(--p-surface-800);\n    border: 1px solid var(--p-form-field-border-color);\n    border-radius: 10px;\n  }\n\n  .maskEditor_topPanelIconButton_dark:hover {\n      background-color: var(--p-surface-900);\n  }\n\n  .maskEditor_topPanelIconButton_dark svg {\n    width: 25px;\n    height: 25px;\n    pointer-events: none;\n    fill: var(--input-text);\n  }\n\n  .maskEditor_topPanelIconButton_light {\n    width: 50px;\n    height: 30px;\n    pointer-events: auto;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    transition: background-color 0.1s;\n    background: var(--comfy-menu-bg);\n    border: 1px solid var(--p-form-field-border-color);\n    border-radius: 10px;\n  }\n\n  .maskEditor_topPanelIconButton_light:hover {\n      background-color: var(--p-surface-300);\n  }\n\n  .maskEditor_topPanelIconButton_light svg {\n    width: 25px;\n    height: 25px;\n    pointer-events: none;\n    fill: var(--input-text);\n  }\n\n  .maskEditor_topPanelButton_dark {\n    height: 30px;\n    background: var(--p-surface-800);\n    border: 1px solid var(--p-form-field-border-color);\n    border-radius: 10px;\n    color: var(--input-text);\n    font-family: sans-serif;\n    pointer-events: auto;\n    transition: 0.1s;\n    width: 60px;\n  }\n\n  .maskEditor_topPanelButton_dark:hover {\n    background-color: var(--p-surface-900);\n  }\n\n  .maskEditor_topPanelButton_light {\n    height: 30px;\n    background: var(--comfy-menu-bg);\n    border: 1px solid var(--p-form-field-border-color);\n    border-radius: 10px;\n    color: var(--input-text);\n    font-family: sans-serif;\n    pointer-events: auto;\n    transition: 0.1s;\n    width: 60px;\n  }\n\n  .maskEditor_topPanelButton_light:hover {\n    background-color: var(--p-surface-300);\n  }\n\n\n  #maskEditor_sidePanelColorSelectSettings {\n    flex-direction: column;\n  }\n\n  .maskEditor_sidePanel_paintBucket_Container {\n    width: 180px;\n    display: flex;\n    flex-direction: column;\n    position: relative;\n  }\n\n  .maskEditor_sidePanel_colorSelect_Container {\n    display: flex;\n    width: 180px;\n    align-items: center;\n    gap: 5px;\n    height: 30px;\n  }\n\n  #maskEditor_sidePanelVisibilityToggle {\n    position: absolute;\n    right: 0;\n  }\n\n  #maskEditor_sidePanelColorSelectMethodSelect {\n    position: absolute;\n    right: 0;\n    height: 30px;\n    border-radius: 0;\n    border: 1px solid var(--border-color);\n    background: rgba(0,0,0,0.2);\n  }\n\n  #maskEditor_sidePanelVisibilityToggle {\n    position: absolute;\n    right: 0;\n  }\n\n  .maskEditor_sidePanel_colorSelect_tolerance_container {\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    margin-bottom: 10px;\n  }\n\n  .maskEditor_sidePanelContainerColumn {\n    display: flex;\n    flex-direction: column;\n    gap: 12px;\n    padding-bottom: 12px;\n  }\n\n  .maskEditor_sidePanelContainerRow {\n    display: flex;\n    flex-direction: row;\n    gap: 10px;\n    align-items: center;\n    min-height: 24px;\n    position: relative;\n  }\n\n  .maskEditor_accent_bg_dark {\n    background: var(--p-surface-800);\n  }\n\n  .maskEditor_accent_bg_very_dark {\n    background: var(--p-surface-900);\n  }\n\n  .maskEditor_accent_bg_light {\n    background: var(--p-surface-300);\n  }\n\n  .maskEditor_accent_bg_very_light {\n    background: var(--comfy-menu-bg);\n  }\n\n  #maskEditor_paintBucketSettings {\n    display: none;\n  }\n\n  #maskEditor_colorSelectSettings {\n    display: none;\n  }\n\n  .maskEditor_sidePanelToggleContainer {\n    cursor: pointer;\n    display: inline-block;\n    position: absolute;\n    right: 0;\n  }\n\n  .maskEditor_toggle_bg_dark {\n    background: var(--p-surface-700);\n  }\n\n  .maskEditor_toggle_bg_light {\n    background: var(--p-surface-300);\n  }\n\n  .maskEditor_sidePanelToggleSwitch {\n    display: inline-block;\n    border-radius: 16px;\n    width: 40px;\n    height: 24px;\n    position: relative;\n    vertical-align: middle;\n    transition: background 0.25s;\n  }\n  .maskEditor_sidePanelToggleSwitch:before, .maskEditor_sidePanelToggleSwitch:after {\n    content: \"\";\n  }\n  .maskEditor_sidePanelToggleSwitch:before {\n    display: block;\n    background: linear-gradient(to bottom, #fff 0%, #eee 100%);\n    border-radius: 50%;\n    width: 16px;\n    height: 16px;\n    position: absolute;\n    top: 4px;\n    left: 4px;\n    transition: ease 0.2s;\n  }\n  .maskEditor_sidePanelToggleContainer:hover .maskEditor_sidePanelToggleSwitch:before {\n    background: linear-gradient(to bottom, #fff 0%, #fff 100%);\n  }\n  .maskEditor_sidePanelToggleCheckbox:checked + .maskEditor_sidePanelToggleSwitch {\n    background: var(--p-button-text-primary-color);\n  }\n  .maskEditor_sidePanelToggleCheckbox:checked + .maskEditor_toggle_bg_dark:before {\n    background: var(--p-surface-900);\n  }\n  .maskEditor_sidePanelToggleCheckbox:checked + .maskEditor_toggle_bg_light:before {\n    background: var(--comfy-menu-bg);\n  }\n  .maskEditor_sidePanelToggleCheckbox:checked + .maskEditor_sidePanelToggleSwitch:before {\n    left: 20px;\n  }\n\n  .maskEditor_sidePanelToggleCheckbox {\n    position: absolute;\n    visibility: hidden;\n  }\n\n  .maskEditor_sidePanelDropdown_dark {\n    border: 1px solid var(--p-form-field-border-color);\n    background: var(--p-surface-900);\n    height: 24px;\n    padding-left: 5px;\n    padding-right: 5px;\n    border-radius: 6px;\n    transition: background 0.1s;\n  }\n\n  .maskEditor_sidePanelDropdown_dark option {\n    background: var(--p-surface-900);\n  }\n\n  .maskEditor_sidePanelDropdown_dark:focus {\n    outline: 1px solid var(--p-button-text-primary-color);\n  }\n\n  .maskEditor_sidePanelDropdown_dark option:hover {\n    background: white;\n  }\n  .maskEditor_sidePanelDropdown_dark option:active {\n    background: var(--p-highlight-background);\n  }\n\n  .maskEditor_sidePanelDropdown_light {\n    border: 1px solid var(--p-form-field-border-color);\n    background: var(--comfy-menu-bg);\n    height: 24px;\n    padding-left: 5px;\n    padding-right: 5px;\n    border-radius: 6px;\n    transition: background 0.1s;\n  }\n\n  .maskEditor_sidePanelDropdown_light option {\n    background: var(--comfy-menu-bg);\n  }\n\n  .maskEditor_sidePanelDropdown_light:focus {\n    outline: 1px solid var(--p-surface-300);\n  }\n\n  .maskEditor_sidePanelDropdown_light option:hover {\n    background: white;\n  }\n  .maskEditor_sidePanelDropdown_light option:active {\n    background: var(--p-surface-300);\n  }\n\n  .maskEditor_layerRow {\n    height: 50px;\n    width: 100%;\n    border-radius: 10px;\n  }\n\n  .maskEditor_sidePanelLayerPreviewContainer {\n    width: 40px;\n    height: 30px;\n  }\n\n  .maskEditor_sidePanelLayerPreviewContainer > svg{\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n    fill: var(--p-surface-100);\n  }\n\n  #maskEditor_sidePanelImageLayerImage {\n    width: 100%;\n    height: 100%;\n    object-fit: contain;\n  }\n\n  .maskEditor_sidePanelSubTitle {\n    text-align: left;\n    font-size: 12px;\n    font-family: sans-serif;\n    color: var(--descrip-text);\n  }\n\n  .maskEditor_containerDropdown {\n    position: absolute;\n    right: 0;\n  }\n\n  .maskEditor_sidePanelLayerCheckbox {\n    margin-left: 15px;\n  }\n\n  .maskEditor_toolPanelZoomIndicator {\n    width: 4rem;\n    height: 4rem;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    gap: 5px;\n    color: var(--p-button-text-secondary-color);\n    position: absolute;\n    bottom: 0;\n    transition: background-color 0.2s;\n  }\n\n  #maskEditor_toolPanelDimensionsText {\n    font-size: 12px;\n  }\n\n  #maskEditor_topBarSaveButton {\n    background: var(--p-primary-color) !important;\n    color: var(--p-button-primary-color) !important;\n  }\n\n  #maskEditor_topBarSaveButton:hover {\n    background: var(--p-primary-hover-color) !important;\n  }\n\n`;\nvar styleSheet = document.createElement(\"style\");\nstyleSheet.type = \"text/css\";\nstyleSheet.innerText = styles;\ndocument.head.appendChild(styleSheet);\nconst allTools = [\n  \"pen\",\n  \"rgbPaint\",\n  \"eraser\",\n  \"paintBucket\",\n  \"colorSelect\"\n  /* MaskColorFill */\n];\nconst allImageLayers = [\"mask\", \"rgb\"];\nvar ColorComparisonMethod = /* @__PURE__ */ ((ColorComparisonMethod2) => {\n  ColorComparisonMethod2[\"Simple\"] = \"simple\";\n  ColorComparisonMethod2[\"HSL\"] = \"hsl\";\n  ColorComparisonMethod2[\"LAB\"] = \"lab\";\n  return ColorComparisonMethod2;\n})(ColorComparisonMethod || {});\nconst saveBrushToCache = debounce(function(key, brush) {\n  try {\n    const brushString = JSON.stringify(brush);\n    setStorageValue(key, brushString);\n  } catch (error) {\n    console.error(\"Failed to save brush to cache:\", error);\n  }\n}, 300);\nfunction loadBrushFromCache(key) {\n  try {\n    const brushString = getStorageValue(key);\n    if (brushString) {\n      const brush = JSON.parse(brushString);\n      console.log(\"Loaded brush from cache:\", brush);\n      return brush;\n    } else {\n      console.log(\"No brush found in cache.\");\n      return null;\n    }\n  } catch (error) {\n    console.error(\"Failed to load brush from cache:\", error);\n    return null;\n  }\n}\nconst _MaskEditorDialog = class _MaskEditorDialog2 extends ComfyDialog {\n  constructor() {\n    super();\n    __publicField$3(this, \"uiManager\");\n    __publicField$3(this, \"toolManager\");\n    __publicField$3(this, \"panAndZoomManager\");\n    __publicField$3(this, \"brushTool\");\n    __publicField$3(this, \"paintBucketTool\");\n    __publicField$3(this, \"colorSelectTool\");\n    __publicField$3(this, \"canvasHistory\");\n    __publicField$3(this, \"messageBroker\");\n    __publicField$3(this, \"keyboardManager\");\n    __publicField$3(this, \"rootElement\");\n    __publicField$3(this, \"imageURL\");\n    __publicField$3(this, \"isLayoutCreated\", false);\n    __publicField$3(this, \"isOpen\", false);\n    __publicField$3(this, \"last_display_style\", null);\n    this.rootElement = $el(\n      \"div.maskEditor_hidden\",\n      { parent: document.body },\n      []\n    );\n    this.element = this.rootElement;\n  }\n  static getInstance() {\n    if (!ComfyApp.clipspace || !ComfyApp.clipspace.imgs) {\n      throw new Error(\"No clipspace images found\");\n    }\n    const currentSrc = ComfyApp.clipspace.imgs[ComfyApp.clipspace[\"selectedIndex\"]].src;\n    if (!_MaskEditorDialog2.instance || currentSrc !== _MaskEditorDialog2.instance.imageURL) {\n      if (_MaskEditorDialog2.instance) _MaskEditorDialog2.instance.destroy();\n      _MaskEditorDialog2.instance = new _MaskEditorDialog2();\n      _MaskEditorDialog2.instance.imageURL = currentSrc;\n    }\n    return _MaskEditorDialog2.instance;\n  }\n  async show() {\n    this.cleanup();\n    if (!this.isLayoutCreated) {\n      this.messageBroker = new MessageBroker();\n      this.canvasHistory = new CanvasHistory(this, 20);\n      this.paintBucketTool = new PaintBucketTool(this);\n      this.brushTool = new BrushTool(this);\n      this.panAndZoomManager = new PanAndZoomManager(this);\n      this.toolManager = new ToolManager(this);\n      this.keyboardManager = new KeyboardManager(this);\n      this.uiManager = new UIManager(this.rootElement, this);\n      this.colorSelectTool = new ColorSelectTool(this);\n      const self2 = this;\n      const observer = new MutationObserver(function(mutations) {\n        mutations.forEach(function(mutation) {\n          if (mutation.type === \"attributes\" && mutation.attributeName === \"style\") {\n            if (self2.last_display_style && self2.last_display_style != \"none\" && self2.element.style.display == \"none\") {\n              ComfyApp.onClipspaceEditorClosed();\n            }\n            self2.last_display_style = self2.element.style.display;\n          }\n        });\n      });\n      const config = { attributes: true };\n      observer.observe(this.rootElement, config);\n      this.isLayoutCreated = true;\n      await this.uiManager.setlayout();\n    }\n    this.rootElement.id = \"maskEditor\";\n    this.rootElement.style.display = \"flex\";\n    this.element.style.display = \"flex\";\n    await this.uiManager.initUI();\n    this.paintBucketTool.initPaintBucketTool();\n    this.colorSelectTool.initColorSelectTool();\n    await this.canvasHistory.saveInitialState();\n    this.isOpen = true;\n    if (ComfyApp.clipspace && ComfyApp.clipspace.imgs) {\n      this.uiManager.setSidebarImage();\n    }\n    this.keyboardManager.addListeners();\n  }\n  cleanup() {\n    const maskEditors = document.querySelectorAll('[id^=\"maskEditor\"]');\n    maskEditors.forEach((element) => element.remove());\n    const brushElements = document.querySelectorAll(\"#maskEditor_brush\");\n    brushElements.forEach((element) => element.remove());\n  }\n  destroy() {\n    this.isLayoutCreated = false;\n    this.isOpen = false;\n    this.canvasHistory.clearStates();\n    this.keyboardManager.removeListeners();\n    this.cleanup();\n    this.close();\n    _MaskEditorDialog2.instance = null;\n  }\n  isOpened() {\n    return this.isOpen;\n  }\n  async save() {\n    const imageCanvas = this.uiManager.getImgCanvas();\n    const maskCanvas = this.uiManager.getMaskCanvas();\n    const maskCanvasCtx = getCanvas2dContext(maskCanvas);\n    const paintCanvas = this.uiManager.getRgbCanvas();\n    const image = this.uiManager.getImage();\n    try {\n      await ensureImageFullyLoaded(maskCanvas.toDataURL());\n    } catch (error) {\n      console.error(\"Error loading mask image:\", error);\n      return;\n    }\n    const unrefinedMaskImageData = maskCanvasCtx.getImageData(\n      0,\n      0,\n      maskCanvas.width,\n      maskCanvas.height\n    );\n    const refinedMaskOnlyData = new ImageData(\n      removeImageRgbValuesAndInvertAlpha(unrefinedMaskImageData.data),\n      unrefinedMaskImageData.width,\n      unrefinedMaskImageData.height\n    );\n    const [refinedMaskCanvas, refinedMaskCanvasCtx] = createCanvasCopy(maskCanvas);\n    refinedMaskCanvasCtx.globalCompositeOperation = \"source-over\";\n    refinedMaskCanvasCtx.putImageData(refinedMaskOnlyData, 0, 0);\n    const timestamp = Math.round(performance.now());\n    const filenames = imageLayerFilenamesByTimestamp(timestamp);\n    const refs = {\n      maskedImage: toRef(filenames.maskedImage),\n      paint: toRef(filenames.paint),\n      paintedImage: toRef(filenames.paintedImage),\n      paintedMaskedImage: toRef(filenames.paintedMaskedImage)\n    };\n    const [paintedImageCanvas] = combineOriginalImageAndPaint({\n      originalImage: imageCanvas,\n      paint: paintCanvas\n    });\n    replaceClipspaceImages(refs.paintedMaskedImage, [refs.paint]);\n    const originalImageUrl = new URL(image.src);\n    this.uiManager.setBrushOpacity(0);\n    const originalImageFilename = originalImageUrl.searchParams.get(\"filename\");\n    if (!originalImageFilename)\n      throw new Error(\n        \"Expected original image URL to have a `filename` query parameter, but couldn't find it.\"\n      );\n    const originalImageRef = {\n      filename: originalImageFilename,\n      subfolder: originalImageUrl.searchParams.get(\"subfolder\") ?? void 0,\n      type: originalImageUrl.searchParams.get(\"type\") ?? void 0\n    };\n    const mkFormData = (blob2, filename, originalImageRefOverride) => {\n      const formData = new FormData();\n      formData.append(\"image\", blob2, filename);\n      formData.append(\n        \"original_ref\",\n        JSON.stringify(originalImageRefOverride ?? originalImageRef)\n      );\n      formData.append(\"type\", \"input\");\n      formData.append(\"subfolder\", \"clipspace\");\n      return formData;\n    };\n    const canvasToFormData = (canvas, filename, originalImageRefOverride) => {\n      const blob2 = this.dataURLToBlob(canvas.toDataURL());\n      return mkFormData(blob2, filename, originalImageRefOverride);\n    };\n    const formDatas = {\n      // Note: this canvas only contains mask data (no image), but during the upload process, the backend combines the mask with the original_image. Refer to the backend repo's `server.py`, search for `@routes.post(\"/upload/mask\")`\n      maskedImage: canvasToFormData(refinedMaskCanvas, filenames.maskedImage),\n      paint: canvasToFormData(paintCanvas, filenames.paint),\n      paintedImage: canvasToFormData(\n        paintedImageCanvas,\n        filenames.paintedImage\n      ),\n      paintedMaskedImage: canvasToFormData(\n        refinedMaskCanvas,\n        filenames.paintedMaskedImage,\n        refs.paintedImage\n      )\n    };\n    this.uiManager.setSaveButtonText(t(\"g.saving\"));\n    this.uiManager.setSaveButtonEnabled(false);\n    this.keyboardManager.removeListeners();\n    try {\n      await this.uploadMask(\n        refs.maskedImage,\n        formDatas.maskedImage,\n        \"selectedIndex\"\n      );\n      await this.uploadImage(refs.paint, formDatas.paint);\n      await this.uploadImage(refs.paintedImage, formDatas.paintedImage, false);\n      await this.uploadMask(\n        refs.paintedMaskedImage,\n        formDatas.paintedMaskedImage,\n        \"combinedIndex\"\n      );\n      ComfyApp.onClipspaceEditorSave();\n      this.destroy();\n    } catch (error) {\n      console.error(\"Error during upload:\", error);\n      this.uiManager.setSaveButtonText(t(\"g.save\"));\n      this.uiManager.setSaveButtonEnabled(true);\n      this.keyboardManager.addListeners();\n    }\n  }\n  getMessageBroker() {\n    return this.messageBroker;\n  }\n  // Helper function to convert a data URL to a Blob object\n  dataURLToBlob(dataURL) {\n    const parts = dataURL.split(\";base64,\");\n    const contentType = parts[0].split(\":\")[1];\n    const byteString = atob(parts[1]);\n    const arrayBuffer = new ArrayBuffer(byteString.length);\n    const uint8Array = new Uint8Array(arrayBuffer);\n    for (let i = 0; i < byteString.length; i++) {\n      uint8Array[i] = byteString.charCodeAt(i);\n    }\n    return new Blob([arrayBuffer], { type: contentType });\n  }\n  async uploadImage(filepath, formData, isPaintLayer = true) {\n    var _a2, _b2;\n    const success = await requestWithRetries(\n      () => api.fetchApi(\"/upload/image\", {\n        method: \"POST\",\n        body: formData\n      })\n    );\n    if (!success) {\n      throw new Error(\"Upload failed.\");\n    }\n    if (!isPaintLayer) {\n      ClipspaceDialog.invalidatePreview();\n      return success;\n    }\n    try {\n      const paintedIndex = (_a2 = ComfyApp.clipspace) == null ? void 0 : _a2.paintedIndex;\n      if (((_b2 = ComfyApp.clipspace) == null ? void 0 : _b2.imgs) && paintedIndex !== void 0) {\n        const newImage = new Image();\n        newImage.src = mkFileUrl({ ref: filepath, preview: true });\n        ComfyApp.clipspace.imgs[paintedIndex] = newImage;\n        if (ComfyApp.clipspace.images) {\n          ComfyApp.clipspace.images[paintedIndex] = filepath;\n        }\n      }\n    } catch (err2) {\n      console.warn(\"Failed to update clipspace image:\", err2);\n    }\n    ClipspaceDialog.invalidatePreview();\n  }\n  async uploadMask(filepath, formData, clipspaceLocation) {\n    var _a2, _b2;\n    const success = await requestWithRetries(\n      () => api.fetchApi(\"/upload/mask\", {\n        method: \"POST\",\n        body: formData\n      })\n    );\n    if (!success) {\n      throw new Error(\"Upload failed.\");\n    }\n    try {\n      const nameOfIndexToSaveTo = {\n        selectedIndex: \"selectedIndex\",\n        combinedIndex: \"combinedIndex\"\n      }[clipspaceLocation];\n      if (!nameOfIndexToSaveTo) return;\n      const indexToSaveTo = (_a2 = ComfyApp.clipspace) == null ? void 0 : _a2[nameOfIndexToSaveTo];\n      if (!((_b2 = ComfyApp.clipspace) == null ? void 0 : _b2.imgs) || indexToSaveTo === void 0) return;\n      const newImage = new Image();\n      newImage.src = mkFileUrl({ ref: filepath, preview: true });\n      ComfyApp.clipspace.imgs[indexToSaveTo] = newImage;\n      if (ComfyApp.clipspace.images) {\n        ComfyApp.clipspace.images[indexToSaveTo] = filepath;\n      }\n    } catch (err2) {\n      console.warn(\"Failed to update clipspace image:\", err2);\n    }\n    ClipspaceDialog.invalidatePreview();\n  }\n};\n__publicField$3(_MaskEditorDialog, \"instance\", null);\nlet MaskEditorDialog = _MaskEditorDialog;\nclass CanvasHistory {\n  constructor(maskEditor, maxStates = 20) {\n    __publicField$3(this, \"maskEditor\");\n    __publicField$3(this, \"messageBroker\");\n    __publicField$3(this, \"canvas\");\n    __publicField$3(this, \"ctx\");\n    __publicField$3(this, \"rgbCanvas\");\n    __publicField$3(this, \"rgbCtx\");\n    __publicField$3(this, \"states\", []);\n    __publicField$3(this, \"currentStateIndex\", -1);\n    __publicField$3(this, \"maxStates\", 20);\n    __publicField$3(this, \"initialized\", false);\n    this.maskEditor = maskEditor;\n    this.messageBroker = maskEditor.getMessageBroker();\n    this.maxStates = maxStates;\n    this.createListeners();\n  }\n  async pullCanvas() {\n    this.canvas = await this.messageBroker.pull(\"maskCanvas\");\n    this.ctx = await this.messageBroker.pull(\"maskCtx\");\n    this.rgbCanvas = await this.messageBroker.pull(\"rgbCanvas\");\n    this.rgbCtx = await this.messageBroker.pull(\"rgbCtx\");\n  }\n  createListeners() {\n    this.messageBroker.subscribe(\"saveState\", () => this.saveState());\n    this.messageBroker.subscribe(\"undo\", () => this.undo());\n    this.messageBroker.subscribe(\"redo\", () => this.redo());\n  }\n  clearStates() {\n    this.states = [];\n    this.currentStateIndex = -1;\n    this.initialized = false;\n  }\n  async saveInitialState() {\n    await this.pullCanvas();\n    if (!this.canvas.width || !this.canvas.height || !this.rgbCanvas.width || !this.rgbCanvas.height) {\n      requestAnimationFrame(() => this.saveInitialState());\n      return;\n    }\n    this.clearStates();\n    const maskState = this.ctx.getImageData(\n      0,\n      0,\n      this.canvas.width,\n      this.canvas.height\n    );\n    const rgbState = this.rgbCtx.getImageData(\n      0,\n      0,\n      this.rgbCanvas.width,\n      this.rgbCanvas.height\n    );\n    this.states.push({ mask: maskState, rgb: rgbState });\n    this.currentStateIndex = 0;\n    this.initialized = true;\n  }\n  saveState() {\n    if (!this.initialized || this.currentStateIndex === -1) {\n      this.saveInitialState();\n      return;\n    }\n    this.states = this.states.slice(0, this.currentStateIndex + 1);\n    const maskState = this.ctx.getImageData(\n      0,\n      0,\n      this.canvas.width,\n      this.canvas.height\n    );\n    const rgbState = this.rgbCtx.getImageData(\n      0,\n      0,\n      this.rgbCanvas.width,\n      this.rgbCanvas.height\n    );\n    this.states.push({ mask: maskState, rgb: rgbState });\n    this.currentStateIndex++;\n    if (this.states.length > this.maxStates) {\n      this.states.shift();\n      this.currentStateIndex--;\n    }\n  }\n  undo() {\n    if (this.states.length > 1 && this.currentStateIndex > 0) {\n      this.currentStateIndex--;\n      this.restoreState(this.states[this.currentStateIndex]);\n    } else {\n      alert(\"No more undo states available\");\n    }\n  }\n  redo() {\n    if (this.states.length > 1 && this.currentStateIndex < this.states.length - 1) {\n      this.currentStateIndex++;\n      this.restoreState(this.states[this.currentStateIndex]);\n    } else {\n      alert(\"No more redo states available\");\n    }\n  }\n  restoreState(state) {\n    if (state && this.initialized) {\n      this.ctx.putImageData(state.mask, 0, 0);\n      this.rgbCtx.putImageData(state.rgb, 0, 0);\n    }\n  }\n}\nclass PaintBucketTool {\n  // Add opacity property (default 100%)\n  constructor(maskEditor) {\n    __publicField$3(this, \"maskEditor\");\n    __publicField$3(this, \"messageBroker\");\n    __publicField$3(this, \"canvas\");\n    __publicField$3(this, \"ctx\");\n    __publicField$3(this, \"width\", null);\n    __publicField$3(this, \"height\", null);\n    __publicField$3(this, \"imageData\", null);\n    __publicField$3(this, \"data\", null);\n    __publicField$3(this, \"tolerance\", 5);\n    __publicField$3(this, \"fillOpacity\", 255);\n    this.maskEditor = maskEditor;\n    this.messageBroker = maskEditor.getMessageBroker();\n    this.createListeners();\n    this.addPullTopics();\n  }\n  initPaintBucketTool() {\n    this.pullCanvas();\n  }\n  async pullCanvas() {\n    this.canvas = await this.messageBroker.pull(\"maskCanvas\");\n    this.ctx = await this.messageBroker.pull(\"maskCtx\");\n  }\n  createListeners() {\n    this.messageBroker.subscribe(\n      \"setPaintBucketTolerance\",\n      (tolerance) => this.setTolerance(tolerance)\n    );\n    this.messageBroker.subscribe(\n      \"paintBucketFill\",\n      (point) => this.floodFill(point)\n    );\n    this.messageBroker.subscribe(\"invert\", () => this.invertMask());\n    this.messageBroker.subscribe(\n      \"setFillOpacity\",\n      (opacity) => this.setFillOpacity(opacity)\n    );\n  }\n  addPullTopics() {\n    this.messageBroker.createPullTopic(\n      \"getTolerance\",\n      async () => this.tolerance\n    );\n    this.messageBroker.createPullTopic(\n      \"getFillOpacity\",\n      async () => this.fillOpacity / 255 * 100\n    );\n  }\n  // Add method to set opacity\n  setFillOpacity(opacity) {\n    this.fillOpacity = Math.floor(opacity / 100 * 255);\n  }\n  getPixel(x, y) {\n    return this.data[(y * this.width + x) * 4 + 3];\n  }\n  setPixel(x, y, alpha, color) {\n    const index = (y * this.width + x) * 4;\n    this.data[index] = color.r;\n    this.data[index + 1] = color.g;\n    this.data[index + 2] = color.b;\n    this.data[index + 3] = alpha;\n  }\n  shouldProcessPixel(currentAlpha, targetAlpha, tolerance, isFillMode) {\n    if (currentAlpha === -1) return false;\n    if (isFillMode) {\n      return currentAlpha !== 255 && Math.abs(currentAlpha - targetAlpha) <= tolerance;\n    } else {\n      return currentAlpha === 255 || Math.abs(currentAlpha - targetAlpha) <= tolerance;\n    }\n  }\n  async floodFill(point) {\n    let startX = Math.floor(point.x);\n    let startY = Math.floor(point.y);\n    this.width = this.canvas.width;\n    this.height = this.canvas.height;\n    if (startX < 0 || startX >= this.width || startY < 0 || startY >= this.height) {\n      return;\n    }\n    this.imageData = this.ctx.getImageData(0, 0, this.width, this.height);\n    this.data = this.imageData.data;\n    const targetAlpha = this.getPixel(startX, startY);\n    const isFillMode = targetAlpha !== 255;\n    if (targetAlpha === -1) return;\n    const maskColor = await this.messageBroker.pull(\"getMaskColor\");\n    const stack = [];\n    const visited = new Uint8Array(this.width * this.height);\n    if (this.shouldProcessPixel(\n      targetAlpha,\n      targetAlpha,\n      this.tolerance,\n      isFillMode\n    )) {\n      stack.push([startX, startY]);\n    }\n    while (stack.length > 0) {\n      const [x, y] = stack.pop();\n      const visitedIndex = y * this.width + x;\n      if (visited[visitedIndex]) continue;\n      const currentAlpha = this.getPixel(x, y);\n      if (!this.shouldProcessPixel(\n        currentAlpha,\n        targetAlpha,\n        this.tolerance,\n        isFillMode\n      )) {\n        continue;\n      }\n      visited[visitedIndex] = 1;\n      this.setPixel(x, y, isFillMode ? this.fillOpacity : 0, maskColor);\n      const checkNeighbor = (nx, ny) => {\n        if (nx < 0 || nx >= this.width || ny < 0 || ny >= this.height) return;\n        if (!visited[ny * this.width + nx]) {\n          const alpha = this.getPixel(nx, ny);\n          if (this.shouldProcessPixel(\n            alpha,\n            targetAlpha,\n            this.tolerance,\n            isFillMode\n          )) {\n            stack.push([nx, ny]);\n          }\n        }\n      };\n      checkNeighbor(x - 1, y);\n      checkNeighbor(x + 1, y);\n      checkNeighbor(x, y - 1);\n      checkNeighbor(x, y + 1);\n    }\n    this.ctx.putImageData(this.imageData, 0, 0);\n    this.imageData = null;\n    this.data = null;\n  }\n  setTolerance(tolerance) {\n    this.tolerance = tolerance;\n  }\n  getTolerance() {\n    return this.tolerance;\n  }\n  //invert mask\n  invertMask() {\n    const imageData = this.ctx.getImageData(\n      0,\n      0,\n      this.canvas.width,\n      this.canvas.height\n    );\n    const data = imageData.data;\n    let maskR = 0, maskG = 0, maskB = 0;\n    for (let i = 0; i < data.length; i += 4) {\n      if (data[i + 3] > 0) {\n        maskR = data[i];\n        maskG = data[i + 1];\n        maskB = data[i + 2];\n        break;\n      }\n    }\n    for (let i = 0; i < data.length; i += 4) {\n      const alpha = data[i + 3];\n      data[i + 3] = 255 - alpha;\n      if (alpha === 0) {\n        data[i] = maskR;\n        data[i + 1] = maskG;\n        data[i + 2] = maskB;\n      }\n    }\n    this.ctx.putImageData(imageData, 0, 0);\n    this.messageBroker.publish(\"saveState\");\n  }\n}\nclass ColorSelectTool {\n  // Add opacity property (default 100%)\n  constructor(maskEditor) {\n    __publicField$3(this, \"maskEditor\");\n    __publicField$3(this, \"messageBroker\");\n    __publicField$3(this, \"width\", null);\n    __publicField$3(this, \"height\", null);\n    __publicField$3(this, \"canvas\");\n    __publicField$3(this, \"maskCTX\");\n    __publicField$3(this, \"imageCTX\");\n    __publicField$3(this, \"maskData\", null);\n    __publicField$3(this, \"imageData\", null);\n    __publicField$3(this, \"tolerance\", 20);\n    __publicField$3(this, \"livePreview\", false);\n    __publicField$3(this, \"lastPoint\", null);\n    __publicField$3(\n      this,\n      \"colorComparisonMethod\",\n      \"simple\"\n      /* Simple */\n    );\n    __publicField$3(this, \"applyWholeImage\", false);\n    __publicField$3(this, \"maskBoundry\", false);\n    __publicField$3(this, \"maskTolerance\", 0);\n    __publicField$3(this, \"selectOpacity\", 255);\n    this.maskEditor = maskEditor;\n    this.messageBroker = maskEditor.getMessageBroker();\n    this.createListeners();\n    this.addPullTopics();\n  }\n  async initColorSelectTool() {\n    await this.pullCanvas();\n  }\n  async pullCanvas() {\n    this.canvas = await this.messageBroker.pull(\"imgCanvas\");\n    this.maskCTX = await this.messageBroker.pull(\"maskCtx\");\n    this.imageCTX = await this.messageBroker.pull(\"imageCtx\");\n  }\n  createListeners() {\n    this.messageBroker.subscribe(\n      \"colorSelectFill\",\n      (point) => this.fillColorSelection(point)\n    );\n    this.messageBroker.subscribe(\n      \"setColorSelectTolerance\",\n      (tolerance) => this.setTolerance(tolerance)\n    );\n    this.messageBroker.subscribe(\n      \"setLivePreview\",\n      (livePreview) => this.setLivePreview(livePreview)\n    );\n    this.messageBroker.subscribe(\n      \"setColorComparisonMethod\",\n      (method) => this.setComparisonMethod(method)\n    );\n    this.messageBroker.subscribe(\"clearLastPoint\", () => this.clearLastPoint());\n    this.messageBroker.subscribe(\n      \"setWholeImage\",\n      (applyWholeImage) => this.setApplyWholeImage(applyWholeImage)\n    );\n    this.messageBroker.subscribe(\n      \"setMaskBoundary\",\n      (maskBoundry) => this.setMaskBoundary(maskBoundry)\n    );\n    this.messageBroker.subscribe(\n      \"setMaskTolerance\",\n      (maskTolerance) => this.setMaskTolerance(maskTolerance)\n    );\n    this.messageBroker.subscribe(\n      \"setSelectionOpacity\",\n      (opacity) => this.setSelectOpacity(opacity)\n    );\n  }\n  async addPullTopics() {\n    this.messageBroker.createPullTopic(\n      \"getLivePreview\",\n      async () => this.livePreview\n    );\n  }\n  getPixel(x, y) {\n    const index = (y * this.width + x) * 4;\n    return {\n      r: this.imageData[index],\n      g: this.imageData[index + 1],\n      b: this.imageData[index + 2]\n    };\n  }\n  getMaskAlpha(x, y) {\n    return this.maskData[(y * this.width + x) * 4 + 3];\n  }\n  isPixelInRange(pixel, target) {\n    switch (this.colorComparisonMethod) {\n      case \"simple\":\n        return this.isPixelInRangeSimple(pixel, target);\n      case \"hsl\":\n        return this.isPixelInRangeHSL(pixel, target);\n      case \"lab\":\n        return this.isPixelInRangeLab(pixel, target);\n      default:\n        return this.isPixelInRangeSimple(pixel, target);\n    }\n  }\n  isPixelInRangeSimple(pixel, target) {\n    const distance = Math.sqrt(\n      Math.pow(pixel.r - target.r, 2) + Math.pow(pixel.g - target.g, 2) + Math.pow(pixel.b - target.b, 2)\n    );\n    return distance <= this.tolerance;\n  }\n  isPixelInRangeHSL(pixel, target) {\n    const pixelHSL = this.rgbToHSL(pixel.r, pixel.g, pixel.b);\n    const targetHSL = this.rgbToHSL(target.r, target.g, target.b);\n    const hueDiff = Math.abs(pixelHSL.h - targetHSL.h);\n    const satDiff = Math.abs(pixelHSL.s - targetHSL.s);\n    const lightDiff = Math.abs(pixelHSL.l - targetHSL.l);\n    const distance = Math.sqrt(\n      Math.pow(hueDiff / 360 * 255, 2) + Math.pow(satDiff / 100 * 255, 2) + Math.pow(lightDiff / 100 * 255, 2)\n    );\n    return distance <= this.tolerance;\n  }\n  rgbToHSL(r, g, b) {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    const max2 = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let h = 0, s = 0, l = (max2 + min) / 2;\n    if (max2 !== min) {\n      const d = max2 - min;\n      s = l > 0.5 ? d / (2 - max2 - min) : d / (max2 + min);\n      switch (max2) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0);\n          break;\n        case g:\n          h = (b - r) / d + 2;\n          break;\n        case b:\n          h = (r - g) / d + 4;\n          break;\n      }\n      h /= 6;\n    }\n    return {\n      h: h * 360,\n      s: s * 100,\n      l: l * 100\n    };\n  }\n  isPixelInRangeLab(pixel, target) {\n    const pixelLab = this.rgbToLab(pixel);\n    const targetLab = this.rgbToLab(target);\n    const deltaE = Math.sqrt(\n      Math.pow(pixelLab.l - targetLab.l, 2) + Math.pow(pixelLab.a - targetLab.a, 2) + Math.pow(pixelLab.b - targetLab.b, 2)\n    );\n    const normalizedDeltaE = deltaE / 100 * 255;\n    return normalizedDeltaE <= this.tolerance;\n  }\n  rgbToLab(rgb) {\n    let r = rgb.r / 255;\n    let g = rgb.g / 255;\n    let b = rgb.b / 255;\n    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n    r *= 100;\n    g *= 100;\n    b *= 100;\n    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n    const xn = 95.047;\n    const yn = 100;\n    const zn = 108.883;\n    const xyz = [x / xn, y / yn, z / zn];\n    for (let i = 0; i < xyz.length; i++) {\n      xyz[i] = xyz[i] > 8856e-6 ? Math.pow(xyz[i], 1 / 3) : 7.787 * xyz[i] + 16 / 116;\n    }\n    return {\n      l: 116 * xyz[1] - 16,\n      a: 500 * (xyz[0] - xyz[1]),\n      b: 200 * (xyz[1] - xyz[2])\n    };\n  }\n  setPixel(x, y, alpha, color) {\n    const index = (y * this.width + x) * 4;\n    this.maskData[index] = color.r;\n    this.maskData[index + 1] = color.g;\n    this.maskData[index + 2] = color.b;\n    this.maskData[index + 3] = alpha;\n  }\n  async fillColorSelection(point) {\n    this.width = this.canvas.width;\n    this.height = this.canvas.height;\n    this.lastPoint = point;\n    const maskData = this.maskCTX.getImageData(0, 0, this.width, this.height);\n    this.maskData = maskData.data;\n    this.imageData = this.imageCTX.getImageData(\n      0,\n      0,\n      this.width,\n      this.height\n    ).data;\n    if (this.applyWholeImage) {\n      const targetPixel = this.getPixel(\n        Math.floor(point.x),\n        Math.floor(point.y)\n      );\n      const maskColor = await this.messageBroker.pull(\"getMaskColor\");\n      const width = this.width;\n      const height = this.height;\n      const CHUNK_SIZE = 1e4;\n      for (let i = 0; i < width * height; i += CHUNK_SIZE) {\n        const endIndex = Math.min(i + CHUNK_SIZE, width * height);\n        for (let pixelIndex = i; pixelIndex < endIndex; pixelIndex++) {\n          const x = pixelIndex % width;\n          const y = Math.floor(pixelIndex / width);\n          if (this.isPixelInRange(this.getPixel(x, y), targetPixel)) {\n            this.setPixel(x, y, this.selectOpacity, maskColor);\n          }\n        }\n        await new Promise((resolve) => setTimeout(resolve, 0));\n      }\n    } else {\n      let startX = Math.floor(point.x);\n      let startY = Math.floor(point.y);\n      if (startX < 0 || startX >= this.width || startY < 0 || startY >= this.height) {\n        return;\n      }\n      const pixel = this.getPixel(startX, startY);\n      const stack = [];\n      const visited = new Uint8Array(this.width * this.height);\n      stack.push([startX, startY]);\n      const maskColor = await this.messageBroker.pull(\"getMaskColor\");\n      while (stack.length > 0) {\n        const [x, y] = stack.pop();\n        const visitedIndex = y * this.width + x;\n        if (visited[visitedIndex] || !this.isPixelInRange(this.getPixel(x, y), pixel)) {\n          continue;\n        }\n        visited[visitedIndex] = 1;\n        this.setPixel(x, y, this.selectOpacity, maskColor);\n        if (x > 0 && !visited[y * this.width + (x - 1)] && this.isPixelInRange(this.getPixel(x - 1, y), pixel)) {\n          if (!this.maskBoundry || 255 - this.getMaskAlpha(x - 1, y) > this.maskTolerance) {\n            stack.push([x - 1, y]);\n          }\n        }\n        if (x < this.width - 1 && !visited[y * this.width + (x + 1)] && this.isPixelInRange(this.getPixel(x + 1, y), pixel)) {\n          if (!this.maskBoundry || 255 - this.getMaskAlpha(x + 1, y) > this.maskTolerance) {\n            stack.push([x + 1, y]);\n          }\n        }\n        if (y > 0 && !visited[(y - 1) * this.width + x] && this.isPixelInRange(this.getPixel(x, y - 1), pixel)) {\n          if (!this.maskBoundry || 255 - this.getMaskAlpha(x, y - 1) > this.maskTolerance) {\n            stack.push([x, y - 1]);\n          }\n        }\n        if (y < this.height - 1 && !visited[(y + 1) * this.width + x] && this.isPixelInRange(this.getPixel(x, y + 1), pixel)) {\n          if (!this.maskBoundry || 255 - this.getMaskAlpha(x, y + 1) > this.maskTolerance) {\n            stack.push([x, y + 1]);\n          }\n        }\n      }\n    }\n    this.maskCTX.putImageData(maskData, 0, 0);\n    this.messageBroker.publish(\"saveState\");\n    this.maskData = null;\n    this.imageData = null;\n  }\n  setTolerance(tolerance) {\n    this.tolerance = tolerance;\n    if (this.lastPoint && this.livePreview) {\n      this.messageBroker.publish(\"undo\");\n      this.fillColorSelection(this.lastPoint);\n    }\n  }\n  setLivePreview(livePreview) {\n    this.livePreview = livePreview;\n  }\n  setComparisonMethod(method) {\n    this.colorComparisonMethod = method;\n    if (this.lastPoint && this.livePreview) {\n      this.messageBroker.publish(\"undo\");\n      this.fillColorSelection(this.lastPoint);\n    }\n  }\n  clearLastPoint() {\n    this.lastPoint = null;\n  }\n  setApplyWholeImage(applyWholeImage) {\n    this.applyWholeImage = applyWholeImage;\n  }\n  setMaskBoundary(maskBoundry) {\n    this.maskBoundry = maskBoundry;\n  }\n  setMaskTolerance(maskTolerance) {\n    this.maskTolerance = maskTolerance;\n  }\n  // Add method to set opacity\n  setSelectOpacity(opacity) {\n    this.selectOpacity = Math.floor(opacity / 100 * 255);\n    if (this.lastPoint && this.livePreview) {\n      this.messageBroker.publish(\"undo\");\n      this.fillColorSelection(this.lastPoint);\n    }\n  }\n}\nclass BrushTool {\n  constructor(maskEditor) {\n    __publicField$3(this, \"brushSettings\");\n    __publicField$3(this, \"maskBlendMode\");\n    __publicField$3(this, \"isDrawing\", false);\n    __publicField$3(this, \"isDrawingLine\", false);\n    __publicField$3(this, \"lineStartPoint\", null);\n    __publicField$3(this, \"smoothingPrecision\", 10);\n    __publicField$3(this, \"smoothingCordsArray\", []);\n    __publicField$3(this, \"smoothingLastDrawTime\");\n    __publicField$3(this, \"maskCtx\", null);\n    __publicField$3(this, \"rgbCtx\", null);\n    __publicField$3(this, \"initialDraw\", true);\n    __publicField$3(this, \"brushStrokeCanvas\", null);\n    __publicField$3(this, \"brushStrokeCtx\", null);\n    __publicField$3(this, \"isBrushAdjusting\", false);\n    __publicField$3(this, \"brushPreviewGradient\", null);\n    __publicField$3(this, \"initialPoint\", null);\n    __publicField$3(this, \"useDominantAxis\", false);\n    __publicField$3(this, \"brushAdjustmentSpeed\", 1);\n    __publicField$3(this, \"maskEditor\");\n    __publicField$3(this, \"messageBroker\");\n    __publicField$3(this, \"rgbColor\", \"#FF0000\");\n    __publicField$3(this, \"activeLayer\", \"mask\");\n    this.maskEditor = maskEditor;\n    this.messageBroker = maskEditor.getMessageBroker();\n    this.createListeners();\n    this.addPullTopics();\n    this.useDominantAxis = app.extensionManager.setting.get(\n      \"Comfy.MaskEditor.UseDominantAxis\"\n    );\n    this.brushAdjustmentSpeed = app.extensionManager.setting.get(\n      \"Comfy.MaskEditor.BrushAdjustmentSpeed\"\n    );\n    const cachedBrushSettings = loadBrushFromCache(\"maskeditor_brush_settings\");\n    if (cachedBrushSettings) {\n      this.brushSettings = cachedBrushSettings;\n    } else {\n      this.brushSettings = {\n        type: \"arc\",\n        size: 10,\n        opacity: 0.7,\n        hardness: 1,\n        smoothingPrecision: 10\n      };\n    }\n    this.maskBlendMode = \"black\";\n  }\n  createListeners() {\n    this.messageBroker.subscribe(\n      \"setBrushSize\",\n      (size) => this.setBrushSize(size)\n    );\n    this.messageBroker.subscribe(\n      \"setBrushOpacity\",\n      (opacity) => this.setBrushOpacity(opacity)\n    );\n    this.messageBroker.subscribe(\n      \"setBrushHardness\",\n      (hardness) => this.setBrushHardness(hardness)\n    );\n    this.messageBroker.subscribe(\n      \"setBrushShape\",\n      (type) => this.setBrushType(type)\n    );\n    this.messageBroker.subscribe(\n      \"setActiveLayer\",\n      (layer) => this.activeLayer = layer\n    );\n    this.messageBroker.subscribe(\n      \"setBrushSmoothingPrecision\",\n      (precision) => this.setBrushSmoothingPrecision(precision)\n    );\n    this.messageBroker.subscribe(\"setRGBColor\", (color) => {\n      this.rgbColor = color;\n    });\n    this.messageBroker.subscribe(\n      \"brushAdjustmentStart\",\n      (event) => this.startBrushAdjustment(event)\n    );\n    this.messageBroker.subscribe(\n      \"brushAdjustment\",\n      (event) => this.handleBrushAdjustment(event)\n    );\n    this.messageBroker.subscribe(\n      \"drawStart\",\n      (event) => this.startDrawing(event)\n    );\n    this.messageBroker.subscribe(\n      \"draw\",\n      (event) => this.handleDrawing(event)\n    );\n    this.messageBroker.subscribe(\n      \"drawEnd\",\n      (event) => this.drawEnd(event)\n    );\n  }\n  addPullTopics() {\n    this.messageBroker.createPullTopic(\n      \"brushSize\",\n      async () => this.brushSettings.size\n    );\n    this.messageBroker.createPullTopic(\n      \"brushOpacity\",\n      async () => this.brushSettings.opacity\n    );\n    this.messageBroker.createPullTopic(\n      \"brushHardness\",\n      async () => this.brushSettings.hardness\n    );\n    this.messageBroker.createPullTopic(\n      \"brushType\",\n      async () => this.brushSettings.type\n    );\n    this.messageBroker.createPullTopic(\n      \"brushSmoothingPrecision\",\n      async () => this.brushSettings.smoothingPrecision\n    );\n    this.messageBroker.createPullTopic(\n      \"maskBlendMode\",\n      async () => this.maskBlendMode\n    );\n    this.messageBroker.createPullTopic(\n      \"brushSettings\",\n      async () => this.brushSettings\n    );\n  }\n  async createBrushStrokeCanvas() {\n    if (this.brushStrokeCanvas !== null) {\n      return;\n    }\n    const maskCanvas = await this.messageBroker.pull(\"maskCanvas\");\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = maskCanvas.width;\n    canvas.height = maskCanvas.height;\n    this.brushStrokeCanvas = canvas;\n    this.brushStrokeCtx = canvas.getContext(\"2d\");\n  }\n  async startDrawing(event) {\n    this.isDrawing = true;\n    let compositionOp;\n    let currentTool = await this.messageBroker.pull(\"currentTool\");\n    let coords = { x: event.offsetX, y: event.offsetY };\n    let coords_canvas = await this.messageBroker.pull(\"screenToCanvas\", coords);\n    await this.createBrushStrokeCanvas();\n    if (currentTool === \"eraser\" || event.buttons == 2) {\n      compositionOp = \"destination-out\";\n    } else {\n      compositionOp = \"source-over\";\n    }\n    if (event.shiftKey && this.lineStartPoint) {\n      this.isDrawingLine = true;\n      this.drawLine(this.lineStartPoint, coords_canvas, compositionOp);\n    } else {\n      this.isDrawingLine = false;\n      this.init_shape(compositionOp);\n      this.draw_shape(coords_canvas);\n    }\n    this.lineStartPoint = coords_canvas;\n    this.smoothingCordsArray = [coords_canvas];\n    this.smoothingLastDrawTime = /* @__PURE__ */ new Date();\n  }\n  async handleDrawing(event) {\n    var diff = performance.now() - this.smoothingLastDrawTime.getTime();\n    let coords = { x: event.offsetX, y: event.offsetY };\n    let coords_canvas = await this.messageBroker.pull(\"screenToCanvas\", coords);\n    let currentTool = await this.messageBroker.pull(\"currentTool\");\n    if (diff > 20 && !this.isDrawing)\n      requestAnimationFrame(() => {\n        this.init_shape(\n          \"source-over\"\n          /* SourceOver */\n        );\n        this.draw_shape(coords_canvas);\n        this.smoothingCordsArray.push(coords_canvas);\n      });\n    else\n      requestAnimationFrame(() => {\n        if (currentTool === \"eraser\" || event.buttons == 2) {\n          this.init_shape(\n            \"destination-out\"\n            /* DestinationOut */\n          );\n        } else {\n          this.init_shape(\n            \"source-over\"\n            /* SourceOver */\n          );\n        }\n        this.drawWithBetterSmoothing(coords_canvas);\n      });\n    this.smoothingLastDrawTime = /* @__PURE__ */ new Date();\n  }\n  async drawEnd(event) {\n    const coords = { x: event.offsetX, y: event.offsetY };\n    const coords_canvas = await this.messageBroker.pull(\n      \"screenToCanvas\",\n      coords\n    );\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this.messageBroker.publish(\"saveState\");\n      this.lineStartPoint = coords_canvas;\n      this.initialDraw = true;\n    }\n  }\n  drawWithBetterSmoothing(point) {\n    if (!this.smoothingCordsArray) {\n      this.smoothingCordsArray = [];\n    }\n    const opacityConstant = 1 / (1 + Math.exp(3));\n    const interpolatedOpacity = 1 / (1 + Math.exp(-6 * (this.brushSettings.opacity - 0.5))) - opacityConstant;\n    this.smoothingCordsArray.push(point);\n    const POINTS_NR = 5;\n    if (this.smoothingCordsArray.length < POINTS_NR) {\n      return;\n    }\n    let totalLength = 0;\n    const points = this.smoothingCordsArray;\n    const len = points.length - 1;\n    let dx, dy;\n    for (let i = 0; i < len; i++) {\n      dx = points[i + 1].x - points[i].x;\n      dy = points[i + 1].y - points[i].y;\n      totalLength += Math.sqrt(dx * dx + dy * dy);\n    }\n    const distanceBetweenPoints = this.brushSettings.size / this.brushSettings.smoothingPrecision * 6;\n    const stepNr = Math.ceil(totalLength / distanceBetweenPoints);\n    let interpolatedPoints = points;\n    if (stepNr > 0) {\n      interpolatedPoints = this.generateEquidistantPoints(\n        this.smoothingCordsArray,\n        distanceBetweenPoints\n        // Distance between interpolated points\n      );\n    }\n    if (!this.initialDraw) {\n      const spliceIndex = interpolatedPoints.findIndex(\n        (point2) => point2.x === this.smoothingCordsArray[2].x && point2.y === this.smoothingCordsArray[2].y\n      );\n      if (spliceIndex !== -1) {\n        interpolatedPoints = interpolatedPoints.slice(spliceIndex + 1);\n      }\n    }\n    for (const point2 of interpolatedPoints) {\n      this.draw_shape(point2, interpolatedOpacity);\n    }\n    if (!this.initialDraw) {\n      this.smoothingCordsArray = this.smoothingCordsArray.slice(2);\n    } else {\n      this.initialDraw = false;\n    }\n  }\n  async drawLine(p1, p2, compositionOp) {\n    const brush_size = await this.messageBroker.pull(\"brushSize\");\n    const distance = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);\n    const steps = Math.ceil(\n      distance / (brush_size / this.brushSettings.smoothingPrecision * 4)\n    );\n    const interpolatedOpacity = 1 / (1 + Math.exp(-6 * (this.brushSettings.opacity - 0.5))) - 1 / (1 + Math.exp(3));\n    this.init_shape(compositionOp);\n    for (let i = 0; i <= steps; i++) {\n      const t2 = i / steps;\n      const x = p1.x + (p2.x - p1.x) * t2;\n      const y = p1.y + (p2.y - p1.y) * t2;\n      const point = { x, y };\n      this.draw_shape(point, interpolatedOpacity);\n    }\n  }\n  //brush adjustment\n  async startBrushAdjustment(event) {\n    event.preventDefault();\n    const coords = { x: event.offsetX, y: event.offsetY };\n    let coords_canvas = await this.messageBroker.pull(\"screenToCanvas\", coords);\n    this.messageBroker.publish(\"setBrushPreviewGradientVisibility\", true);\n    this.initialPoint = coords_canvas;\n    this.isBrushAdjusting = true;\n    return;\n  }\n  async handleBrushAdjustment(event) {\n    const coords = { x: event.offsetX, y: event.offsetY };\n    const brushDeadZone = 5;\n    let coords_canvas = await this.messageBroker.pull(\"screenToCanvas\", coords);\n    const delta_x = coords_canvas.x - this.initialPoint.x;\n    const delta_y = coords_canvas.y - this.initialPoint.y;\n    const effectiveDeltaX = Math.abs(delta_x) < brushDeadZone ? 0 : delta_x;\n    const effectiveDeltaY = Math.abs(delta_y) < brushDeadZone ? 0 : delta_y;\n    let finalDeltaX = effectiveDeltaX;\n    let finalDeltaY = effectiveDeltaY;\n    console.log(this.useDominantAxis);\n    if (this.useDominantAxis) {\n      const ratio = Math.abs(effectiveDeltaX) / Math.abs(effectiveDeltaY);\n      const threshold = 2;\n      if (ratio > threshold) {\n        finalDeltaY = 0;\n      } else if (ratio < 1 / threshold) {\n        finalDeltaX = 0;\n      }\n    }\n    const cappedDeltaX = Math.max(-100, Math.min(100, finalDeltaX));\n    const cappedDeltaY = Math.max(-100, Math.min(100, finalDeltaY));\n    const newSize = Math.max(\n      1,\n      Math.min(\n        100,\n        this.brushSettings.size + cappedDeltaX / 35 * this.brushAdjustmentSpeed\n      )\n    );\n    const newHardness = Math.max(\n      0,\n      Math.min(\n        1,\n        this.brushSettings.hardness - cappedDeltaY / 4e3 * this.brushAdjustmentSpeed\n      )\n    );\n    this.brushSettings.size = newSize;\n    this.brushSettings.hardness = newHardness;\n    this.messageBroker.publish(\"updateBrushPreview\");\n  }\n  //helper functions\n  async draw_shape(point, overrideOpacity) {\n    const brushSettings = this.brushSettings;\n    const maskCtx = this.maskCtx || await this.messageBroker.pull(\"maskCtx\");\n    const rgbCtx = this.rgbCtx || await this.messageBroker.pull(\"rgbCtx\");\n    const brushType = await this.messageBroker.pull(\"brushType\");\n    const maskColor = await this.messageBroker.pull(\"getMaskColor\");\n    const size = brushSettings.size;\n    const brushSettingsSliderOpacity = brushSettings.opacity;\n    const opacity = overrideOpacity == void 0 ? brushSettingsSliderOpacity : overrideOpacity;\n    const hardness = brushSettings.hardness;\n    const x = point.x;\n    const y = point.y;\n    const extendedSize = size * (2 - hardness);\n    const isErasing = maskCtx.globalCompositeOperation === \"destination-out\";\n    const currentTool = await this.messageBroker.pull(\"currentTool\");\n    if (this.activeLayer === \"rgb\" && (currentTool === \"eraser\" || currentTool === \"rgbPaint\")) {\n      const rgbaColor = this.formatRgba(this.rgbColor, opacity);\n      let gradient2 = rgbCtx.createRadialGradient(x, y, 0, x, y, extendedSize);\n      if (hardness === 1) {\n        gradient2.addColorStop(0, rgbaColor);\n        gradient2.addColorStop(\n          1,\n          this.formatRgba(this.rgbColor, brushSettingsSliderOpacity)\n        );\n      } else {\n        gradient2.addColorStop(0, rgbaColor);\n        gradient2.addColorStop(hardness, rgbaColor);\n        gradient2.addColorStop(1, this.formatRgba(this.rgbColor, 0));\n      }\n      rgbCtx.fillStyle = gradient2;\n      rgbCtx.beginPath();\n      if (brushType === \"rect\") {\n        rgbCtx.rect(\n          x - extendedSize,\n          y - extendedSize,\n          extendedSize * 2,\n          extendedSize * 2\n        );\n      } else {\n        rgbCtx.arc(x, y, extendedSize, 0, Math.PI * 2, false);\n      }\n      rgbCtx.fill();\n      return;\n    }\n    let gradient = maskCtx.createRadialGradient(x, y, 0, x, y, extendedSize);\n    if (hardness === 1) {\n      gradient.addColorStop(\n        0,\n        isErasing ? `rgba(255, 255, 255, ${opacity})` : `rgba(${maskColor.r}, ${maskColor.g}, ${maskColor.b}, ${opacity})`\n      );\n      gradient.addColorStop(\n        1,\n        isErasing ? `rgba(255, 255, 255, ${opacity})` : `rgba(${maskColor.r}, ${maskColor.g}, ${maskColor.b}, ${opacity})`\n      );\n    } else {\n      let softness = 1 - hardness;\n      let innerStop = Math.max(0, hardness - softness);\n      let outerStop = size / extendedSize;\n      if (isErasing) {\n        gradient.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);\n        gradient.addColorStop(innerStop, `rgba(255, 255, 255, ${opacity})`);\n        gradient.addColorStop(outerStop, `rgba(255, 255, 255, ${opacity / 2})`);\n        gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);\n      } else {\n        gradient.addColorStop(\n          0,\n          `rgba(${maskColor.r}, ${maskColor.g}, ${maskColor.b}, ${opacity})`\n        );\n        gradient.addColorStop(\n          innerStop,\n          `rgba(${maskColor.r}, ${maskColor.g}, ${maskColor.b}, ${opacity})`\n        );\n        gradient.addColorStop(\n          outerStop,\n          `rgba(${maskColor.r}, ${maskColor.g}, ${maskColor.b}, ${opacity / 2})`\n        );\n        gradient.addColorStop(\n          1,\n          `rgba(${maskColor.r}, ${maskColor.g}, ${maskColor.b}, 0)`\n        );\n      }\n    }\n    maskCtx.fillStyle = gradient;\n    maskCtx.beginPath();\n    if (brushType === \"rect\") {\n      maskCtx.rect(\n        x - extendedSize,\n        y - extendedSize,\n        extendedSize * 2,\n        extendedSize * 2\n      );\n    } else {\n      maskCtx.arc(x, y, extendedSize, 0, Math.PI * 2, false);\n    }\n    maskCtx.fill();\n  }\n  formatRgba(hex, alpha) {\n    const { r, g, b } = hexToRgb(hex);\n    return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n  }\n  async init_shape(compositionOperation) {\n    const maskBlendMode = await this.messageBroker.pull(\"maskBlendMode\");\n    const maskCtx = this.maskCtx || await this.messageBroker.pull(\"maskCtx\");\n    const rgbCtx = this.rgbCtx || await this.messageBroker.pull(\"rgbCtx\");\n    maskCtx.beginPath();\n    rgbCtx.beginPath();\n    if (compositionOperation == \"source-over\") {\n      maskCtx.fillStyle = maskBlendMode;\n      maskCtx.globalCompositeOperation = \"source-over\";\n      rgbCtx.globalCompositeOperation = \"source-over\";\n    } else if (compositionOperation == \"destination-out\") {\n      maskCtx.globalCompositeOperation = \"destination-out\";\n      rgbCtx.globalCompositeOperation = \"destination-out\";\n    }\n  }\n  generateEquidistantPoints(points, distance) {\n    const result = [];\n    const cumulativeDistances = [0];\n    for (let i = 1; i < points.length; i++) {\n      const dx = points[i].x - points[i - 1].x;\n      const dy = points[i].y - points[i - 1].y;\n      const dist = Math.hypot(dx, dy);\n      cumulativeDistances[i] = cumulativeDistances[i - 1] + dist;\n    }\n    const totalLength = cumulativeDistances[cumulativeDistances.length - 1];\n    const numPoints = Math.floor(totalLength / distance);\n    for (let i = 0; i <= numPoints; i++) {\n      const targetDistance = i * distance;\n      let idx = 0;\n      while (idx < cumulativeDistances.length - 1 && cumulativeDistances[idx + 1] < targetDistance) {\n        idx++;\n      }\n      if (idx >= points.length - 1) {\n        result.push(points[points.length - 1]);\n        continue;\n      }\n      const d0 = cumulativeDistances[idx];\n      const d1 = cumulativeDistances[idx + 1];\n      const t2 = (targetDistance - d0) / (d1 - d0);\n      const x = points[idx].x + t2 * (points[idx + 1].x - points[idx].x);\n      const y = points[idx].y + t2 * (points[idx + 1].y - points[idx].y);\n      result.push({ x, y });\n    }\n    return result;\n  }\n  setBrushSize(size) {\n    this.brushSettings.size = size;\n    saveBrushToCache(\"maskeditor_brush_settings\", this.brushSettings);\n  }\n  setBrushOpacity(opacity) {\n    this.brushSettings.opacity = opacity;\n    saveBrushToCache(\"maskeditor_brush_settings\", this.brushSettings);\n  }\n  setBrushHardness(hardness) {\n    this.brushSettings.hardness = hardness;\n    saveBrushToCache(\"maskeditor_brush_settings\", this.brushSettings);\n  }\n  setBrushType(type) {\n    this.brushSettings.type = type;\n    saveBrushToCache(\"maskeditor_brush_settings\", this.brushSettings);\n  }\n  setBrushSmoothingPrecision(precision) {\n    this.brushSettings.smoothingPrecision = precision;\n    saveBrushToCache(\"maskeditor_brush_settings\", this.brushSettings);\n  }\n}\nclass UIManager {\n  constructor(rootElement, maskEditor) {\n    __publicField$3(this, \"rootElement\");\n    __publicField$3(this, \"brush\");\n    __publicField$3(this, \"brushPreviewGradient\");\n    __publicField$3(this, \"maskCtx\");\n    __publicField$3(this, \"rgbCtx\");\n    __publicField$3(this, \"imageCtx\");\n    __publicField$3(this, \"maskCanvas\");\n    __publicField$3(this, \"rgbCanvas\");\n    __publicField$3(this, \"imgCanvas\");\n    __publicField$3(this, \"brushSettingsHTML\");\n    __publicField$3(this, \"paintBucketSettingsHTML\");\n    __publicField$3(this, \"colorSelectSettingsHTML\");\n    __publicField$3(this, \"maskOpacitySlider\");\n    __publicField$3(this, \"brushHardnessSlider\");\n    __publicField$3(this, \"brushSizeSlider\");\n    __publicField$3(this, \"brushOpacitySlider\");\n    __publicField$3(this, \"sidebarImage\");\n    __publicField$3(this, \"saveButton\");\n    __publicField$3(this, \"toolPanel\");\n    __publicField$3(this, \"sidePanel\");\n    __publicField$3(this, \"pointerZone\");\n    __publicField$3(this, \"canvasBackground\");\n    __publicField$3(this, \"canvasContainer\");\n    __publicField$3(this, \"image\");\n    __publicField$3(this, \"paint_image\");\n    __publicField$3(this, \"imageURL\");\n    __publicField$3(this, \"darkMode\", true);\n    __publicField$3(this, \"maskLayerContainer\", null);\n    __publicField$3(this, \"paintLayerContainer\", null);\n    __publicField$3(this, \"maskEditor\");\n    __publicField$3(this, \"messageBroker\");\n    __publicField$3(this, \"mask_opacity\", 0.8);\n    __publicField$3(\n      this,\n      \"maskBlendMode\",\n      \"black\"\n      /* Black */\n    );\n    __publicField$3(this, \"zoomTextHTML\");\n    __publicField$3(this, \"dimensionsTextHTML\");\n    __publicField$3(this, \"activeLayer\", \"mask\");\n    __publicField$3(this, \"layerButtons\", {\n      mask: (() => {\n        const btn = document.createElement(\"button\");\n        btn.style.fontSize = \"12px\";\n        return btn;\n      })(),\n      rgb: (() => {\n        const btn = document.createElement(\"button\");\n        btn.style.fontSize = \"12px\";\n        return btn;\n      })()\n    });\n    __publicField$3(this, \"toolElements\", []);\n    __publicField$3(this, \"toolSettings\", {\n      [\n        \"pen\"\n        /* MaskPen */\n      ]: {\n        container: document.createElement(\"div\"),\n        newActiveLayerOnSet: \"mask\"\n      },\n      [\n        \"eraser\"\n        /* Eraser */\n      ]: {\n        container: document.createElement(\"div\")\n      },\n      [\n        \"rgbPaint\"\n        /* PaintPen */\n      ]: {\n        container: document.createElement(\"div\"),\n        newActiveLayerOnSet: \"rgb\"\n      },\n      [\n        \"paintBucket\"\n        /* MaskBucket */\n      ]: {\n        container: document.createElement(\"div\"),\n        cursor: \"url('/cursor/paintBucket.png') 30 25, auto\",\n        newActiveLayerOnSet: \"mask\"\n      },\n      [\n        \"colorSelect\"\n        /* MaskColorFill */\n      ]: {\n        container: document.createElement(\"div\"),\n        cursor: \"url('/cursor/colorSelect.png') 15 25, auto\",\n        newActiveLayerOnSet: \"mask\"\n      }\n    });\n    this.rootElement = rootElement;\n    this.maskEditor = maskEditor;\n    this.messageBroker = maskEditor.getMessageBroker();\n    this.addListeners();\n    this.addPullTopics();\n  }\n  createColorPicker() {\n    const colorPicker = document.createElement(\"input\");\n    colorPicker.type = \"color\";\n    colorPicker.id = \"maskEditor_colorPicker\";\n    colorPicker.value = \"#FF0000\";\n    colorPicker.addEventListener(\"input\", (event) => {\n      const color = event.target.value;\n      this.messageBroker.publish(\"setRGBColor\", color);\n    });\n    return colorPicker;\n  }\n  addListeners() {\n    this.messageBroker.subscribe(\n      \"updateBrushPreview\",\n      async () => this.updateBrushPreview()\n    );\n    this.messageBroker.subscribe(\n      \"paintBucketCursor\",\n      (isPaintBucket) => this.handlePaintBucketCursor(isPaintBucket)\n    );\n    this.messageBroker.subscribe(\n      \"panCursor\",\n      (isPan) => this.handlePanCursor(isPan)\n    );\n    this.messageBroker.subscribe(\n      \"setBrushVisibility\",\n      (isVisible) => this.setBrushVisibility(isVisible)\n    );\n    this.messageBroker.subscribe(\n      \"setBrushPreviewGradientVisibility\",\n      (isVisible) => this.setBrushPreviewGradientVisibility(isVisible)\n    );\n    this.messageBroker.subscribe(\"updateCursor\", () => this.updateCursor());\n    this.messageBroker.subscribe(\n      \"setZoomText\",\n      (text) => this.setZoomText(text)\n    );\n  }\n  addPullTopics() {\n    this.messageBroker.createPullTopic(\n      \"maskCanvas\",\n      async () => this.maskCanvas\n    );\n    this.messageBroker.createPullTopic(\"maskCtx\", async () => this.maskCtx);\n    this.messageBroker.createPullTopic(\"imageCtx\", async () => this.imageCtx);\n    this.messageBroker.createPullTopic(\"imgCanvas\", async () => this.imgCanvas);\n    this.messageBroker.createPullTopic(\"rgbCtx\", async () => this.rgbCtx);\n    this.messageBroker.createPullTopic(\"rgbCanvas\", async () => this.rgbCanvas);\n    this.messageBroker.createPullTopic(\n      \"screenToCanvas\",\n      async (coords) => this.screenToCanvas(coords)\n    );\n    this.messageBroker.createPullTopic(\n      \"getCanvasContainer\",\n      async () => this.canvasContainer\n    );\n    this.messageBroker.createPullTopic(\n      \"getMaskColor\",\n      async () => this.getMaskColor()\n    );\n  }\n  async setlayout() {\n    this.detectLightMode();\n    var user_ui = await this.createUI();\n    var canvasContainer = this.createBackgroundUI();\n    var brush = await this.createBrush();\n    await this.setBrushBorderRadius();\n    this.setBrushOpacity(1);\n    this.rootElement.appendChild(canvasContainer);\n    this.rootElement.appendChild(user_ui);\n    document.body.appendChild(brush);\n  }\n  async createUI() {\n    var ui_container = document.createElement(\"div\");\n    ui_container.id = \"maskEditor_uiContainer\";\n    var top_bar = await this.createTopBar();\n    var ui_horizontal_container = document.createElement(\"div\");\n    ui_horizontal_container.id = \"maskEditor_uiHorizontalContainer\";\n    var side_panel_container = await this.createSidePanel();\n    var pointer_zone = this.createPointerZone();\n    var tool_panel = this.createToolPanel();\n    ui_horizontal_container.appendChild(tool_panel);\n    ui_horizontal_container.appendChild(pointer_zone);\n    ui_horizontal_container.appendChild(side_panel_container);\n    ui_container.appendChild(top_bar);\n    ui_container.appendChild(ui_horizontal_container);\n    return ui_container;\n  }\n  createBackgroundUI() {\n    const canvasContainer = document.createElement(\"div\");\n    canvasContainer.id = \"maskEditorCanvasContainer\";\n    const imgCanvas = document.createElement(\"canvas\");\n    imgCanvas.id = \"imageCanvas\";\n    const maskCanvas = document.createElement(\"canvas\");\n    maskCanvas.id = \"maskCanvas\";\n    const rgbCanvas = document.createElement(\"canvas\");\n    rgbCanvas.id = \"rgbCanvas\";\n    const canvas_background = document.createElement(\"div\");\n    canvas_background.id = \"canvasBackground\";\n    canvasContainer.appendChild(imgCanvas);\n    canvasContainer.appendChild(rgbCanvas);\n    canvasContainer.appendChild(maskCanvas);\n    canvasContainer.appendChild(canvas_background);\n    this.imgCanvas = imgCanvas;\n    this.rgbCanvas = rgbCanvas;\n    this.maskCanvas = maskCanvas;\n    this.canvasContainer = canvasContainer;\n    this.canvasBackground = canvas_background;\n    let maskCtx = maskCanvas.getContext(\"2d\", { willReadFrequently: true });\n    if (maskCtx) {\n      this.maskCtx = maskCtx;\n    }\n    let rgbCtx = rgbCanvas.getContext(\"2d\", { willReadFrequently: true });\n    if (rgbCtx) {\n      this.rgbCtx = rgbCtx;\n    }\n    let imgCtx = imgCanvas.getContext(\"2d\", { willReadFrequently: true });\n    if (imgCtx) {\n      this.imageCtx = imgCtx;\n    }\n    this.setEventHandler();\n    this.imgCanvas.style.position = \"absolute\";\n    this.rgbCanvas.style.position = \"absolute\";\n    this.maskCanvas.style.position = \"absolute\";\n    this.imgCanvas.style.top = \"200\";\n    this.imgCanvas.style.left = \"0\";\n    this.rgbCanvas.style.top = this.imgCanvas.style.top;\n    this.rgbCanvas.style.left = this.imgCanvas.style.left;\n    this.maskCanvas.style.top = this.imgCanvas.style.top;\n    this.maskCanvas.style.left = this.imgCanvas.style.left;\n    const maskCanvasStyle = this.getMaskCanvasStyle();\n    this.maskCanvas.style.mixBlendMode = maskCanvasStyle.mixBlendMode;\n    this.maskCanvas.style.opacity = maskCanvasStyle.opacity.toString();\n    return canvasContainer;\n  }\n  async setBrushBorderRadius() {\n    const brushSettings = await this.messageBroker.pull(\"brushSettings\");\n    if (brushSettings.type === \"rect\") {\n      this.brush.style.borderRadius = \"0%\";\n      this.brush.style.MozBorderRadius = \"0%\";\n      this.brush.style.WebkitBorderRadius = \"0%\";\n    } else {\n      this.brush.style.borderRadius = \"50%\";\n      this.brush.style.MozBorderRadius = \"50%\";\n      this.brush.style.WebkitBorderRadius = \"50%\";\n    }\n  }\n  async initUI() {\n    this.saveButton.innerText = t(\"g.save\");\n    this.saveButton.disabled = false;\n    await this.setImages(this.imgCanvas);\n  }\n  async createSidePanel() {\n    const sidePanelWrapper = this.createContainer(true);\n    const side_panel = document.createElement(\"div\");\n    sidePanelWrapper.id = \"maskEditor_sidePanel\";\n    side_panel.id = \"maskEditor_sidePanelContent\";\n    const brush_settings = await this.createBrushSettings();\n    brush_settings.id = \"maskEditor_brushSettings\";\n    this.brushSettingsHTML = brush_settings;\n    const paint_bucket_settings = await this.createPaintBucketSettings();\n    paint_bucket_settings.id = \"maskEditor_paintBucketSettings\";\n    this.paintBucketSettingsHTML = paint_bucket_settings;\n    const color_select_settings = await this.createColorSelectSettings();\n    color_select_settings.id = \"maskEditor_colorSelectSettings\";\n    this.colorSelectSettingsHTML = color_select_settings;\n    const image_layer_settings = await this.createImageLayerSettings();\n    const separator = this.createSeparator();\n    side_panel.appendChild(brush_settings);\n    side_panel.appendChild(paint_bucket_settings);\n    side_panel.appendChild(color_select_settings);\n    side_panel.appendChild(separator);\n    side_panel.appendChild(image_layer_settings);\n    sidePanelWrapper.appendChild(side_panel);\n    return sidePanelWrapper;\n  }\n  async createBrushSettings() {\n    const shapeColor = this.darkMode ? \"maskEditor_brushShape_dark\" : \"maskEditor_brushShape_light\";\n    const brush_settings_container = this.createContainer(true);\n    const brush_settings_title = this.createHeadline(\n      t(\"maskEditor.Brush Settings\")\n    );\n    const brush_shape_outer_container = this.createContainer(true);\n    const brush_shape_title = this.createContainerTitle(\n      t(\"maskEditor.Brush Shape\")\n    );\n    const brush_shape_container = this.createContainer(false);\n    const accentColor = this.darkMode ? \"maskEditor_accent_bg_dark\" : \"maskEditor_accent_bg_light\";\n    brush_shape_container.classList.add(accentColor);\n    brush_shape_container.classList.add(\"maskEditor_layerRow\");\n    const circle_shape = document.createElement(\"div\");\n    circle_shape.id = \"maskEditor_sidePanelBrushShapeCircle\";\n    circle_shape.classList.add(shapeColor);\n    circle_shape.addEventListener(\"click\", () => {\n      this.messageBroker.publish(\n        \"setBrushShape\",\n        \"arc\"\n        /* Arc */\n      );\n      this.setBrushBorderRadius();\n      circle_shape.style.background = \"var(--p-button-text-primary-color)\";\n      square_shape.style.background = \"\";\n    });\n    const square_shape = document.createElement(\"div\");\n    square_shape.id = \"maskEditor_sidePanelBrushShapeSquare\";\n    square_shape.classList.add(shapeColor);\n    square_shape.addEventListener(\"click\", () => {\n      this.messageBroker.publish(\n        \"setBrushShape\",\n        \"rect\"\n        /* Rect */\n      );\n      this.setBrushBorderRadius();\n      square_shape.style.background = \"var(--p-button-text-primary-color)\";\n      circle_shape.style.background = \"\";\n    });\n    if ((await this.messageBroker.pull(\"brushSettings\")).type === \"arc\") {\n      circle_shape.style.background = \"var(--p-button-text-primary-color)\";\n      square_shape.style.background = \"\";\n    } else {\n      circle_shape.style.background = \"\";\n      square_shape.style.background = \"var(--p-button-text-primary-color)\";\n    }\n    brush_shape_container.appendChild(circle_shape);\n    brush_shape_container.appendChild(square_shape);\n    brush_shape_outer_container.appendChild(brush_shape_title);\n    brush_shape_outer_container.appendChild(brush_shape_container);\n    const thicknesSliderObj = this.createSlider(\n      t(\"maskEditor.Thickness\"),\n      1,\n      100,\n      1,\n      (await this.messageBroker.pull(\"brushSettings\")).size,\n      (_2, value) => {\n        this.messageBroker.publish(\"setBrushSize\", parseInt(value));\n        this.updateBrushPreview();\n      }\n    );\n    this.brushSizeSlider = thicknesSliderObj.slider;\n    const opacitySliderObj = this.createSlider(\n      t(\"maskEditor.Opacity\"),\n      0,\n      1,\n      0.01,\n      (await this.messageBroker.pull(\"brushSettings\")).opacity,\n      (_2, value) => {\n        this.messageBroker.publish(\"setBrushOpacity\", parseFloat(value));\n        this.updateBrushPreview();\n      }\n    );\n    this.brushOpacitySlider = opacitySliderObj.slider;\n    const hardnessSliderObj = this.createSlider(\n      t(\"maskEditor.Hardness\"),\n      0,\n      1,\n      0.01,\n      (await this.messageBroker.pull(\"brushSettings\")).hardness,\n      (_2, value) => {\n        this.messageBroker.publish(\"setBrushHardness\", parseFloat(value));\n        this.updateBrushPreview();\n      }\n    );\n    this.brushHardnessSlider = hardnessSliderObj.slider;\n    const brushSmoothingPrecisionSliderObj = this.createSlider(\n      t(\"maskEditor.Smoothing Precision\"),\n      1,\n      100,\n      1,\n      (await this.messageBroker.pull(\"brushSettings\")).smoothingPrecision,\n      (_2, value) => {\n        this.messageBroker.publish(\n          \"setBrushSmoothingPrecision\",\n          parseInt(value)\n        );\n      }\n    );\n    const resetBrushSettingsButton = document.createElement(\"button\");\n    resetBrushSettingsButton.id = \"resetBrushSettingsButton\";\n    resetBrushSettingsButton.innerText = t(\"maskEditor.Reset to Default\");\n    resetBrushSettingsButton.addEventListener(\"click\", () => {\n      this.messageBroker.publish(\n        \"setBrushShape\",\n        \"arc\"\n        /* Arc */\n      );\n      this.messageBroker.publish(\"setBrushSize\", 20);\n      this.messageBroker.publish(\"setBrushOpacity\", 1);\n      this.messageBroker.publish(\"setBrushHardness\", 1);\n      this.messageBroker.publish(\"setBrushSmoothingPrecision\", 60);\n      circle_shape.style.background = \"var(--p-button-text-primary-color)\";\n      square_shape.style.background = \"\";\n      thicknesSliderObj.slider.value = \"20\";\n      opacitySliderObj.slider.value = \"1\";\n      hardnessSliderObj.slider.value = \"1\";\n      brushSmoothingPrecisionSliderObj.slider.value = \"60\";\n      this.setBrushBorderRadius();\n      this.updateBrushPreview();\n    });\n    brush_settings_container.appendChild(brush_settings_title);\n    brush_settings_container.appendChild(resetBrushSettingsButton);\n    brush_settings_container.appendChild(brush_shape_outer_container);\n    const color_picker_container = this.createContainer(true);\n    const colorPickerTitle = document.createElement(\"span\");\n    colorPickerTitle.innerText = \"Color Selector\";\n    colorPickerTitle.classList.add(\"maskEditor_sidePanelSubTitle\");\n    color_picker_container.appendChild(colorPickerTitle);\n    const colorPicker = this.createColorPicker();\n    color_picker_container.appendChild(colorPicker);\n    brush_settings_container.appendChild(color_picker_container);\n    brush_settings_container.appendChild(thicknesSliderObj.container);\n    brush_settings_container.appendChild(opacitySliderObj.container);\n    brush_settings_container.appendChild(hardnessSliderObj.container);\n    brush_settings_container.appendChild(\n      brushSmoothingPrecisionSliderObj.container\n    );\n    return brush_settings_container;\n  }\n  async createPaintBucketSettings() {\n    const paint_bucket_settings_container = this.createContainer(true);\n    const paint_bucket_settings_title = this.createHeadline(\n      t(\"maskEditor.Paint Bucket Settings\")\n    );\n    const tolerance = await this.messageBroker.pull(\"getTolerance\");\n    const paintBucketToleranceSliderObj = this.createSlider(\n      t(\"maskEditor.Tolerance\"),\n      0,\n      255,\n      1,\n      tolerance,\n      (_2, value) => {\n        this.messageBroker.publish(\"setPaintBucketTolerance\", parseInt(value));\n      }\n    );\n    const fillOpacity = await this.messageBroker.pull(\"getFillOpacity\") || 100;\n    const fillOpacitySliderObj = this.createSlider(\n      t(\"maskEditor.Fill Opacity\"),\n      0,\n      100,\n      1,\n      fillOpacity,\n      (_2, value) => {\n        this.messageBroker.publish(\"setFillOpacity\", parseInt(value));\n      }\n    );\n    paint_bucket_settings_container.appendChild(paint_bucket_settings_title);\n    paint_bucket_settings_container.appendChild(\n      paintBucketToleranceSliderObj.container\n    );\n    paint_bucket_settings_container.appendChild(fillOpacitySliderObj.container);\n    return paint_bucket_settings_container;\n  }\n  async createColorSelectSettings() {\n    const color_select_settings_container = this.createContainer(true);\n    const color_select_settings_title = this.createHeadline(\n      t(\"maskEditor.Color Select Settings\")\n    );\n    var tolerance = await this.messageBroker.pull(\"getTolerance\");\n    const colorSelectToleranceSliderObj = this.createSlider(\n      t(\"maskEditor.Tolerance\"),\n      0,\n      255,\n      1,\n      tolerance,\n      (_2, value) => {\n        this.messageBroker.publish(\"setColorSelectTolerance\", parseInt(value));\n      }\n    );\n    const selectionOpacitySliderObj = this.createSlider(\n      t(\"maskEditor.Selection Opacity\"),\n      0,\n      100,\n      1,\n      100,\n      // Default to 100%\n      (_2, value) => {\n        this.messageBroker.publish(\"setSelectionOpacity\", parseInt(value));\n      }\n    );\n    const livePreviewToggle = this.createToggle(\n      t(\"maskEditor.Live Preview\"),\n      (_2, value) => {\n        this.messageBroker.publish(\"setLivePreview\", value);\n      }\n    );\n    const wholeImageToggle = this.createToggle(\n      t(\"maskEditor.Apply to Whole Image\"),\n      (_2, value) => {\n        this.messageBroker.publish(\"setWholeImage\", value);\n      }\n    );\n    const methodOptions = Object.values(ColorComparisonMethod);\n    const methodSelect = this.createDropdown(\n      t(\"maskEditor.Method\"),\n      methodOptions,\n      (_2, value) => {\n        this.messageBroker.publish(\"setColorComparisonMethod\", value);\n      }\n    );\n    const maskBoundaryToggle = this.createToggle(\n      t(\"maskEditor.Stop at mask\"),\n      (_2, value) => {\n        this.messageBroker.publish(\"setMaskBoundary\", value);\n      }\n    );\n    const maskToleranceSliderObj = this.createSlider(\n      t(\"maskEditor.Mask Tolerance\"),\n      0,\n      255,\n      1,\n      0,\n      (_2, value) => {\n        this.messageBroker.publish(\"setMaskTolerance\", parseInt(value));\n      }\n    );\n    color_select_settings_container.appendChild(color_select_settings_title);\n    color_select_settings_container.appendChild(\n      colorSelectToleranceSliderObj.container\n    );\n    color_select_settings_container.appendChild(\n      selectionOpacitySliderObj.container\n    );\n    color_select_settings_container.appendChild(livePreviewToggle);\n    color_select_settings_container.appendChild(wholeImageToggle);\n    color_select_settings_container.appendChild(methodSelect);\n    color_select_settings_container.appendChild(maskBoundaryToggle);\n    color_select_settings_container.appendChild(\n      maskToleranceSliderObj.container\n    );\n    return color_select_settings_container;\n  }\n  updateButtonsVisibility() {\n    allImageLayers.forEach((layer) => {\n      const button = this.layerButtons[layer];\n      if (layer === this.activeLayer) {\n        button.style.opacity = \"0.5\";\n        button.disabled = true;\n      } else {\n        button.style.opacity = \"1\";\n        button.disabled = false;\n      }\n    });\n  }\n  async updateLayerButtonsForTool() {\n    const currentTool = await this.messageBroker.pull(\"currentTool\");\n    const isEraserTool = currentTool === \"eraser\";\n    Object.values(this.layerButtons).forEach((button) => {\n      if (isEraserTool) {\n        button.style.display = \"block\";\n      } else {\n        button.style.display = \"none\";\n      }\n    });\n  }\n  async setActiveLayer(layer) {\n    this.messageBroker.publish(\"setActiveLayer\", layer);\n    this.activeLayer = layer;\n    this.updateButtonsVisibility();\n    const currentTool = await this.messageBroker.pull(\"currentTool\");\n    const maskOnlyTools = [\n      \"pen\",\n      \"paintBucket\",\n      \"colorSelect\"\n      /* MaskColorFill */\n    ];\n    if (maskOnlyTools.includes(currentTool) && layer === \"rgb\") {\n      this.setToolTo(\n        \"rgbPaint\"\n        /* PaintPen */\n      );\n    }\n    if (currentTool === \"rgbPaint\" && layer === \"mask\") {\n      this.setToolTo(\n        \"pen\"\n        /* MaskPen */\n      );\n    }\n    this.updateActiveLayerHighlight();\n  }\n  updateActiveLayerHighlight() {\n    if (this.maskLayerContainer) {\n      this.maskLayerContainer.style.border = \"none\";\n    }\n    if (this.paintLayerContainer) {\n      this.paintLayerContainer.style.border = \"none\";\n    }\n    if (this.activeLayer === \"mask\" && this.maskLayerContainer) {\n      this.maskLayerContainer.style.border = \"2px solid #007acc\";\n    } else if (this.activeLayer === \"rgb\" && this.paintLayerContainer) {\n      this.paintLayerContainer.style.border = \"2px solid #007acc\";\n    }\n  }\n  async createImageLayerSettings() {\n    var _a2, _b2, _c, _d;\n    const accentColor = this.darkMode ? \"maskEditor_accent_bg_dark\" : \"maskEditor_accent_bg_light\";\n    const image_layer_settings_container = this.createContainer(true);\n    const image_layer_settings_title = this.createHeadline(\n      t(\"maskEditor.Layers\")\n    );\n    const layer_selection_container = this.createContainer(false);\n    layer_selection_container.classList.add(accentColor);\n    layer_selection_container.classList.add(\"maskEditor_layerRow\");\n    this.layerButtons.mask.innerText = \"Activate Layer\";\n    this.layerButtons.mask.addEventListener(\"click\", async () => {\n      this.setActiveLayer(\"mask\");\n    });\n    this.layerButtons.rgb.innerText = \"Activate Layer\";\n    this.layerButtons.rgb.addEventListener(\"click\", async () => {\n      this.setActiveLayer(\"rgb\");\n    });\n    this.layerButtons.mask.style.display = \"none\";\n    this.layerButtons.rgb.style.display = \"none\";\n    this.setActiveLayer(\"mask\");\n    const mask_layer_title = this.createContainerTitle(\"Mask Layer\");\n    const mask_layer_container = this.createContainer(false);\n    mask_layer_container.classList.add(accentColor);\n    mask_layer_container.classList.add(\"maskEditor_layerRow\");\n    const mask_layer_visibility_checkbox = document.createElement(\"input\");\n    mask_layer_visibility_checkbox.setAttribute(\"type\", \"checkbox\");\n    mask_layer_visibility_checkbox.checked = true;\n    mask_layer_visibility_checkbox.classList.add(\n      \"maskEditor_sidePanelLayerCheckbox\"\n    );\n    mask_layer_visibility_checkbox.addEventListener(\"change\", (event) => {\n      if (!event.target.checked) {\n        this.maskCanvas.style.opacity = \"0\";\n      } else {\n        this.maskCanvas.style.opacity = String(this.mask_opacity);\n      }\n    });\n    var mask_layer_image_container = document.createElement(\"div\");\n    mask_layer_image_container.classList.add(\n      \"maskEditor_sidePanelLayerPreviewContainer\"\n    );\n    mask_layer_image_container.innerHTML = '<svg viewBox=\"0 0 20 20\" style=\"\">   <path class=\"cls-1\" d=\"M1.31,5.32v9.36c0,.55.45,1,1,1h15.38c.55,0,1-.45,1-1V5.32c0-.55-.45-1-1-1H2.31c-.55,0-1,.45-1,1ZM11.19,13.44c-2.91.94-5.57-1.72-4.63-4.63.34-1.05,1.19-1.9,2.24-2.24,2.91-.94,5.57,1.72,4.63,4.63-.34,1.05-1.19-1.9-2.24,2.24Z\"/> </svg>';\n    mask_layer_container.appendChild(mask_layer_visibility_checkbox);\n    mask_layer_container.appendChild(mask_layer_image_container);\n    mask_layer_container.appendChild(this.layerButtons.mask);\n    this.maskLayerContainer = mask_layer_container;\n    const mask_blending_options_title = this.createContainerTitle(\n      \"Mask Blending Options\"\n    );\n    const mask_blending_options_container = this.createContainer(false);\n    mask_blending_options_container.classList.add(\"maskEditor_layerRow\");\n    mask_blending_options_container.style.marginTop = \"-9px\";\n    mask_blending_options_container.style.marginBottom = \"-6px\";\n    var blending_options = [\"black\", \"white\", \"negative\"];\n    const sidePanelDropdownAccent = this.darkMode ? \"maskEditor_sidePanelDropdown_dark\" : \"maskEditor_sidePanelDropdown_light\";\n    var mask_layer_dropdown = document.createElement(\"select\");\n    mask_layer_dropdown.classList.add(sidePanelDropdownAccent);\n    blending_options.forEach((option) => {\n      var option_element = document.createElement(\"option\");\n      option_element.value = option;\n      option_element.innerText = option;\n      mask_layer_dropdown.appendChild(option_element);\n      if (option == this.maskBlendMode) {\n        option_element.selected = true;\n      }\n    });\n    mask_layer_dropdown.addEventListener(\"change\", (event) => {\n      const selectedValue = event.target.value;\n      this.maskBlendMode = selectedValue;\n      this.updateMaskColor();\n    });\n    mask_blending_options_container.appendChild(mask_layer_dropdown);\n    const mask_layer_opacity_sliderObj = this.createSlider(\n      t(\"maskEditor.Mask Opacity\"),\n      0,\n      1,\n      0.01,\n      this.mask_opacity,\n      (_2, value) => {\n        this.mask_opacity = parseFloat(value);\n        this.maskCanvas.style.opacity = String(this.mask_opacity);\n        if (this.mask_opacity == 0) {\n          mask_layer_visibility_checkbox.checked = false;\n        } else {\n          mask_layer_visibility_checkbox.checked = true;\n        }\n      }\n    );\n    this.maskOpacitySlider = mask_layer_opacity_sliderObj.slider;\n    const paint_layer_title = this.createContainerTitle(\"Paint Layer\");\n    const paint_layer_container = this.createContainer(false);\n    paint_layer_container.classList.add(accentColor);\n    paint_layer_container.classList.add(\"maskEditor_layerRow\");\n    const paint_layer_checkbox = document.createElement(\"input\");\n    paint_layer_checkbox.setAttribute(\"type\", \"checkbox\");\n    paint_layer_checkbox.classList.add(\"maskEditor_sidePanelLayerCheckbox\");\n    paint_layer_checkbox.checked = true;\n    paint_layer_checkbox.addEventListener(\"change\", (event) => {\n      if (!event.target.checked) {\n        this.rgbCanvas.style.opacity = \"0\";\n      } else {\n        this.rgbCanvas.style.opacity = \"1\";\n      }\n    });\n    const paint_layer_image_container = document.createElement(\"div\");\n    paint_layer_image_container.classList.add(\n      \"maskEditor_sidePanelLayerPreviewContainer\"\n    );\n    paint_layer_image_container.innerHTML = `\n      <svg viewBox=\"0 0 20 20\">\n        <path class=\"cls-1\" d=\"M 17 6.965 c 0 0.235 -0.095 0.47 -0.275 0.655 l -6.51 6.52 c -0.045 0.035 -0.09 0.075 -0.135 0.11 c -0.035 -0.695 -0.605 -1.24 -1.305 -1.245 c 0.035 -0.06 0.08 -0.12 0.135 -0.17 l 6.52 -6.52 c 0.36 -0.36 0.945 -0.36 1.3 0 c 0.175 0.175 0.275 0.415 0.275 0.65 Z\"/>\n        <path class=\"cls-1\" d=\"M 9.82 14.515 c 0 2.23 -3.23 1.59 -4.82 0 c 1.65 -0.235 2.375 -1.29 3.53 -1.29 c 0.715 0 1.29 0.58 1.29 1.29 Z\"/>\n      </svg>\n    `;\n    paint_layer_container.appendChild(paint_layer_checkbox);\n    paint_layer_container.appendChild(paint_layer_image_container);\n    paint_layer_container.appendChild(this.layerButtons.rgb);\n    this.paintLayerContainer = paint_layer_container;\n    const base_image_layer_title = this.createContainerTitle(\"Base Image Layer\");\n    const base_image_layer_container = this.createContainer(false);\n    base_image_layer_container.classList.add(accentColor);\n    base_image_layer_container.classList.add(\"maskEditor_layerRow\");\n    const base_image_layer_visibility_checkbox = document.createElement(\"input\");\n    base_image_layer_visibility_checkbox.setAttribute(\"type\", \"checkbox\");\n    base_image_layer_visibility_checkbox.classList.add(\n      \"maskEditor_sidePanelLayerCheckbox\"\n    );\n    base_image_layer_visibility_checkbox.checked = true;\n    base_image_layer_visibility_checkbox.addEventListener(\"change\", (event) => {\n      if (!event.target.checked) {\n        this.imgCanvas.style.opacity = \"0\";\n      } else {\n        this.imgCanvas.style.opacity = \"1\";\n      }\n    });\n    const base_image_layer_image_container = document.createElement(\"div\");\n    base_image_layer_image_container.classList.add(\n      \"maskEditor_sidePanelLayerPreviewContainer\"\n    );\n    const base_image_layer_image = document.createElement(\"img\");\n    base_image_layer_image.id = \"maskEditor_sidePanelImageLayerImage\";\n    base_image_layer_image.src = ((_d = (_c = (_a2 = ComfyApp.clipspace) == null ? void 0 : _a2.imgs) == null ? void 0 : _c[((_b2 = ComfyApp.clipspace) == null ? void 0 : _b2.selectedIndex) ?? 0]) == null ? void 0 : _d.src) ?? \"\";\n    this.sidebarImage = base_image_layer_image;\n    base_image_layer_image_container.appendChild(base_image_layer_image);\n    base_image_layer_container.appendChild(base_image_layer_visibility_checkbox);\n    base_image_layer_container.appendChild(base_image_layer_image_container);\n    image_layer_settings_container.appendChild(image_layer_settings_title);\n    image_layer_settings_container.appendChild(\n      mask_layer_opacity_sliderObj.container\n    );\n    image_layer_settings_container.appendChild(mask_blending_options_title);\n    image_layer_settings_container.appendChild(mask_blending_options_container);\n    image_layer_settings_container.appendChild(mask_layer_title);\n    image_layer_settings_container.appendChild(mask_layer_container);\n    image_layer_settings_container.appendChild(paint_layer_title);\n    image_layer_settings_container.appendChild(paint_layer_container);\n    image_layer_settings_container.appendChild(base_image_layer_title);\n    image_layer_settings_container.appendChild(base_image_layer_container);\n    this.updateActiveLayerHighlight();\n    this.updateLayerButtonsForTool();\n    return image_layer_settings_container;\n  }\n  // Method to be called when tool changes\n  async onToolChange() {\n    await this.updateLayerButtonsForTool();\n  }\n  createHeadline(title) {\n    var headline = document.createElement(\"h3\");\n    headline.classList.add(\"maskEditor_sidePanelTitle\");\n    headline.innerText = title;\n    return headline;\n  }\n  createContainer(flexDirection) {\n    var container = document.createElement(\"div\");\n    if (flexDirection) {\n      container.classList.add(\"maskEditor_sidePanelContainerColumn\");\n    } else {\n      container.classList.add(\"maskEditor_sidePanelContainerRow\");\n    }\n    return container;\n  }\n  createContainerTitle(title) {\n    var container_title = document.createElement(\"span\");\n    container_title.classList.add(\"maskEditor_sidePanelSubTitle\");\n    container_title.innerText = title;\n    return container_title;\n  }\n  createSlider(title, min, max2, step, value, callback) {\n    var slider_container = this.createContainer(true);\n    var slider_title = this.createContainerTitle(title);\n    var slider = document.createElement(\"input\");\n    slider.classList.add(\"maskEditor_sidePanelBrushRange\");\n    slider.setAttribute(\"type\", \"range\");\n    slider.setAttribute(\"min\", String(min));\n    slider.setAttribute(\"max\", String(max2));\n    slider.setAttribute(\"step\", String(step));\n    slider.setAttribute(\"value\", String(value));\n    slider.addEventListener(\"input\", (event) => {\n      callback(event, event.target.value);\n    });\n    slider_container.appendChild(slider_title);\n    slider_container.appendChild(slider);\n    return { container: slider_container, slider };\n  }\n  createToggle(title, callback) {\n    var outer_Container = this.createContainer(false);\n    var toggle_title = this.createContainerTitle(title);\n    var toggle_container = document.createElement(\"label\");\n    toggle_container.classList.add(\"maskEditor_sidePanelToggleContainer\");\n    var toggle_checkbox = document.createElement(\"input\");\n    toggle_checkbox.setAttribute(\"type\", \"checkbox\");\n    toggle_checkbox.classList.add(\"maskEditor_sidePanelToggleCheckbox\");\n    toggle_checkbox.addEventListener(\"change\", (event) => {\n      callback(event, event.target.checked);\n    });\n    var toggleAccentColor = this.darkMode ? \"maskEditor_toggle_bg_dark\" : \"maskEditor_toggle_bg_light\";\n    var toggle_switch = document.createElement(\"div\");\n    toggle_switch.classList.add(\"maskEditor_sidePanelToggleSwitch\");\n    toggle_switch.classList.add(toggleAccentColor);\n    toggle_container.appendChild(toggle_checkbox);\n    toggle_container.appendChild(toggle_switch);\n    outer_Container.appendChild(toggle_title);\n    outer_Container.appendChild(toggle_container);\n    return outer_Container;\n  }\n  createDropdown(title, options, callback) {\n    const sidePanelDropdownAccent = this.darkMode ? \"maskEditor_sidePanelDropdown_dark\" : \"maskEditor_sidePanelDropdown_light\";\n    var dropdown_container = this.createContainer(false);\n    var dropdown_title = this.createContainerTitle(title);\n    var dropdown = document.createElement(\"select\");\n    dropdown.classList.add(sidePanelDropdownAccent);\n    dropdown.classList.add(\"maskEditor_containerDropdown\");\n    options.forEach((option) => {\n      var option_element = document.createElement(\"option\");\n      option_element.value = option;\n      option_element.innerText = option;\n      dropdown.appendChild(option_element);\n    });\n    dropdown.addEventListener(\"change\", (event) => {\n      callback(event, event.target.value);\n    });\n    dropdown_container.appendChild(dropdown_title);\n    dropdown_container.appendChild(dropdown);\n    return dropdown_container;\n  }\n  createSeparator() {\n    var separator = document.createElement(\"div\");\n    separator.classList.add(\"maskEditor_sidePanelSeparator\");\n    return separator;\n  }\n  //----------------\n  async createTopBar() {\n    const buttonAccentColor = this.darkMode ? \"maskEditor_topPanelButton_dark\" : \"maskEditor_topPanelButton_light\";\n    const iconButtonAccentColor = this.darkMode ? \"maskEditor_topPanelIconButton_dark\" : \"maskEditor_topPanelIconButton_light\";\n    var top_bar = document.createElement(\"div\");\n    top_bar.id = \"maskEditor_topBar\";\n    var top_bar_title_container = document.createElement(\"div\");\n    top_bar_title_container.id = \"maskEditor_topBarTitleContainer\";\n    var top_bar_title = document.createElement(\"h1\");\n    top_bar_title.id = \"maskEditor_topBarTitle\";\n    top_bar_title.innerText = \"ComfyUI\";\n    top_bar_title_container.appendChild(top_bar_title);\n    var top_bar_shortcuts_container = document.createElement(\"div\");\n    top_bar_shortcuts_container.id = \"maskEditor_topBarShortcutsContainer\";\n    var top_bar_undo_button = document.createElement(\"div\");\n    top_bar_undo_button.id = \"maskEditor_topBarUndoButton\";\n    top_bar_undo_button.classList.add(iconButtonAccentColor);\n    top_bar_undo_button.innerHTML = '<svg viewBox=\"0 0 15 15\"><path d=\"M8.77,12.18c-.25,0-.46-.2-.46-.46s.2-.46.46-.46c1.47,0,2.67-1.2,2.67-2.67,0-1.57-1.34-2.67-3.26-2.67h-3.98l1.43,1.43c.18.18.18.47,0,.64-.18.18-.47.18-.64,0l-2.21-2.21c-.18-.18-.18-.47,0-.64l2.21-2.21c.18-.18.47-.18.64,0,.18.18.18.47,0,.64l-1.43,1.43h3.98c2.45,0,4.17,1.47,4.17,3.58,0,1.97-1.61,3.58-3.58,3.58Z\"></path> </svg>';\n    top_bar_undo_button.addEventListener(\"click\", () => {\n      this.messageBroker.publish(\"undo\");\n    });\n    var top_bar_redo_button = document.createElement(\"div\");\n    top_bar_redo_button.id = \"maskEditor_topBarRedoButton\";\n    top_bar_redo_button.classList.add(iconButtonAccentColor);\n    top_bar_redo_button.innerHTML = '<svg viewBox=\"0 0 15 15\"> <path class=\"cls-1\" d=\"M6.23,12.18c-1.97,0-3.58-1.61-3.58-3.58,0-2.11,1.71-3.58,4.17-3.58h3.98l-1.43-1.43c-.18-.18-.18-.47,0-.64.18-.18.46-.18.64,0l2.21,2.21c.09.09.13.2.13.32s-.05.24-.13.32l-2.21,2.21c-.18.18-.47.18-.64,0-.18-.18-.18-.47,0-.64l1.43-1.43h-3.98c-1.92,0-3.26,1.1-3.26,2.67,0,1.47,1.2,2.67,2.67,2.67.25,0,.46.2.46.46s-.2.46-.46.46Z\"/></svg>';\n    top_bar_redo_button.addEventListener(\"click\", () => {\n      this.messageBroker.publish(\"redo\");\n    });\n    var top_bar_invert_button = document.createElement(\"button\");\n    top_bar_invert_button.id = \"maskEditor_topBarInvertButton\";\n    top_bar_invert_button.classList.add(buttonAccentColor);\n    top_bar_invert_button.innerText = t(\"maskEditor.Invert\");\n    top_bar_invert_button.addEventListener(\"click\", () => {\n      this.messageBroker.publish(\"invert\");\n    });\n    var top_bar_clear_button = document.createElement(\"button\");\n    top_bar_clear_button.id = \"maskEditor_topBarClearButton\";\n    top_bar_clear_button.classList.add(buttonAccentColor);\n    top_bar_clear_button.innerText = t(\"maskEditor.Clear\");\n    top_bar_clear_button.addEventListener(\"click\", () => {\n      this.maskCtx.clearRect(\n        0,\n        0,\n        this.maskCanvas.width,\n        this.maskCanvas.height\n      );\n      this.rgbCtx.clearRect(0, 0, this.rgbCanvas.width, this.rgbCanvas.height);\n      this.messageBroker.publish(\"saveState\");\n    });\n    var top_bar_save_button = document.createElement(\"button\");\n    top_bar_save_button.id = \"maskEditor_topBarSaveButton\";\n    top_bar_save_button.classList.add(buttonAccentColor);\n    top_bar_save_button.innerText = t(\"g.save\");\n    this.saveButton = top_bar_save_button;\n    top_bar_save_button.addEventListener(\"click\", () => {\n      this.maskEditor.save();\n    });\n    var top_bar_cancel_button = document.createElement(\"button\");\n    top_bar_cancel_button.id = \"maskEditor_topBarCancelButton\";\n    top_bar_cancel_button.classList.add(buttonAccentColor);\n    top_bar_cancel_button.innerText = t(\"g.cancel\");\n    top_bar_cancel_button.addEventListener(\"click\", () => {\n      this.maskEditor.destroy();\n    });\n    top_bar_shortcuts_container.appendChild(top_bar_undo_button);\n    top_bar_shortcuts_container.appendChild(top_bar_redo_button);\n    top_bar_shortcuts_container.appendChild(top_bar_invert_button);\n    top_bar_shortcuts_container.appendChild(top_bar_clear_button);\n    top_bar_shortcuts_container.appendChild(top_bar_save_button);\n    top_bar_shortcuts_container.appendChild(top_bar_cancel_button);\n    top_bar.appendChild(top_bar_title_container);\n    top_bar.appendChild(top_bar_shortcuts_container);\n    return top_bar;\n  }\n  setToolTo(tool) {\n    this.messageBroker.publish(\"setTool\", tool);\n    for (let toolElement of this.toolElements) {\n      if (toolElement != this.toolSettings[tool].container) {\n        toolElement.classList.remove(\"maskEditor_toolPanelContainerSelected\");\n      } else {\n        toolElement.classList.add(\"maskEditor_toolPanelContainerSelected\");\n        this.brushSettingsHTML.style.display = \"flex\";\n        this.colorSelectSettingsHTML.style.display = \"none\";\n        this.paintBucketSettingsHTML.style.display = \"none\";\n      }\n    }\n    this.messageBroker.publish(\"setTool\", tool);\n    this.onToolChange();\n    const newActiveLayer = this.toolSettings[tool].newActiveLayerOnSet;\n    if (newActiveLayer) {\n      this.setActiveLayer(newActiveLayer);\n    }\n    const cursor = this.toolSettings[tool].cursor;\n    this.pointerZone.style.cursor = cursor ?? \"none\";\n    if (cursor) {\n      this.brush.style.opacity = \"0\";\n    }\n  }\n  createToolPanel() {\n    var tool_panel = document.createElement(\"div\");\n    tool_panel.id = \"maskEditor_toolPanel\";\n    this.toolPanel = tool_panel;\n    var toolPanelHoverAccent = this.darkMode ? \"maskEditor_toolPanelContainerDark\" : \"maskEditor_toolPanelContainerLight\";\n    this.toolElements = [];\n    const setupToolContainer = (tool) => {\n      this.toolSettings[tool].container = document.createElement(\"div\");\n      this.toolSettings[tool].container.classList.add(\n        \"maskEditor_toolPanelContainer\"\n      );\n      if (tool == \"pen\")\n        this.toolSettings[tool].container.classList.add(\n          \"maskEditor_toolPanelContainerSelected\"\n        );\n      this.toolSettings[tool].container.classList.add(toolPanelHoverAccent);\n      this.toolSettings[tool].container.innerHTML = iconsHtml[tool];\n      this.toolElements.push(this.toolSettings[tool].container);\n      this.toolSettings[tool].container.addEventListener(\"click\", () => {\n        this.setToolTo(tool);\n      });\n      const activeIndicator = document.createElement(\"div\");\n      activeIndicator.classList.add(\"maskEditor_toolPanelIndicator\");\n      this.toolSettings[tool].container.appendChild(activeIndicator);\n      tool_panel.appendChild(this.toolSettings[tool].container);\n    };\n    allTools.forEach(setupToolContainer);\n    const setupZoomIndicatorContainer = () => {\n      var toolPanel_zoomIndicator = document.createElement(\"div\");\n      toolPanel_zoomIndicator.classList.add(\"maskEditor_toolPanelZoomIndicator\");\n      toolPanel_zoomIndicator.classList.add(toolPanelHoverAccent);\n      var toolPanel_zoomText = document.createElement(\"span\");\n      toolPanel_zoomText.id = \"maskEditor_toolPanelZoomText\";\n      toolPanel_zoomText.innerText = \"100%\";\n      this.zoomTextHTML = toolPanel_zoomText;\n      var toolPanel_DimensionsText = document.createElement(\"span\");\n      toolPanel_DimensionsText.id = \"maskEditor_toolPanelDimensionsText\";\n      toolPanel_DimensionsText.innerText = \" \";\n      this.dimensionsTextHTML = toolPanel_DimensionsText;\n      toolPanel_zoomIndicator.appendChild(toolPanel_zoomText);\n      toolPanel_zoomIndicator.appendChild(toolPanel_DimensionsText);\n      toolPanel_zoomIndicator.addEventListener(\"click\", () => {\n        this.messageBroker.publish(\"resetZoom\");\n      });\n      tool_panel.appendChild(toolPanel_zoomIndicator);\n    };\n    setupZoomIndicatorContainer();\n    return tool_panel;\n  }\n  createPointerZone() {\n    const pointer_zone = document.createElement(\"div\");\n    pointer_zone.id = \"maskEditor_pointerZone\";\n    this.pointerZone = pointer_zone;\n    pointer_zone.addEventListener(\"pointerdown\", (event) => {\n      this.messageBroker.publish(\"pointerDown\", event);\n    });\n    pointer_zone.addEventListener(\"pointermove\", (event) => {\n      this.messageBroker.publish(\"pointerMove\", event);\n    });\n    pointer_zone.addEventListener(\"pointerup\", (event) => {\n      this.messageBroker.publish(\"pointerUp\", event);\n    });\n    pointer_zone.addEventListener(\"pointerleave\", () => {\n      this.brush.style.opacity = \"0\";\n      this.pointerZone.style.cursor = \"\";\n    });\n    pointer_zone.addEventListener(\"touchstart\", (event) => {\n      this.messageBroker.publish(\"handleTouchStart\", event);\n    });\n    pointer_zone.addEventListener(\"touchmove\", (event) => {\n      this.messageBroker.publish(\"handleTouchMove\", event);\n    });\n    pointer_zone.addEventListener(\"touchend\", (event) => {\n      this.messageBroker.publish(\"handleTouchEnd\", event);\n    });\n    pointer_zone.addEventListener(\n      \"wheel\",\n      (event) => this.messageBroker.publish(\"wheel\", event)\n    );\n    pointer_zone.addEventListener(\"pointerenter\", async () => {\n      this.updateCursor();\n    });\n    return pointer_zone;\n  }\n  async screenToCanvas(clientPoint) {\n    const zoomRatio = await this.messageBroker.pull(\"zoomRatio\");\n    const maskCanvasRect = this.maskCanvas.getBoundingClientRect();\n    const rgbCanvasRect = this.rgbCanvas.getBoundingClientRect();\n    const currentTool = await this.messageBroker.pull(\"currentTool\");\n    const isUsingRGBCanvas = currentTool === \"rgbPaint\";\n    const canvasRect = isUsingRGBCanvas ? rgbCanvasRect : maskCanvasRect;\n    const offsetX = clientPoint.x - canvasRect.left + this.toolPanel.clientWidth;\n    const offsetY = clientPoint.y - canvasRect.top + 44;\n    const x = offsetX / zoomRatio;\n    const y = offsetY / zoomRatio;\n    return { x, y };\n  }\n  setEventHandler() {\n    this.maskCanvas.addEventListener(\"contextmenu\", (event) => {\n      event.preventDefault();\n    });\n    this.rgbCanvas.addEventListener(\"contextmenu\", (event) => {\n      event.preventDefault();\n    });\n    this.rootElement.addEventListener(\"contextmenu\", (event) => {\n      event.preventDefault();\n    });\n    this.rootElement.addEventListener(\"dragstart\", (event) => {\n      if (event.ctrlKey) {\n        event.preventDefault();\n      }\n    });\n  }\n  async createBrush() {\n    var brush = document.createElement(\"div\");\n    await this.messageBroker.pull(\"brushSettings\");\n    brush.id = \"maskEditor_brush\";\n    var brush_preview_gradient = document.createElement(\"div\");\n    brush_preview_gradient.id = \"maskEditor_brushPreviewGradient\";\n    brush.appendChild(brush_preview_gradient);\n    this.brush = brush;\n    this.brushPreviewGradient = brush_preview_gradient;\n    return brush;\n  }\n  async setImages(imgCanvas) {\n    var _a2, _b2, _c, _d, _e, _f, _g;\n    const imgCtx = imgCanvas.getContext(\"2d\", { willReadFrequently: true });\n    const maskCtx = this.maskCtx;\n    const maskCanvas = this.maskCanvas;\n    const rgbCanvas = this.rgbCanvas;\n    imgCtx.clearRect(0, 0, this.imgCanvas.width, this.imgCanvas.height);\n    maskCtx.clearRect(0, 0, this.maskCanvas.width, this.maskCanvas.height);\n    const mainImageUrl = (_d = (_c = (_a2 = ComfyApp.clipspace) == null ? void 0 : _a2.imgs) == null ? void 0 : _c[((_b2 = ComfyApp.clipspace) == null ? void 0 : _b2.selectedIndex) ?? 0]) == null ? void 0 : _d.src;\n    if (!mainImageUrl) {\n      throw new Error(\n        \"Unable to access image source - clipspace or image is null\"\n      );\n    }\n    const mainImageFilename = new URL(mainImageUrl).searchParams.get(\"filename\") ?? void 0;\n    let combinedImageFilename;\n    if (((_e = ComfyApp.clipspace) == null ? void 0 : _e.combinedIndex) !== void 0 && ((_f = ComfyApp.clipspace) == null ? void 0 : _f.imgs) && ComfyApp.clipspace.combinedIndex < ComfyApp.clipspace.imgs.length && ((_g = ComfyApp.clipspace.imgs[ComfyApp.clipspace.combinedIndex]) == null ? void 0 : _g.src)) {\n      combinedImageFilename = new URL(\n        ComfyApp.clipspace.imgs[ComfyApp.clipspace.combinedIndex].src\n      ).searchParams.get(\"filename\");\n    } else {\n      combinedImageFilename = void 0;\n    }\n    const imageLayerFilenames = mainImageFilename !== void 0 ? imageLayerFilenamesIfApplicable(\n      combinedImageFilename ?? mainImageFilename\n    ) : void 0;\n    const inputUrls = {\n      baseImagePlusMask: (imageLayerFilenames == null ? void 0 : imageLayerFilenames.maskedImage) ? mkFileUrl({ ref: toRef(imageLayerFilenames.maskedImage) }) : mainImageUrl,\n      paintLayer: (imageLayerFilenames == null ? void 0 : imageLayerFilenames.paint) ? mkFileUrl({ ref: toRef(imageLayerFilenames.paint) }) : void 0\n    };\n    const alpha_url = new URL(inputUrls.baseImagePlusMask);\n    alpha_url.searchParams.delete(\"channel\");\n    alpha_url.searchParams.delete(\"preview\");\n    alpha_url.searchParams.set(\"channel\", \"a\");\n    let mask_image = await this.loadImage(alpha_url);\n    const rgb_url = new URL(inputUrls.baseImagePlusMask);\n    this.imageURL = rgb_url;\n    rgb_url.searchParams.delete(\"channel\");\n    rgb_url.searchParams.set(\"channel\", \"rgb\");\n    this.image = new Image();\n    this.image = await new Promise((resolve, reject) => {\n      const img = new Image();\n      img.onload = () => resolve(img);\n      img.onerror = reject;\n      img.src = rgb_url.toString();\n    });\n    if (inputUrls.paintLayer) {\n      const paintURL = new URL(inputUrls.paintLayer);\n      this.paint_image = new Image();\n      this.paint_image = await new Promise(\n        (resolve, reject) => {\n          const img = new Image();\n          img.onload = () => resolve(img);\n          img.onerror = reject;\n          img.src = paintURL.toString();\n        }\n      );\n    }\n    maskCanvas.width = this.image.width;\n    maskCanvas.height = this.image.height;\n    rgbCanvas.width = this.image.width;\n    rgbCanvas.height = this.image.height;\n    this.dimensionsTextHTML.innerText = `${this.image.width}x${this.image.height}`;\n    await this.invalidateCanvas(this.image, mask_image, this.paint_image);\n    this.messageBroker.publish(\"initZoomPan\", [this.image, this.rootElement]);\n  }\n  async invalidateCanvas(orig_image, mask_image, paint_image) {\n    this.imgCanvas.width = orig_image.width;\n    this.imgCanvas.height = orig_image.height;\n    this.maskCanvas.width = orig_image.width;\n    this.maskCanvas.height = orig_image.height;\n    this.rgbCanvas.width = orig_image.width;\n    this.rgbCanvas.height = orig_image.height;\n    let imgCtx = this.imgCanvas.getContext(\"2d\", { willReadFrequently: true });\n    let maskCtx = this.maskCanvas.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    let rgbCtx = this.rgbCanvas.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    imgCtx.drawImage(orig_image, 0, 0, orig_image.width, orig_image.height);\n    if (paint_image) {\n      rgbCtx.drawImage(\n        paint_image,\n        0,\n        0,\n        paint_image.width,\n        paint_image.height\n      );\n    }\n    await this.prepare_mask(\n      mask_image,\n      this.maskCanvas,\n      maskCtx,\n      await this.getMaskColor()\n    );\n  }\n  async prepare_mask(image, maskCanvas, maskCtx, maskColor) {\n    maskCtx.drawImage(image, 0, 0, maskCanvas.width, maskCanvas.height);\n    const maskData = maskCtx.getImageData(\n      0,\n      0,\n      maskCanvas.width,\n      maskCanvas.height\n    );\n    for (let i = 0; i < maskData.data.length; i += 4) {\n      const alpha = maskData.data[i + 3];\n      maskData.data[i] = maskColor.r;\n      maskData.data[i + 1] = maskColor.g;\n      maskData.data[i + 2] = maskColor.b;\n      maskData.data[i + 3] = 255 - alpha;\n    }\n    maskCtx.globalCompositeOperation = \"source-over\";\n    maskCtx.putImageData(maskData, 0, 0);\n  }\n  async updateMaskColor() {\n    const maskCanvasStyle = this.getMaskCanvasStyle();\n    this.maskCanvas.style.mixBlendMode = maskCanvasStyle.mixBlendMode;\n    this.maskCanvas.style.opacity = maskCanvasStyle.opacity.toString();\n    const maskColor = await this.getMaskColor();\n    this.maskCtx.fillStyle = `rgb(${maskColor.r}, ${maskColor.g}, ${maskColor.b})`;\n    this.setCanvasBackground();\n    const maskData = this.maskCtx.getImageData(\n      0,\n      0,\n      this.maskCanvas.width,\n      this.maskCanvas.height\n    );\n    for (let i = 0; i < maskData.data.length; i += 4) {\n      maskData.data[i] = maskColor.r;\n      maskData.data[i + 1] = maskColor.g;\n      maskData.data[i + 2] = maskColor.b;\n    }\n    this.maskCtx.putImageData(maskData, 0, 0);\n  }\n  getMaskCanvasStyle() {\n    if (this.maskBlendMode === \"negative\") {\n      return {\n        mixBlendMode: \"difference\",\n        opacity: \"1\"\n      };\n    } else {\n      return {\n        mixBlendMode: \"initial\",\n        opacity: this.mask_opacity\n      };\n    }\n  }\n  detectLightMode() {\n    this.darkMode = document.body.classList.contains(\"dark-theme\");\n  }\n  loadImage(imagePath) {\n    return new Promise((resolve, reject) => {\n      const image = new Image();\n      image.onload = function() {\n        resolve(image);\n      };\n      image.onerror = function(error) {\n        reject(error);\n      };\n      image.src = imagePath.href;\n    });\n  }\n  async updateBrushPreview() {\n    const cursorPoint = await this.messageBroker.pull(\"cursorPoint\");\n    const pan_offset = await this.messageBroker.pull(\"panOffset\");\n    const brushSettings = await this.messageBroker.pull(\"brushSettings\");\n    const zoom_ratio = await this.messageBroker.pull(\"zoomRatio\");\n    const centerX = cursorPoint.x + pan_offset.x;\n    const centerY = cursorPoint.y + pan_offset.y;\n    const brush = this.brush;\n    const hardness = brushSettings.hardness;\n    const extendedSize = brushSettings.size * (2 - hardness) * 2 * zoom_ratio;\n    this.brushSizeSlider.value = String(brushSettings.size);\n    this.brushHardnessSlider.value = String(hardness);\n    brush.style.width = extendedSize + \"px\";\n    brush.style.height = extendedSize + \"px\";\n    brush.style.left = centerX - extendedSize / 2 + \"px\";\n    brush.style.top = centerY - extendedSize / 2 + \"px\";\n    if (hardness === 1) {\n      this.brushPreviewGradient.style.background = \"rgba(255, 0, 0, 0.5)\";\n      return;\n    }\n    const opacityStop = hardness / 4 + 0.25;\n    this.brushPreviewGradient.style.background = `\n        radial-gradient(\n            circle,\n            rgba(255, 0, 0, 0.5) 0%,\n            rgba(255, 0, 0, ${opacityStop}) ${hardness * 100}%,\n            rgba(255, 0, 0, 0) 100%\n        )\n    `;\n  }\n  getMaskBlendMode() {\n    return this.maskBlendMode;\n  }\n  setSidebarImage() {\n    this.sidebarImage.src = this.imageURL.href;\n  }\n  async getMaskColor() {\n    if (this.maskBlendMode === \"black\") {\n      return { r: 0, g: 0, b: 0 };\n    }\n    if (this.maskBlendMode === \"white\") {\n      return { r: 255, g: 255, b: 255 };\n    }\n    if (this.maskBlendMode === \"negative\") {\n      return { r: 255, g: 255, b: 255 };\n    }\n    return { r: 0, g: 0, b: 0 };\n  }\n  async getMaskFillStyle() {\n    const maskColor = await this.getMaskColor();\n    return \"rgb(\" + maskColor.r + \",\" + maskColor.g + \",\" + maskColor.b + \")\";\n  }\n  async setCanvasBackground() {\n    if (this.maskBlendMode === \"white\") {\n      this.canvasBackground.style.background = \"black\";\n    } else {\n      this.canvasBackground.style.background = \"white\";\n    }\n  }\n  getMaskCanvas() {\n    return this.maskCanvas;\n  }\n  getImgCanvas() {\n    return this.imgCanvas;\n  }\n  getRgbCanvas() {\n    return this.rgbCanvas;\n  }\n  getImage() {\n    return this.image;\n  }\n  setBrushOpacity(opacity) {\n    this.brush.style.opacity = String(opacity);\n  }\n  setSaveButtonEnabled(enabled) {\n    this.saveButton.disabled = !enabled;\n  }\n  setSaveButtonText(text) {\n    this.saveButton.innerText = text;\n  }\n  handlePaintBucketCursor(isPaintBucket) {\n    if (isPaintBucket) {\n      this.pointerZone.style.cursor = \"url('/cursor/paintBucket.png') 30 25, auto\";\n    } else {\n      this.pointerZone.style.cursor = \"none\";\n    }\n  }\n  handlePanCursor(isPanning) {\n    if (isPanning) {\n      this.pointerZone.style.cursor = \"grabbing\";\n    } else {\n      this.pointerZone.style.cursor = \"none\";\n    }\n  }\n  setBrushVisibility(visible) {\n    this.brush.style.opacity = visible ? \"1\" : \"0\";\n  }\n  setBrushPreviewGradientVisibility(visible) {\n    this.brushPreviewGradient.style.display = visible ? \"block\" : \"none\";\n  }\n  async updateCursor() {\n    const currentTool = await this.messageBroker.pull(\"currentTool\");\n    if (currentTool === \"paintBucket\") {\n      this.pointerZone.style.cursor = \"url('/cursor/paintBucket.png') 30 25, auto\";\n      this.setBrushOpacity(0);\n    } else if (currentTool === \"colorSelect\") {\n      this.pointerZone.style.cursor = \"url('/cursor/colorSelect.png') 15 25, auto\";\n      this.setBrushOpacity(0);\n    } else {\n      this.pointerZone.style.cursor = \"none\";\n      this.setBrushOpacity(1);\n    }\n    this.updateBrushPreview();\n    this.setBrushPreviewGradientVisibility(false);\n  }\n  setZoomText(zoomText) {\n    this.zoomTextHTML.innerText = zoomText;\n  }\n  setDimensionsText(dimensionsText) {\n    this.dimensionsTextHTML.innerText = dimensionsText;\n  }\n}\nclass ToolManager {\n  // is user adjusting brush size or hardness with alt + right mouse button\n  constructor(maskEditor) {\n    __publicField$3(this, \"maskEditor\");\n    __publicField$3(this, \"messageBroker\");\n    __publicField$3(this, \"mouseDownPoint\", null);\n    __publicField$3(\n      this,\n      \"currentTool\",\n      \"pen\"\n      /* MaskPen */\n    );\n    __publicField$3(this, \"isAdjustingBrush\", false);\n    this.maskEditor = maskEditor;\n    this.messageBroker = maskEditor.getMessageBroker();\n    this.addListeners();\n    this.addPullTopics();\n  }\n  addListeners() {\n    this.messageBroker.subscribe(\"setTool\", async (tool) => {\n      this.setTool(tool);\n    });\n    this.messageBroker.subscribe(\"pointerDown\", async (event) => {\n      this.handlePointerDown(event);\n    });\n    this.messageBroker.subscribe(\"pointerMove\", async (event) => {\n      this.handlePointerMove(event);\n    });\n    this.messageBroker.subscribe(\"pointerUp\", async (event) => {\n      this.handlePointerUp(event);\n    });\n    this.messageBroker.subscribe(\"wheel\", async (event) => {\n      this.handleWheelEvent(event);\n    });\n  }\n  async addPullTopics() {\n    this.messageBroker.createPullTopic(\n      \"currentTool\",\n      async () => this.getCurrentTool()\n    );\n  }\n  //tools\n  setTool(tool) {\n    this.currentTool = tool;\n    if (tool != \"colorSelect\") {\n      this.messageBroker.publish(\"clearLastPoint\");\n    }\n  }\n  getCurrentTool() {\n    return this.currentTool;\n  }\n  async handlePointerDown(event) {\n    event.preventDefault();\n    if (event.pointerType == \"touch\") return;\n    var isSpacePressed = await this.messageBroker.pull(\"isKeyPressed\", \" \");\n    if (event.buttons === 4 || event.buttons === 1 && isSpacePressed) {\n      this.messageBroker.publish(\"panStart\", event);\n      this.messageBroker.publish(\"setBrushVisibility\", false);\n      return;\n    }\n    if (this.currentTool === \"rgbPaint\" && event.button === 0) {\n      this.messageBroker.publish(\"drawStart\", event);\n      this.messageBroker.publish(\"saveState\");\n      return;\n    }\n    if (this.currentTool === \"rgbPaint\" && event.buttons === 1) {\n      this.messageBroker.publish(\"draw\", event);\n      return;\n    }\n    if (this.currentTool === \"paintBucket\" && event.button === 0) {\n      const offset = { x: event.offsetX, y: event.offsetY };\n      const coords_canvas = await this.messageBroker.pull(\n        \"screenToCanvas\",\n        offset\n      );\n      this.messageBroker.publish(\"paintBucketFill\", coords_canvas);\n      this.messageBroker.publish(\"saveState\");\n      return;\n    }\n    if (this.currentTool === \"colorSelect\" && event.button === 0) {\n      const offset = { x: event.offsetX, y: event.offsetY };\n      const coords_canvas = await this.messageBroker.pull(\n        \"screenToCanvas\",\n        offset\n      );\n      this.messageBroker.publish(\"colorSelectFill\", coords_canvas);\n      return;\n    }\n    if (event.altKey && event.button === 2) {\n      this.isAdjustingBrush = true;\n      this.messageBroker.publish(\"brushAdjustmentStart\", event);\n      return;\n    }\n    var isDrawingTool = [\n      \"pen\",\n      \"eraser\",\n      \"rgbPaint\"\n      /* PaintPen */\n    ].includes(\n      this.currentTool\n    );\n    if ([0, 2].includes(event.button) && isDrawingTool) {\n      this.messageBroker.publish(\"drawStart\", event);\n      return;\n    }\n  }\n  async handlePointerMove(event) {\n    event.preventDefault();\n    if (event.pointerType == \"touch\") return;\n    const newCursorPoint = { x: event.clientX, y: event.clientY };\n    this.messageBroker.publish(\"cursorPoint\", newCursorPoint);\n    var isSpacePressed = await this.messageBroker.pull(\"isKeyPressed\", \" \");\n    this.messageBroker.publish(\"updateBrushPreview\");\n    if (event.buttons === 4 || event.buttons === 1 && isSpacePressed) {\n      this.messageBroker.publish(\"panMove\", event);\n      return;\n    }\n    var isDrawingTool = [\n      \"pen\",\n      \"eraser\",\n      \"rgbPaint\"\n      /* PaintPen */\n    ].includes(\n      this.currentTool\n    );\n    if (!isDrawingTool) return;\n    if (this.isAdjustingBrush && (this.currentTool === \"pen\" || this.currentTool === \"eraser\") && event.altKey && event.buttons === 2) {\n      this.messageBroker.publish(\"brushAdjustment\", event);\n      return;\n    }\n    if (event.buttons == 1 || event.buttons == 2) {\n      this.messageBroker.publish(\"draw\", event);\n      return;\n    }\n  }\n  handlePointerUp(event) {\n    this.messageBroker.publish(\"panCursor\", false);\n    if (event.pointerType === \"touch\") return;\n    this.messageBroker.publish(\"updateCursor\");\n    this.isAdjustingBrush = false;\n    this.messageBroker.publish(\"drawEnd\", event);\n    this.mouseDownPoint = null;\n  }\n  handleWheelEvent(event) {\n    this.messageBroker.publish(\"zoom\", event);\n    const newCursorPoint = { x: event.clientX, y: event.clientY };\n    this.messageBroker.publish(\"cursorPoint\", newCursorPoint);\n  }\n}\nclass PanAndZoomManager {\n  constructor(maskEditor) {\n    __publicField$3(this, \"maskEditor\");\n    __publicField$3(this, \"messageBroker\");\n    __publicField$3(this, \"DOUBLE_TAP_DELAY\", 300);\n    __publicField$3(this, \"lastTwoFingerTap\", 0);\n    __publicField$3(this, \"isTouchZooming\", false);\n    __publicField$3(this, \"lastTouchZoomDistance\", 0);\n    __publicField$3(this, \"lastTouchMidPoint\", { x: 0, y: 0 });\n    __publicField$3(this, \"lastTouchPoint\", { x: 0, y: 0 });\n    __publicField$3(this, \"zoom_ratio\", 1);\n    __publicField$3(this, \"interpolatedZoomRatio\", 1);\n    __publicField$3(this, \"pan_offset\", { x: 0, y: 0 });\n    __publicField$3(this, \"mouseDownPoint\", null);\n    __publicField$3(this, \"initialPan\", { x: 0, y: 0 });\n    __publicField$3(this, \"canvasContainer\", null);\n    __publicField$3(this, \"maskCanvas\", null);\n    __publicField$3(this, \"rgbCanvas\", null);\n    __publicField$3(this, \"rootElement\", null);\n    __publicField$3(this, \"image\", null);\n    __publicField$3(this, \"imageRootWidth\", 0);\n    __publicField$3(this, \"imageRootHeight\", 0);\n    __publicField$3(this, \"cursorPoint\", { x: 0, y: 0 });\n    __publicField$3(this, \"penPointerIdList\", []);\n    this.maskEditor = maskEditor;\n    this.messageBroker = maskEditor.getMessageBroker();\n    this.addListeners();\n    this.addPullTopics();\n  }\n  addListeners() {\n    this.messageBroker.subscribe(\n      \"initZoomPan\",\n      async (args) => {\n        await this.initializeCanvasPanZoom(args[0], args[1]);\n      }\n    );\n    this.messageBroker.subscribe(\"panStart\", async (event) => {\n      this.handlePanStart(event);\n    });\n    this.messageBroker.subscribe(\"panMove\", async (event) => {\n      this.handlePanMove(event);\n    });\n    this.messageBroker.subscribe(\"zoom\", async (event) => {\n      this.zoom(event);\n    });\n    this.messageBroker.subscribe(\"cursorPoint\", async (point) => {\n      this.updateCursorPosition(point);\n    });\n    this.messageBroker.subscribe(\"pointerDown\", async (event) => {\n      if (event.pointerType === \"pen\")\n        this.penPointerIdList.push(event.pointerId);\n    });\n    this.messageBroker.subscribe(\"pointerUp\", async (event) => {\n      if (event.pointerType === \"pen\") {\n        const index = this.penPointerIdList.indexOf(event.pointerId);\n        if (index > -1) this.penPointerIdList.splice(index, 1);\n      }\n    });\n    this.messageBroker.subscribe(\n      \"handleTouchStart\",\n      async (event) => {\n        this.handleTouchStart(event);\n      }\n    );\n    this.messageBroker.subscribe(\n      \"handleTouchMove\",\n      async (event) => {\n        this.handleTouchMove(event);\n      }\n    );\n    this.messageBroker.subscribe(\n      \"handleTouchEnd\",\n      async (event) => {\n        this.handleTouchEnd(event);\n      }\n    );\n    this.messageBroker.subscribe(\"resetZoom\", async () => {\n      if (this.interpolatedZoomRatio === 1) return;\n      await this.smoothResetView();\n    });\n  }\n  addPullTopics() {\n    this.messageBroker.createPullTopic(\n      \"cursorPoint\",\n      async () => this.cursorPoint\n    );\n    this.messageBroker.createPullTopic(\"zoomRatio\", async () => this.zoom_ratio);\n    this.messageBroker.createPullTopic(\"panOffset\", async () => this.pan_offset);\n  }\n  handleTouchStart(event) {\n    event.preventDefault();\n    if (this.penPointerIdList.length > 0) return;\n    this.messageBroker.publish(\"setBrushVisibility\", false);\n    if (event.touches.length === 2) {\n      const currentTime = (/* @__PURE__ */ new Date()).getTime();\n      const tapTimeDiff = currentTime - this.lastTwoFingerTap;\n      if (tapTimeDiff < this.DOUBLE_TAP_DELAY) {\n        this.handleDoubleTap();\n        this.lastTwoFingerTap = 0;\n      } else {\n        this.lastTwoFingerTap = currentTime;\n        this.isTouchZooming = true;\n        this.lastTouchZoomDistance = this.getTouchDistance(event.touches);\n        const midpoint = this.getTouchMidpoint(event.touches);\n        this.lastTouchMidPoint = midpoint;\n      }\n    } else if (event.touches.length === 1) {\n      this.lastTouchPoint = {\n        x: event.touches[0].clientX,\n        y: event.touches[0].clientY\n      };\n    }\n  }\n  async handleTouchMove(event) {\n    event.preventDefault();\n    if (this.penPointerIdList.length > 0) return;\n    this.lastTwoFingerTap = 0;\n    if (this.isTouchZooming && event.touches.length === 2) {\n      const newDistance = this.getTouchDistance(event.touches);\n      const zoomFactor = newDistance / this.lastTouchZoomDistance;\n      const oldZoom = this.zoom_ratio;\n      this.zoom_ratio = Math.max(\n        0.2,\n        Math.min(10, this.zoom_ratio * zoomFactor)\n      );\n      const newZoom = this.zoom_ratio;\n      const midpoint = this.getTouchMidpoint(event.touches);\n      if (this.lastTouchMidPoint) {\n        const deltaX = midpoint.x - this.lastTouchMidPoint.x;\n        const deltaY = midpoint.y - this.lastTouchMidPoint.y;\n        this.pan_offset.x += deltaX;\n        this.pan_offset.y += deltaY;\n      }\n      if (this.maskCanvas === null) {\n        this.maskCanvas = await this.messageBroker.pull(\"maskCanvas\");\n      }\n      const rect = this.maskCanvas.getBoundingClientRect();\n      const touchX = midpoint.x - rect.left;\n      const touchY = midpoint.y - rect.top;\n      const scaleFactor = newZoom / oldZoom;\n      this.pan_offset.x += touchX - touchX * scaleFactor;\n      this.pan_offset.y += touchY - touchY * scaleFactor;\n      this.invalidatePanZoom();\n      this.lastTouchZoomDistance = newDistance;\n      this.lastTouchMidPoint = midpoint;\n    } else if (event.touches.length === 1) {\n      this.handleSingleTouchPan(event.touches[0]);\n    }\n  }\n  handleTouchEnd(event) {\n    event.preventDefault();\n    const lastTouch = event.touches[0];\n    if (lastTouch) {\n      this.lastTouchPoint = {\n        x: lastTouch.clientX,\n        y: lastTouch.clientY\n      };\n    } else {\n      this.isTouchZooming = false;\n      this.lastTouchMidPoint = { x: 0, y: 0 };\n    }\n  }\n  getTouchDistance(touches) {\n    const dx = touches[0].clientX - touches[1].clientX;\n    const dy = touches[0].clientY - touches[1].clientY;\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n  getTouchMidpoint(touches) {\n    return {\n      x: (touches[0].clientX + touches[1].clientX) / 2,\n      y: (touches[0].clientY + touches[1].clientY) / 2\n    };\n  }\n  async handleSingleTouchPan(touch) {\n    if (this.lastTouchPoint === null) {\n      this.lastTouchPoint = { x: touch.clientX, y: touch.clientY };\n      return;\n    }\n    const deltaX = touch.clientX - this.lastTouchPoint.x;\n    const deltaY = touch.clientY - this.lastTouchPoint.y;\n    this.pan_offset.x += deltaX;\n    this.pan_offset.y += deltaY;\n    await this.invalidatePanZoom();\n    this.lastTouchPoint = { x: touch.clientX, y: touch.clientY };\n  }\n  updateCursorPosition(clientPoint) {\n    var cursorX = clientPoint.x - this.pan_offset.x;\n    var cursorY = clientPoint.y - this.pan_offset.y;\n    this.cursorPoint = { x: cursorX, y: cursorY };\n  }\n  //prob redundant\n  handleDoubleTap() {\n    this.messageBroker.publish(\"undo\");\n  }\n  async zoom(event) {\n    const cursorPoint = { x: event.clientX, y: event.clientY };\n    const oldZoom = this.zoom_ratio;\n    const zoomFactor = event.deltaY < 0 ? 1.1 : 0.9;\n    this.zoom_ratio = Math.max(\n      0.2,\n      Math.min(10, this.zoom_ratio * zoomFactor)\n    );\n    const newZoom = this.zoom_ratio;\n    const maskCanvas = await this.messageBroker.pull(\"maskCanvas\");\n    const rect = maskCanvas.getBoundingClientRect();\n    const mouseX = cursorPoint.x - rect.left;\n    const mouseY = cursorPoint.y - rect.top;\n    console.log(oldZoom, newZoom);\n    const scaleFactor = newZoom / oldZoom;\n    this.pan_offset.x += mouseX - mouseX * scaleFactor;\n    this.pan_offset.y += mouseY - mouseY * scaleFactor;\n    await this.invalidatePanZoom();\n    const newImageWidth = maskCanvas.clientWidth;\n    const zoomRatio = newImageWidth / this.imageRootWidth;\n    this.interpolatedZoomRatio = zoomRatio;\n    this.messageBroker.publish(\"setZoomText\", `${Math.round(zoomRatio * 100)}%`);\n    this.updateCursorPosition(cursorPoint);\n    requestAnimationFrame(() => {\n      this.messageBroker.publish(\"updateBrushPreview\");\n    });\n  }\n  async smoothResetView(duration = 500) {\n    const startZoom = this.zoom_ratio;\n    const startPan = { ...this.pan_offset };\n    const sidePanelWidth = 220;\n    const toolPanelWidth = 64;\n    const topBarHeight = 44;\n    const availableWidth = this.rootElement.clientWidth - sidePanelWidth - toolPanelWidth;\n    const availableHeight = this.rootElement.clientHeight - topBarHeight;\n    const zoomRatioWidth = availableWidth / this.image.width;\n    const zoomRatioHeight = availableHeight / this.image.height;\n    const targetZoom = Math.min(zoomRatioWidth, zoomRatioHeight);\n    const aspectRatio = this.image.width / this.image.height;\n    let finalWidth = 0;\n    let finalHeight = 0;\n    const targetPan = { x: toolPanelWidth, y: topBarHeight };\n    if (zoomRatioHeight > zoomRatioWidth) {\n      finalWidth = availableWidth;\n      finalHeight = finalWidth / aspectRatio;\n      targetPan.y = (availableHeight - finalHeight) / 2 + topBarHeight;\n    } else {\n      finalHeight = availableHeight;\n      finalWidth = finalHeight * aspectRatio;\n      targetPan.x = (availableWidth - finalWidth) / 2 + toolPanelWidth;\n    }\n    const startTime = performance.now();\n    const animate = (currentTime) => {\n      const elapsed = currentTime - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n      const eased = 1 - Math.pow(1 - progress, 3);\n      const currentZoom = startZoom + (targetZoom - startZoom) * eased;\n      this.zoom_ratio = currentZoom;\n      this.pan_offset.x = startPan.x + (targetPan.x - startPan.x) * eased;\n      this.pan_offset.y = startPan.y + (targetPan.y - startPan.y) * eased;\n      this.invalidatePanZoom();\n      const interpolatedZoomRatio = startZoom + (1 - startZoom) * eased;\n      this.messageBroker.publish(\n        \"setZoomText\",\n        `${Math.round(interpolatedZoomRatio * 100)}%`\n      );\n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      }\n    };\n    requestAnimationFrame(animate);\n    this.interpolatedZoomRatio = 1;\n  }\n  async initializeCanvasPanZoom(image, rootElement) {\n    let sidePanelWidth = 220;\n    const toolPanelWidth = 64;\n    let topBarHeight = 44;\n    this.rootElement = rootElement;\n    let availableWidth = rootElement.clientWidth - sidePanelWidth - toolPanelWidth;\n    let availableHeight = rootElement.clientHeight - topBarHeight;\n    let zoomRatioWidth = availableWidth / image.width;\n    let zoomRatioHeight = availableHeight / image.height;\n    let aspectRatio = image.width / image.height;\n    let finalWidth = 0;\n    let finalHeight = 0;\n    let pan_offset = { x: toolPanelWidth, y: topBarHeight };\n    if (zoomRatioHeight > zoomRatioWidth) {\n      finalWidth = availableWidth;\n      finalHeight = finalWidth / aspectRatio;\n      pan_offset.y = (availableHeight - finalHeight) / 2 + topBarHeight;\n    } else {\n      finalHeight = availableHeight;\n      finalWidth = finalHeight * aspectRatio;\n      pan_offset.x = (availableWidth - finalWidth) / 2 + toolPanelWidth;\n    }\n    if (this.image === null) {\n      this.image = image;\n    }\n    this.imageRootWidth = finalWidth;\n    this.imageRootHeight = finalHeight;\n    this.zoom_ratio = Math.min(zoomRatioWidth, zoomRatioHeight);\n    this.pan_offset = pan_offset;\n    this.penPointerIdList = [];\n    await this.invalidatePanZoom();\n  }\n  async invalidatePanZoom() {\n    var _a2, _b2, _c;\n    if (!((_a2 = this.image) == null ? void 0 : _a2.width) || !((_b2 = this.image) == null ? void 0 : _b2.height) || !this.pan_offset || !this.zoom_ratio) {\n      console.warn(\"Missing required properties for pan/zoom\");\n      return;\n    }\n    const raw_width = this.image.width * this.zoom_ratio;\n    const raw_height = this.image.height * this.zoom_ratio;\n    this.canvasContainer ?? (this.canvasContainer = await ((_c = this.messageBroker) == null ? void 0 : _c.pull(\"getCanvasContainer\")));\n    if (!this.canvasContainer) return;\n    Object.assign(this.canvasContainer.style, {\n      width: `${raw_width}px`,\n      height: `${raw_height}px`,\n      left: `${this.pan_offset.x}px`,\n      top: `${this.pan_offset.y}px`\n    });\n    this.rgbCanvas = await this.messageBroker.pull(\"rgbCanvas\");\n    if (this.rgbCanvas) {\n      if (this.rgbCanvas.width !== this.image.width || this.rgbCanvas.height !== this.image.height) {\n        this.rgbCanvas.width = this.image.width;\n        this.rgbCanvas.height = this.image.height;\n      }\n      this.rgbCanvas.style.width = `${raw_width}px`;\n      this.rgbCanvas.style.height = `${raw_height}px`;\n    }\n  }\n  handlePanStart(event) {\n    this.messageBroker.pull(\"screenToCanvas\", {\n      x: event.offsetX,\n      y: event.offsetY\n    });\n    this.mouseDownPoint = { x: event.clientX, y: event.clientY };\n    this.messageBroker.publish(\"panCursor\", true);\n    this.initialPan = this.pan_offset;\n    return;\n  }\n  handlePanMove(event) {\n    if (this.mouseDownPoint === null) throw new Error(\"mouseDownPoint is null\");\n    let deltaX = this.mouseDownPoint.x - event.clientX;\n    let deltaY = this.mouseDownPoint.y - event.clientY;\n    let pan_x = this.initialPan.x - deltaX;\n    let pan_y = this.initialPan.y - deltaY;\n    this.pan_offset = { x: pan_x, y: pan_y };\n    this.invalidatePanZoom();\n  }\n}\nclass MessageBroker {\n  constructor() {\n    __publicField$3(this, \"pushTopics\", {});\n    __publicField$3(this, \"pullTopics\", {});\n    this.registerListeners();\n  }\n  // Push\n  registerListeners() {\n    this.createPushTopic(\"panStart\");\n    this.createPushTopic(\"paintBucketFill\");\n    this.createPushTopic(\"saveState\");\n    this.createPushTopic(\"brushAdjustmentStart\");\n    this.createPushTopic(\"drawStart\");\n    this.createPushTopic(\"panMove\");\n    this.createPushTopic(\"updateBrushPreview\");\n    this.createPushTopic(\"brushAdjustment\");\n    this.createPushTopic(\"draw\");\n    this.createPushTopic(\"paintBucketCursor\");\n    this.createPushTopic(\"panCursor\");\n    this.createPushTopic(\"drawEnd\");\n    this.createPushTopic(\"zoom\");\n    this.createPushTopic(\"undo\");\n    this.createPushTopic(\"redo\");\n    this.createPushTopic(\"cursorPoint\");\n    this.createPushTopic(\"panOffset\");\n    this.createPushTopic(\"zoomRatio\");\n    this.createPushTopic(\"getMaskCanvas\");\n    this.createPushTopic(\"getCanvasContainer\");\n    this.createPushTopic(\"screenToCanvas\");\n    this.createPushTopic(\"isKeyPressed\");\n    this.createPushTopic(\"isCombinationPressed\");\n    this.createPushTopic(\"setPaintBucketTolerance\");\n    this.createPushTopic(\"setBrushSize\");\n    this.createPushTopic(\"setBrushHardness\");\n    this.createPushTopic(\"setBrushOpacity\");\n    this.createPushTopic(\"setBrushShape\");\n    this.createPushTopic(\"initZoomPan\");\n    this.createPushTopic(\"setTool\");\n    this.createPushTopic(\"setActiveLayer\");\n    this.createPushTopic(\"pointerDown\");\n    this.createPushTopic(\"pointerMove\");\n    this.createPushTopic(\"pointerUp\");\n    this.createPushTopic(\"wheel\");\n    this.createPushTopic(\"initPaintBucketTool\");\n    this.createPushTopic(\"setBrushVisibility\");\n    this.createPushTopic(\"setBrushPreviewGradientVisibility\");\n    this.createPushTopic(\"handleTouchStart\");\n    this.createPushTopic(\"handleTouchMove\");\n    this.createPushTopic(\"handleTouchEnd\");\n    this.createPushTopic(\"colorSelectFill\");\n    this.createPushTopic(\"setColorSelectTolerance\");\n    this.createPushTopic(\"setLivePreview\");\n    this.createPushTopic(\"updateCursor\");\n    this.createPushTopic(\"setColorComparisonMethod\");\n    this.createPushTopic(\"clearLastPoint\");\n    this.createPushTopic(\"setWholeImage\");\n    this.createPushTopic(\"setMaskBoundary\");\n    this.createPushTopic(\"setMaskTolerance\");\n    this.createPushTopic(\"setBrushSmoothingPrecision\");\n    this.createPushTopic(\"setZoomText\");\n    this.createPushTopic(\"resetZoom\");\n    this.createPushTopic(\"invert\");\n    this.createPushTopic(\"setRGBColor\");\n    this.createPushTopic(\"paintedurl\");\n    this.createPushTopic(\"setSelectionOpacity\");\n    this.createPushTopic(\"setFillOpacity\");\n  }\n  /**\n   * Creates a new push topic (listener is notified)\n   *\n   * @param {string} topicName - The name of the topic to create.\n   * @throws {Error} If the topic already exists.\n   */\n  createPushTopic(topicName) {\n    if (this.topicExists(this.pushTopics, topicName)) {\n      throw new Error(\"Topic already exists\");\n    }\n    this.pushTopics[topicName] = [];\n  }\n  /**\n   * Subscribe a callback function to the given topic.\n   *\n   * @param {string} topicName - The name of the topic to subscribe to.\n   * @param {Callback} callback - The callback function to be subscribed.\n   * @throws {Error} If the topic does not exist.\n   */\n  subscribe(topicName, callback) {\n    if (!this.topicExists(this.pushTopics, topicName)) {\n      throw new Error(`Topic \"${topicName}\" does not exist!`);\n    }\n    this.pushTopics[topicName].push(callback);\n  }\n  /**\n   * Removes a callback function from the list of subscribers for a given topic.\n   *\n   * @param {string} topicName - The name of the topic to unsubscribe from.\n   * @param {Callback} callback - The callback function to remove from the subscribers list.\n   * @throws {Error} If the topic does not exist in the list of topics.\n   */\n  unsubscribe(topicName, callback) {\n    if (!this.topicExists(this.pushTopics, topicName)) {\n      throw new Error(\"Topic does not exist\");\n    }\n    const index = this.pushTopics[topicName].indexOf(callback);\n    if (index > -1) {\n      this.pushTopics[topicName].splice(index, 1);\n    }\n  }\n  /**\n   * Publishes data to a specified topic with variable number of arguments.\n   * @param {string} topicName - The name of the topic to publish to.\n   * @param {...any[]} args - Variable number of arguments to pass to subscribers\n   * @throws {Error} If the specified topic does not exist.\n   */\n  publish(topicName, ...args) {\n    if (!this.topicExists(this.pushTopics, topicName)) {\n      throw new Error(`Topic \"${topicName}\" does not exist!`);\n    }\n    this.pushTopics[topicName].forEach((callback) => {\n      callback(...args);\n    });\n  }\n  // Pull\n  /**\n   * Creates a new pull topic (listener must request data)\n   *\n   * @param {string} topicName - The name of the topic to create.\n   * @param {() => Promise<any>} callBack - The callback function to be called when data is requested.\n   * @throws {Error} If the topic already exists.\n   */\n  createPullTopic(topicName, callBack) {\n    if (this.topicExists(this.pullTopics, topicName)) {\n      throw new Error(\"Topic already exists\");\n    }\n    this.pullTopics[topicName] = callBack;\n  }\n  /**\n   * Requests data from a specified pull topic.\n   * @param {string} topicName - The name of the topic to request data from.\n   * @returns {Promise<any>} - The data from the pull topic.\n   * @throws {Error} If the specified topic does not exist.\n   */\n  async pull(topicName, data) {\n    if (!this.topicExists(this.pullTopics, topicName)) {\n      throw new Error(\"Topic does not exist\");\n    }\n    const callBack = this.pullTopics[topicName];\n    try {\n      const result = await callBack(data);\n      return result;\n    } catch (error) {\n      console.error(`Error pulling data from topic \"${topicName}\":`, error);\n      throw error;\n    }\n  }\n  // Helper Methods\n  /**\n   * Checks if a topic exists in the given topics object.\n   * @param {Record<string, any>} topics - The topics object to check.\n   * @param {string} topicName - The name of the topic to check.\n   * @returns {boolean} - True if the topic exists, false otherwise.\n   */\n  topicExists(topics, topicName) {\n    return topics.hasOwnProperty(topicName);\n  }\n}\nclass KeyboardManager {\n  constructor(maskEditor) {\n    __publicField$3(this, \"keysDown\", []);\n    __publicField$3(this, \"maskEditor\");\n    __publicField$3(this, \"messageBroker\");\n    __publicField$3(this, \"handleKeyDownBound\", this.handleKeyDown.bind(this));\n    __publicField$3(this, \"handleKeyUpBound\", this.handleKeyUp.bind(this));\n    __publicField$3(this, \"clearKeysBound\", this.clearKeys.bind(this));\n    this.maskEditor = maskEditor;\n    this.messageBroker = maskEditor.getMessageBroker();\n    this.addPullTopics();\n  }\n  addPullTopics() {\n    this.messageBroker.createPullTopic(\n      \"isKeyPressed\",\n      (key) => Promise.resolve(this.isKeyDown(key))\n    );\n  }\n  addListeners() {\n    document.addEventListener(\"keydown\", this.handleKeyDownBound);\n    document.addEventListener(\"keyup\", this.handleKeyUpBound);\n    window.addEventListener(\"blur\", this.clearKeysBound);\n  }\n  removeListeners() {\n    document.removeEventListener(\"keydown\", this.handleKeyDownBound);\n    document.removeEventListener(\"keyup\", this.handleKeyUpBound);\n    window.removeEventListener(\"blur\", this.clearKeysBound);\n  }\n  clearKeys() {\n    this.keysDown = [];\n  }\n  handleKeyDown(event) {\n    if (!this.keysDown.includes(event.key)) {\n      this.keysDown.push(event.key);\n    }\n    if ((event.ctrlKey || event.metaKey) && !event.altKey) {\n      const key = event.key.toUpperCase();\n      if (key === \"Y\" && !event.shiftKey || key == \"Z\" && event.shiftKey) {\n        this.messageBroker.publish(\"redo\");\n      } else if (key === \"Z\" && !event.shiftKey) {\n        this.messageBroker.publish(\"undo\");\n      }\n    }\n  }\n  handleKeyUp(event) {\n    this.keysDown = this.keysDown.filter((key) => key !== event.key);\n  }\n  isKeyDown(key) {\n    return this.keysDown.includes(key);\n  }\n}\nfunction openMaskEditor() {\n  const useNewEditor = app.extensionManager.setting.get(\n    \"Comfy.MaskEditor.UseNewEditor\"\n  );\n  if (useNewEditor) {\n    const dlg = MaskEditorDialog.getInstance();\n    if ((dlg == null ? void 0 : dlg.isOpened) && !dlg.isOpened()) {\n      dlg.show();\n    }\n  } else {\n    const dlg = MaskEditorDialogOld.getInstance();\n    if ((dlg == null ? void 0 : dlg.isOpened) && !dlg.isOpened()) {\n      dlg.show();\n    }\n  }\n}\nfunction isOpened() {\n  var _a2, _b2, _c, _d;\n  const useNewEditor = app.extensionManager.setting.get(\n    \"Comfy.MaskEditor.UseNewEditor\"\n  );\n  if (useNewEditor) {\n    return ((_b2 = (_a2 = MaskEditorDialog.instance) == null ? void 0 : _a2.isOpened) == null ? void 0 : _b2.call(_a2)) ?? false;\n  } else {\n    return ((_d = (_c = MaskEditorDialogOld.instance) == null ? void 0 : _c.isOpened) == null ? void 0 : _d.call(_c)) ?? false;\n  }\n}\nconst context_predicate = () => {\n  return !!(ComfyApp.clipspace && ComfyApp.clipspace.imgs && ComfyApp.clipspace.imgs.length > 0);\n};\napp.registerExtension({\n  name: \"Comfy.MaskEditor\",\n  settings: [\n    {\n      id: \"Comfy.MaskEditor.UseNewEditor\",\n      category: [\"Mask Editor\", \"NewEditor\"],\n      name: \"Use new mask editor\",\n      tooltip: \"Switch to the new mask editor interface\",\n      type: \"boolean\",\n      defaultValue: true,\n      experimental: true\n    },\n    {\n      id: \"Comfy.MaskEditor.BrushAdjustmentSpeed\",\n      category: [\"Mask Editor\", \"BrushAdjustment\", \"Sensitivity\"],\n      name: \"Brush adjustment speed multiplier\",\n      tooltip: \"Controls how quickly the brush size and hardness change when adjusting. Higher values mean faster changes.\",\n      experimental: true,\n      type: \"slider\",\n      attrs: {\n        min: 0.1,\n        max: 2,\n        step: 0.1\n      },\n      defaultValue: 1,\n      versionAdded: \"1.0.0\"\n    },\n    {\n      id: \"Comfy.MaskEditor.UseDominantAxis\",\n      category: [\"Mask Editor\", \"BrushAdjustment\", \"UseDominantAxis\"],\n      name: \"Lock brush adjustment to dominant axis\",\n      tooltip: \"When enabled, brush adjustments will only affect size OR hardness based on which direction you move more\",\n      type: \"boolean\",\n      defaultValue: true,\n      experimental: true\n    }\n  ],\n  commands: [\n    {\n      id: \"Comfy.MaskEditor.OpenMaskEditor\",\n      icon: \"pi pi-pencil\",\n      label: \"Open Mask Editor for Selected Node\",\n      function: () => {\n        var _a2;\n        const selectedNodes = app.canvas.selected_nodes;\n        if (!selectedNodes || Object.keys(selectedNodes).length !== 1) return;\n        const selectedNode = selectedNodes[Object.keys(selectedNodes)[0]];\n        if (!((_a2 = selectedNode.imgs) == null ? void 0 : _a2.length) && selectedNode.previewMediaType !== \"image\")\n          return;\n        ComfyApp.copyToClipspace(selectedNode);\n        ComfyApp.clipspace_return_node = selectedNode;\n        openMaskEditor();\n      }\n    },\n    {\n      id: \"Comfy.MaskEditor.BrushSize.Increase\",\n      icon: \"pi pi-plus-circle\",\n      label: \"Increase Brush Size in MaskEditor\",\n      function: () => changeBrushSize((old) => toolkit.clamp(old + 4, 1, 100))\n    },\n    {\n      id: \"Comfy.MaskEditor.BrushSize.Decrease\",\n      icon: \"pi pi-minus-circle\",\n      label: \"Decrease Brush Size in MaskEditor\",\n      function: () => changeBrushSize((old) => toolkit.clamp(old - 4, 1, 100))\n    }\n  ],\n  init() {\n    ComfyApp.open_maskeditor = openMaskEditor;\n    ComfyApp.maskeditor_is_opended = isOpened;\n    ClipspaceDialog.registerButton(\n      \"MaskEditor\",\n      context_predicate,\n      openMaskEditor\n    );\n  }\n});\nconst changeBrushSize = async (sizeChanger) => {\n  if (!isOpened()) return;\n  const maskEditor = MaskEditorDialog.getInstance();\n  if (!maskEditor) return;\n  const messageBroker = maskEditor.getMessageBroker();\n  const oldBrushSize = (await messageBroker.pull(\"brushSettings\")).size;\n  const newBrushSize = sizeChanger(oldBrushSize);\n  messageBroker.publish(\"setBrushSize\", newBrushSize);\n  messageBroker.publish(\"updateBrushPreview\");\n};\nconst requestWithRetries = async (mkRequest, maxRetries = 3) => {\n  let attempt = 0;\n  let success = false;\n  while (attempt < maxRetries && !success) {\n    try {\n      const response = await mkRequest();\n      if (response.ok) {\n        success = true;\n      } else {\n        console.log(\"Failed to upload mask:\", response);\n      }\n    } catch (error) {\n      console.error(`Upload attempt ${attempt + 1} failed:`, error);\n      attempt++;\n      if (attempt < maxRetries) {\n        console.log(\"Retrying upload...\");\n      } else {\n        console.log(\"Max retries reached. Upload failed.\");\n      }\n    }\n  }\n  return { success };\n};\nconst isAlphaValue = (index) => index % 4 === 3;\nconst removeImageRgbValuesAndInvertAlpha = (imageData) => imageData.map((val, i) => isAlphaValue(i) ? 255 - val : 0);\nconst replaceClipspaceImages = (newMainOutput, otherImagesInClipspace) => {\n  var _a2, _b2, _c;\n  try {\n    if (!((_c = (_b2 = (_a2 = ComfyApp) == null ? void 0 : _a2.clipspace) == null ? void 0 : _b2.widgets) == null ? void 0 : _c.length)) return;\n    const firstImageWidgetIndex = ComfyApp.clipspace.widgets.findIndex(\n      (obj) => (obj == null ? void 0 : obj.name) === \"image\"\n    );\n    const firstImageWidget = ComfyApp.clipspace.widgets[firstImageWidgetIndex];\n    if (!firstImageWidget) return;\n    ComfyApp.clipspace.widgets[firstImageWidgetIndex].value = newMainOutput;\n    otherImagesInClipspace == null ? void 0 : otherImagesInClipspace.forEach((extraImage, extraImageIndex) => {\n      const extraImageWidgetIndex = firstImageWidgetIndex + extraImageIndex + 1;\n      ComfyApp.clipspace.widgets[extraImageWidgetIndex].value = extraImage;\n    });\n  } catch (err2) {\n    console.warn(\"Failed to set widget value:\", err2);\n  }\n};\nconst ensureImageFullyLoaded = (src) => new Promise((resolve, reject) => {\n  const maskImage = new Image();\n  maskImage.src = src;\n  maskImage.onload = () => resolve();\n  maskImage.onerror = reject;\n});\nconst createCanvasCopy = (canvas) => {\n  const newCanvas = document.createElement(\"canvas\");\n  const newCanvasCtx = getCanvas2dContext(newCanvas);\n  newCanvas.width = canvas.width;\n  newCanvas.height = canvas.height;\n  newCanvasCtx.clearRect(0, 0, canvas.width, canvas.height);\n  newCanvasCtx.drawImage(\n    canvas,\n    0,\n    0,\n    canvas.width,\n    canvas.height,\n    0,\n    0,\n    canvas.width,\n    canvas.height\n  );\n  return [newCanvas, newCanvasCtx];\n};\nconst getCanvas2dContext = (canvas) => {\n  const ctx = canvas.getContext(\"2d\", { willReadFrequently: true });\n  if (!ctx) throw new Error(\"Failed to get 2D context from canvas\");\n  return ctx;\n};\nconst combineOriginalImageAndPaint = (canvases) => {\n  const { originalImage, paint } = canvases;\n  const [resultCanvas, resultCanvasCtx] = createCanvasCopy(originalImage);\n  resultCanvasCtx.drawImage(paint, 0, 0);\n  return [resultCanvas, resultCanvasCtx];\n};\nconst iconsHtml = {\n  [\n    \"pen\"\n    /* MaskPen */\n  ]: `\n    <svg viewBox=\"0 0 44 44\">\n      <path class=\"cls-1\" d=\"M10.97,15.98v14.04c0,.825.675,1.5,1.5,1.5h23.07c.825,0,1.5-.675,1.5-1.5V15.98c0-.825-.675-1.5-1.5-1.5H12.47c-.825,0-1.5.675-1.5,1.5ZM25.79,28.16c-4.365,1.41-8.355-2.58-6.945-6.945.51-1.575,1.785-2.85,3.36-3.36,4.365-1.41,8.355,2.58,6.945,6.945-.51,1.575-1.785,2.85-3.36,3.36Z\"/>\n    </svg>\n  `,\n  [\n    \"eraser\"\n    /* Eraser */\n  ]: `\n    <svg viewBox=\"0 0 44 44\">\n      <g>\n        <rect class=\"cls-2\" x=\"16.68\" y=\"10\" width=\"10.63\" height=\"24\" rx=\"1.16\" ry=\"1.16\" transform=\"translate(22 -9.11) rotate(45)\"/>\n        <path class=\"cls-1\" d=\"M17.27,34.27c-.42,0-.85-.16-1.17-.48l-5.88-5.88c-.31-.31-.48-.73-.48-1.17s.17-.86.48-1.17l15.34-15.34c.62-.62,1.72-.62,2.34,0l5.88,5.88c.65.65.65,1.7,0,2.34l-15.34,15.34c-.32.32-.75.48-1.17.48ZM26.73,10.73c-.18,0-.34.07-.46.19l-15.34,15.34c-.12.12-.19.29-.19.46s.07.34.19.46l5.88,5.88c.26.26.67.26.93,0l15.34-15.34c.26-.26.26-.67,0-.93l-5.88-5.88c-.12-.12-.29-.19-.46-.19Z\"/>\n      </g>\n      <path class=\"cls-3\" d=\"M20.33,11.03h8.32c.64,0,1.16.52,1.16,1.16v15.79h-10.63v-15.79c0-.64.52-1.16,1.16-1.16Z\" transform=\"translate(20.97 -11.61) rotate(45)\"/>\n    </svg>\n  `,\n  [\n    \"paintBucket\"\n    /* MaskBucket */\n  ]: `\n    <svg viewBox=\"0 0 44 44\">\n      <path class=\"cls-1\" d=\"M33.4,21.76l-11.42,11.41-.04.05c-.61.61-1.6.61-2.21,0l-8.91-8.91c-.61-.61-.61-1.6,0-2.21l.04-.05.3-.29h22.24Z\"/>\n      <path class=\"cls-1\" d=\"M20.83,34.17c-.55,0-1.07-.21-1.46-.6l-8.91-8.91c-.8-.8-.8-2.11,0-2.92l11.31-11.31c.8-.8,2.11-.8,2.92,0l8.91,8.91c.39.39.6.91.6,1.46s-.21,1.07-.6,1.46l-11.31,11.31c-.39.39-.91.6-1.46.6ZM23.24,10.83c-.27,0-.54.1-.75.31l-11.31,11.31c-.41.41-.41,1.09,0,1.5l8.91,8.91c.4.4,1.1.4,1.5,0l11.31-11.31c.2-.2.31-.47.31-.75s-.11-.55-.31-.75l-8.91-8.91c-.21-.21-.48-.31-.75-.31Z\"/>\n      <path class=\"cls-1\" d=\"M34.28,26.85c0,.84-.68,1.52-1.52,1.52s-1.52-.68-1.52-1.52,1.52-2.86,1.52-2.86c0,0,1.52,2.02,1.52,2.86Z\"/>\n    </svg>\n  `,\n  [\n    \"colorSelect\"\n    /* MaskColorFill */\n  ]: `\n    <svg viewBox=\"0 0 44 44\">\n      <path class=\"cls-1\" d=\"M30.29,13.72c-1.09-1.1-2.85-1.09-3.94,0l-2.88,2.88-.75-.75c-.2-.19-.51-.19-.71,0-.19.2-.19.51,0,.71l1.4,1.4-9.59,9.59c-.35.36-.54.82-.54,1.32,0,.14,0,.28.05.41-.05.04-.1.08-.15.13-.39.39-.39,1.01,0,1.4.38.39,1.01.39,1.4,0,.04-.04.08-.09.11-.13.14.04.3.06.45.06.5,0,.97-.19,1.32-.55l9.59-9.59,1.38,1.38c.1.09.22.14.35.14s.26-.05.35-.14c.2-.2.2-.52,0-.71l-.71-.72,2.88-2.89c1.08-1.08,1.08-2.85-.01-3.94ZM19.43,25.82h-2.46l7.15-7.15,1.23,1.23-5.92,5.92Z\"/>\n    </svg>\n  `,\n  [\n    \"rgbPaint\"\n    /* PaintPen */\n  ]: `\n    <svg viewBox=\"0 0 44 44\">\n      <path class=\"cls-1\" d=\"M34,13.93c0,.47-.19.94-.55,1.31l-13.02,13.04c-.09.07-.18.15-.27.22-.07-1.39-1.21-2.48-2.61-2.49.07-.12.16-.24.27-.34l13.04-13.04c.72-.72,1.89-.72,2.6,0,.35.35.55.83.55,1.3Z\"/>\n      <path class=\"cls-1\" d=\"M19.64,29.03c0,4.46-6.46,3.18-9.64,0,3.3-.47,4.75-2.58,7.06-2.58,1.43,0,2.58,1.16,2.58,2.58Z\"/>\n    </svg>\n  `\n};\nconst toRef = (filename) => ({\n  filename,\n  subfolder: \"clipspace\",\n  type: \"input\"\n});\nconst mkFileUrl = (props) => {\n  const pathPlusQueryParams = api.apiURL(\n    \"/view?\" + new URLSearchParams(props.ref).toString() + app.getPreviewFormatParam() + app.getRandParam()\n  );\n  const imageElement = new Image();\n  imageElement.src = pathPlusQueryParams;\n  const fullyResolvedUrl = imageElement.src;\n  return fullyResolvedUrl;\n};\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nconst id = \"Comfy.NodeTemplates\";\nconst file = \"comfy.templates.json\";\nclass ManageTemplates extends ComfyDialog {\n  constructor() {\n    super();\n    __publicField$2(this, \"templates\");\n    __publicField$2(this, \"draggedEl\");\n    __publicField$2(this, \"saveVisualCue\");\n    __publicField$2(this, \"emptyImg\");\n    __publicField$2(this, \"importInput\");\n    this.load().then((v) => {\n      this.templates = v;\n    });\n    this.element.classList.add(\"comfy-manage-templates\");\n    this.draggedEl = null;\n    this.saveVisualCue = null;\n    this.emptyImg = new Image();\n    this.emptyImg.src = \"data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=\";\n    this.importInput = $el(\"input\", {\n      type: \"file\",\n      accept: \".json\",\n      multiple: true,\n      style: { display: \"none\" },\n      parent: document.body,\n      onchange: () => this.importAll()\n    });\n  }\n  createButtons() {\n    const btns = super.createButtons();\n    btns[0].textContent = \"Close\";\n    btns[0].onclick = () => {\n      clearTimeout(this.saveVisualCue);\n      this.close();\n    };\n    btns.unshift(\n      $el(\"button\", {\n        type: \"button\",\n        textContent: \"Export\",\n        onclick: () => this.exportAll()\n      })\n    );\n    btns.unshift(\n      $el(\"button\", {\n        type: \"button\",\n        textContent: \"Import\",\n        onclick: () => {\n          this.importInput.click();\n        }\n      })\n    );\n    return btns;\n  }\n  async load() {\n    let templates = [];\n    const res = await api.getUserData(file);\n    if (res.status === 200) {\n      try {\n        templates = await res.json();\n      } catch (error) {\n      }\n    } else if (res.status !== 404) {\n      console.error(res.status + \" \" + res.statusText);\n    }\n    return templates ?? [];\n  }\n  async store() {\n    const templates = JSON.stringify(this.templates, void 0, 4);\n    try {\n      await api.storeUserData(file, templates, { stringify: false });\n    } catch (error) {\n      console.error(error);\n      useToastStore().addAlert(error.message);\n    }\n  }\n  async importAll() {\n    for (const file2 of this.importInput.files) {\n      if (file2.type === \"application/json\" || file2.name.endsWith(\".json\")) {\n        const reader = new FileReader();\n        reader.onload = async () => {\n          const importFile = JSON.parse(reader.result);\n          if (importFile == null ? void 0 : importFile.templates) {\n            for (const template of importFile.templates) {\n              if ((template == null ? void 0 : template.name) && (template == null ? void 0 : template.data)) {\n                this.templates.push(template);\n              }\n            }\n            await this.store();\n          }\n        };\n        await reader.readAsText(file2);\n      }\n    }\n    this.importInput.value = null;\n    this.close();\n  }\n  exportAll() {\n    if (this.templates.length == 0) {\n      useToastStore().addAlert(t(\"toastMessages.noTemplatesToExport\"));\n      return;\n    }\n    const json = JSON.stringify({ templates: this.templates }, null, 2);\n    const blob2 = new Blob([json], { type: \"application/json\" });\n    const url2 = URL.createObjectURL(blob2);\n    const a = $el(\"a\", {\n      href: url2,\n      download: \"node_templates.json\",\n      style: { display: \"none\" },\n      parent: document.body\n    });\n    a.click();\n    setTimeout(function() {\n      a.remove();\n      window.URL.revokeObjectURL(url2);\n    }, 0);\n  }\n  show() {\n    super.show(\n      $el(\n        \"div\",\n        {},\n        this.templates.flatMap((t2, i) => {\n          let nameInput;\n          return [\n            $el(\n              \"div\",\n              {\n                dataset: { id: i.toString() },\n                className: \"templateManagerRow\",\n                style: {\n                  display: \"grid\",\n                  gridTemplateColumns: \"1fr auto\",\n                  border: \"1px dashed transparent\",\n                  gap: \"5px\",\n                  backgroundColor: \"var(--comfy-menu-bg)\"\n                },\n                // @ts-expect-error fixme ts strict error\n                ondragstart: (e) => {\n                  this.draggedEl = e.currentTarget;\n                  e.currentTarget.style.opacity = \"0.6\";\n                  e.currentTarget.style.border = \"1px dashed yellow\";\n                  e.dataTransfer.effectAllowed = \"move\";\n                  e.dataTransfer.setDragImage(this.emptyImg, 0, 0);\n                },\n                // @ts-expect-error fixme ts strict error\n                ondragend: (e) => {\n                  e.target.style.opacity = \"1\";\n                  e.currentTarget.style.border = \"1px dashed transparent\";\n                  e.currentTarget.removeAttribute(\"draggable\");\n                  this.element.querySelectorAll(\".templateManagerRow\").forEach((el, i2) => {\n                    var prev_i = Number.parseInt(el.dataset.id);\n                    if (el == this.draggedEl && prev_i != i2) {\n                      this.templates.splice(\n                        i2,\n                        0,\n                        this.templates.splice(prev_i, 1)[0]\n                      );\n                    }\n                    el.dataset.id = i2.toString();\n                  });\n                  this.store();\n                },\n                // @ts-expect-error fixme ts strict error\n                ondragover: (e) => {\n                  e.preventDefault();\n                  if (e.currentTarget == this.draggedEl) return;\n                  let rect = e.currentTarget.getBoundingClientRect();\n                  if (e.clientY > rect.top + rect.height / 2) {\n                    e.currentTarget.parentNode.insertBefore(\n                      this.draggedEl,\n                      e.currentTarget.nextSibling\n                    );\n                  } else {\n                    e.currentTarget.parentNode.insertBefore(\n                      this.draggedEl,\n                      e.currentTarget\n                    );\n                  }\n                }\n              },\n              [\n                $el(\n                  \"label\",\n                  {\n                    textContent: \"Name: \",\n                    style: {\n                      cursor: \"grab\"\n                    },\n                    // @ts-expect-error fixme ts strict error\n                    onmousedown: (e) => {\n                      if (e.target.localName == \"label\")\n                        e.currentTarget.parentNode.draggable = \"true\";\n                    }\n                  },\n                  [\n                    $el(\"input\", {\n                      value: t2.name,\n                      dataset: { name: t2.name },\n                      style: {\n                        transitionProperty: \"background-color\",\n                        transitionDuration: \"0s\"\n                      },\n                      // @ts-expect-error fixme ts strict error\n                      onchange: (e) => {\n                        clearTimeout(this.saveVisualCue);\n                        var el = e.target;\n                        var row = el.parentNode.parentNode;\n                        this.templates[row.dataset.id].name = el.value.trim() || \"untitled\";\n                        this.store();\n                        el.style.backgroundColor = \"rgb(40, 95, 40)\";\n                        el.style.transitionDuration = \"0s\";\n                        this.saveVisualCue = setTimeout(function() {\n                          el.style.transitionDuration = \".7s\";\n                          el.style.backgroundColor = \"var(--comfy-input-bg)\";\n                        }, 15);\n                      },\n                      // @ts-expect-error fixme ts strict error\n                      onkeypress: (e) => {\n                        var el = e.target;\n                        clearTimeout(this.saveVisualCue);\n                        el.style.transitionDuration = \"0s\";\n                        el.style.backgroundColor = \"var(--comfy-input-bg)\";\n                      },\n                      $: (el) => nameInput = el\n                    })\n                  ]\n                ),\n                $el(\"div\", {}, [\n                  $el(\"button\", {\n                    textContent: \"Export\",\n                    style: {\n                      fontSize: \"12px\",\n                      fontWeight: \"normal\"\n                    },\n                    onclick: () => {\n                      const json = JSON.stringify({ templates: [t2] }, null, 2);\n                      const blob2 = new Blob([json], {\n                        type: \"application/json\"\n                      });\n                      const url2 = URL.createObjectURL(blob2);\n                      const a = $el(\"a\", {\n                        href: url2,\n                        // @ts-expect-error fixme ts strict error\n                        download: (nameInput.value || t2.name) + \".json\",\n                        style: { display: \"none\" },\n                        parent: document.body\n                      });\n                      a.click();\n                      setTimeout(function() {\n                        a.remove();\n                        window.URL.revokeObjectURL(url2);\n                      }, 0);\n                    }\n                  }),\n                  $el(\"button\", {\n                    textContent: \"Delete\",\n                    style: {\n                      fontSize: \"12px\",\n                      color: \"red\",\n                      fontWeight: \"normal\"\n                    },\n                    // @ts-expect-error fixme ts strict error\n                    onclick: (e) => {\n                      const item = e.target.parentNode.parentNode;\n                      item.parentNode.removeChild(item);\n                      this.templates.splice(item.dataset.id * 1, 1);\n                      this.store();\n                      var that = this;\n                      setTimeout(function() {\n                        that.element.querySelectorAll(\".templateManagerRow\").forEach((el, i2) => {\n                          el.dataset.id = i2.toString();\n                        });\n                      }, 0);\n                    }\n                  })\n                ])\n              ]\n            )\n          ];\n        })\n      )\n    );\n  }\n}\napp.registerExtension({\n  name: id,\n  setup() {\n    const manage = new ManageTemplates();\n    const clipboardAction = async (cb) => {\n      const old = localStorage.getItem(\"litegrapheditor_clipboard\");\n      await cb();\n      localStorage.setItem(\"litegrapheditor_clipboard\", old);\n    };\n    const orig = LGraphCanvas.prototype.getCanvasMenuOptions;\n    LGraphCanvas.prototype.getCanvasMenuOptions = function() {\n      const options = orig.apply(this, arguments);\n      options.push(null);\n      options.push({\n        content: `Save Selected as Template`,\n        disabled: !Object.keys(app.canvas.selected_nodes || {}).length,\n        // @ts-expect-error fixme ts strict error\n        callback: async () => {\n          const name = await useDialogService().prompt({\n            title: t(\"nodeTemplates.saveAsTemplate\"),\n            message: t(\"nodeTemplates.enterName\"),\n            defaultValue: \"\"\n          });\n          if (!(name == null ? void 0 : name.trim())) return;\n          clipboardAction(() => {\n            app.canvas.copyToClipboard();\n            let data = localStorage.getItem(\"litegrapheditor_clipboard\");\n            data = JSON.parse(data);\n            const nodeIds = Object.keys(app.canvas.selected_nodes);\n            for (let i = 0; i < nodeIds.length; i++) {\n              const node = app.graph.getNodeById(nodeIds[i]);\n              const nodeData = node == null ? void 0 : node.constructor.nodeData;\n              let groupData = GroupNodeHandler.getGroupData(node);\n              if (groupData) {\n                groupData = groupData.nodeData;\n                if (!data.groupNodes) {\n                  data.groupNodes = {};\n                }\n                if (nodeData == null) throw new TypeError(\"nodeData is not set\");\n                data.groupNodes[nodeData.name] = groupData;\n                data.nodes[i].type = nodeData.name;\n              }\n            }\n            manage.templates.push({\n              name,\n              data: JSON.stringify(data)\n            });\n            manage.store();\n          });\n        }\n      });\n      const subItems = manage.templates.map((t2) => {\n        return {\n          content: t2.name,\n          callback: () => {\n            clipboardAction(async () => {\n              const data = JSON.parse(t2.data);\n              await GroupNodeConfig.registerFromWorkflow(data.groupNodes, {});\n              if (!data.reroutes) {\n                deserialiseAndCreate(t2.data, app.canvas);\n              } else {\n                localStorage.setItem(\"litegrapheditor_clipboard\", t2.data);\n                app.canvas.pasteFromClipboard();\n              }\n            });\n          }\n        };\n      });\n      subItems.push(null, {\n        content: \"Manage\",\n        callback: () => manage.show()\n      });\n      options.push({\n        content: \"Node Templates\",\n        submenu: {\n          options: subItems\n        }\n      });\n      return options;\n    };\n  }\n});\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\napp.registerExtension({\n  name: \"Comfy.NoteNode\",\n  registerCustomNodes() {\n    class NoteNode extends LGraphNode {\n      constructor(title) {\n        super(title);\n        __publicField$1(this, \"color\", LGraphCanvas.node_colors.yellow.color);\n        __publicField$1(this, \"bgcolor\", LGraphCanvas.node_colors.yellow.bgcolor);\n        __publicField$1(this, \"groupcolor\", LGraphCanvas.node_colors.yellow.groupcolor);\n        __publicField$1(this, \"isVirtualNode\");\n        if (!this.properties) {\n          this.properties = { text: \"\" };\n        }\n        ComfyWidgets.STRING(\n          this,\n          \"text\",\n          [\"STRING\", { default: this.properties.text, multiline: true }],\n          app\n        );\n        this.serialize_widgets = true;\n        this.isVirtualNode = true;\n      }\n    }\n    __publicField$1(NoteNode, \"category\");\n    __publicField$1(NoteNode, \"collapsable\");\n    __publicField$1(NoteNode, \"title_mode\");\n    LiteGraph.registerNodeType(\n      \"Note\",\n      Object.assign(NoteNode, {\n        title_mode: LiteGraph.NORMAL_TITLE,\n        title: \"Note\",\n        collapsable: true\n      })\n    );\n    NoteNode.category = \"utils\";\n    class MarkdownNoteNode extends LGraphNode {\n      constructor(title) {\n        super(title);\n        __publicField$1(this, \"color\", LGraphCanvas.node_colors.yellow.color);\n        __publicField$1(this, \"bgcolor\", LGraphCanvas.node_colors.yellow.bgcolor);\n        __publicField$1(this, \"groupcolor\", LGraphCanvas.node_colors.yellow.groupcolor);\n        if (!this.properties) {\n          this.properties = { text: \"\" };\n        }\n        ComfyWidgets.MARKDOWN(\n          this,\n          \"text\",\n          [\"STRING\", { default: this.properties.text }],\n          app\n        );\n        this.serialize_widgets = true;\n        this.isVirtualNode = true;\n      }\n    }\n    __publicField$1(MarkdownNoteNode, \"title\", \"Markdown Note\");\n    LiteGraph.registerNodeType(\"MarkdownNote\", MarkdownNoteNode);\n    MarkdownNoteNode.category = \"utils\";\n  }\n});\nuseExtensionService().registerExtension({\n  name: \"Comfy.PreviewAny\",\n  async beforeRegisterNodeDef(nodeType, nodeData) {\n    if (nodeData.name === \"PreviewAny\") {\n      const onNodeCreated = nodeType.prototype.onNodeCreated;\n      nodeType.prototype.onNodeCreated = function() {\n        onNodeCreated ? onNodeCreated.apply(this, []) : void 0;\n        const showValueWidget = ComfyWidgets[\"STRING\"](\n          this,\n          \"preview\",\n          [\"STRING\", { multiline: true }],\n          app\n        ).widget;\n        showValueWidget.element.readOnly = true;\n        showValueWidget.serialize = false;\n      };\n      const onExecuted = nodeType.prototype.onExecuted;\n      nodeType.prototype.onExecuted = function(message) {\n        var _a2;\n        onExecuted === null || onExecuted === void 0 ? void 0 : onExecuted.apply(this, [message]);\n        const previewWidget = (_a2 = this.widgets) == null ? void 0 : _a2.find((w) => w.name === \"preview\");\n        if (previewWidget) {\n          previewWidget.value = message.text[0];\n        }\n      };\n    }\n  }\n});\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\napp.registerExtension({\n  name: \"Comfy.RerouteNode\",\n  registerCustomNodes(app2) {\n    const _RerouteNode = class _RerouteNode2 extends LGraphNode {\n      constructor(title) {\n        super(title);\n        if (!this.properties) {\n          this.properties = {};\n        }\n        this.properties.showOutputText = _RerouteNode2.defaultVisibility;\n        this.properties.horizontal = false;\n        this.addInput(\"\", \"*\");\n        this.addOutput(this.properties.showOutputText ? \"*\" : \"\", \"*\");\n        this.onAfterGraphConfigured = function() {\n          requestAnimationFrame(() => {\n            this.onConnectionsChange(LiteGraph.INPUT, null, true, null);\n          });\n        };\n        this.onConnectionsChange = (type, _index, connected) => {\n          var _a2, _b2;\n          if (app2.configuringGraph) return;\n          if (connected && type === LiteGraph.OUTPUT) {\n            const types = new Set(\n              // @ts-expect-error fixme ts strict error\n              this.outputs[0].links.map((l) => app2.graph.links[l].type).filter((t2) => t2 !== \"*\")\n            );\n            if (types.size > 1) {\n              const linksToDisconnect = [];\n              for (let i = 0; i < this.outputs[0].links.length - 1; i++) {\n                const linkId = this.outputs[0].links[i];\n                const link = app2.graph.links[linkId];\n                linksToDisconnect.push(link);\n              }\n              for (const link of linksToDisconnect) {\n                const node = app2.graph.getNodeById(link.target_id);\n                node.disconnectInput(link.target_slot);\n              }\n            }\n          }\n          let currentNode = this;\n          let updateNodes = [];\n          let inputType = null;\n          let inputNode = null;\n          while (currentNode) {\n            updateNodes.unshift(currentNode);\n            const linkId = currentNode.inputs[0].link;\n            if (linkId !== null) {\n              const link = app2.graph.links[linkId];\n              if (!link) return;\n              const node = app2.graph.getNodeById(link.origin_id);\n              const type2 = node.constructor.type;\n              if (type2 === \"Reroute\") {\n                if (node === this) {\n                  currentNode.disconnectInput(link.target_slot);\n                  currentNode = null;\n                } else {\n                  currentNode = node;\n                }\n              } else {\n                inputNode = currentNode;\n                inputType = ((_a2 = node.outputs[link.origin_slot]) == null ? void 0 : _a2.type) ?? null;\n                break;\n              }\n            } else {\n              currentNode = null;\n              break;\n            }\n          }\n          const nodes = [this];\n          let outputType = null;\n          while (nodes.length) {\n            currentNode = nodes.pop();\n            const outputs = (\n              // @ts-expect-error fixme ts strict error\n              (currentNode.outputs ? currentNode.outputs[0].links : []) || []\n            );\n            if (outputs.length) {\n              for (const linkId of outputs) {\n                const link = app2.graph.links[linkId];\n                if (!link) continue;\n                const node = app2.graph.getNodeById(link.target_id);\n                const type2 = node.constructor.type;\n                if (type2 === \"Reroute\") {\n                  nodes.push(node);\n                  updateNodes.push(node);\n                } else {\n                  const nodeOutType = (\n                    // @ts-expect-error fixme ts strict error\n                    node.inputs && // @ts-expect-error fixme ts strict error\n                    node.inputs[link == null ? void 0 : link.target_slot] && // @ts-expect-error fixme ts strict error\n                    node.inputs[link.target_slot].type ? (\n                      // @ts-expect-error fixme ts strict error\n                      node.inputs[link.target_slot].type\n                    ) : null\n                  );\n                  if (inputType && // @ts-expect-error fixme ts strict error\n                  !LiteGraph.isValidConnection(inputType, nodeOutType)) {\n                    node.disconnectInput(link.target_slot);\n                  } else {\n                    outputType = nodeOutType;\n                  }\n                }\n              }\n            }\n          }\n          const displayType = inputType || outputType || \"*\";\n          const color = LGraphCanvas.link_type_colors[displayType];\n          let widgetConfig;\n          let widgetType;\n          for (const node of updateNodes) {\n            node.outputs[0].type = inputType || \"*\";\n            node.__outputType = displayType;\n            node.outputs[0].name = node.properties.showOutputText ? displayType : \"\";\n            node.setSize(node.computeSize());\n            for (const l of node.outputs[0].links || []) {\n              const link = app2.graph.links[l];\n              if (link) {\n                link.color = color;\n                if (app2.configuringGraph) continue;\n                const targetNode = app2.graph.getNodeById(link.target_id);\n                const targetInput = (_b2 = targetNode.inputs) == null ? void 0 : _b2[link.target_slot];\n                if (targetInput == null ? void 0 : targetInput.widget) {\n                  const config = getWidgetConfig(targetInput);\n                  if (!widgetConfig) {\n                    widgetConfig = config[1] ?? {};\n                    widgetType = config[0];\n                  }\n                  const merged = mergeIfValid(targetInput, [\n                    config[0],\n                    widgetConfig\n                  ]);\n                  if (merged.customConfig) {\n                    widgetConfig = merged.customConfig;\n                  }\n                }\n              }\n            }\n          }\n          for (const node of updateNodes) {\n            if (widgetConfig && outputType) {\n              node.inputs[0].widget = { name: \"value\" };\n              setWidgetConfig(node.inputs[0], [\n                // @ts-expect-error fixme ts strict error\n                widgetType ?? displayType,\n                widgetConfig\n              ]);\n            } else {\n              setWidgetConfig(node.inputs[0], null);\n            }\n          }\n          if (inputNode) {\n            const link = app2.graph.links[inputNode.inputs[0].link];\n            if (link) {\n              link.color = color;\n            }\n          }\n        };\n        this.clone = function() {\n          const cloned = _RerouteNode2.prototype.clone.apply(this);\n          cloned.removeOutput(0);\n          cloned.addOutput(this.properties.showOutputText ? \"*\" : \"\", \"*\");\n          cloned.setSize(cloned.computeSize());\n          return cloned;\n        };\n        this.isVirtualNode = true;\n      }\n      // @ts-expect-error fixme ts strict error\n      getExtraMenuOptions(_, options) {\n        options.unshift(\n          {\n            content: (this.properties.showOutputText ? \"Hide\" : \"Show\") + \" Type\",\n            callback: () => {\n              this.properties.showOutputText = !this.properties.showOutputText;\n              if (this.properties.showOutputText) {\n                this.outputs[0].name = this.__outputType || this.outputs[0].type;\n              } else {\n                this.outputs[0].name = \"\";\n              }\n              this.setSize(this.computeSize());\n              app2.graph.setDirtyCanvas(true, true);\n            }\n          },\n          {\n            content: (_RerouteNode2.defaultVisibility ? \"Hide\" : \"Show\") + \" Type By Default\",\n            callback: () => {\n              _RerouteNode2.setDefaultTextVisibility(\n                !_RerouteNode2.defaultVisibility\n              );\n            }\n          }\n        );\n        return [];\n      }\n      computeSize() {\n        return [\n          this.properties.showOutputText && this.outputs && this.outputs.length ? Math.max(\n            75,\n            LiteGraph.NODE_TEXT_SIZE * this.outputs[0].name.length * 0.6 + 40\n          ) : 75,\n          26\n        ];\n      }\n      // @ts-expect-error fixme ts strict error\n      static setDefaultTextVisibility(visible) {\n        _RerouteNode2.defaultVisibility = visible;\n        if (visible) {\n          localStorage[\"Comfy.RerouteNode.DefaultVisibility\"] = \"true\";\n        } else {\n          delete localStorage[\"Comfy.RerouteNode.DefaultVisibility\"];\n        }\n      }\n    };\n    __publicField(_RerouteNode, \"category\");\n    __publicField(_RerouteNode, \"defaultVisibility\", false);\n    let RerouteNode = _RerouteNode;\n    RerouteNode.setDefaultTextVisibility(\n      !!localStorage[\"Comfy.RerouteNode.DefaultVisibility\"]\n    );\n    LiteGraph.registerNodeType(\n      \"Reroute\",\n      Object.assign(RerouteNode, {\n        title_mode: LiteGraph.NO_TITLE,\n        title: \"Reroute\",\n        collapsable: false\n      })\n    );\n    RerouteNode.category = \"utils\";\n  }\n});\nconst saveNodeTypes = /* @__PURE__ */ new Set([\n  \"SaveImage\",\n  \"SaveAnimatedWEBP\",\n  \"SaveWEBM\",\n  \"SaveAudio\",\n  \"SaveGLB\",\n  \"SaveAnimatedPNG\",\n  \"CLIPSave\",\n  \"VAESave\",\n  \"ModelSave\",\n  \"LoraSave\",\n  \"SaveLatent\"\n]);\napp.registerExtension({\n  name: \"Comfy.SaveImageExtraOutput\",\n  async beforeRegisterNodeDef(nodeType, nodeData, app2) {\n    if (saveNodeTypes.has(nodeData.name)) {\n      const onNodeCreated = nodeType.prototype.onNodeCreated;\n      nodeType.prototype.onNodeCreated = function() {\n        const r = onNodeCreated ? (\n          // @ts-expect-error fixme ts strict error\n          onNodeCreated.apply(this, arguments)\n        ) : void 0;\n        const widget = this.widgets.find((w) => w.name === \"filename_prefix\");\n        widget.serializeValue = () => {\n          return applyTextReplacements(app2.graph, widget.value);\n        };\n        return r;\n      };\n    } else {\n      const onNodeCreated = nodeType.prototype.onNodeCreated;\n      nodeType.prototype.onNodeCreated = function() {\n        const r = onNodeCreated ? (\n          // @ts-expect-error fixme ts strict error\n          onNodeCreated.apply(this, arguments)\n        ) : void 0;\n        if (!this.properties || !(\"Node name for S&R\" in this.properties)) {\n          this.addProperty(\"Node name for S&R\", this.constructor.type, \"string\");\n        }\n        return r;\n      };\n    }\n  }\n});\nuseExtensionService().registerExtension({\n  name: \"Comfy.SaveGLB\",\n  async beforeRegisterNodeDef(_nodeType, nodeData) {\n    if (\"SaveGLB\" === nodeData.name) {\n      nodeData.input.required.image = [\"PREVIEW_3D\"];\n    }\n  },\n  getCustomWidgets() {\n    return {\n      PREVIEW_3D(node) {\n        const inputSpec = {\n          name: \"image\",\n          type: \"Preview3D\",\n          isAnimation: false,\n          isPreview: true\n        };\n        const widget = new ComponentWidgetImpl({\n          node,\n          name: inputSpec.name,\n          component: _sfc_main$3,\n          inputSpec,\n          options: {}\n        });\n        addWidget(node, widget);\n        return { widget };\n      }\n    };\n  },\n  async nodeCreated(node) {\n    if (node.constructor.comfyClass !== \"SaveGLB\") return;\n    const [oldWidth, oldHeight] = node.size;\n    node.setSize([Math.max(oldWidth, 400), Math.max(oldHeight, 550)]);\n    await nextTick();\n    const onExecuted = node.onExecuted;\n    node.onExecuted = function(message) {\n      var _a2;\n      onExecuted == null ? void 0 : onExecuted.apply(this, arguments);\n      const fileInfo = message[\"3d\"][0];\n      const load3d = useLoad3dService().getLoad3d(node);\n      const modelWidget = (_a2 = node.widgets) == null ? void 0 : _a2.find((w) => w.name === \"image\");\n      if (load3d && modelWidget) {\n        const filePath = fileInfo[\"subfolder\"] + \"/\" + fileInfo[\"filename\"];\n        modelWidget.value = filePath;\n        const config = new Load3DConfiguration(load3d);\n        config.configureForSaveMesh(fileInfo[\"type\"], filePath);\n      }\n    };\n  }\n});\nlet touchZooming = false;\nlet touchCount = 0;\napp.registerExtension({\n  name: \"Comfy.SimpleTouchSupport\",\n  setup() {\n    var _a2, _b2, _c;\n    let touchDist = null;\n    let touchTime = null;\n    let lastTouch = null;\n    let lastScale = null;\n    function getMultiTouchPos(e) {\n      return Math.hypot(\n        e.touches[0].clientX - e.touches[1].clientX,\n        e.touches[0].clientY - e.touches[1].clientY\n      );\n    }\n    function getMultiTouchCenter(e) {\n      return {\n        clientX: (e.touches[0].clientX + e.touches[1].clientX) / 2,\n        clientY: (e.touches[0].clientY + e.touches[1].clientY) / 2\n      };\n    }\n    (_a2 = app.canvasEl.parentElement) == null ? void 0 : _a2.addEventListener(\n      \"touchstart\",\n      (e) => {\n        var _a3, _b3;\n        touchCount += e.changedTouches.length;\n        lastTouch = null;\n        lastScale = null;\n        if (((_a3 = e.touches) == null ? void 0 : _a3.length) === 1) {\n          touchTime = /* @__PURE__ */ new Date();\n          lastTouch = e.touches[0];\n        } else {\n          touchTime = null;\n          if (((_b3 = e.touches) == null ? void 0 : _b3.length) === 2) {\n            lastScale = app.canvas.ds.scale;\n            lastTouch = getMultiTouchCenter(e);\n            touchDist = getMultiTouchPos(e);\n            app.canvas.pointer.isDown = false;\n          }\n        }\n      },\n      true\n    );\n    (_b2 = app.canvasEl.parentElement) == null ? void 0 : _b2.addEventListener(\n      \"touchend\",\n      (e) => {\n        var _a3, _b3;\n        touchCount -= e.changedTouches.length;\n        if (((_a3 = e.touches) == null ? void 0 : _a3.length) !== 1) touchZooming = false;\n        if (touchTime && !((_b3 = e.touches) == null ? void 0 : _b3.length)) {\n          if ((/* @__PURE__ */ new Date()).getTime() - touchTime.getTime() > 600) {\n            if (e.target === app.canvasEl) {\n              const touch = {\n                button: 2,\n                // Right click\n                clientX: e.changedTouches[0].clientX,\n                clientY: e.changedTouches[0].clientY,\n                pointerId: 1,\n                // changedTouches' id is 0, set it to any number\n                isPrimary: true\n                // changedTouches' isPrimary is false, so set it to true\n              };\n              app.canvasEl.dispatchEvent(new PointerEvent(\"pointerdown\", touch));\n              setTimeout(() => {\n                app.canvasEl.dispatchEvent(new PointerEvent(\"pointerup\", touch));\n              });\n              e.preventDefault();\n            }\n          }\n          touchTime = null;\n        }\n      }\n    );\n    (_c = app.canvasEl.parentElement) == null ? void 0 : _c.addEventListener(\n      \"touchmove\",\n      (e) => {\n        var _a3, _b3, _c2;\n        if (touchTime && lastTouch && ((_a3 = e.touches) == null ? void 0 : _a3.length) === 1) {\n          const onlyTouch = e.touches[0];\n          const deltaX = onlyTouch.clientX - lastTouch.clientX;\n          const deltaY = onlyTouch.clientY - lastTouch.clientY;\n          if (deltaX * deltaX + deltaY * deltaY > 30) {\n            touchTime = null;\n          }\n        }\n        if (((_b3 = e.touches) == null ? void 0 : _b3.length) === 2 && lastTouch && !e.ctrlKey && !e.shiftKey) {\n          e.preventDefault();\n          app.canvas.pointer.isDown = false;\n          touchZooming = true;\n          LiteGraph.closeAllContextMenus(window);\n          (_c2 = app.canvas.search_box) == null ? void 0 : _c2.close();\n          const newTouchDist = getMultiTouchPos(e);\n          const center = getMultiTouchCenter(e);\n          if (lastScale === null || touchDist === null) return;\n          let scale = lastScale * newTouchDist / touchDist;\n          const newX = (center.clientX - lastTouch.clientX) / scale;\n          const newY = (center.clientY - lastTouch.clientY) / scale;\n          if (scale < app.canvas.ds.min_scale) {\n            scale = app.canvas.ds.min_scale;\n          } else if (scale > app.canvas.ds.max_scale) {\n            scale = app.canvas.ds.max_scale;\n          }\n          const oldScale = app.canvas.ds.scale;\n          app.canvas.ds.scale = scale;\n          if (Math.abs(app.canvas.ds.scale - 1) < 0.01) {\n            app.canvas.ds.scale = 1;\n          }\n          const newScale = app.canvas.ds.scale;\n          const convertScaleToOffset = (scale2) => [\n            center.clientX / scale2 - app.canvas.ds.offset[0],\n            center.clientY / scale2 - app.canvas.ds.offset[1]\n          ];\n          var oldCenter = convertScaleToOffset(oldScale);\n          var newCenter = convertScaleToOffset(newScale);\n          app.canvas.ds.offset[0] += newX + newCenter[0] - oldCenter[0];\n          app.canvas.ds.offset[1] += newY + newCenter[1] - oldCenter[1];\n          lastTouch.clientX = center.clientX;\n          lastTouch.clientY = center.clientY;\n          app.canvas.setDirty(true, true);\n        }\n      },\n      true\n    );\n  }\n});\nconst processMouseDown = LGraphCanvas.prototype.processMouseDown;\nLGraphCanvas.prototype.processMouseDown = function(e) {\n  if (touchZooming || touchCount) {\n    return;\n  }\n  app.canvas.pointer.isDown = false;\n  return processMouseDown.apply(this, [e]);\n};\nconst processMouseMove = LGraphCanvas.prototype.processMouseMove;\nLGraphCanvas.prototype.processMouseMove = function(e) {\n  if (touchZooming || touchCount > 1) {\n    return;\n  }\n  return processMouseMove.apply(this, [e]);\n};\napp.registerExtension({\n  name: \"Comfy.SlotDefaults\",\n  suggestionsNumber: null,\n  init() {\n    LiteGraph.search_filter_enabled = true;\n    LiteGraph.middle_click_slot_add_default_node = true;\n    this.suggestionsNumber = app.ui.settings.addSetting({\n      id: \"Comfy.NodeSuggestions.number\",\n      category: [\"Comfy\", \"Node Search Box\", \"NodeSuggestions\"],\n      name: \"Number of nodes suggestions\",\n      tooltip: \"Only for litegraph searchbox/context menu\",\n      type: \"slider\",\n      attrs: {\n        min: 1,\n        max: 100,\n        step: 1\n      },\n      defaultValue: 5,\n      onChange: (newVal) => {\n        this.setDefaults(newVal);\n      }\n    });\n  },\n  slot_types_default_out: {},\n  slot_types_default_in: {},\n  async beforeRegisterNodeDef(nodeType, nodeData) {\n    var _a2;\n    var nodeId = nodeData.name;\n    const inputs = (_a2 = nodeData[\"input\"]) == null ? void 0 : _a2[\"required\"];\n    for (const inputKey in inputs) {\n      var input = inputs[inputKey];\n      if (typeof input[0] !== \"string\") continue;\n      var type = input[0];\n      if (type in ComfyWidgets) {\n        var customProperties = input[1];\n        if (!(customProperties == null ? void 0 : customProperties.forceInput)) continue;\n      }\n      if (!(type in this.slot_types_default_out)) {\n        this.slot_types_default_out[type] = [\"Reroute\"];\n      }\n      if (this.slot_types_default_out[type].includes(nodeId)) continue;\n      this.slot_types_default_out[type].push(nodeId);\n      const lowerType = type.toLocaleLowerCase();\n      if (!(lowerType in LiteGraph.registered_slot_in_types)) {\n        LiteGraph.registered_slot_in_types[lowerType] = { nodes: [] };\n      }\n      LiteGraph.registered_slot_in_types[lowerType].nodes.push(\n        // @ts-expect-error ComfyNode\n        nodeType.comfyClass\n      );\n    }\n    var outputs = nodeData[\"output\"] ?? [];\n    for (const el of outputs) {\n      const type2 = el;\n      if (!(type2 in this.slot_types_default_in)) {\n        this.slot_types_default_in[type2] = [\"Reroute\"];\n      }\n      if (this.slot_types_default_in[type2].includes(nodeId)) continue;\n      this.slot_types_default_in[type2].push(nodeId);\n      if (!(type2 in LiteGraph.registered_slot_out_types)) {\n        LiteGraph.registered_slot_out_types[type2] = { nodes: [] };\n      }\n      LiteGraph.registered_slot_out_types[type2].nodes.push(nodeType.comfyClass);\n      if (!LiteGraph.slot_types_out.includes(type2)) {\n        LiteGraph.slot_types_out.push(type2);\n      }\n    }\n    var maxNum = this.suggestionsNumber.value;\n    this.setDefaults(maxNum);\n  },\n  setDefaults(maxNum) {\n    LiteGraph.slot_types_default_out = {};\n    LiteGraph.slot_types_default_in = {};\n    for (const type in this.slot_types_default_out) {\n      LiteGraph.slot_types_default_out[type] = this.slot_types_default_out[type].slice(0, maxNum);\n    }\n    for (const type in this.slot_types_default_in) {\n      LiteGraph.slot_types_default_in[type] = this.slot_types_default_in[type].slice(0, maxNum);\n    }\n  }\n});\nconst createAddUniqueNumber = (generateUniqueNumber2) => {\n  return (set) => {\n    const number = generateUniqueNumber2(set);\n    set.add(number);\n    return number;\n  };\n};\nconst createCache = (lastNumberWeakMap) => {\n  return (collection, nextNumber) => {\n    lastNumberWeakMap.set(collection, nextNumber);\n    return nextNumber;\n  };\n};\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === void 0 ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\nconst TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\nconst TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\nconst createGenerateUniqueNumber = (cache2, lastNumberWeakMap) => {\n  return (collection) => {\n    const lastNumber = lastNumberWeakMap.get(collection);\n    let nextNumber = lastNumber === void 0 ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n    if (!collection.has(nextNumber)) {\n      return cache2(collection, nextNumber);\n    }\n    if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n      while (collection.has(nextNumber)) {\n        nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n      }\n      return cache2(collection, nextNumber);\n    }\n    if (collection.size > MAX_SAFE_INTEGER) {\n      throw new Error(\"Congratulations, you created a collection of unique numbers which uses all available integers!\");\n    }\n    while (collection.has(nextNumber)) {\n      nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n    }\n    return cache2(collection, nextNumber);\n  };\n};\nconst LAST_NUMBER_WEAK_MAP = /* @__PURE__ */ new WeakMap();\nconst cache = createCache(LAST_NUMBER_WEAK_MAP);\nconst generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\nconst addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\nconst isMessagePort = (sender) => {\n  return typeof sender.start === \"function\";\n};\nconst PORT_MAP = /* @__PURE__ */ new WeakMap();\nconst extendBrokerImplementation = (partialBrokerImplementation) => ({\n  ...partialBrokerImplementation,\n  connect: ({ call }) => {\n    return async () => {\n      const { port1, port2 } = new MessageChannel();\n      const portId = await call(\"connect\", { port: port1 }, [port1]);\n      PORT_MAP.set(port2, portId);\n      return port2;\n    };\n  },\n  disconnect: ({ call }) => {\n    return async (port) => {\n      const portId = PORT_MAP.get(port);\n      if (portId === void 0) {\n        throw new Error(\"The given port is not connected.\");\n      }\n      await call(\"disconnect\", { portId });\n    };\n  },\n  isSupported: ({ call }) => {\n    return () => call(\"isSupported\");\n  }\n});\nconst ONGOING_REQUESTS = /* @__PURE__ */ new WeakMap();\nconst createOrGetOngoingRequests = (sender) => {\n  if (ONGOING_REQUESTS.has(sender)) {\n    return ONGOING_REQUESTS.get(sender);\n  }\n  const ongoingRequests = /* @__PURE__ */ new Map();\n  ONGOING_REQUESTS.set(sender, ongoingRequests);\n  return ongoingRequests;\n};\nconst createBroker = (brokerImplementation) => {\n  const fullBrokerImplementation = extendBrokerImplementation(brokerImplementation);\n  return (sender) => {\n    const ongoingRequests = createOrGetOngoingRequests(sender);\n    sender.addEventListener(\"message\", ({ data: message }) => {\n      const { id: id2 } = message;\n      if (id2 !== null && ongoingRequests.has(id2)) {\n        const { reject, resolve } = ongoingRequests.get(id2);\n        ongoingRequests.delete(id2);\n        if (message.error === void 0) {\n          resolve(message.result);\n        } else {\n          reject(new Error(message.error.message));\n        }\n      }\n    });\n    if (isMessagePort(sender)) {\n      sender.start();\n    }\n    const call = (method, params = null, transferables = []) => {\n      return new Promise((resolve, reject) => {\n        const id2 = generateUniqueNumber(ongoingRequests);\n        ongoingRequests.set(id2, { reject, resolve });\n        if (params === null) {\n          sender.postMessage({ id: id2, method }, transferables);\n        } else {\n          sender.postMessage({ id: id2, method, params }, transferables);\n        }\n      });\n    };\n    const notify = (method, params, transferables = []) => {\n      sender.postMessage({ id: null, method, params }, transferables);\n    };\n    let functions = {};\n    for (const [key, handler2] of Object.entries(fullBrokerImplementation)) {\n      functions = { ...functions, [key]: handler2({ call, notify }) };\n    }\n    return { ...functions };\n  };\n};\nconst encoderIds = /* @__PURE__ */ new Set();\nconst encoderInstanceIds = /* @__PURE__ */ new Set();\nconst messagePorts = /* @__PURE__ */ new WeakMap();\nconst wrap$1 = createBroker({\n  deregister: ({ call }) => {\n    return async (port) => {\n      const encoderId = messagePorts.get(port);\n      if (encoderId === void 0) {\n        throw new Error(\"There is no encoder registered with the given port.\");\n      }\n      const result = await call(\"deregister\", { encoderId });\n      encoderIds.delete(encoderId);\n      messagePorts.delete(port);\n      return result;\n    };\n  },\n  encode: ({ call }) => {\n    return async (encoderInstanceId, timeslice) => {\n      const arrayBuffers = await call(\"encode\", { encoderInstanceId, timeslice });\n      encoderInstanceIds.delete(encoderInstanceId);\n      return arrayBuffers;\n    };\n  },\n  instantiate: ({ call }) => {\n    return async (mimeType, sampleRate) => {\n      const encoderInstanceId = addUniqueNumber(encoderInstanceIds);\n      const port = await call(\"instantiate\", { encoderInstanceId, mimeType, sampleRate });\n      return { encoderInstanceId, port };\n    };\n  },\n  register: ({ call }) => {\n    return async (port) => {\n      if (messagePorts.has(port)) {\n        throw new Error(\"\");\n      }\n      const encoderId = addUniqueNumber(encoderIds);\n      messagePorts.set(port, encoderId);\n      try {\n        return await call(\"register\", { encoderId, port }, [port]);\n      } catch (err2) {\n        encoderIds.delete(encoderId);\n        messagePorts.delete(port);\n        throw err2;\n      }\n    };\n  }\n});\nconst load$1 = (url2) => {\n  const worker2 = new Worker(url2);\n  return wrap$1(worker2);\n};\nconst worker$1 = `(()=>{var e={455:function(e,t){!function(e){\"use strict\";var t=function(e){return function(t){var r=e(t);return t.add(r),r}},r=function(e){return function(t,r){return e.set(t,r),r}},n=void 0===Number.MAX_SAFE_INTEGER?9007199254740991:Number.MAX_SAFE_INTEGER,o=536870912,s=2*o,a=function(e,t){return function(r){var a=t.get(r),c=void 0===a?r.size:a<s?a+1:0;if(!r.has(c))return e(r,c);if(r.size<o){for(;r.has(c);)c=Math.floor(Math.random()*s);return e(r,c)}if(r.size>n)throw new Error(\"Congratulations, you created a collection of unique numbers which uses all available integers!\");for(;r.has(c);)c=Math.floor(Math.random()*n);return e(r,c)}},c=new WeakMap,i=r(c),d=a(i,c),l=t(d);e.addUniqueNumber=l,e.generateUniqueNumber=d}(t)}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var s=t[n]={exports:{}};return e[n].call(s.exports,s,s.exports,r),s.exports}(()=>{\"use strict\";var e=r(455);const t=new WeakMap,n=new WeakMap,o=(r=>{const o=(s=r,{...s,connect:({call:e})=>async()=>{const{port1:r,port2:n}=new MessageChannel,o=await e(\"connect\",{port:r},[r]);return t.set(n,o),n},disconnect:({call:e})=>async r=>{const n=t.get(r);if(void 0===n)throw new Error(\"The given port is not connected.\");await e(\"disconnect\",{portId:n})},isSupported:({call:e})=>()=>e(\"isSupported\")});var s;return t=>{const r=(e=>{if(n.has(e))return n.get(e);const t=new Map;return n.set(e,t),t})(t);t.addEventListener(\"message\",(({data:e})=>{const{id:t}=e;if(null!==t&&r.has(t)){const{reject:n,resolve:o}=r.get(t);r.delete(t),void 0===e.error?o(e.result):n(new Error(e.error.message))}})),(e=>\"function\"==typeof e.start)(t)&&t.start();const s=(n,o=null,s=[])=>new Promise(((a,c)=>{const i=(0,e.generateUniqueNumber)(r);r.set(i,{reject:c,resolve:a}),null===o?t.postMessage({id:i,method:n},s):t.postMessage({id:i,method:n,params:o},s)})),a=(e,r,n=[])=>{t.postMessage({id:null,method:e,params:r},n)};let c={};for(const[e,t]of Object.entries(o))c={...c,[e]:t({call:s,notify:a})};return{...c}}})({characterize:({call:e})=>()=>e(\"characterize\"),encode:({call:e})=>(t,r)=>e(\"encode\",{recordingId:t,timeslice:r}),record:({call:e})=>async(t,r,n)=>{await e(\"record\",{recordingId:t,sampleRate:r,typedArrays:n},n.map((({buffer:e})=>e)))}}),s=-32603,a=-32602,c=-32601,i=(e,t)=>Object.assign(new Error(e),{status:t}),d=e=>i('The handler of the method called \"'.concat(e,'\" returned an unexpected result.'),s),l=(e,t)=>async({data:{id:r,method:n,params:o}})=>{const a=t[n];try{if(void 0===a)throw(e=>i('The requested method called \"'.concat(e,'\" is not supported.'),c))(n);const t=void 0===o?a():a(o);if(void 0===t)throw(e=>i('The handler of the method called \"'.concat(e,'\" returned no required result.'),s))(n);const l=t instanceof Promise?await t:t;if(null===r){if(void 0!==l.result)throw d(n)}else{if(void 0===l.result)throw d(n);const{result:t,transferables:o=[]}=l;e.postMessage({id:r,result:t},o)}}catch(t){const{message:n,status:o=-32603}=t;e.postMessage({error:{code:o,message:n},id:r})}},u=new Map,h=(t,r,n)=>({...r,connect:({port:n})=>{n.start();const o=t(n,r),s=(0,e.generateUniqueNumber)(u);return u.set(s,(()=>{o(),n.close(),u.delete(s)})),{result:s}},disconnect:({portId:e})=>{const t=u.get(e);if(void 0===t)throw(e=>i('The specified parameter called \"portId\" with the given value \"'.concat(e,'\" does not identify a port connected to this worker.'),a))(e);return t(),{result:null}},isSupported:async()=>{if(await new Promise((e=>{const t=new ArrayBuffer(0),{port1:r,port2:n}=new MessageChannel;r.onmessage=({data:t})=>e(null!==t),n.postMessage(t,[t])}))){const e=n();return{result:e instanceof Promise?await e:e}}return{result:!1}}}),w=(e,t,r=()=>!0)=>{const n=h(w,t,r),o=l(e,n);return e.addEventListener(\"message\",o),()=>e.removeEventListener(\"message\",o)},f=e=>{e.onmessage=null,e.close()},p=new Map,m=new Map,g=((e,t)=>r=>{const n=t.get(r);if(void 0===n)throw new Error(\"There was no encoder stored with the given id.\");e.delete(n),t.delete(r)})(p,m),v=new Map,y=(e=>t=>{const r=e.get(t);if(void 0===r)throw new Error(\"There was no instance of an encoder stored with the given id.\");return r})(v),M=((e,t)=>r=>{const n=t(r);return e.delete(r),n})(v,y),E=((e,t)=>r=>{const[n,o,s,a]=t(r);return s?new Promise((t=>{o.onmessage=({data:s})=>{0===s.length?(e(o),t(n.encode(r,null))):n.record(r,a,s)}})):n.encode(r,null)})(f,M),b=(e=>t=>{for(const[r,n]of Array.from(e.values()))if(r.test(t))return n;throw new Error(\"There is no encoder registered which could handle the given mimeType.\")})(p),T=((e,t,r)=>(n,o,s)=>{if(t.has(n))throw new Error('There is already an encoder instance registered with an id called \"'.concat(n,'\".'));const a=r(o),{port1:c,port2:i}=new MessageChannel,d=[a,c,!0,s];return t.set(n,d),c.onmessage=({data:t})=>{0===t.length?(e(c),d[2]=!1):a.record(n,s,t.map((e=>\"number\"==typeof e?new Float32Array(e):e)))},i})(f,v,b),I=((e,t,r)=>async(n,o)=>{const s=r(o),a=await s.characterize(),c=a.toString();if(e.has(c))throw new Error(\"There is already an encoder stored which handles exactly the same mime types.\");if(t.has(n))throw new Error('There is already an encoder registered with an id called \"'.concat(n,'\".'));return e.set(c,[a,s]),t.set(n,c),a})(p,m,o),A=(e=>(t,r)=>{const[n]=e(t);return n.encode(t,r)})(y);w(self,{deregister:async({encoderId:e})=>(g(e),{result:null}),encode:async({encoderInstanceId:e,timeslice:t})=>{const r=null===t?await E(e):await A(e,t);return{result:r,transferables:r}},instantiate:({encoderInstanceId:e,mimeType:t,sampleRate:r})=>{const n=T(e,t,r);return{result:n,transferables:[n]}},register:async({encoderId:e,port:t})=>({result:await I(e,t)})})})()})();`;\nconst blob$1 = new Blob([worker$1], { type: \"application/javascript; charset=utf-8\" });\nconst url$1 = URL.createObjectURL(blob$1);\nconst mediaEncoderHost = load$1(url$1);\nconst encode = mediaEncoderHost.encode;\nconst instantiate = mediaEncoderHost.instantiate;\nconst register$1 = mediaEncoderHost.register;\nURL.revokeObjectURL(url$1);\nconst createBlobEventFactory = (nativeBlobEventConstructor2) => {\n  return (type, blobEventInit) => {\n    if (nativeBlobEventConstructor2 === null) {\n      throw new Error(\"A native BlobEvent could not be created.\");\n    }\n    return new nativeBlobEventConstructor2(type, blobEventInit);\n  };\n};\nconst createDecodeWebMChunk = (readElementContent2, readElementType2) => {\n  return (dataView, elementType, channelCount) => {\n    const contents = [];\n    let currentElementType = elementType;\n    let offset = 0;\n    while (offset < dataView.byteLength) {\n      if (currentElementType === null) {\n        const lengthAndType = readElementType2(dataView, offset);\n        if (lengthAndType === null) {\n          break;\n        }\n        const { length, type } = lengthAndType;\n        currentElementType = type;\n        offset += length;\n      } else {\n        const contentAndLength = readElementContent2(dataView, offset, currentElementType, channelCount);\n        if (contentAndLength === null) {\n          break;\n        }\n        const { content, length } = contentAndLength;\n        currentElementType = null;\n        offset += length;\n        if (content !== null) {\n          contents.push(content);\n        }\n      }\n    }\n    return { contents, currentElementType, offset };\n  };\n};\nconst createEventTargetConstructor$1 = (createEventTarget2, wrapEventListener2) => {\n  return class EventTarget {\n    constructor(nativeEventTarget = null) {\n      this._listeners = /* @__PURE__ */ new WeakMap();\n      this._nativeEventTarget = nativeEventTarget === null ? createEventTarget2() : nativeEventTarget;\n    }\n    addEventListener(type, listener, options) {\n      if (listener !== null) {\n        let wrappedEventListener = this._listeners.get(listener);\n        if (wrappedEventListener === void 0) {\n          wrappedEventListener = wrapEventListener2(this, listener);\n          if (typeof listener === \"function\") {\n            this._listeners.set(listener, wrappedEventListener);\n          }\n        }\n        this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n      }\n    }\n    dispatchEvent(event) {\n      return this._nativeEventTarget.dispatchEvent(event);\n    }\n    removeEventListener(type, listener, options) {\n      const wrappedEventListener = listener === null ? void 0 : this._listeners.get(listener);\n      this._nativeEventTarget.removeEventListener(type, wrappedEventListener === void 0 ? null : wrappedEventListener, options);\n    }\n  };\n};\nconst createEventTargetFactory = (window2) => {\n  return () => {\n    if (window2 === null) {\n      throw new Error(\"A native EventTarget could not be created.\");\n    }\n    return window2.document.createElement(\"p\");\n  };\n};\nconst createInvalidModificationError = (message = \"\") => {\n  try {\n    return new DOMException(message, \"InvalidModificationError\");\n  } catch (err2) {\n    err2.code = 13;\n    err2.message = message;\n    err2.name = \"InvalidModificationError\";\n    return err2;\n  }\n};\nconst createInvalidStateError$1 = () => {\n  try {\n    return new DOMException(\"\", \"InvalidStateError\");\n  } catch (err2) {\n    err2.code = 11;\n    err2.name = \"InvalidStateError\";\n    return err2;\n  }\n};\nconst createMediaRecorderConstructor = (createNativeMediaRecorder, createNotSupportedError2, createWebAudioMediaRecorder2, createWebmPcmMediaRecorder2, encoderRegexes2, eventTargetConstructor2, nativeMediaRecorderConstructor2) => {\n  return class MediaRecorder extends eventTargetConstructor2 {\n    constructor(stream, options = {}) {\n      const { mimeType } = options;\n      if (nativeMediaRecorderConstructor2 !== null && // Bug #10: Safari does not yet implement the isTypeSupported() method.\n      (mimeType === void 0 || nativeMediaRecorderConstructor2.isTypeSupported !== void 0 && nativeMediaRecorderConstructor2.isTypeSupported(mimeType))) {\n        const internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor2, stream, options);\n        super(internalMediaRecorder);\n        this._internalMediaRecorder = internalMediaRecorder;\n      } else if (mimeType !== void 0 && encoderRegexes2.some((regex) => regex.test(mimeType))) {\n        super();\n        if (nativeMediaRecorderConstructor2 !== null && nativeMediaRecorderConstructor2.isTypeSupported !== void 0 && nativeMediaRecorderConstructor2.isTypeSupported(\"audio/webm; codecs=pcm\")) {\n          this._internalMediaRecorder = createWebmPcmMediaRecorder2(this, nativeMediaRecorderConstructor2, stream, mimeType);\n        } else {\n          this._internalMediaRecorder = createWebAudioMediaRecorder2(this, stream, mimeType);\n        }\n      } else {\n        if (nativeMediaRecorderConstructor2 !== null) {\n          createNativeMediaRecorder(nativeMediaRecorderConstructor2, stream, options);\n        }\n        throw createNotSupportedError2();\n      }\n      this._ondataavailable = null;\n      this._onerror = null;\n      this._onpause = null;\n      this._onresume = null;\n      this._onstart = null;\n      this._onstop = null;\n    }\n    get mimeType() {\n      return this._internalMediaRecorder.mimeType;\n    }\n    get ondataavailable() {\n      return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];\n    }\n    set ondataavailable(value) {\n      if (this._ondataavailable !== null) {\n        this.removeEventListener(\"dataavailable\", this._ondataavailable[1]);\n      }\n      if (typeof value === \"function\") {\n        const boundListener = value.bind(this);\n        this.addEventListener(\"dataavailable\", boundListener);\n        this._ondataavailable = [value, boundListener];\n      } else {\n        this._ondataavailable = null;\n      }\n    }\n    get onerror() {\n      return this._onerror === null ? this._onerror : this._onerror[0];\n    }\n    set onerror(value) {\n      if (this._onerror !== null) {\n        this.removeEventListener(\"error\", this._onerror[1]);\n      }\n      if (typeof value === \"function\") {\n        const boundListener = value.bind(this);\n        this.addEventListener(\"error\", boundListener);\n        this._onerror = [value, boundListener];\n      } else {\n        this._onerror = null;\n      }\n    }\n    get onpause() {\n      return this._onpause === null ? this._onpause : this._onpause[0];\n    }\n    set onpause(value) {\n      if (this._onpause !== null) {\n        this.removeEventListener(\"pause\", this._onpause[1]);\n      }\n      if (typeof value === \"function\") {\n        const boundListener = value.bind(this);\n        this.addEventListener(\"pause\", boundListener);\n        this._onpause = [value, boundListener];\n      } else {\n        this._onpause = null;\n      }\n    }\n    get onresume() {\n      return this._onresume === null ? this._onresume : this._onresume[0];\n    }\n    set onresume(value) {\n      if (this._onresume !== null) {\n        this.removeEventListener(\"resume\", this._onresume[1]);\n      }\n      if (typeof value === \"function\") {\n        const boundListener = value.bind(this);\n        this.addEventListener(\"resume\", boundListener);\n        this._onresume = [value, boundListener];\n      } else {\n        this._onresume = null;\n      }\n    }\n    get onstart() {\n      return this._onstart === null ? this._onstart : this._onstart[0];\n    }\n    set onstart(value) {\n      if (this._onstart !== null) {\n        this.removeEventListener(\"start\", this._onstart[1]);\n      }\n      if (typeof value === \"function\") {\n        const boundListener = value.bind(this);\n        this.addEventListener(\"start\", boundListener);\n        this._onstart = [value, boundListener];\n      } else {\n        this._onstart = null;\n      }\n    }\n    get onstop() {\n      return this._onstop === null ? this._onstop : this._onstop[0];\n    }\n    set onstop(value) {\n      if (this._onstop !== null) {\n        this.removeEventListener(\"stop\", this._onstop[1]);\n      }\n      if (typeof value === \"function\") {\n        const boundListener = value.bind(this);\n        this.addEventListener(\"stop\", boundListener);\n        this._onstop = [value, boundListener];\n      } else {\n        this._onstop = null;\n      }\n    }\n    get state() {\n      return this._internalMediaRecorder.state;\n    }\n    pause() {\n      return this._internalMediaRecorder.pause();\n    }\n    resume() {\n      return this._internalMediaRecorder.resume();\n    }\n    start(timeslice) {\n      return this._internalMediaRecorder.start(timeslice);\n    }\n    stop() {\n      return this._internalMediaRecorder.stop();\n    }\n    static isTypeSupported(mimeType) {\n      return nativeMediaRecorderConstructor2 !== null && // Bug #10: Safari does not yet implement the isTypeSupported() method.\n      nativeMediaRecorderConstructor2.isTypeSupported !== void 0 && nativeMediaRecorderConstructor2.isTypeSupported(mimeType) || encoderRegexes2.some((regex) => regex.test(mimeType));\n    }\n  };\n};\nconst createNativeBlobEventConstructor = (window2) => {\n  if (window2 !== null && window2.BlobEvent !== void 0) {\n    return window2.BlobEvent;\n  }\n  return null;\n};\nconst createNativeMediaRecorderConstructor = (window2) => {\n  if (window2 === null) {\n    return null;\n  }\n  return window2.MediaRecorder === void 0 ? null : window2.MediaRecorder;\n};\nconst createNativeMediaRecorderFactory = (createNotSupportedError2) => (nativeMediaRecorderConstructor2, stream, mediaRecorderOptions) => {\n  const bufferedBlobEventListeners = /* @__PURE__ */ new Map();\n  const dataAvailableListeners = /* @__PURE__ */ new WeakMap();\n  const errorListeners = /* @__PURE__ */ new WeakMap();\n  const flags = [];\n  const nativeMediaRecorder = new nativeMediaRecorderConstructor2(stream, mediaRecorderOptions);\n  const stopListeners = /* @__PURE__ */ new WeakMap();\n  nativeMediaRecorder.addEventListener(\"stop\", ({ isTrusted }) => {\n    if (isTrusted) {\n      setTimeout(() => flags.shift());\n    }\n  });\n  nativeMediaRecorder.addEventListener = /* @__PURE__ */ ((addEventListener) => {\n    return (type, listener, options) => {\n      let patchedEventListener = listener;\n      if (typeof listener === \"function\") {\n        if (type === \"dataavailable\") {\n          const bufferedBlobEvents = [];\n          patchedEventListener = (event) => {\n            const [[isSliced, isActive] = [false, false]] = flags;\n            if (isSliced && !isActive) {\n              bufferedBlobEvents.push(event);\n            } else {\n              listener.call(nativeMediaRecorder, event);\n            }\n          };\n          bufferedBlobEventListeners.set(listener, bufferedBlobEvents);\n          dataAvailableListeners.set(listener, patchedEventListener);\n        } else if (type === \"error\") {\n          patchedEventListener = (event) => {\n            if (event instanceof ErrorEvent) {\n              listener.call(nativeMediaRecorder, event);\n            } else {\n              listener.call(nativeMediaRecorder, new ErrorEvent(\"error\", { error: event.error }));\n            }\n          };\n          errorListeners.set(listener, patchedEventListener);\n        } else if (type === \"stop\") {\n          patchedEventListener = (event) => {\n            for (const [dataAvailableListener, bufferedBlobEvents] of bufferedBlobEventListeners.entries()) {\n              if (bufferedBlobEvents.length > 0) {\n                const [blobEvent] = bufferedBlobEvents;\n                if (bufferedBlobEvents.length > 1) {\n                  Object.defineProperty(blobEvent, \"data\", {\n                    value: new Blob(bufferedBlobEvents.map(({ data }) => data), { type: blobEvent.data.type })\n                  });\n                }\n                bufferedBlobEvents.length = 0;\n                dataAvailableListener.call(nativeMediaRecorder, blobEvent);\n              }\n            }\n            listener.call(nativeMediaRecorder, event);\n          };\n          stopListeners.set(listener, patchedEventListener);\n        }\n      }\n      return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n    };\n  })(nativeMediaRecorder.addEventListener);\n  nativeMediaRecorder.removeEventListener = /* @__PURE__ */ ((removeEventListener) => {\n    return (type, listener, options) => {\n      let patchedEventListener = listener;\n      if (typeof listener === \"function\") {\n        if (type === \"dataavailable\") {\n          bufferedBlobEventListeners.delete(listener);\n          const dataAvailableListener = dataAvailableListeners.get(listener);\n          if (dataAvailableListener !== void 0) {\n            patchedEventListener = dataAvailableListener;\n          }\n        } else if (type === \"error\") {\n          const errorListener = errorListeners.get(listener);\n          if (errorListener !== void 0) {\n            patchedEventListener = errorListener;\n          }\n        } else if (type === \"stop\") {\n          const stopListener = stopListeners.get(listener);\n          if (stopListener !== void 0) {\n            patchedEventListener = stopListener;\n          }\n        }\n      }\n      return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n    };\n  })(nativeMediaRecorder.removeEventListener);\n  nativeMediaRecorder.start = /* @__PURE__ */ ((start) => {\n    return (timeslice) => {\n      if (mediaRecorderOptions.mimeType !== void 0 && mediaRecorderOptions.mimeType.startsWith(\"audio/\") && stream.getVideoTracks().length > 0) {\n        throw createNotSupportedError2();\n      }\n      if (nativeMediaRecorder.state === \"inactive\") {\n        flags.push([timeslice !== void 0, true]);\n      }\n      return timeslice === void 0 ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);\n    };\n  })(nativeMediaRecorder.start);\n  nativeMediaRecorder.stop = /* @__PURE__ */ ((stop) => {\n    return () => {\n      if (nativeMediaRecorder.state !== \"inactive\") {\n        flags[0][1] = false;\n      }\n      stop.call(nativeMediaRecorder);\n    };\n  })(nativeMediaRecorder.stop);\n  return nativeMediaRecorder;\n};\nconst createNotSupportedError$1 = () => {\n  try {\n    return new DOMException(\"\", \"NotSupportedError\");\n  } catch (err2) {\n    err2.code = 9;\n    err2.name = \"NotSupportedError\";\n    return err2;\n  }\n};\nconst createReadElementContent = (readVariableSizeInteger2) => {\n  return (dataView, offset, type, channelCount = 2) => {\n    const lengthAndValue = readVariableSizeInteger2(dataView, offset);\n    if (lengthAndValue === null) {\n      return lengthAndValue;\n    }\n    const { length, value } = lengthAndValue;\n    if (type === \"master\") {\n      return { content: null, length };\n    }\n    if (offset + length + value > dataView.byteLength) {\n      return null;\n    }\n    if (type === \"binary\") {\n      const numberOfSamples = (value / Float32Array.BYTES_PER_ELEMENT - 1) / channelCount;\n      const content = Array.from({ length: channelCount }, () => new Float32Array(numberOfSamples));\n      for (let i = 0; i < numberOfSamples; i += 1) {\n        const elementOffset = i * channelCount + 1;\n        for (let j = 0; j < channelCount; j += 1) {\n          content[j][i] = dataView.getFloat32(offset + length + (elementOffset + j) * Float32Array.BYTES_PER_ELEMENT, true);\n        }\n      }\n      return { content, length: length + value };\n    }\n    return { content: null, length: length + value };\n  };\n};\nconst createReadElementType = (readVariableSizeInteger2) => {\n  return (dataView, offset) => {\n    const lengthAndValue = readVariableSizeInteger2(dataView, offset);\n    if (lengthAndValue === null) {\n      return lengthAndValue;\n    }\n    const { length, value } = lengthAndValue;\n    if (value === 35) {\n      return { length, type: \"binary\" };\n    }\n    if (value === 46 || value === 97 || value === 88713574 || value === 106212971 || value === 139690087 || value === 172351395 || value === 256095861) {\n      return { length, type: \"master\" };\n    }\n    return { length, type: \"unknown\" };\n  };\n};\nconst createReadVariableSizeInteger = (readVariableSizeIntegerLength2) => {\n  return (dataView, offset) => {\n    const length = readVariableSizeIntegerLength2(dataView, offset);\n    if (length === null) {\n      return length;\n    }\n    const firstDataByteOffset = offset + Math.floor((length - 1) / 8);\n    if (firstDataByteOffset + length > dataView.byteLength) {\n      return null;\n    }\n    const firstDataByte = dataView.getUint8(firstDataByteOffset);\n    let value = firstDataByte & (1 << 8 - length % 8) - 1;\n    for (let i = 1; i < length; i += 1) {\n      value = (value << 8) + dataView.getUint8(firstDataByteOffset + i);\n    }\n    return { length, value };\n  };\n};\nconst observable = Symbol.observable || \"@@observable\";\nfunction patch(arg) {\n  if (!Symbol.observable) {\n    if (typeof arg === \"function\" && arg.prototype && arg.prototype[Symbol.observable]) {\n      arg.prototype[observable] = arg.prototype[Symbol.observable];\n      delete arg.prototype[Symbol.observable];\n    } else {\n      arg[observable] = arg[Symbol.observable];\n      delete arg[Symbol.observable];\n    }\n  }\n  return arg;\n}\nconst noop = () => {\n};\nconst rethrow = (error) => {\n  throw error;\n};\nfunction toObserver(observer) {\n  if (observer) {\n    if (observer.next && observer.error && observer.complete) {\n      return observer;\n    }\n    return {\n      complete: (observer.complete ?? noop).bind(observer),\n      error: (observer.error ?? rethrow).bind(observer),\n      next: (observer.next ?? noop).bind(observer)\n    };\n  }\n  return {\n    complete: noop,\n    error: rethrow,\n    next: noop\n  };\n}\nconst createOn = (wrapSubscribeFunction2) => {\n  return (target, type, options) => wrapSubscribeFunction2((observer) => {\n    const listener = (event) => observer.next(event);\n    target.addEventListener(type, listener, options);\n    return () => target.removeEventListener(type, listener, options);\n  });\n};\nconst createWrapSubscribeFunction = (patch2, toObserver2) => {\n  const emptyFunction = () => {\n  };\n  const isNextFunction = (args) => typeof args[0] === \"function\";\n  return (innerSubscribe) => {\n    const subscribe = (...args) => {\n      const unsubscribe = innerSubscribe(isNextFunction(args) ? toObserver2({ next: args[0] }) : toObserver2(...args));\n      if (unsubscribe !== void 0) {\n        return unsubscribe;\n      }\n      return emptyFunction;\n    };\n    subscribe[Symbol.observable] = () => ({\n      subscribe: (...args) => ({ unsubscribe: subscribe(...args) })\n    });\n    return patch2(subscribe);\n  };\n};\nconst wrapSubscribeFunction = createWrapSubscribeFunction(patch, toObserver);\nconst on = createOn(wrapSubscribeFunction);\nconst createAddRecorderAudioWorkletModule = (blobConstructor, urlConstructor, worklet2) => {\n  return async (addAudioWorkletModule2) => {\n    const blob2 = new blobConstructor([worklet2], { type: \"application/javascript; charset=utf-8\" });\n    const url2 = urlConstructor.createObjectURL(blob2);\n    try {\n      await addAudioWorkletModule2(url2);\n    } finally {\n      urlConstructor.revokeObjectURL(url2);\n    }\n  };\n};\nconst createListener = (ongoingRequests) => {\n  return ({ data: message }) => {\n    const { id: id2 } = message;\n    if (id2 !== null) {\n      const ongoingRequest = ongoingRequests.get(id2);\n      if (ongoingRequest !== void 0) {\n        const { reject, resolve } = ongoingRequest;\n        ongoingRequests.delete(id2);\n        if (message.error === void 0) {\n          resolve(message.result);\n        } else {\n          reject(new Error(message.error.message));\n        }\n      }\n    }\n  };\n};\nconst createPostMessageFactory = (generateUniqueNumber2) => {\n  return (ongoingRequests, port) => {\n    return (message, transferables = []) => {\n      return new Promise((resolve, reject) => {\n        const id2 = generateUniqueNumber2(ongoingRequests);\n        ongoingRequests.set(id2, { reject, resolve });\n        port.postMessage({ id: id2, ...message }, transferables);\n      });\n    };\n  };\n};\nconst createRecorderAudioWorkletNodeFactory = (createListener2, createPostMessage, on2, validateState2) => {\n  return (audioWorkletNodeConstructor2, context, options = {}) => {\n    const audioWorkletNode = new audioWorkletNodeConstructor2(context, \"recorder-audio-worklet-processor\", {\n      ...options,\n      channelCountMode: \"explicit\",\n      numberOfInputs: 1,\n      numberOfOutputs: 0\n    });\n    const ongoingRequests = /* @__PURE__ */ new Map();\n    const postMessage = createPostMessage(ongoingRequests, audioWorkletNode.port);\n    const unsubscribe = on2(audioWorkletNode.port, \"message\")(createListener2(ongoingRequests));\n    audioWorkletNode.port.start();\n    let state = \"inactive\";\n    Object.defineProperties(audioWorkletNode, {\n      pause: {\n        get() {\n          return async () => {\n            validateState2([\"recording\"], state);\n            state = \"paused\";\n            return postMessage({\n              method: \"pause\"\n            });\n          };\n        }\n      },\n      port: {\n        get() {\n          throw new Error(\"The port of a RecorderAudioWorkletNode can't be accessed.\");\n        }\n      },\n      record: {\n        get() {\n          return async (encoderPort) => {\n            validateState2([\"inactive\"], state);\n            state = \"recording\";\n            return postMessage({\n              method: \"record\",\n              params: { encoderPort }\n            }, [encoderPort]);\n          };\n        }\n      },\n      resume: {\n        get() {\n          return async () => {\n            validateState2([\"paused\"], state);\n            state = \"recording\";\n            return postMessage({\n              method: \"resume\"\n            });\n          };\n        }\n      },\n      stop: {\n        get() {\n          return async () => {\n            validateState2([\"paused\", \"recording\"], state);\n            state = \"stopped\";\n            try {\n              await postMessage({ method: \"stop\" });\n            } finally {\n              unsubscribe();\n            }\n          };\n        }\n      }\n    });\n    return audioWorkletNode;\n  };\n};\nconst validateState = (expectedStates, currentState) => {\n  if (!expectedStates.includes(currentState)) {\n    throw new Error(`Expected the state to be ${expectedStates.map((expectedState) => `\"${expectedState}\"`).join(\" or \")} but it was \"${currentState}\".`);\n  }\n};\nconst worklet = `(()=>{\"use strict\";class e extends AudioWorkletProcessor{constructor(){super(),this._encoderPort=null,this._numberOfChannels=0,this._state=\"inactive\",this.port.onmessage=({data:e})=>{\"pause\"===e.method?\"active\"===this._state||\"recording\"===this._state?(this._state=\"paused\",this._sendAcknowledgement(e.id)):this._sendUnexpectedStateError(e.id):\"record\"===e.method?\"inactive\"===this._state?(this._encoderPort=e.params.encoderPort,this._state=\"active\",this._sendAcknowledgement(e.id)):this._sendUnexpectedStateError(e.id):\"resume\"===e.method?\"paused\"===this._state?(this._state=\"active\",this._sendAcknowledgement(e.id)):this._sendUnexpectedStateError(e.id):\"stop\"===e.method?\"active\"!==this._state&&\"paused\"!==this._state&&\"recording\"!==this._state||null===this._encoderPort?this._sendUnexpectedStateError(e.id):(this._stop(this._encoderPort),this._sendAcknowledgement(e.id)):\"number\"==typeof e.id&&this.port.postMessage({error:{code:-32601,message:\"The requested method is not supported.\"},id:e.id})}}process([e]){if(\"inactive\"===this._state||\"paused\"===this._state)return!0;if(\"active\"===this._state){if(void 0===e)throw new Error(\"No channelData was received for the first input.\");if(0===e.length)return!0;this._state=\"recording\"}if(\"recording\"===this._state&&null!==this._encoderPort){if(void 0===e)throw new Error(\"No channelData was received for the first input.\");return 0===e.length?this._encoderPort.postMessage(Array.from({length:this._numberOfChannels},(()=>128))):(this._encoderPort.postMessage(e,e.map((({buffer:e})=>e))),this._numberOfChannels=e.length),!0}return!1}_sendAcknowledgement(e){this.port.postMessage({id:e,result:null})}_sendUnexpectedStateError(e){this.port.postMessage({error:{code:-32603,message:\"The internal state does not allow to process the given message.\"},id:e})}_stop(e){e.postMessage([]),e.close(),this._encoderPort=null,this._state=\"stopped\"}}e.parameterDescriptors=[],registerProcessor(\"recorder-audio-worklet-processor\",e)})();`;\nconst addRecorderAudioWorkletModule = createAddRecorderAudioWorkletModule(Blob, URL, worklet);\nconst createRecorderAudioWorkletNode = createRecorderAudioWorkletNodeFactory(createListener, createPostMessageFactory(generateUniqueNumber), on, validateState);\nconst createExtendedExponentialRampToValueAutomationEvent = (value, endTime, insertTime) => {\n  return { endTime, insertTime, type: \"exponentialRampToValue\", value };\n};\nconst createExtendedLinearRampToValueAutomationEvent = (value, endTime, insertTime) => {\n  return { endTime, insertTime, type: \"linearRampToValue\", value };\n};\nconst createSetValueAutomationEvent = (value, startTime) => {\n  return { startTime, type: \"setValue\", value };\n};\nconst createSetValueCurveAutomationEvent = (values, startTime, duration) => {\n  return { duration, startTime, type: \"setValueCurve\", values };\n};\nconst getTargetValueAtTime = (time, valueAtStartTime, { startTime, target, timeConstant }) => {\n  return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n};\nconst isExponentialRampToValueAutomationEvent = (automationEvent) => {\n  return automationEvent.type === \"exponentialRampToValue\";\n};\nconst isLinearRampToValueAutomationEvent = (automationEvent) => {\n  return automationEvent.type === \"linearRampToValue\";\n};\nconst isAnyRampToValueAutomationEvent = (automationEvent) => {\n  return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n};\nconst isSetValueAutomationEvent = (automationEvent) => {\n  return automationEvent.type === \"setValue\";\n};\nconst isSetValueCurveAutomationEvent = (automationEvent) => {\n  return automationEvent.type === \"setValueCurve\";\n};\nconst getValueOfAutomationEventAtIndexAtTime = (automationEvents, index, time, defaultValue) => {\n  const automationEvent = automationEvents[index];\n  return automationEvent === void 0 ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n};\nconst getEndTimeAndValueOfPreviousAutomationEvent = (automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) => {\n  return currentAutomationEvent === void 0 ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [\n    currentAutomationEvent.startTime + currentAutomationEvent.duration,\n    currentAutomationEvent.values[currentAutomationEvent.values.length - 1]\n  ] : [\n    currentAutomationEvent.startTime,\n    getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)\n  ];\n};\nconst isCancelAndHoldAutomationEvent = (automationEvent) => {\n  return automationEvent.type === \"cancelAndHold\";\n};\nconst isCancelScheduledValuesAutomationEvent = (automationEvent) => {\n  return automationEvent.type === \"cancelScheduledValues\";\n};\nconst getEventTime = (automationEvent) => {\n  if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n    return automationEvent.cancelTime;\n  }\n  if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n    return automationEvent.endTime;\n  }\n  return automationEvent.startTime;\n};\nconst getExponentialRampValueAtTime = (time, startTime, valueAtStartTime, { endTime, value }) => {\n  if (valueAtStartTime === value) {\n    return value;\n  }\n  if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n    return valueAtStartTime * (value / valueAtStartTime) ** ((time - startTime) / (endTime - startTime));\n  }\n  return 0;\n};\nconst getLinearRampValueAtTime = (time, startTime, valueAtStartTime, { endTime, value }) => {\n  return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n};\nconst interpolateValue = (values, theoreticIndex) => {\n  const lowerIndex = Math.floor(theoreticIndex);\n  const upperIndex = Math.ceil(theoreticIndex);\n  if (lowerIndex === upperIndex) {\n    return values[lowerIndex];\n  }\n  return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n};\nconst getValueCurveValueAtTime = (time, { duration, startTime, values }) => {\n  const theoreticIndex = (time - startTime) / duration * (values.length - 1);\n  return interpolateValue(values, theoreticIndex);\n};\nconst isSetTargetAutomationEvent = (automationEvent) => {\n  return automationEvent.type === \"setTarget\";\n};\nclass AutomationEventList {\n  constructor(defaultValue) {\n    this._automationEvents = [];\n    this._currenTime = 0;\n    this._defaultValue = defaultValue;\n  }\n  [Symbol.iterator]() {\n    return this._automationEvents[Symbol.iterator]();\n  }\n  add(automationEvent) {\n    const eventTime = getEventTime(automationEvent);\n    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n      const index = this._automationEvents.findIndex((currentAutomationEvent) => {\n        if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n          return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n        }\n        return getEventTime(currentAutomationEvent) >= eventTime;\n      });\n      const removedAutomationEvent = this._automationEvents[index];\n      if (index !== -1) {\n        this._automationEvents = this._automationEvents.slice(0, index);\n      }\n      if (isCancelAndHoldAutomationEvent(automationEvent)) {\n        const lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n        if (removedAutomationEvent !== void 0 && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n          if (lastAutomationEvent !== void 0 && isSetTargetAutomationEvent(lastAutomationEvent)) {\n            throw new Error(\"The internal list is malformed.\");\n          }\n          const startTime = lastAutomationEvent === void 0 ? removedAutomationEvent.insertTime : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n          const startValue = lastAutomationEvent === void 0 ? this._defaultValue : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n          const value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n          const truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n          this._automationEvents.push(truncatedAutomationEvent);\n        }\n        if (lastAutomationEvent !== void 0 && isSetTargetAutomationEvent(lastAutomationEvent)) {\n          this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n        }\n        if (lastAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n          const duration = eventTime - lastAutomationEvent.startTime;\n          const ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;\n          const length = Math.max(2, 1 + Math.ceil(duration * ratio));\n          const fraction = duration / (length - 1) * ratio;\n          const values = lastAutomationEvent.values.slice(0, length);\n          if (fraction < 1) {\n            for (let i = 1; i < length; i += 1) {\n              const factor = fraction * i % 1;\n              values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;\n            }\n          }\n          this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(values, lastAutomationEvent.startTime, duration);\n        }\n      }\n    } else {\n      const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > eventTime);\n      const previousAutomationEvent = index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[index - 1];\n      if (previousAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n        return false;\n      }\n      const persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n      if (index === -1) {\n        this._automationEvents.push(persistentAutomationEvent);\n      } else {\n        if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[index])) {\n          return false;\n        }\n        this._automationEvents.splice(index, 0, persistentAutomationEvent);\n      }\n    }\n    return true;\n  }\n  flush(time) {\n    const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > time);\n    if (index > 1) {\n      const remainingAutomationEvents = this._automationEvents.slice(index - 1);\n      const firstRemainingAutomationEvent = remainingAutomationEvents[0];\n      if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n        remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n      }\n      this._automationEvents = remainingAutomationEvents;\n    }\n  }\n  getValue(time) {\n    if (this._automationEvents.length === 0) {\n      return this._defaultValue;\n    }\n    const indexOfNextEvent = this._automationEvents.findIndex((automationEvent) => getEventTime(automationEvent) > time);\n    const nextAutomationEvent = this._automationEvents[indexOfNextEvent];\n    const indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;\n    const currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];\n    if (currentAutomationEvent !== void 0 && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n      return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n    }\n    if (currentAutomationEvent !== void 0 && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n      return currentAutomationEvent.value;\n    }\n    if (currentAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n      if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n        return getValueCurveValueAtTime(time, currentAutomationEvent);\n      }\n      return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n    }\n    if (currentAutomationEvent !== void 0 && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n      return currentAutomationEvent.value;\n    }\n    if (nextAutomationEvent !== void 0 && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n      const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);\n      return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n    }\n    if (nextAutomationEvent !== void 0 && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n      const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);\n      return getLinearRampValueAtTime(time, startTime, value, nextAutomationEvent);\n    }\n    return this._defaultValue;\n  }\n}\nconst createCancelAndHoldAutomationEvent = (cancelTime) => {\n  return { cancelTime, type: \"cancelAndHold\" };\n};\nconst createCancelScheduledValuesAutomationEvent = (cancelTime) => {\n  return { cancelTime, type: \"cancelScheduledValues\" };\n};\nconst createExponentialRampToValueAutomationEvent = (value, endTime) => {\n  return { endTime, type: \"exponentialRampToValue\", value };\n};\nconst createLinearRampToValueAutomationEvent = (value, endTime) => {\n  return { endTime, type: \"linearRampToValue\", value };\n};\nconst createSetTargetAutomationEvent = (target, startTime, timeConstant) => {\n  return { startTime, target, timeConstant, type: \"setTarget\" };\n};\nconst createAbortError = () => new DOMException(\"\", \"AbortError\");\nconst createAddActiveInputConnectionToAudioNode = (insertElementInSet2) => {\n  return (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n    insertElementInSet2(activeInputs[input], [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n  };\n};\nconst createAddAudioNodeConnections = (audioNodeConnectionsStore) => {\n  return (audioNode, audioNodeRenderer, nativeAudioNode) => {\n    const activeInputs = [];\n    for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n      activeInputs.push(/* @__PURE__ */ new Set());\n    }\n    audioNodeConnectionsStore.set(audioNode, {\n      activeInputs,\n      outputs: /* @__PURE__ */ new Set(),\n      passiveInputs: /* @__PURE__ */ new WeakMap(),\n      renderer: audioNodeRenderer\n    });\n  };\n};\nconst createAddAudioParamConnections = (audioParamConnectionsStore) => {\n  return (audioParam, audioParamRenderer) => {\n    audioParamConnectionsStore.set(audioParam, { activeInputs: /* @__PURE__ */ new Set(), passiveInputs: /* @__PURE__ */ new WeakMap(), renderer: audioParamRenderer });\n  };\n};\nconst ACTIVE_AUDIO_NODE_STORE = /* @__PURE__ */ new WeakSet();\nconst AUDIO_NODE_CONNECTIONS_STORE = /* @__PURE__ */ new WeakMap();\nconst AUDIO_NODE_STORE = /* @__PURE__ */ new WeakMap();\nconst AUDIO_PARAM_CONNECTIONS_STORE = /* @__PURE__ */ new WeakMap();\nconst AUDIO_PARAM_STORE = /* @__PURE__ */ new WeakMap();\nconst CONTEXT_STORE = /* @__PURE__ */ new WeakMap();\nconst EVENT_LISTENERS = /* @__PURE__ */ new WeakMap();\nconst CYCLE_COUNTERS = /* @__PURE__ */ new WeakMap();\nconst NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = /* @__PURE__ */ new WeakMap();\nconst NODE_TO_PROCESSOR_MAPS = /* @__PURE__ */ new WeakMap();\nconst handler = {\n  construct() {\n    return handler;\n  }\n};\nconst isConstructible = (constructible) => {\n  try {\n    const proxy = new Proxy(constructible, handler);\n    new proxy();\n  } catch {\n    return false;\n  }\n  return true;\n};\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/;\nconst splitImportStatements = (source, url2) => {\n  const importStatements = [];\n  let sourceWithoutImportStatements = source.replace(/^[\\s]+/, \"\");\n  let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n  while (result !== null) {\n    const unresolvedUrl = result[1].slice(1, -1);\n    const importStatementWithResolvedUrl = result[0].replace(/([\\s]+)?;?$/, \"\").replace(unresolvedUrl, new URL(unresolvedUrl, url2).toString());\n    importStatements.push(importStatementWithResolvedUrl);\n    sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, \"\");\n    result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n  }\n  return [importStatements.join(\";\"), sourceWithoutImportStatements];\n};\nconst verifyParameterDescriptors = (parameterDescriptors) => {\n  if (parameterDescriptors !== void 0 && !Array.isArray(parameterDescriptors)) {\n    throw new TypeError(\"The parameterDescriptors property of given value for processorCtor is not an array.\");\n  }\n};\nconst verifyProcessorCtor = (processorCtor) => {\n  if (!isConstructible(processorCtor)) {\n    throw new TypeError(\"The given value for processorCtor should be a constructor.\");\n  }\n  if (processorCtor.prototype === null || typeof processorCtor.prototype !== \"object\") {\n    throw new TypeError(\"The given value for processorCtor should have a prototype.\");\n  }\n};\nconst createAddAudioWorkletModule = (cacheTestResult2, createNotSupportedError2, evaluateSource, exposeCurrentFrameAndCurrentTime2, fetchSource, getNativeContext2, getOrCreateBackupOfflineAudioContext2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window2) => {\n  let index = 0;\n  return (context, moduleURL, options = { credentials: \"omit\" }) => {\n    const resolvedRequestsOfContext = resolvedRequests.get(context);\n    if (resolvedRequestsOfContext !== void 0 && resolvedRequestsOfContext.has(moduleURL)) {\n      return Promise.resolve();\n    }\n    const ongoingRequestsOfContext = ongoingRequests.get(context);\n    if (ongoingRequestsOfContext !== void 0) {\n      const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n      if (promiseOfOngoingRequest !== void 0) {\n        return promiseOfOngoingRequest;\n      }\n    }\n    const nativeContext = getNativeContext2(context);\n    const promise = nativeContext.audioWorklet === void 0 ? fetchSource(moduleURL).then(([source, absoluteUrl]) => {\n      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n      const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n      return evaluateSource(wrappedSource);\n    }).then(() => {\n      const evaluateAudioWorkletGlobalScope = window2._AWGS.pop();\n      if (evaluateAudioWorkletGlobalScope === void 0) {\n        throw new SyntaxError();\n      }\n      exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {\n      }, void 0, (name, processorCtor) => {\n        if (name.trim() === \"\") {\n          throw createNotSupportedError2();\n        }\n        const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n        if (nodeNameToProcessorConstructorMap !== void 0) {\n          if (nodeNameToProcessorConstructorMap.has(name)) {\n            throw createNotSupportedError2();\n          }\n          verifyProcessorCtor(processorCtor);\n          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n          nodeNameToProcessorConstructorMap.set(name, processorCtor);\n        } else {\n          verifyProcessorCtor(processorCtor);\n          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, /* @__PURE__ */ new Map([[name, processorCtor]]));\n        }\n      }, nativeContext.sampleRate, void 0, void 0));\n    }) : Promise.all([\n      fetchSource(moduleURL),\n      Promise.resolve(cacheTestResult2(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))\n    ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {\n      const currentIndex = index + 1;\n      index = currentIndex;\n      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n      const patchedAudioWorkletProcessor = isSupportingPostMessage ? \"AudioWorkletProcessor\" : \"class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}\";\n      const memberDefinition = isSupportingPostMessage ? \"\" : \"__c = (a) => a.forEach(e=>this.__b.add(e.buffer));\";\n      const bufferRegistration = isSupportingPostMessage ? \"\" : \"i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));\";\n      const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;\n      const blob2 = new Blob([wrappedSource], { type: \"application/javascript; charset=utf-8\" });\n      const url2 = URL.createObjectURL(blob2);\n      return nativeContext.audioWorklet.addModule(url2, options).then(() => {\n        if (isNativeOfflineAudioContext2(nativeContext)) {\n          return nativeContext;\n        }\n        const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext2(nativeContext);\n        return backupOfflineAudioContext.audioWorklet.addModule(url2, options).then(() => backupOfflineAudioContext);\n      }).then((nativeContextOrBackupOfflineAudioContext) => {\n        if (nativeAudioWorkletNodeConstructor2 === null) {\n          throw new SyntaxError();\n        }\n        try {\n          new nativeAudioWorkletNodeConstructor2(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`);\n        } catch {\n          throw new SyntaxError();\n        }\n      }).finally(() => URL.revokeObjectURL(url2));\n    });\n    if (ongoingRequestsOfContext === void 0) {\n      ongoingRequests.set(context, /* @__PURE__ */ new Map([[moduleURL, promise]]));\n    } else {\n      ongoingRequestsOfContext.set(moduleURL, promise);\n    }\n    promise.then(() => {\n      const updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n      if (updatedResolvedRequestsOfContext === void 0) {\n        resolvedRequests.set(context, /* @__PURE__ */ new Set([moduleURL]));\n      } else {\n        updatedResolvedRequestsOfContext.add(moduleURL);\n      }\n    }).finally(() => {\n      const updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n      if (updatedOngoingRequestsOfContext !== void 0) {\n        updatedOngoingRequestsOfContext.delete(moduleURL);\n      }\n    });\n    return promise;\n  };\n};\nconst getValueForKey = (map, key) => {\n  const value = map.get(key);\n  if (value === void 0) {\n    throw new Error(\"A value with the given key could not be found.\");\n  }\n  return value;\n};\nconst pickElementFromSet = (set, predicate) => {\n  const matchingElements = Array.from(set).filter(predicate);\n  if (matchingElements.length > 1) {\n    throw Error(\"More than one element was found.\");\n  }\n  if (matchingElements.length === 0) {\n    throw Error(\"No element was found.\");\n  }\n  const [matchingElement] = matchingElements;\n  set.delete(matchingElement);\n  return matchingElement;\n};\nconst deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {\n  const passiveInputConnections = getValueForKey(passiveInputs, source);\n  const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input);\n  if (passiveInputConnections.size === 0) {\n    passiveInputs.delete(source);\n  }\n  return matchingConnection;\n};\nconst getEventListenersOfAudioNode = (audioNode) => {\n  return getValueForKey(EVENT_LISTENERS, audioNode);\n};\nconst setInternalStateToActive = (audioNode) => {\n  if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n    throw new Error(\"The AudioNode is already stored.\");\n  }\n  ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n  getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));\n};\nconst isAudioWorkletNode = (audioNode) => {\n  return \"port\" in audioNode;\n};\nconst setInternalStateToPassive = (audioNode) => {\n  if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n    throw new Error(\"The AudioNode is not stored.\");\n  }\n  ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n  getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));\n};\nconst setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {\n  if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections2) => connections2.size === 0)) {\n    setInternalStateToPassive(audioNode);\n  }\n};\nconst createAddConnectionToAudioNode = (addActiveInputConnectionToAudioNode2, addPassiveInputConnectionToAudioNode2, connectNativeAudioNodeToNativeAudioNode2, deleteActiveInputConnectionToAudioNode2, disconnectNativeAudioNodeFromNativeAudioNode2, getAudioNodeConnections2, getAudioNodeTailTime2, getEventListenersOfAudioNode2, getNativeAudioNode2, insertElementInSet2, isActiveAudioNode2, isPartOfACycle2, isPassiveAudioNode2) => {\n  const tailTimeTimeoutIds = /* @__PURE__ */ new WeakMap();\n  return (source, destination, output, input, isOffline) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections2(destination);\n    const { outputs } = getAudioNodeConnections2(source);\n    const eventListeners = getEventListenersOfAudioNode2(source);\n    const eventListener = (isActive) => {\n      const nativeDestinationAudioNode = getNativeAudioNode2(destination);\n      const nativeSourceAudioNode = getNativeAudioNode2(source);\n      if (isActive) {\n        const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        addActiveInputConnectionToAudioNode2(activeInputs, source, partialConnection, false);\n        if (!isOffline && !isPartOfACycle2(source)) {\n          connectNativeAudioNodeToNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n        }\n        if (isPassiveAudioNode2(destination)) {\n          setInternalStateToActive(destination);\n        }\n      } else {\n        const partialConnection = deleteActiveInputConnectionToAudioNode2(activeInputs, source, output, input);\n        addPassiveInputConnectionToAudioNode2(passiveInputs, input, partialConnection, false);\n        if (!isOffline && !isPartOfACycle2(source)) {\n          disconnectNativeAudioNodeFromNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n        }\n        const tailTime = getAudioNodeTailTime2(destination);\n        if (tailTime === 0) {\n          if (isActiveAudioNode2(destination)) {\n            setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n          }\n        } else {\n          const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);\n          if (tailTimeTimeoutId !== void 0) {\n            clearTimeout(tailTimeTimeoutId);\n          }\n          tailTimeTimeoutIds.set(destination, setTimeout(() => {\n            if (isActiveAudioNode2(destination)) {\n              setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n            }\n          }, tailTime * 1e3));\n        }\n      }\n    };\n    if (insertElementInSet2(outputs, [destination, output, input], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {\n      eventListeners.add(eventListener);\n      if (isActiveAudioNode2(source)) {\n        addActiveInputConnectionToAudioNode2(activeInputs, source, [output, input, eventListener], true);\n      } else {\n        addPassiveInputConnectionToAudioNode2(passiveInputs, input, [source, output, eventListener], true);\n      }\n      return true;\n    }\n    return false;\n  };\n};\nconst createAddPassiveInputConnectionToAudioNode = (insertElementInSet2) => {\n  return (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === void 0) {\n      passiveInputs.set(source, /* @__PURE__ */ new Set([[output, input, eventListener]]));\n    } else {\n      insertElementInSet2(passiveInputConnections, [output, input, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input, ignoreDuplicates);\n    }\n  };\n};\nconst createAddSilentConnection = (createNativeGainNode2) => {\n  return (nativeContext, nativeAudioScheduledSourceNode) => {\n    const nativeGainNode = createNativeGainNode2(nativeContext, {\n      channelCount: 1,\n      channelCountMode: \"explicit\",\n      channelInterpretation: \"discrete\",\n      gain: 0\n    });\n    nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);\n    const disconnect = () => {\n      nativeAudioScheduledSourceNode.removeEventListener(\"ended\", disconnect);\n      nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n      nativeGainNode.disconnect();\n    };\n    nativeAudioScheduledSourceNode.addEventListener(\"ended\", disconnect);\n  };\n};\nconst createAddUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes2) => {\n  return (nativeContext, audioWorkletNode) => {\n    getUnrenderedAudioWorkletNodes2(nativeContext).add(audioWorkletNode);\n  };\n};\nconst isOwnedByContext = (nativeAudioNode, nativeContext) => {\n  return nativeAudioNode.context === nativeContext;\n};\nconst testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {\n  try {\n    nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n  } catch {\n    return false;\n  }\n  return true;\n};\nconst createIndexSizeError = () => new DOMException(\"\", \"IndexSizeError\");\nconst wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {\n  audioBuffer.getChannelData = /* @__PURE__ */ ((getChannelData) => {\n    return (channel) => {\n      try {\n        return getChannelData.call(audioBuffer, channel);\n      } catch (err2) {\n        if (err2.code === 12) {\n          throw createIndexSizeError();\n        }\n        throw err2;\n      }\n    };\n  })(audioBuffer.getChannelData);\n};\nconst DEFAULT_OPTIONS$2 = {\n  numberOfChannels: 1\n};\nconst createAudioBufferConstructor = (audioBufferStore2, cacheTestResult2, createNotSupportedError2, nativeAudioBufferConstructor2, nativeOfflineAudioContextConstructor2, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {\n  let nativeOfflineAudioContext = null;\n  return class AudioBuffer {\n    constructor(options) {\n      if (nativeOfflineAudioContextConstructor2 === null) {\n        throw new Error(\"Missing the native OfflineAudioContext constructor.\");\n      }\n      const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS$2, ...options };\n      if (nativeOfflineAudioContext === null) {\n        nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);\n      }\n      const audioBuffer = nativeAudioBufferConstructor2 !== null && cacheTestResult2(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor2({ length, numberOfChannels, sampleRate }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n      if (audioBuffer.numberOfChannels === 0) {\n        throw createNotSupportedError2();\n      }\n      if (typeof audioBuffer.copyFromChannel !== \"function\") {\n        wrapAudioBufferCopyChannelMethods2(audioBuffer);\n        wrapAudioBufferGetChannelDataMethod(audioBuffer);\n      } else if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n        wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);\n      }\n      audioBufferStore2.add(audioBuffer);\n      return audioBuffer;\n    }\n    static [Symbol.hasInstance](instance) {\n      return instance !== null && typeof instance === \"object\" && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore2.has(instance);\n    }\n  };\n};\nconst MOST_NEGATIVE_SINGLE_FLOAT = -34028234663852886e22;\nconst MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\nconst isActiveAudioNode = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);\nconst DEFAULT_OPTIONS$1 = {\n  buffer: null,\n  channelCount: 2,\n  channelCountMode: \"max\",\n  channelInterpretation: \"speakers\",\n  // Bug #149: Safari does not yet support the detune AudioParam.\n  loop: false,\n  loopEnd: 0,\n  loopStart: 0,\n  playbackRate: 1\n};\nconst createAudioBufferSourceNodeConstructor = (audioNodeConstructor2, createAudioBufferSourceNodeRenderer2, createAudioParam2, createInvalidStateError2, createNativeAudioBufferSourceNode2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener2) => {\n  return class AudioBufferSourceNode extends audioNodeConstructor2 {\n    constructor(context, options) {\n      const nativeContext = getNativeContext2(context);\n      const mergedOptions = { ...DEFAULT_OPTIONS$1, ...options };\n      const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, mergedOptions);\n      const isOffline = isNativeOfflineAudioContext2(nativeContext);\n      const audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer2() : null;\n      super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n      this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n      this._isBufferNullified = false;\n      this._isBufferSet = mergedOptions.buffer !== null;\n      this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n      this._onended = null;\n      this._playbackRate = createAudioParam2(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n    }\n    get buffer() {\n      if (this._isBufferNullified) {\n        return null;\n      }\n      return this._nativeAudioBufferSourceNode.buffer;\n    }\n    set buffer(value) {\n      this._nativeAudioBufferSourceNode.buffer = value;\n      if (value !== null) {\n        if (this._isBufferSet) {\n          throw createInvalidStateError2();\n        }\n        this._isBufferSet = true;\n      }\n    }\n    get loop() {\n      return this._nativeAudioBufferSourceNode.loop;\n    }\n    set loop(value) {\n      this._nativeAudioBufferSourceNode.loop = value;\n    }\n    get loopEnd() {\n      return this._nativeAudioBufferSourceNode.loopEnd;\n    }\n    set loopEnd(value) {\n      this._nativeAudioBufferSourceNode.loopEnd = value;\n    }\n    get loopStart() {\n      return this._nativeAudioBufferSourceNode.loopStart;\n    }\n    set loopStart(value) {\n      this._nativeAudioBufferSourceNode.loopStart = value;\n    }\n    get onended() {\n      return this._onended;\n    }\n    set onended(value) {\n      const wrappedListener = typeof value === \"function\" ? wrapEventListener2(this, value) : null;\n      this._nativeAudioBufferSourceNode.onended = wrappedListener;\n      const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n      this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n    }\n    get playbackRate() {\n      return this._playbackRate;\n    }\n    start(when = 0, offset = 0, duration) {\n      this._nativeAudioBufferSourceNode.start(when, offset, duration);\n      if (this._audioBufferSourceNodeRenderer !== null) {\n        this._audioBufferSourceNodeRenderer.start = duration === void 0 ? [when, offset] : [when, offset, duration];\n      }\n      if (this.context.state !== \"closed\") {\n        setInternalStateToActive(this);\n        const resetInternalStateToPassive = () => {\n          this._nativeAudioBufferSourceNode.removeEventListener(\"ended\", resetInternalStateToPassive);\n          if (isActiveAudioNode(this)) {\n            setInternalStateToPassive(this);\n          }\n        };\n        this._nativeAudioBufferSourceNode.addEventListener(\"ended\", resetInternalStateToPassive);\n      }\n    }\n    stop(when = 0) {\n      this._nativeAudioBufferSourceNode.stop(when);\n      if (this._audioBufferSourceNodeRenderer !== null) {\n        this._audioBufferSourceNodeRenderer.stop = when;\n      }\n    }\n  };\n};\nconst createAudioBufferSourceNodeRendererFactory = (connectAudioParam2, createNativeAudioBufferSourceNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {\n  return () => {\n    const renderedNativeAudioBufferSourceNodes = /* @__PURE__ */ new WeakMap();\n    let start = null;\n    let stop = null;\n    const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext) => {\n      let nativeAudioBufferSourceNode = getNativeAudioNode2(proxy);\n      const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n      if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n        const options = {\n          buffer: nativeAudioBufferSourceNode.buffer,\n          channelCount: nativeAudioBufferSourceNode.channelCount,\n          channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n          channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n          // Bug #149: Safari does not yet support the detune AudioParam.\n          loop: nativeAudioBufferSourceNode.loop,\n          loopEnd: nativeAudioBufferSourceNode.loopEnd,\n          loopStart: nativeAudioBufferSourceNode.loopStart,\n          playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n        };\n        nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, options);\n        if (start !== null) {\n          nativeAudioBufferSourceNode.start(...start);\n        }\n        if (stop !== null) {\n          nativeAudioBufferSourceNode.stop(stop);\n        }\n      }\n      renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n      if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n        await renderAutomation2(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n      } else {\n        await connectAudioParam2(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n      }\n      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n      return nativeAudioBufferSourceNode;\n    };\n    return {\n      set start(value) {\n        start = value;\n      },\n      set stop(value) {\n        stop = value;\n      },\n      render(proxy, nativeOfflineAudioContext) {\n        const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n        if (renderedNativeAudioBufferSourceNode !== void 0) {\n          return Promise.resolve(renderedNativeAudioBufferSourceNode);\n        }\n        return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);\n      }\n    };\n  };\n};\nconst isAudioBufferSourceNode = (audioNode) => {\n  return \"playbackRate\" in audioNode;\n};\nconst isBiquadFilterNode = (audioNode) => {\n  return \"frequency\" in audioNode && \"gain\" in audioNode;\n};\nconst isConstantSourceNode = (audioNode) => {\n  return \"offset\" in audioNode;\n};\nconst isGainNode = (audioNode) => {\n  return !(\"frequency\" in audioNode) && \"gain\" in audioNode;\n};\nconst isOscillatorNode = (audioNode) => {\n  return \"detune\" in audioNode && \"frequency\" in audioNode && !(\"gain\" in audioNode);\n};\nconst isStereoPannerNode = (audioNode) => {\n  return \"pan\" in audioNode;\n};\nconst getAudioNodeConnections = (audioNode) => {\n  return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};\nconst getAudioParamConnections = (audioParam) => {\n  return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};\nconst deactivateActiveAudioNodeInputConnections = (audioNode, trace) => {\n  const { activeInputs } = getAudioNodeConnections(audioNode);\n  activeInputs.forEach((connections2) => connections2.forEach(([source]) => {\n    if (!trace.includes(audioNode)) {\n      deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);\n    }\n  }));\n  const audioParams = isAudioBufferSourceNode(audioNode) ? [\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    audioNode.playbackRate\n  ] : isAudioWorkletNode(audioNode) ? Array.from(audioNode.parameters.values()) : isBiquadFilterNode(audioNode) ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain] : isConstantSourceNode(audioNode) ? [audioNode.offset] : isGainNode(audioNode) ? [audioNode.gain] : isOscillatorNode(audioNode) ? [audioNode.detune, audioNode.frequency] : isStereoPannerNode(audioNode) ? [audioNode.pan] : [];\n  for (const audioParam of audioParams) {\n    const audioParamConnections = getAudioParamConnections(audioParam);\n    if (audioParamConnections !== void 0) {\n      audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));\n    }\n  }\n  if (isActiveAudioNode(audioNode)) {\n    setInternalStateToPassive(audioNode);\n  }\n};\nconst deactivateAudioGraph = (context) => {\n  deactivateActiveAudioNodeInputConnections(context.destination, []);\n};\nconst isValidLatencyHint = (latencyHint) => {\n  return latencyHint === void 0 || typeof latencyHint === \"number\" || typeof latencyHint === \"string\" && (latencyHint === \"balanced\" || latencyHint === \"interactive\" || latencyHint === \"playback\");\n};\nconst createAudioDestinationNodeConstructor = (audioNodeConstructor2, createAudioDestinationNodeRenderer2, createIndexSizeError2, createInvalidStateError2, createNativeAudioDestinationNode, getNativeContext2, isNativeOfflineAudioContext2, renderInputsOfAudioNode2) => {\n  return class AudioDestinationNode extends audioNodeConstructor2 {\n    constructor(context, channelCount) {\n      const nativeContext = getNativeContext2(context);\n      const isOffline = isNativeOfflineAudioContext2(nativeContext);\n      const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n      const audioDestinationNodeRenderer = isOffline ? createAudioDestinationNodeRenderer2(renderInputsOfAudioNode2) : null;\n      super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n      this._isNodeOfNativeOfflineAudioContext = isOffline;\n      this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n    }\n    get channelCount() {\n      return this._nativeAudioDestinationNode.channelCount;\n    }\n    set channelCount(value) {\n      if (this._isNodeOfNativeOfflineAudioContext) {\n        throw createInvalidStateError2();\n      }\n      if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n        throw createIndexSizeError2();\n      }\n      this._nativeAudioDestinationNode.channelCount = value;\n    }\n    get channelCountMode() {\n      return this._nativeAudioDestinationNode.channelCountMode;\n    }\n    set channelCountMode(value) {\n      if (this._isNodeOfNativeOfflineAudioContext) {\n        throw createInvalidStateError2();\n      }\n      this._nativeAudioDestinationNode.channelCountMode = value;\n    }\n    get maxChannelCount() {\n      return this._nativeAudioDestinationNode.maxChannelCount;\n    }\n  };\n};\nconst createAudioDestinationNodeRenderer = (renderInputsOfAudioNode2) => {\n  const renderedNativeAudioDestinationNodes = /* @__PURE__ */ new WeakMap();\n  const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext) => {\n    const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n    renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);\n    await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);\n    return nativeAudioDestinationNode;\n  };\n  return {\n    render(proxy, nativeOfflineAudioContext) {\n      const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);\n      if (renderedNativeAudioDestinationNode !== void 0) {\n        return Promise.resolve(renderedNativeAudioDestinationNode);\n      }\n      return createAudioDestinationNode(proxy, nativeOfflineAudioContext);\n    }\n  };\n};\nconst createAudioListenerFactory = (createAudioParam2, createNativeChannelMergerNode2, createNativeConstantSourceNode2, createNativeScriptProcessorNode2, createNotSupportedError2, getFirstSample2, isNativeOfflineAudioContext2, overwriteAccessors2) => {\n  return (context, nativeContext) => {\n    const nativeListener = nativeContext.listener;\n    const createFakeAudioParams = () => {\n      const buffer = new Float32Array(1);\n      const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {\n        channelCount: 1,\n        channelCountMode: \"explicit\",\n        channelInterpretation: \"speakers\",\n        numberOfInputs: 9\n      });\n      const isOffline = isNativeOfflineAudioContext2(nativeContext);\n      let isScriptProcessorNodeCreated = false;\n      let lastOrientation = [0, 0, -1, 0, 1, 0];\n      let lastPosition = [0, 0, 0];\n      const createScriptProcessorNode = () => {\n        if (isScriptProcessorNodeCreated) {\n          return;\n        }\n        isScriptProcessorNodeCreated = true;\n        const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, 256, 9, 0);\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n          const orientation = [\n            getFirstSample2(inputBuffer, buffer, 0),\n            getFirstSample2(inputBuffer, buffer, 1),\n            getFirstSample2(inputBuffer, buffer, 2),\n            getFirstSample2(inputBuffer, buffer, 3),\n            getFirstSample2(inputBuffer, buffer, 4),\n            getFirstSample2(inputBuffer, buffer, 5)\n          ];\n          if (orientation.some((value, index) => value !== lastOrientation[index])) {\n            nativeListener.setOrientation(...orientation);\n            lastOrientation = orientation;\n          }\n          const positon = [\n            getFirstSample2(inputBuffer, buffer, 6),\n            getFirstSample2(inputBuffer, buffer, 7),\n            getFirstSample2(inputBuffer, buffer, 8)\n          ];\n          if (positon.some((value, index) => value !== lastPosition[index])) {\n            nativeListener.setPosition(...positon);\n            lastPosition = positon;\n          }\n        };\n        channelMergerNode.connect(scriptProcessorNode);\n      };\n      const createSetOrientation = (index) => (value) => {\n        if (value !== lastOrientation[index]) {\n          lastOrientation[index] = value;\n          nativeListener.setOrientation(...lastOrientation);\n        }\n      };\n      const createSetPosition = (index) => (value) => {\n        if (value !== lastPosition[index]) {\n          lastPosition[index] = value;\n          nativeListener.setPosition(...lastPosition);\n        }\n      };\n      const createFakeAudioParam = (input, initialValue, setValue) => {\n        const constantSourceNode = createNativeConstantSourceNode2(nativeContext, {\n          channelCount: 1,\n          channelCountMode: \"explicit\",\n          channelInterpretation: \"discrete\",\n          offset: initialValue\n        });\n        constantSourceNode.connect(channelMergerNode, 0, input);\n        constantSourceNode.start();\n        Object.defineProperty(constantSourceNode.offset, \"defaultValue\", {\n          get() {\n            return initialValue;\n          }\n        });\n        const audioParam = createAudioParam2({ context }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        overwriteAccessors2(audioParam, \"value\", (get) => () => get.call(audioParam), (set) => (value) => {\n          try {\n            set.call(audioParam, value);\n          } catch (err2) {\n            if (err2.code !== 9) {\n              throw err2;\n            }\n          }\n          createScriptProcessorNode();\n          if (isOffline) {\n            setValue(value);\n          }\n        });\n        audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError2();\n            };\n          }\n          return (...args) => {\n            const value = cancelAndHoldAtTime.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.cancelAndHoldAtTime);\n        audioParam.cancelScheduledValues = ((cancelScheduledValues) => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError2();\n            };\n          }\n          return (...args) => {\n            const value = cancelScheduledValues.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.cancelScheduledValues);\n        audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError2();\n            };\n          }\n          return (...args) => {\n            const value = exponentialRampToValueAtTime.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.exponentialRampToValueAtTime);\n        audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError2();\n            };\n          }\n          return (...args) => {\n            const value = linearRampToValueAtTime.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.linearRampToValueAtTime);\n        audioParam.setTargetAtTime = ((setTargetAtTime) => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError2();\n            };\n          }\n          return (...args) => {\n            const value = setTargetAtTime.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.setTargetAtTime);\n        audioParam.setValueAtTime = ((setValueAtTime) => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError2();\n            };\n          }\n          return (...args) => {\n            const value = setValueAtTime.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.setValueAtTime);\n        audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {\n          if (isOffline) {\n            return () => {\n              throw createNotSupportedError2();\n            };\n          }\n          return (...args) => {\n            const value = setValueCurveAtTime.apply(audioParam, args);\n            createScriptProcessorNode();\n            return value;\n          };\n        })(audioParam.setValueCurveAtTime);\n        return audioParam;\n      };\n      return {\n        forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),\n        forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),\n        forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),\n        positionX: createFakeAudioParam(6, 0, createSetPosition(0)),\n        positionY: createFakeAudioParam(7, 0, createSetPosition(1)),\n        positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),\n        upX: createFakeAudioParam(3, 0, createSetOrientation(3)),\n        upY: createFakeAudioParam(4, 1, createSetOrientation(4)),\n        upZ: createFakeAudioParam(5, 0, createSetOrientation(5))\n      };\n    };\n    const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = nativeListener.forwardX === void 0 ? createFakeAudioParams() : nativeListener;\n    return {\n      get forwardX() {\n        return forwardX;\n      },\n      get forwardY() {\n        return forwardY;\n      },\n      get forwardZ() {\n        return forwardZ;\n      },\n      get positionX() {\n        return positionX;\n      },\n      get positionY() {\n        return positionY;\n      },\n      get positionZ() {\n        return positionZ;\n      },\n      get upX() {\n        return upX;\n      },\n      get upY() {\n        return upY;\n      },\n      get upZ() {\n        return upZ;\n      }\n    };\n  };\n};\nconst isAudioNode = (audioNodeOrAudioParam) => {\n  return \"context\" in audioNodeOrAudioParam;\n};\nconst isAudioNodeOutputConnection = (outputConnection) => {\n  return isAudioNode(outputConnection[0]);\n};\nconst insertElementInSet = (set, element, predicate, ignoreDuplicates) => {\n  for (const lmnt of set) {\n    if (predicate(lmnt)) {\n      if (ignoreDuplicates) {\n        return false;\n      }\n      throw Error(\"The set contains at least one similar element.\");\n    }\n  }\n  set.add(element);\n  return true;\n};\nconst addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {\n  insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);\n};\nconst addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {\n  const passiveInputConnections = passiveInputs.get(source);\n  if (passiveInputConnections === void 0) {\n    passiveInputs.set(source, /* @__PURE__ */ new Set([[output, eventListener]]));\n  } else {\n    insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output, ignoreDuplicates);\n  }\n};\nconst isNativeAudioNodeFaker = (nativeAudioNodeOrNativeAudioNodeFaker) => {\n  return \"inputs\" in nativeAudioNodeOrNativeAudioNodeFaker;\n};\nconst connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n  if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n    const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n    nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n    return [fakeNativeDestinationAudioNode, output, 0];\n  }\n  nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n  return [nativeDestinationAudioNode, output, input];\n};\nconst deleteActiveInputConnection = (activeInputConnections, source, output) => {\n  for (const activeInputConnection of activeInputConnections) {\n    if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n      activeInputConnections.delete(activeInputConnection);\n      return activeInputConnection;\n    }\n  }\n  return null;\n};\nconst deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {\n  return pickElementFromSet(activeInputs, (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);\n};\nconst deleteEventListenerOfAudioNode = (audioNode, eventListener) => {\n  const eventListeners = getEventListenersOfAudioNode(audioNode);\n  if (!eventListeners.delete(eventListener)) {\n    throw new Error(\"Missing the expected event listener.\");\n  }\n};\nconst deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {\n  const passiveInputConnections = getValueForKey(passiveInputs, source);\n  const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output);\n  if (passiveInputConnections.size === 0) {\n    passiveInputs.delete(source);\n  }\n  return matchingConnection;\n};\nconst disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n  if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n    nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n  } else {\n    nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n  }\n};\nconst getNativeAudioNode = (audioNode) => {\n  return getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\nconst getNativeAudioParam = (audioParam) => {\n  return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\nconst isPartOfACycle = (audioNode) => {\n  return CYCLE_COUNTERS.has(audioNode);\n};\nconst isPassiveAudioNode = (audioNode) => {\n  return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\nconst testAudioNodeDisconnectMethodSupport = (nativeAudioContext, nativeAudioWorkletNodeConstructor2) => {\n  return new Promise((resolve) => {\n    if (nativeAudioWorkletNodeConstructor2 !== null) {\n      resolve(true);\n    } else {\n      const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);\n      const dummy = nativeAudioContext.createGain();\n      const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n      const channelData = ones.getChannelData(0);\n      channelData[0] = 1;\n      channelData[1] = 1;\n      const source = nativeAudioContext.createBufferSource();\n      source.buffer = ones;\n      source.loop = true;\n      source.connect(analyzer).connect(nativeAudioContext.destination);\n      source.connect(dummy);\n      source.disconnect(dummy);\n      analyzer.onaudioprocess = (event) => {\n        const chnnlDt = event.inputBuffer.getChannelData(0);\n        if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {\n          resolve(true);\n        } else {\n          resolve(false);\n        }\n        source.stop();\n        analyzer.onaudioprocess = null;\n        source.disconnect(analyzer);\n        analyzer.disconnect(nativeAudioContext.destination);\n      };\n      source.start();\n    }\n  });\n};\nconst visitEachAudioNodeOnce = (cycles, visitor) => {\n  const counts = /* @__PURE__ */ new Map();\n  for (const cycle of cycles) {\n    for (const audioNode of cycle) {\n      const count = counts.get(audioNode);\n      counts.set(audioNode, count === void 0 ? 1 : count + 1);\n    }\n  }\n  counts.forEach((count, audioNode) => visitor(audioNode, count));\n};\nconst isNativeAudioNode$1 = (nativeAudioNodeOrAudioParam) => {\n  return \"context\" in nativeAudioNodeOrAudioParam;\n};\nconst wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {\n  const connections2 = /* @__PURE__ */ new Map();\n  nativeAudioNode.connect = /* @__PURE__ */ ((connect2) => {\n    return (destination, output = 0, input = 0) => {\n      const returnValue = isNativeAudioNode$1(destination) ? connect2(destination, output, input) : connect2(destination, output);\n      const connectionsToDestination = connections2.get(destination);\n      if (connectionsToDestination === void 0) {\n        connections2.set(destination, [{ input, output }]);\n      } else {\n        if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n          connectionsToDestination.push({ input, output });\n        }\n      }\n      return returnValue;\n    };\n  })(nativeAudioNode.connect.bind(nativeAudioNode));\n  nativeAudioNode.disconnect = /* @__PURE__ */ ((disconnect) => {\n    return (destinationOrOutput, output, input) => {\n      disconnect.apply(nativeAudioNode);\n      if (destinationOrOutput === void 0) {\n        connections2.clear();\n      } else if (typeof destinationOrOutput === \"number\") {\n        for (const [destination, connectionsToDestination] of connections2) {\n          const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n          if (filteredConnections.length === 0) {\n            connections2.delete(destination);\n          } else {\n            connections2.set(destination, filteredConnections);\n          }\n        }\n      } else if (connections2.has(destinationOrOutput)) {\n        if (output === void 0) {\n          connections2.delete(destinationOrOutput);\n        } else {\n          const connectionsToDestination = connections2.get(destinationOrOutput);\n          if (connectionsToDestination !== void 0) {\n            const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== output && (connection.input !== input || input === void 0));\n            if (filteredConnections.length === 0) {\n              connections2.delete(destinationOrOutput);\n            } else {\n              connections2.set(destinationOrOutput, filteredConnections);\n            }\n          }\n        }\n      }\n      for (const [destination, connectionsToDestination] of connections2) {\n        connectionsToDestination.forEach((connection) => {\n          if (isNativeAudioNode$1(destination)) {\n            nativeAudioNode.connect(destination, connection.output, connection.input);\n          } else {\n            nativeAudioNode.connect(destination, connection.output);\n          }\n        });\n      }\n    };\n  })(nativeAudioNode.disconnect);\n};\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {\n  const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n  const { outputs } = getAudioNodeConnections(source);\n  const eventListeners = getEventListenersOfAudioNode(source);\n  const eventListener = (isActive) => {\n    const nativeAudioNode = getNativeAudioNode(source);\n    const nativeAudioParam = getNativeAudioParam(destination);\n    if (isActive) {\n      const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n      addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.connect(nativeAudioParam, output);\n      }\n    } else {\n      const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n      addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.disconnect(nativeAudioParam, output);\n      }\n    }\n  };\n  if (insertElementInSet(outputs, [destination, output], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output, true)) {\n    eventListeners.add(eventListener);\n    if (isActiveAudioNode(source)) {\n      addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n    } else {\n      addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n    }\n    return true;\n  }\n  return false;\n};\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n  const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n  const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n  if (activeInputConnection === null) {\n    const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n    return [passiveInputConnection[2], false];\n  }\n  return [activeInputConnection[2], true];\n};\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n  const { activeInputs, passiveInputs } = getAudioParamConnections(destination);\n  const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n  if (activeInputConnection === null) {\n    const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n    return [passiveInputConnection[1], false];\n  }\n  return [activeInputConnection[2], true];\n};\nconst deleteInputsOfAudioNode = (source, isOffline, destination, output, input) => {\n  const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n    }\n  }\n  if (isActiveAudioNode(destination)) {\n    const { activeInputs } = getAudioNodeConnections(destination);\n    setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n  }\n};\nconst deleteInputsOfAudioParam = (source, isOffline, destination, output) => {\n  const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n    }\n  }\n};\nconst deleteAnyConnection = (source, isOffline) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  const destinations = [];\n  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n    } else {\n      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n    }\n    destinations.push(outputConnection[0]);\n  }\n  audioNodeConnectionsOfSource.outputs.clear();\n  return destinations;\n};\nconst deleteConnectionAtOutput = (source, isOffline, output) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  const destinations = [];\n  for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n    if (outputConnection[1] === output) {\n      if (isAudioNodeOutputConnection(outputConnection)) {\n        deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n      } else {\n        deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n      }\n      destinations.push(outputConnection[0]);\n      audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    }\n  }\n  return destinations;\n};\nconst deleteConnectionToDestination = (source, isOffline, destination, output, input) => {\n  const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  return Array.from(audioNodeConnectionsOfSource.outputs).filter((outputConnection) => outputConnection[0] === destination && (output === void 0 || outputConnection[1] === output) && (input === void 0 || outputConnection[2] === input)).map((outputConnection) => {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n    } else {\n      deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n    }\n    audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    return outputConnection[0];\n  });\n};\nconst createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult2, createIncrementCycleCounter, createIndexSizeError2, createInvalidAccessError2, createNotSupportedError2, decrementCycleCounter, detectCycles, eventTargetConstructor2, getNativeContext2, isNativeAudioContext2, isNativeAudioNode2, isNativeAudioParam2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2) => {\n  return class AudioNode extends eventTargetConstructor2 {\n    constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {\n      super(nativeAudioNode);\n      this._context = context;\n      this._nativeAudioNode = nativeAudioNode;\n      const nativeContext = getNativeContext2(context);\n      if (isNativeAudioContext2(nativeContext) && true !== cacheTestResult2(testAudioNodeDisconnectMethodSupport, () => {\n        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor2);\n      })) {\n        wrapAudioNodeDisconnectMethod(nativeAudioNode);\n      }\n      AUDIO_NODE_STORE.set(this, nativeAudioNode);\n      EVENT_LISTENERS.set(this, /* @__PURE__ */ new Set());\n      if (context.state !== \"closed\" && isActive) {\n        setInternalStateToActive(this);\n      }\n      addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n    }\n    get channelCount() {\n      return this._nativeAudioNode.channelCount;\n    }\n    set channelCount(value) {\n      this._nativeAudioNode.channelCount = value;\n    }\n    get channelCountMode() {\n      return this._nativeAudioNode.channelCountMode;\n    }\n    set channelCountMode(value) {\n      this._nativeAudioNode.channelCountMode = value;\n    }\n    get channelInterpretation() {\n      return this._nativeAudioNode.channelInterpretation;\n    }\n    set channelInterpretation(value) {\n      this._nativeAudioNode.channelInterpretation = value;\n    }\n    get context() {\n      return this._context;\n    }\n    get numberOfInputs() {\n      return this._nativeAudioNode.numberOfInputs;\n    }\n    get numberOfOutputs() {\n      return this._nativeAudioNode.numberOfOutputs;\n    }\n    // tslint:disable-next-line:invalid-void\n    connect(destination, output = 0, input = 0) {\n      if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n        throw createIndexSizeError2();\n      }\n      const nativeContext = getNativeContext2(this._context);\n      const isOffline = isNativeOfflineAudioContext2(nativeContext);\n      if (isNativeAudioNode2(destination) || isNativeAudioParam2(destination)) {\n        throw createInvalidAccessError2();\n      }\n      if (isAudioNode(destination)) {\n        const nativeDestinationAudioNode = getNativeAudioNode(destination);\n        try {\n          const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n          const isPassive = isPassiveAudioNode(this);\n          if (isOffline || isPassive) {\n            this._nativeAudioNode.disconnect(...connection);\n          }\n          if (this.context.state !== \"closed\" && !isPassive && isPassiveAudioNode(destination)) {\n            setInternalStateToActive(destination);\n          }\n        } catch (err2) {\n          if (err2.code === 12) {\n            throw createInvalidAccessError2();\n          }\n          throw err2;\n        }\n        const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline);\n        if (isNewConnectionToAudioNode) {\n          const cycles = detectCycles([this], destination);\n          visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n        }\n        return destination;\n      }\n      const nativeAudioParam = getNativeAudioParam(destination);\n      if (nativeAudioParam.name === \"playbackRate\" && nativeAudioParam.maxValue === 1024) {\n        throw createNotSupportedError2();\n      }\n      try {\n        this._nativeAudioNode.connect(nativeAudioParam, output);\n        if (isOffline || isPassiveAudioNode(this)) {\n          this._nativeAudioNode.disconnect(nativeAudioParam, output);\n        }\n      } catch (err2) {\n        if (err2.code === 12) {\n          throw createInvalidAccessError2();\n        }\n        throw err2;\n      }\n      const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n      if (isNewConnectionToAudioParam) {\n        const cycles = detectCycles([this], destination);\n        visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n      }\n    }\n    disconnect(destinationOrOutput, output, input) {\n      let destinations;\n      const nativeContext = getNativeContext2(this._context);\n      const isOffline = isNativeOfflineAudioContext2(nativeContext);\n      if (destinationOrOutput === void 0) {\n        destinations = deleteAnyConnection(this, isOffline);\n      } else if (typeof destinationOrOutput === \"number\") {\n        if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n          throw createIndexSizeError2();\n        }\n        destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n      } else {\n        if (output !== void 0 && (output < 0 || output >= this.numberOfOutputs)) {\n          throw createIndexSizeError2();\n        }\n        if (isAudioNode(destinationOrOutput) && input !== void 0 && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n          throw createIndexSizeError2();\n        }\n        destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n        if (destinations.length === 0) {\n          throw createInvalidAccessError2();\n        }\n      }\n      for (const destination of destinations) {\n        const cycles = detectCycles([this], destination);\n        visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n      }\n    }\n  };\n};\nconst createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore2, audioParamStore, createAudioParamRenderer2, createCancelAndHoldAutomationEvent2, createCancelScheduledValuesAutomationEvent2, createExponentialRampToValueAutomationEvent2, createLinearRampToValueAutomationEvent2, createSetTargetAutomationEvent2, createSetValueAutomationEvent2, createSetValueCurveAutomationEvent2, nativeAudioContextConstructor2, setValueAtTimeUntilPossible2) => {\n  return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n    const defaultValue = nativeAudioParam.value;\n    const automationEventList = new AutomationEventList(defaultValue);\n    const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer2(automationEventList) : null;\n    const audioParam = {\n      get defaultValue() {\n        return defaultValue;\n      },\n      get maxValue() {\n        return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n      },\n      get minValue() {\n        return minValue === null ? nativeAudioParam.minValue : minValue;\n      },\n      get value() {\n        return nativeAudioParam.value;\n      },\n      set value(value) {\n        nativeAudioParam.value = value;\n        audioParam.setValueAtTime(value, audioNode.context.currentTime);\n      },\n      cancelAndHoldAtTime(cancelTime) {\n        if (typeof nativeAudioParam.cancelAndHoldAtTime === \"function\") {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n          automationEventList.add(createCancelAndHoldAutomationEvent2(cancelTime));\n          nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n        } else {\n          const previousLastEvent = Array.from(automationEventList).pop();\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n          automationEventList.add(createCancelAndHoldAutomationEvent2(cancelTime));\n          const currentLastEvent = Array.from(automationEventList).pop();\n          nativeAudioParam.cancelScheduledValues(cancelTime);\n          if (previousLastEvent !== currentLastEvent && currentLastEvent !== void 0) {\n            if (currentLastEvent.type === \"exponentialRampToValue\") {\n              nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === \"linearRampToValue\") {\n              nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === \"setValue\") {\n              nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n            } else if (currentLastEvent.type === \"setValueCurve\") {\n              nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n            }\n          }\n        }\n        return audioParam;\n      },\n      cancelScheduledValues(cancelTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n        automationEventList.add(createCancelScheduledValuesAutomationEvent2(cancelTime));\n        nativeAudioParam.cancelScheduledValues(cancelTime);\n        return audioParam;\n      },\n      exponentialRampToValueAtTime(value, endTime) {\n        if (value === 0) {\n          throw new RangeError();\n        }\n        if (!Number.isFinite(endTime) || endTime < 0) {\n          throw new RangeError();\n        }\n        const currentTime = audioNode.context.currentTime;\n        if (audioParamRenderer === null) {\n          automationEventList.flush(currentTime);\n        }\n        if (Array.from(automationEventList).length === 0) {\n          automationEventList.add(createSetValueAutomationEvent2(defaultValue, currentTime));\n          nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n        }\n        automationEventList.add(createExponentialRampToValueAutomationEvent2(value, endTime));\n        nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n      linearRampToValueAtTime(value, endTime) {\n        const currentTime = audioNode.context.currentTime;\n        if (audioParamRenderer === null) {\n          automationEventList.flush(currentTime);\n        }\n        if (Array.from(automationEventList).length === 0) {\n          automationEventList.add(createSetValueAutomationEvent2(defaultValue, currentTime));\n          nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n        }\n        automationEventList.add(createLinearRampToValueAutomationEvent2(value, endTime));\n        nativeAudioParam.linearRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n      setTargetAtTime(target, startTime, timeConstant) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n        automationEventList.add(createSetTargetAutomationEvent2(target, startTime, timeConstant));\n        nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n        return audioParam;\n      },\n      setValueAtTime(value, startTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n        automationEventList.add(createSetValueAutomationEvent2(value, startTime));\n        nativeAudioParam.setValueAtTime(value, startTime);\n        return audioParam;\n      },\n      setValueCurveAtTime(values, startTime, duration) {\n        const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n        if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === \"webkitAudioContext\") {\n          const endTime = startTime + duration;\n          const sampleRate = audioNode.context.sampleRate;\n          const firstSample = Math.ceil(startTime * sampleRate);\n          const lastSample = Math.floor(endTime * sampleRate);\n          const numberOfInterpolatedValues = lastSample - firstSample;\n          const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n          for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n            const theoreticIndex = (convertedValues.length - 1) / duration * ((firstSample + i) / sampleRate - startTime);\n            const lowerIndex = Math.floor(theoreticIndex);\n            const upperIndex = Math.ceil(theoreticIndex);\n            interpolatedValues[i] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n          }\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n          automationEventList.add(createSetValueCurveAutomationEvent2(interpolatedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n          const timeOfLastSample = lastSample / sampleRate;\n          if (timeOfLastSample < endTime) {\n            setValueAtTimeUntilPossible2(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n          }\n          setValueAtTimeUntilPossible2(audioParam, convertedValues[convertedValues.length - 1], endTime);\n        } else {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n          automationEventList.add(createSetValueCurveAutomationEvent2(convertedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n        }\n        return audioParam;\n      }\n    };\n    audioParamStore.set(audioParam, nativeAudioParam);\n    audioParamAudioNodeStore2.set(audioParam, audioNode);\n    addAudioParamConnections(audioParam, audioParamRenderer);\n    return audioParam;\n  };\n};\nconst createAudioParamRenderer = (automationEventList) => {\n  return {\n    replay(audioParam) {\n      for (const automationEvent of automationEventList) {\n        if (automationEvent.type === \"exponentialRampToValue\") {\n          const { endTime, value } = automationEvent;\n          audioParam.exponentialRampToValueAtTime(value, endTime);\n        } else if (automationEvent.type === \"linearRampToValue\") {\n          const { endTime, value } = automationEvent;\n          audioParam.linearRampToValueAtTime(value, endTime);\n        } else if (automationEvent.type === \"setTarget\") {\n          const { startTime, target, timeConstant } = automationEvent;\n          audioParam.setTargetAtTime(target, startTime, timeConstant);\n        } else if (automationEvent.type === \"setValue\") {\n          const { startTime, value } = automationEvent;\n          audioParam.setValueAtTime(value, startTime);\n        } else if (automationEvent.type === \"setValueCurve\") {\n          const { duration, startTime, values } = automationEvent;\n          audioParam.setValueCurveAtTime(values, startTime, duration);\n        } else {\n          throw new Error(\"Can't apply an unknown automation.\");\n        }\n      }\n    }\n  };\n};\nclass ReadOnlyMap {\n  constructor(parameters) {\n    this._map = new Map(parameters);\n  }\n  get size() {\n    return this._map.size;\n  }\n  entries() {\n    return this._map.entries();\n  }\n  forEach(callback, thisArg = null) {\n    return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));\n  }\n  get(name) {\n    return this._map.get(name);\n  }\n  has(name) {\n    return this._map.has(name);\n  }\n  keys() {\n    return this._map.keys();\n  }\n  values() {\n    return this._map.values();\n  }\n}\nconst DEFAULT_OPTIONS = {\n  channelCount: 2,\n  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n  channelCountMode: \"explicit\",\n  channelInterpretation: \"speakers\",\n  numberOfInputs: 1,\n  numberOfOutputs: 1,\n  parameterData: {},\n  processorOptions: {}\n};\nconst createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode2, audioNodeConstructor2, createAudioParam2, createAudioWorkletNodeRenderer2, createNativeAudioWorkletNode2, getAudioNodeConnections2, getBackupOfflineAudioContext2, getNativeContext2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2, sanitizeAudioWorkletNodeOptions2, setActiveAudioWorkletNodeInputs2, testAudioWorkletNodeOptionsClonability2, wrapEventListener2) => {\n  return class AudioWorkletNode extends audioNodeConstructor2 {\n    constructor(context, name, options) {\n      var _a2;\n      const nativeContext = getNativeContext2(context);\n      const isOffline = isNativeOfflineAudioContext2(nativeContext);\n      const mergedOptions = sanitizeAudioWorkletNodeOptions2({ ...DEFAULT_OPTIONS, ...options });\n      testAudioWorkletNodeOptionsClonability2(mergedOptions);\n      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n      const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name);\n      const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== \"closed\" ? nativeContext : (_a2 = getBackupOfflineAudioContext2(nativeContext)) !== null && _a2 !== void 0 ? _a2 : nativeContext;\n      const nativeAudioWorkletNode = createNativeAudioWorkletNode2(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor2, name, processorConstructor, mergedOptions);\n      const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer2(name, mergedOptions, processorConstructor) : null;\n      super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n      const parameters = [];\n      nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n        const audioParam = createAudioParam2(this, isOffline, nativeAudioParam);\n        parameters.push([nm, audioParam]);\n      });\n      this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n      this._onprocessorerror = null;\n      this._parameters = new ReadOnlyMap(parameters);\n      if (isOffline) {\n        addUnrenderedAudioWorkletNode2(nativeContext, this);\n      }\n      const { activeInputs } = getAudioNodeConnections2(this);\n      setActiveAudioWorkletNodeInputs2(nativeAudioWorkletNode, activeInputs);\n    }\n    get onprocessorerror() {\n      return this._onprocessorerror;\n    }\n    set onprocessorerror(value) {\n      const wrappedListener = typeof value === \"function\" ? wrapEventListener2(this, value) : null;\n      this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n      const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n      this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n    }\n    get parameters() {\n      if (this._parameters === null) {\n        return this._nativeAudioWorkletNode.parameters;\n      }\n      return this._parameters;\n    }\n    get port() {\n      return this._nativeAudioWorkletNode.port;\n    }\n  };\n};\nfunction copyFromChannel(audioBuffer, parent, key, channelNumber, bufferOffset) {\n  if (typeof audioBuffer.copyFromChannel === \"function\") {\n    if (parent[key].byteLength === 0) {\n      parent[key] = new Float32Array(128);\n    }\n    audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n  } else {\n    const channelData = audioBuffer.getChannelData(channelNumber);\n    if (parent[key].byteLength === 0) {\n      parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n    } else {\n      const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n      parent[key].set(slicedInput);\n    }\n  }\n}\nconst copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {\n  if (typeof audioBuffer.copyToChannel === \"function\") {\n    if (parent[key].byteLength !== 0) {\n      audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n    }\n  } else {\n    if (parent[key].byteLength !== 0) {\n      audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n    }\n  }\n};\nconst createNestedArrays = (x, y) => {\n  const arrays = [];\n  for (let i = 0; i < x; i += 1) {\n    const array = [];\n    const length = typeof y === \"number\" ? y : y[i];\n    for (let j = 0; j < length; j += 1) {\n      array.push(new Float32Array(128));\n    }\n    arrays.push(array);\n  }\n  return arrays;\n};\nconst getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {\n  const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n  const nativeAudioWorkletNode = getNativeAudioNode(proxy);\n  return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime2) => {\n  const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n  const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n  const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n  const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n  if (processorConstructor === void 0) {\n    throw new Error(\"Missing the processor constructor.\");\n  }\n  const audioNodeConnections = getAudioNodeConnections(proxy);\n  const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n  const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n  const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n  const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n  for (let i = 0; i < length; i += 128) {\n    if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n      for (let j = 0; j < options.numberOfInputs; j += 1) {\n        for (let k = 0; k < options.channelCount; k += 1) {\n          copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n        }\n      }\n    }\n    if (processorConstructor.parameterDescriptors !== void 0 && renderedBuffer !== null) {\n      processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n        copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n      });\n    }\n    for (let j = 0; j < options.numberOfInputs; j += 1) {\n      for (let k = 0; k < outputChannelCount[j]; k += 1) {\n        if (outputs[j][k].byteLength === 0) {\n          outputs[j][k] = new Float32Array(128);\n        }\n      }\n    }\n    try {\n      const potentiallyEmptyInputs = inputs.map((input, index) => {\n        if (audioNodeConnections.activeInputs[index].size === 0) {\n          return [];\n        }\n        return input;\n      });\n      const activeSourceFlag = exposeCurrentFrameAndCurrentTime2(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n      if (processedBuffer !== null) {\n        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n          for (let k = 0; k < outputChannelCount[j]; k += 1) {\n            copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n          }\n          outputChannelSplitterNodeOutput += outputChannelCount[j];\n        }\n      }\n      if (!activeSourceFlag) {\n        break;\n      }\n    } catch (error) {\n      proxy.dispatchEvent(new ErrorEvent(\"processorerror\", {\n        colno: error.colno,\n        filename: error.filename,\n        lineno: error.lineno,\n        message: error.message\n      }));\n      break;\n    }\n  }\n  return processedBuffer;\n};\nconst createAudioWorkletNodeRendererFactory = (connectAudioParam2, connectMultipleOutputs2, createNativeAudioBufferSourceNode2, createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeConstantSourceNode2, createNativeGainNode2, deleteUnrenderedAudioWorkletNode2, disconnectMultipleOutputs2, exposeCurrentFrameAndCurrentTime2, getNativeAudioNode2, nativeAudioWorkletNodeConstructor2, nativeOfflineAudioContextConstructor2, renderAutomation2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {\n  return (name, options, processorConstructor) => {\n    const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();\n    let processedBufferPromise = null;\n    const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n      let nativeAudioWorkletNode = getNativeAudioNode2(proxy);\n      let nativeOutputNodes = null;\n      const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n      const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount);\n      if (nativeAudioWorkletNodeConstructor2 === null) {\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const outputChannelSplitterNode = createNativeChannelSplitterNode2(nativeOfflineAudioContext, {\n          channelCount: Math.max(1, numberOfOutputChannels),\n          channelCountMode: \"explicit\",\n          channelInterpretation: \"discrete\",\n          numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n          outputChannelMergerNodes.push(createNativeChannelMergerNode2(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: \"explicit\",\n            channelInterpretation: \"speakers\",\n            numberOfInputs: outputChannelCount[i]\n          }));\n        }\n        const outputGainNode = createNativeGainNode2(nativeOfflineAudioContext, {\n          channelCount: options.channelCount,\n          channelCountMode: options.channelCountMode,\n          channelInterpretation: options.channelInterpretation,\n          gain: 1\n        });\n        outputGainNode.connect = connectMultipleOutputs2.bind(null, outputChannelMergerNodes);\n        outputGainNode.disconnect = disconnectMultipleOutputs2.bind(null, outputChannelMergerNodes);\n        nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n      } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor2(nativeOfflineAudioContext, name);\n      }\n      renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n      if (nativeOutputNodes !== null) {\n        if (processedBufferPromise === null) {\n          if (processorConstructor === void 0) {\n            throw new Error(\"Missing the processor constructor.\");\n          }\n          if (nativeOfflineAudioContextConstructor2 === null) {\n            throw new Error(\"Missing the native OfflineAudioContext constructor.\");\n          }\n          const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n          const numberOfParameters = processorConstructor.parameterDescriptors === void 0 ? 0 : processorConstructor.parameterDescriptors.length;\n          const numberOfChannels = numberOfInputChannels + numberOfParameters;\n          const renderBuffer = async () => {\n            const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(\n              numberOfChannels,\n              // Ceil the length to the next full render quantum.\n              // Bug #17: Safari does not yet expose the length.\n              Math.ceil(proxy.context.length / 128) * 128,\n              nativeOfflineAudioContext.sampleRate\n            );\n            const gainNodes = [];\n            const inputChannelSplitterNodes = [];\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes.push(createNativeGainNode2(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n              }));\n              inputChannelSplitterNodes.push(createNativeChannelSplitterNode2(partialOfflineAudioContext, {\n                channelCount: options.channelCount,\n                channelCountMode: \"explicit\",\n                channelInterpretation: \"discrete\",\n                numberOfOutputs: options.channelCount\n              }));\n            }\n            const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {\n              const constantSourceNode = createNativeConstantSourceNode2(partialOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: \"explicit\",\n                channelInterpretation: \"discrete\",\n                offset: audioParam.value\n              });\n              await renderAutomation2(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n              return constantSourceNode;\n            }));\n            const inputChannelMergerNode = createNativeChannelMergerNode2(partialOfflineAudioContext, {\n              channelCount: 1,\n              channelCountMode: \"explicit\",\n              channelInterpretation: \"speakers\",\n              numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n            });\n            for (let i = 0; i < options.numberOfInputs; i += 1) {\n              gainNodes[i].connect(inputChannelSplitterNodes[i]);\n              for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n              }\n            }\n            for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n              constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n              constantSourceNode.start(0);\n            }\n            inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n            await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode2(proxy, partialOfflineAudioContext, gainNode)));\n            return renderNativeOfflineAudioContext2(partialOfflineAudioContext);\n          };\n          processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime2);\n        }\n        const processedBuffer = await processedBufferPromise;\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, {\n          buffer: null,\n          channelCount: 2,\n          channelCountMode: \"max\",\n          channelInterpretation: \"speakers\",\n          loop: false,\n          loopEnd: 0,\n          loopStart: 0,\n          playbackRate: 1\n        });\n        const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n        if (processedBuffer !== null) {\n          audioBufferSourceNode.buffer = processedBuffer;\n          audioBufferSourceNode.start(0);\n        }\n        audioBufferSourceNode.connect(outputChannelSplitterNode);\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n          for (let j = 0; j < outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n          outputChannelSplitterNodeOutput += outputChannelCount[i];\n        }\n        return outputGainNode;\n      }\n      if (!nativeAudioWorkletNodeIsOwnedByContext) {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await renderAutomation2(\n            nativeOfflineAudioContext,\n            audioParam,\n            // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n            nativeAudioWorkletNode.parameters.get(nm)\n          );\n        }\n      } else {\n        for (const [nm, audioParam] of proxy.parameters.entries()) {\n          await connectAudioParam2(\n            nativeOfflineAudioContext,\n            audioParam,\n            // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n            nativeAudioWorkletNode.parameters.get(nm)\n          );\n        }\n      }\n      await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n      return nativeAudioWorkletNode;\n    };\n    return {\n      render(proxy, nativeOfflineAudioContext) {\n        deleteUnrenderedAudioWorkletNode2(nativeOfflineAudioContext, proxy);\n        const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n        if (renderedNativeAudioWorkletNodeOrGainNode !== void 0) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n        return createAudioNode(proxy, nativeOfflineAudioContext);\n      }\n    };\n  };\n};\nconst createCacheTestResult = (ongoingTests, testResults) => {\n  return (tester, test) => {\n    const cachedTestResult = testResults.get(tester);\n    if (cachedTestResult !== void 0) {\n      return cachedTestResult;\n    }\n    const ongoingTest = ongoingTests.get(tester);\n    if (ongoingTest !== void 0) {\n      return ongoingTest;\n    }\n    try {\n      const synchronousTestResult = test();\n      if (synchronousTestResult instanceof Promise) {\n        ongoingTests.set(tester, synchronousTestResult);\n        return synchronousTestResult.catch(() => false).then((finalTestResult) => {\n          ongoingTests.delete(tester);\n          testResults.set(tester, finalTestResult);\n          return finalTestResult;\n        });\n      }\n      testResults.set(tester, synchronousTestResult);\n      return synchronousTestResult;\n    } catch {\n      testResults.set(tester, false);\n      return false;\n    }\n  };\n};\nconst createConnectAudioParam = (renderInputsOfAudioParam2) => {\n  return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n    return renderInputsOfAudioParam2(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n  };\n};\nconst createConnectMultipleOutputs = (createIndexSizeError2) => {\n  return (outputAudioNodes, destination, output = 0, input = 0) => {\n    const outputAudioNode = outputAudioNodes[output];\n    if (outputAudioNode === void 0) {\n      throw createIndexSizeError2();\n    }\n    if (isNativeAudioNode$1(destination)) {\n      return outputAudioNode.connect(destination, 0, input);\n    }\n    return outputAudioNode.connect(destination, 0);\n  };\n};\nconst createConvertNumberToUnsignedLong = (unit32Array) => {\n  return (value) => {\n    unit32Array[0] = value;\n    return unit32Array[0];\n  };\n};\nconst createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode2, cycleCounters, getAudioNodeConnections2, getNativeAudioNode2, getNativeAudioParam2, getNativeContext2, isActiveAudioNode2, isNativeOfflineAudioContext2) => {\n  return (audioNode, count) => {\n    const cycleCounter = cycleCounters.get(audioNode);\n    if (cycleCounter === void 0) {\n      throw new Error(\"Missing the expected cycle count.\");\n    }\n    const nativeContext = getNativeContext2(audioNode.context);\n    const isOffline = isNativeOfflineAudioContext2(nativeContext);\n    if (cycleCounter === count) {\n      cycleCounters.delete(audioNode);\n      if (!isOffline && isActiveAudioNode2(audioNode)) {\n        const nativeSourceAudioNode = getNativeAudioNode2(audioNode);\n        const { outputs } = getAudioNodeConnections2(audioNode);\n        for (const output of outputs) {\n          if (isAudioNodeOutputConnection(output)) {\n            const nativeDestinationAudioNode = getNativeAudioNode2(output[0]);\n            connectNativeAudioNodeToNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n          } else {\n            const nativeDestinationAudioParam = getNativeAudioParam2(output[0]);\n            nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n          }\n        }\n      }\n    } else {\n      cycleCounters.set(audioNode, cycleCounter - count);\n    }\n  };\n};\nconst createDeleteActiveInputConnectionToAudioNode = (pickElementFromSet2) => {\n  return (activeInputs, source, output, input) => {\n    return pickElementFromSet2(activeInputs[input], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);\n  };\n};\nconst createDeleteUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes2) => {\n  return (nativeContext, audioWorkletNode) => {\n    getUnrenderedAudioWorkletNodes2(nativeContext).delete(audioWorkletNode);\n  };\n};\nconst isDelayNode = (audioNode) => {\n  return \"delayTime\" in audioNode;\n};\nconst createDetectCycles = (audioParamAudioNodeStore2, getAudioNodeConnections2, getValueForKey2) => {\n  return function detectCycles(chain, nextLink) {\n    const audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey2(audioParamAudioNodeStore2, nextLink);\n    if (isDelayNode(audioNode)) {\n      return [];\n    }\n    if (chain[0] === audioNode) {\n      return [chain];\n    }\n    if (chain.includes(audioNode)) {\n      return [];\n    }\n    const { outputs } = getAudioNodeConnections2(audioNode);\n    return Array.from(outputs).map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0])).reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n  };\n};\nconst getOutputAudioNodeAtIndex = (createIndexSizeError2, outputAudioNodes, output) => {\n  const outputAudioNode = outputAudioNodes[output];\n  if (outputAudioNode === void 0) {\n    throw createIndexSizeError2();\n  }\n  return outputAudioNode;\n};\nconst createDisconnectMultipleOutputs = (createIndexSizeError2) => {\n  return (outputAudioNodes, destinationOrOutput = void 0, output = void 0, input = 0) => {\n    if (destinationOrOutput === void 0) {\n      return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());\n    }\n    if (typeof destinationOrOutput === \"number\") {\n      return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, destinationOrOutput).disconnect();\n    }\n    if (isNativeAudioNode$1(destinationOrOutput)) {\n      if (output === void 0) {\n        return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n      }\n      if (input === void 0) {\n        return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n      }\n      return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n    }\n    if (output === void 0) {\n      return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n    }\n    return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n  };\n};\nconst createEvaluateSource = (window2) => {\n  return (source) => new Promise((resolve, reject) => {\n    if (window2 === null) {\n      reject(new SyntaxError());\n      return;\n    }\n    const head = window2.document.head;\n    if (head === null) {\n      reject(new SyntaxError());\n    } else {\n      const script = window2.document.createElement(\"script\");\n      const blob2 = new Blob([source], { type: \"application/javascript\" });\n      const url2 = URL.createObjectURL(blob2);\n      const originalOnErrorHandler = window2.onerror;\n      const removeErrorEventListenerAndRevokeUrl = () => {\n        window2.onerror = originalOnErrorHandler;\n        URL.revokeObjectURL(url2);\n      };\n      window2.onerror = (message, src, lineno, colno, error) => {\n        if (src === url2 || src === window2.location.href && lineno === 1 && colno === 1) {\n          removeErrorEventListenerAndRevokeUrl();\n          reject(error);\n          return false;\n        }\n        if (originalOnErrorHandler !== null) {\n          return originalOnErrorHandler(message, src, lineno, colno, error);\n        }\n      };\n      script.onerror = () => {\n        removeErrorEventListenerAndRevokeUrl();\n        reject(new SyntaxError());\n      };\n      script.onload = () => {\n        removeErrorEventListenerAndRevokeUrl();\n        resolve();\n      };\n      script.src = url2;\n      script.type = \"module\";\n      head.appendChild(script);\n    }\n  });\n};\nconst createEventTargetConstructor = (wrapEventListener2) => {\n  return class EventTarget {\n    constructor(_nativeEventTarget) {\n      this._nativeEventTarget = _nativeEventTarget;\n      this._listeners = /* @__PURE__ */ new WeakMap();\n    }\n    addEventListener(type, listener, options) {\n      if (listener !== null) {\n        let wrappedEventListener = this._listeners.get(listener);\n        if (wrappedEventListener === void 0) {\n          wrappedEventListener = wrapEventListener2(this, listener);\n          if (typeof listener === \"function\") {\n            this._listeners.set(listener, wrappedEventListener);\n          }\n        }\n        this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n      }\n    }\n    dispatchEvent(event) {\n      return this._nativeEventTarget.dispatchEvent(event);\n    }\n    removeEventListener(type, listener, options) {\n      const wrappedEventListener = listener === null ? void 0 : this._listeners.get(listener);\n      this._nativeEventTarget.removeEventListener(type, wrappedEventListener === void 0 ? null : wrappedEventListener, options);\n    }\n  };\n};\nconst createExposeCurrentFrameAndCurrentTime = (window2) => {\n  return (currentTime, sampleRate, fn) => {\n    Object.defineProperties(window2, {\n      currentFrame: {\n        configurable: true,\n        get() {\n          return Math.round(currentTime * sampleRate);\n        }\n      },\n      currentTime: {\n        configurable: true,\n        get() {\n          return currentTime;\n        }\n      }\n    });\n    try {\n      return fn();\n    } finally {\n      if (window2 !== null) {\n        delete window2.currentFrame;\n        delete window2.currentTime;\n      }\n    }\n  };\n};\nconst createFetchSource = (createAbortError2) => {\n  return async (url2) => {\n    try {\n      const response = await fetch(url2);\n      if (response.ok) {\n        return [await response.text(), response.url];\n      }\n    } catch {\n    }\n    throw createAbortError2();\n  };\n};\nconst createGetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore2, getValueForKey2) => {\n  return (nativeAudioWorkletNode) => getValueForKey2(activeAudioWorkletNodeInputsStore2, nativeAudioWorkletNode);\n};\nconst createGetAudioNodeRenderer = (getAudioNodeConnections2) => {\n  return (audioNode) => {\n    const audioNodeConnections = getAudioNodeConnections2(audioNode);\n    if (audioNodeConnections.renderer === null) {\n      throw new Error(\"Missing the renderer of the given AudioNode in the audio graph.\");\n    }\n    return audioNodeConnections.renderer;\n  };\n};\nconst createGetAudioNodeTailTime = (audioNodeTailTimeStore2) => {\n  return (audioNode) => {\n    var _a2;\n    return (_a2 = audioNodeTailTimeStore2.get(audioNode)) !== null && _a2 !== void 0 ? _a2 : 0;\n  };\n};\nconst createGetAudioParamRenderer = (getAudioParamConnections2) => {\n  return (audioParam) => {\n    const audioParamConnections = getAudioParamConnections2(audioParam);\n    if (audioParamConnections.renderer === null) {\n      throw new Error(\"Missing the renderer of the given AudioParam in the audio graph.\");\n    }\n    return audioParamConnections.renderer;\n  };\n};\nconst createGetBackupOfflineAudioContext = (backupOfflineAudioContextStore2) => {\n  return (nativeContext) => {\n    return backupOfflineAudioContextStore2.get(nativeContext);\n  };\n};\nconst createInvalidStateError = () => new DOMException(\"\", \"InvalidStateError\");\nconst createGetNativeContext = (contextStore) => {\n  return (context) => {\n    const nativeContext = contextStore.get(context);\n    if (nativeContext === void 0) {\n      throw createInvalidStateError();\n    }\n    return nativeContext;\n  };\n};\nconst createGetOrCreateBackupOfflineAudioContext = (backupOfflineAudioContextStore2, nativeOfflineAudioContextConstructor2) => {\n  return (nativeContext) => {\n    let backupOfflineAudioContext = backupOfflineAudioContextStore2.get(nativeContext);\n    if (backupOfflineAudioContext !== void 0) {\n      return backupOfflineAudioContext;\n    }\n    if (nativeOfflineAudioContextConstructor2 === null) {\n      throw new Error(\"Missing the native OfflineAudioContext constructor.\");\n    }\n    backupOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);\n    backupOfflineAudioContextStore2.set(nativeContext, backupOfflineAudioContext);\n    return backupOfflineAudioContext;\n  };\n};\nconst createGetUnrenderedAudioWorkletNodes = (unrenderedAudioWorkletNodeStore2) => {\n  return (nativeContext) => {\n    const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore2.get(nativeContext);\n    if (unrenderedAudioWorkletNodes === void 0) {\n      throw new Error(\"The context has no set of AudioWorkletNodes.\");\n    }\n    return unrenderedAudioWorkletNodes;\n  };\n};\nconst createInvalidAccessError = () => new DOMException(\"\", \"InvalidAccessError\");\nconst createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode2, getAudioNodeConnections2, getNativeAudioNode2, getNativeAudioParam2, isActiveAudioNode2) => {\n  return (isOffline) => {\n    return (audioNode, count) => {\n      const cycleCounter = cycleCounters.get(audioNode);\n      if (cycleCounter === void 0) {\n        if (!isOffline && isActiveAudioNode2(audioNode)) {\n          const nativeSourceAudioNode = getNativeAudioNode2(audioNode);\n          const { outputs } = getAudioNodeConnections2(audioNode);\n          for (const output of outputs) {\n            if (isAudioNodeOutputConnection(output)) {\n              const nativeDestinationAudioNode = getNativeAudioNode2(output[0]);\n              disconnectNativeAudioNodeFromNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n            } else {\n              const nativeDestinationAudioParam = getNativeAudioParam2(output[0]);\n              nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n            }\n          }\n        }\n        cycleCounters.set(audioNode, count);\n      } else {\n        cycleCounters.set(audioNode, cycleCounter + count);\n      }\n    };\n  };\n};\nconst createIsNativeAudioContext = (nativeAudioContextConstructor2) => {\n  return (anything) => {\n    return nativeAudioContextConstructor2 !== null && anything instanceof nativeAudioContextConstructor2;\n  };\n};\nconst createIsNativeAudioNode = (window2) => {\n  return (anything) => {\n    return window2 !== null && typeof window2.AudioNode === \"function\" && anything instanceof window2.AudioNode;\n  };\n};\nconst createIsNativeAudioParam = (window2) => {\n  return (anything) => {\n    return window2 !== null && typeof window2.AudioParam === \"function\" && anything instanceof window2.AudioParam;\n  };\n};\nconst createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor2) => {\n  return (anything) => {\n    return nativeOfflineAudioContextConstructor2 !== null && anything instanceof nativeOfflineAudioContextConstructor2;\n  };\n};\nconst createIsSecureContext = (window2) => window2 !== null && window2.isSecureContext;\nconst createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamAudioSourceNode2, getNativeContext2, isNativeOfflineAudioContext2) => {\n  return class MediaStreamAudioSourceNode extends audioNodeConstructor2 {\n    constructor(context, options) {\n      const nativeContext = getNativeContext2(context);\n      const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode2(nativeContext, options);\n      if (isNativeOfflineAudioContext2(nativeContext)) {\n        throw new TypeError();\n      }\n      super(context, true, nativeMediaStreamAudioSourceNode, null);\n      this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n    }\n    get mediaStream() {\n      return this._nativeMediaStreamAudioSourceNode.mediaStream;\n    }\n  };\n};\nconst createMinimalAudioContextConstructor = (createInvalidStateError2, createNotSupportedError2, createUnknownError2, minimalBaseAudioContextConstructor2, nativeAudioContextConstructor2) => {\n  return class MinimalAudioContext extends minimalBaseAudioContextConstructor2 {\n    constructor(options = {}) {\n      if (nativeAudioContextConstructor2 === null) {\n        throw new Error(\"Missing the native AudioContext constructor.\");\n      }\n      let nativeAudioContext;\n      try {\n        nativeAudioContext = new nativeAudioContextConstructor2(options);\n      } catch (err2) {\n        if (err2.code === 12 && err2.message === \"sampleRate is not in range\") {\n          throw createNotSupportedError2();\n        }\n        throw err2;\n      }\n      if (nativeAudioContext === null) {\n        throw createUnknownError2();\n      }\n      if (!isValidLatencyHint(options.latencyHint)) {\n        throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n      }\n      if (options.sampleRate !== void 0 && nativeAudioContext.sampleRate !== options.sampleRate) {\n        throw createNotSupportedError2();\n      }\n      super(nativeAudioContext, 2);\n      const { latencyHint } = options;\n      const { sampleRate } = nativeAudioContext;\n      this._baseLatency = typeof nativeAudioContext.baseLatency === \"number\" ? nativeAudioContext.baseLatency : latencyHint === \"balanced\" ? 512 / sampleRate : latencyHint === \"interactive\" || latencyHint === void 0 ? 256 / sampleRate : latencyHint === \"playback\" ? 1024 / sampleRate : (\n        /*\n         * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n         * ScriptProcessorNode.\n         */\n        Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate\n      );\n      this._nativeAudioContext = nativeAudioContext;\n      if (nativeAudioContextConstructor2.name === \"webkitAudioContext\") {\n        this._nativeGainNode = nativeAudioContext.createGain();\n        this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n        this._nativeGainNode.gain.value = 1e-37;\n        this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n        this._nativeOscillatorNode.start();\n      } else {\n        this._nativeGainNode = null;\n        this._nativeOscillatorNode = null;\n      }\n      this._state = null;\n      if (nativeAudioContext.state === \"running\") {\n        this._state = \"suspended\";\n        const revokeState = () => {\n          if (this._state === \"suspended\") {\n            this._state = null;\n          }\n          nativeAudioContext.removeEventListener(\"statechange\", revokeState);\n        };\n        nativeAudioContext.addEventListener(\"statechange\", revokeState);\n      }\n    }\n    get baseLatency() {\n      return this._baseLatency;\n    }\n    get state() {\n      return this._state !== null ? this._state : this._nativeAudioContext.state;\n    }\n    close() {\n      if (this.state === \"closed\") {\n        return this._nativeAudioContext.close().then(() => {\n          throw createInvalidStateError2();\n        });\n      }\n      if (this._state === \"suspended\") {\n        this._state = null;\n      }\n      return this._nativeAudioContext.close().then(() => {\n        if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n          this._nativeOscillatorNode.stop();\n          this._nativeGainNode.disconnect();\n          this._nativeOscillatorNode.disconnect();\n        }\n        deactivateAudioGraph(this);\n      });\n    }\n    resume() {\n      if (this._state === \"suspended\") {\n        return new Promise((resolve, reject) => {\n          const resolvePromise = () => {\n            this._nativeAudioContext.removeEventListener(\"statechange\", resolvePromise);\n            if (this._nativeAudioContext.state === \"running\") {\n              resolve();\n            } else {\n              this.resume().then(resolve, reject);\n            }\n          };\n          this._nativeAudioContext.addEventListener(\"statechange\", resolvePromise);\n        });\n      }\n      return this._nativeAudioContext.resume().catch((err2) => {\n        if (err2 === void 0 || err2.code === 15) {\n          throw createInvalidStateError2();\n        }\n        throw err2;\n      });\n    }\n    suspend() {\n      return this._nativeAudioContext.suspend().catch((err2) => {\n        if (err2 === void 0) {\n          throw createInvalidStateError2();\n        }\n        throw err2;\n      });\n    }\n  };\n};\nconst createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor2, createAudioListener2, eventTargetConstructor2, isNativeOfflineAudioContext2, unrenderedAudioWorkletNodeStore2, wrapEventListener2) => {\n  return class MinimalBaseAudioContext extends eventTargetConstructor2 {\n    constructor(_nativeContext, numberOfChannels) {\n      super(_nativeContext);\n      this._nativeContext = _nativeContext;\n      CONTEXT_STORE.set(this, _nativeContext);\n      if (isNativeOfflineAudioContext2(_nativeContext)) {\n        unrenderedAudioWorkletNodeStore2.set(_nativeContext, /* @__PURE__ */ new Set());\n      }\n      this._destination = new audioDestinationNodeConstructor2(this, numberOfChannels);\n      this._listener = createAudioListener2(this, _nativeContext);\n      this._onstatechange = null;\n    }\n    get currentTime() {\n      return this._nativeContext.currentTime;\n    }\n    get destination() {\n      return this._destination;\n    }\n    get listener() {\n      return this._listener;\n    }\n    get onstatechange() {\n      return this._onstatechange;\n    }\n    set onstatechange(value) {\n      const wrappedListener = typeof value === \"function\" ? wrapEventListener2(this, value) : null;\n      this._nativeContext.onstatechange = wrappedListener;\n      const nativeOnStateChange = this._nativeContext.onstatechange;\n      this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;\n    }\n    get sampleRate() {\n      return this._nativeContext.sampleRate;\n    }\n    get state() {\n      return this._nativeContext.state;\n    }\n  };\n};\nconst testPromiseSupport = (nativeContext) => {\n  const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n  try {\n    const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {\n    });\n    if (promise === void 0) {\n      return false;\n    }\n    promise.catch(() => {\n    });\n    return true;\n  } catch {\n  }\n  return false;\n};\nconst createMonitorConnections = (insertElementInSet2, isNativeAudioNode2) => {\n  return (nativeAudioNode, whenConnected, whenDisconnected) => {\n    const connections2 = /* @__PURE__ */ new Set();\n    nativeAudioNode.connect = /* @__PURE__ */ ((connect2) => {\n      return (destination, output = 0, input = 0) => {\n        const wasDisconnected = connections2.size === 0;\n        if (isNativeAudioNode2(destination)) {\n          connect2.call(nativeAudioNode, destination, output, input);\n          insertElementInSet2(connections2, [destination, output, input], (connection) => connection[0] === destination && connection[1] === output && connection[2] === input, true);\n          if (wasDisconnected) {\n            whenConnected();\n          }\n          return destination;\n        }\n        connect2.call(nativeAudioNode, destination, output);\n        insertElementInSet2(connections2, [destination, output], (connection) => connection[0] === destination && connection[1] === output, true);\n        if (wasDisconnected) {\n          whenConnected();\n        }\n        return;\n      };\n    })(nativeAudioNode.connect);\n    nativeAudioNode.disconnect = /* @__PURE__ */ ((disconnect) => {\n      return (destinationOrOutput, output, input) => {\n        const wasConnected = connections2.size > 0;\n        if (destinationOrOutput === void 0) {\n          disconnect.apply(nativeAudioNode);\n          connections2.clear();\n        } else if (typeof destinationOrOutput === \"number\") {\n          disconnect.call(nativeAudioNode, destinationOrOutput);\n          for (const connection of connections2) {\n            if (connection[1] === destinationOrOutput) {\n              connections2.delete(connection);\n            }\n          }\n        } else {\n          if (isNativeAudioNode2(destinationOrOutput)) {\n            disconnect.call(nativeAudioNode, destinationOrOutput, output, input);\n          } else {\n            disconnect.call(nativeAudioNode, destinationOrOutput, output);\n          }\n          for (const connection of connections2) {\n            if (connection[0] === destinationOrOutput && (output === void 0 || connection[1] === output) && (input === void 0 || connection[2] === input)) {\n              connections2.delete(connection);\n            }\n          }\n        }\n        const isDisconnected = connections2.size === 0;\n        if (wasConnected && isDisconnected) {\n          whenDisconnected();\n        }\n      };\n    })(nativeAudioNode.disconnect);\n    return nativeAudioNode;\n  };\n};\nconst assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {\n  const value = options[option];\n  if (value !== void 0 && value !== nativeAudioNode[option]) {\n    nativeAudioNode[option] = value;\n  }\n};\nconst assignNativeAudioNodeOptions = (nativeAudioNode, options) => {\n  assignNativeAudioNodeOption(nativeAudioNode, options, \"channelCount\");\n  assignNativeAudioNodeOption(nativeAudioNode, options, \"channelCountMode\");\n  assignNativeAudioNodeOption(nativeAudioNode, options, \"channelInterpretation\");\n};\nconst createNativeAudioBufferConstructor = (window2) => {\n  if (window2 === null) {\n    return null;\n  }\n  if (window2.hasOwnProperty(\"AudioBuffer\")) {\n    return window2.AudioBuffer;\n  }\n  return null;\n};\nconst assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {\n  const value = options[audioParam];\n  if (value !== void 0 && value !== nativeAudioNode[audioParam].value) {\n    nativeAudioNode[audioParam].value = value;\n  }\n};\nconst wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {\n  nativeAudioBufferSourceNode.start = /* @__PURE__ */ ((start) => {\n    let isScheduled = false;\n    return (when = 0, offset = 0, duration) => {\n      if (isScheduled) {\n        throw createInvalidStateError();\n      }\n      start.call(nativeAudioBufferSourceNode, when, offset, duration);\n      isScheduled = true;\n    };\n  })(nativeAudioBufferSourceNode.start);\n};\nconst wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n  nativeAudioScheduledSourceNode.start = /* @__PURE__ */ ((start) => {\n    return (when = 0, offset = 0, duration) => {\n      if (typeof duration === \"number\" && duration < 0 || offset < 0 || when < 0) {\n        throw new RangeError(\"The parameters can't be negative.\");\n      }\n      start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n    };\n  })(nativeAudioScheduledSourceNode.start);\n};\nconst wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n  nativeAudioScheduledSourceNode.stop = /* @__PURE__ */ ((stop) => {\n    return (when = 0) => {\n      if (when < 0) {\n        throw new RangeError(\"The parameter can't be negative.\");\n      }\n      stop.call(nativeAudioScheduledSourceNode, when);\n    };\n  })(nativeAudioScheduledSourceNode.stop);\n};\nconst createNativeAudioBufferSourceNodeFactory = (addSilentConnection2, cacheTestResult2, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2, testAudioBufferSourceNodeStartMethodOffsetClampingSupport2, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2) => {\n  return (nativeContext, options) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, \"playbackRate\");\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, \"buffer\");\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, \"loop\");\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, \"loopEnd\");\n    assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, \"loopStart\");\n    if (!cacheTestResult2(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2(nativeContext))) {\n      wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n    }\n    if (!cacheTestResult2(testAudioBufferSourceNodeStartMethodOffsetClampingSupport2, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport2(nativeContext))) {\n      wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n    }\n    if (!cacheTestResult2(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2(nativeContext))) {\n      wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n    }\n    if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {\n      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n    }\n    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2(nativeAudioBufferSourceNode, nativeContext);\n    }\n    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n    }\n    addSilentConnection2(nativeContext, nativeAudioBufferSourceNode);\n    return nativeAudioBufferSourceNode;\n  };\n};\nconst createNativeAudioContextConstructor = (window2) => {\n  if (window2 === null) {\n    return null;\n  }\n  if (window2.hasOwnProperty(\"AudioContext\")) {\n    return window2.AudioContext;\n  }\n  return window2.hasOwnProperty(\"webkitAudioContext\") ? window2.webkitAudioContext : null;\n};\nconst createNativeAudioDestinationNodeFactory = (createNativeGainNode2, overwriteAccessors2) => {\n  return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n    const nativeAudioDestinationNode = nativeContext.destination;\n    if (nativeAudioDestinationNode.channelCount !== channelCount) {\n      try {\n        nativeAudioDestinationNode.channelCount = channelCount;\n      } catch {\n      }\n    }\n    if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== \"explicit\") {\n      nativeAudioDestinationNode.channelCountMode = \"explicit\";\n    }\n    if (nativeAudioDestinationNode.maxChannelCount === 0) {\n      Object.defineProperty(nativeAudioDestinationNode, \"maxChannelCount\", {\n        value: channelCount\n      });\n    }\n    const gainNode = createNativeGainNode2(nativeContext, {\n      channelCount,\n      channelCountMode: nativeAudioDestinationNode.channelCountMode,\n      channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n      gain: 1\n    });\n    overwriteAccessors2(gainNode, \"channelCount\", (get) => () => get.call(gainNode), (set) => (value) => {\n      set.call(gainNode, value);\n      try {\n        nativeAudioDestinationNode.channelCount = value;\n      } catch (err2) {\n        if (value > nativeAudioDestinationNode.maxChannelCount) {\n          throw err2;\n        }\n      }\n    });\n    overwriteAccessors2(gainNode, \"channelCountMode\", (get) => () => get.call(gainNode), (set) => (value) => {\n      set.call(gainNode, value);\n      nativeAudioDestinationNode.channelCountMode = value;\n    });\n    overwriteAccessors2(gainNode, \"channelInterpretation\", (get) => () => get.call(gainNode), (set) => (value) => {\n      set.call(gainNode, value);\n      nativeAudioDestinationNode.channelInterpretation = value;\n    });\n    Object.defineProperty(gainNode, \"maxChannelCount\", {\n      get: () => nativeAudioDestinationNode.maxChannelCount\n    });\n    gainNode.connect(nativeAudioDestinationNode);\n    return gainNode;\n  };\n};\nconst createNativeAudioWorkletNodeConstructor = (window2) => {\n  if (window2 === null) {\n    return null;\n  }\n  return window2.hasOwnProperty(\"AudioWorkletNode\") ? window2.AudioWorkletNode : null;\n};\nconst testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n  const { port1 } = new MessageChannel();\n  try {\n    port1.postMessage(audioWorkletNodeOptions);\n  } finally {\n    port1.close();\n  }\n};\nconst createNativeAudioWorkletNodeFactory = (createInvalidStateError2, createNativeAudioWorkletNodeFaker2, createNativeGainNode2, createNotSupportedError2, monitorConnections2) => {\n  return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor2, name, processorConstructor, options) => {\n    if (nativeAudioWorkletNodeConstructor2 !== null) {\n      try {\n        const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor2(nativeContext, name, options);\n        const patchedEventListeners = /* @__PURE__ */ new Map();\n        let onprocessorerror = null;\n        Object.defineProperties(nativeAudioWorkletNode, {\n          /*\n           * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n           * browsers have no native implementation to achieve a consistent behavior.\n           */\n          channelCount: {\n            get: () => options.channelCount,\n            set: () => {\n              throw createInvalidStateError2();\n            }\n          },\n          channelCountMode: {\n            get: () => \"explicit\",\n            set: () => {\n              throw createInvalidStateError2();\n            }\n          },\n          // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.\n          onprocessorerror: {\n            get: () => onprocessorerror,\n            set: (value) => {\n              if (typeof onprocessorerror === \"function\") {\n                nativeAudioWorkletNode.removeEventListener(\"processorerror\", onprocessorerror);\n              }\n              onprocessorerror = typeof value === \"function\" ? value : null;\n              if (typeof onprocessorerror === \"function\") {\n                nativeAudioWorkletNode.addEventListener(\"processorerror\", onprocessorerror);\n              }\n            }\n          }\n        });\n        nativeAudioWorkletNode.addEventListener = /* @__PURE__ */ ((addEventListener) => {\n          return (...args) => {\n            if (args[0] === \"processorerror\") {\n              const unpatchedEventListener = typeof args[1] === \"function\" ? args[1] : typeof args[1] === \"object\" && args[1] !== null && typeof args[1].handleEvent === \"function\" ? args[1].handleEvent : null;\n              if (unpatchedEventListener !== null) {\n                const patchedEventListener = patchedEventListeners.get(args[1]);\n                if (patchedEventListener !== void 0) {\n                  args[1] = patchedEventListener;\n                } else {\n                  args[1] = (event) => {\n                    if (event.type === \"error\") {\n                      Object.defineProperties(event, {\n                        type: { value: \"processorerror\" }\n                      });\n                      unpatchedEventListener(event);\n                    } else {\n                      unpatchedEventListener(new ErrorEvent(args[0], { ...event }));\n                    }\n                  };\n                  patchedEventListeners.set(unpatchedEventListener, args[1]);\n                }\n              }\n            }\n            addEventListener.call(nativeAudioWorkletNode, \"error\", args[1], args[2]);\n            return addEventListener.call(nativeAudioWorkletNode, ...args);\n          };\n        })(nativeAudioWorkletNode.addEventListener);\n        nativeAudioWorkletNode.removeEventListener = /* @__PURE__ */ ((removeEventListener) => {\n          return (...args) => {\n            if (args[0] === \"processorerror\") {\n              const patchedEventListener = patchedEventListeners.get(args[1]);\n              if (patchedEventListener !== void 0) {\n                patchedEventListeners.delete(args[1]);\n                args[1] = patchedEventListener;\n              }\n            }\n            removeEventListener.call(nativeAudioWorkletNode, \"error\", args[1], args[2]);\n            return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n          };\n        })(nativeAudioWorkletNode.removeEventListener);\n        if (options.numberOfOutputs !== 0) {\n          const nativeGainNode = createNativeGainNode2(nativeContext, {\n            channelCount: 1,\n            channelCountMode: \"explicit\",\n            channelInterpretation: \"discrete\",\n            gain: 0\n          });\n          nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);\n          const whenConnected = () => nativeGainNode.disconnect();\n          const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);\n          return monitorConnections2(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n        }\n        return nativeAudioWorkletNode;\n      } catch (err2) {\n        if (err2.code === 11) {\n          throw createNotSupportedError2();\n        }\n        throw err2;\n      }\n    }\n    if (processorConstructor === void 0) {\n      throw createNotSupportedError2();\n    }\n    testClonabilityOfAudioWorkletNodeOptions(options);\n    return createNativeAudioWorkletNodeFaker2(nativeContext, baseLatency, processorConstructor, options);\n  };\n};\nconst computeBufferSize = (baseLatency, sampleRate) => {\n  if (baseLatency === null) {\n    return 512;\n  }\n  return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\nconst cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n  return new Promise((resolve, reject) => {\n    const { port1, port2 } = new MessageChannel();\n    port1.onmessage = ({ data }) => {\n      port1.close();\n      port2.close();\n      resolve(data);\n    };\n    port1.onmessageerror = ({ data }) => {\n      port1.close();\n      port2.close();\n      reject(data);\n    };\n    port2.postMessage(audioWorkletNodeOptions);\n  });\n};\nconst createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {\n  const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n  return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\nconst createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {\n  let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n  if (nodeToProcessorMap === void 0) {\n    nodeToProcessorMap = /* @__PURE__ */ new WeakMap();\n    NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n  }\n  const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n  nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n  return audioWorkletProcessorPromise;\n};\nconst createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs2, createIndexSizeError2, createInvalidStateError2, createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeConstantSourceNode2, createNativeGainNode2, createNativeScriptProcessorNode2, createNotSupportedError2, disconnectMultipleOutputs2, exposeCurrentFrameAndCurrentTime2, getActiveAudioWorkletNodeInputs2, monitorConnections2) => {\n  return (nativeContext, baseLatency, processorConstructor, options) => {\n    if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n      throw createNotSupportedError2();\n    }\n    const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount);\n    if (outputChannelCount.some((channelCount) => channelCount < 1)) {\n      throw createNotSupportedError2();\n    }\n    if (outputChannelCount.length !== options.numberOfOutputs) {\n      throw createIndexSizeError2();\n    }\n    if (options.channelCountMode !== \"explicit\") {\n      throw createNotSupportedError2();\n    }\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const numberOfParameters = processorConstructor.parameterDescriptors === void 0 ? 0 : processorConstructor.parameterDescriptors.length;\n    if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n      throw createNotSupportedError2();\n    }\n    const messageChannel = new MessageChannel();\n    const gainNodes = [];\n    const inputChannelSplitterNodes = [];\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes.push(createNativeGainNode2(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: options.channelCountMode,\n        channelInterpretation: options.channelInterpretation,\n        gain: 1\n      }));\n      inputChannelSplitterNodes.push(createNativeChannelSplitterNode2(nativeContext, {\n        channelCount: options.channelCount,\n        channelCountMode: \"explicit\",\n        channelInterpretation: \"discrete\",\n        numberOfOutputs: options.channelCount\n      }));\n    }\n    const constantSourceNodes = [];\n    if (processorConstructor.parameterDescriptors !== void 0) {\n      for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n        const constantSourceNode = createNativeConstantSourceNode2(nativeContext, {\n          channelCount: 1,\n          channelCountMode: \"explicit\",\n          channelInterpretation: \"discrete\",\n          offset: options.parameterData[name] !== void 0 ? options.parameterData[name] : defaultValue === void 0 ? 0 : defaultValue\n        });\n        Object.defineProperties(constantSourceNode.offset, {\n          defaultValue: {\n            get: () => defaultValue === void 0 ? 0 : defaultValue\n          },\n          maxValue: {\n            get: () => maxValue === void 0 ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n          },\n          minValue: {\n            get: () => minValue === void 0 ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n          }\n        });\n        constantSourceNodes.push(constantSourceNode);\n      }\n    }\n    const inputChannelMergerNode = createNativeChannelMergerNode2(nativeContext, {\n      channelCount: 1,\n      channelCountMode: \"explicit\",\n      channelInterpretation: \"speakers\",\n      numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n    });\n    const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n    const scriptProcessorNode = createNativeScriptProcessorNode2(\n      nativeContext,\n      bufferSize,\n      numberOfInputChannels + numberOfParameters,\n      // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n      Math.max(1, numberOfOutputChannels)\n    );\n    const outputChannelSplitterNode = createNativeChannelSplitterNode2(nativeContext, {\n      channelCount: Math.max(1, numberOfOutputChannels),\n      channelCountMode: \"explicit\",\n      channelInterpretation: \"discrete\",\n      numberOfOutputs: Math.max(1, numberOfOutputChannels)\n    });\n    const outputChannelMergerNodes = [];\n    for (let i = 0; i < options.numberOfOutputs; i += 1) {\n      outputChannelMergerNodes.push(createNativeChannelMergerNode2(nativeContext, {\n        channelCount: 1,\n        channelCountMode: \"explicit\",\n        channelInterpretation: \"speakers\",\n        numberOfInputs: outputChannelCount[i]\n      }));\n    }\n    for (let i = 0; i < options.numberOfInputs; i += 1) {\n      gainNodes[i].connect(inputChannelSplitterNodes[i]);\n      for (let j = 0; j < options.channelCount; j += 1) {\n        inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n      }\n    }\n    const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === void 0 ? [] : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n      const constantSourceNode = constantSourceNodes[index];\n      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n      constantSourceNode.start(0);\n      return [name, constantSourceNode.offset];\n    }));\n    inputChannelMergerNode.connect(scriptProcessorNode);\n    let channelInterpretation = options.channelInterpretation;\n    let onprocessorerror = null;\n    const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n    const nativeAudioWorkletNodeFaker = {\n      get bufferSize() {\n        return bufferSize;\n      },\n      get channelCount() {\n        return options.channelCount;\n      },\n      set channelCount(_) {\n        throw createInvalidStateError2();\n      },\n      get channelCountMode() {\n        return options.channelCountMode;\n      },\n      set channelCountMode(_) {\n        throw createInvalidStateError2();\n      },\n      get channelInterpretation() {\n        return channelInterpretation;\n      },\n      set channelInterpretation(value) {\n        for (const gainNode of gainNodes) {\n          gainNode.channelInterpretation = value;\n        }\n        channelInterpretation = value;\n      },\n      get context() {\n        return scriptProcessorNode.context;\n      },\n      get inputs() {\n        return gainNodes;\n      },\n      get numberOfInputs() {\n        return options.numberOfInputs;\n      },\n      get numberOfOutputs() {\n        return options.numberOfOutputs;\n      },\n      get onprocessorerror() {\n        return onprocessorerror;\n      },\n      set onprocessorerror(value) {\n        if (typeof onprocessorerror === \"function\") {\n          nativeAudioWorkletNodeFaker.removeEventListener(\"processorerror\", onprocessorerror);\n        }\n        onprocessorerror = typeof value === \"function\" ? value : null;\n        if (typeof onprocessorerror === \"function\") {\n          nativeAudioWorkletNodeFaker.addEventListener(\"processorerror\", onprocessorerror);\n        }\n      },\n      get parameters() {\n        return parameterMap;\n      },\n      get port() {\n        return messageChannel.port2;\n      },\n      addEventListener(...args) {\n        return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n      },\n      connect: connectMultipleOutputs2.bind(null, outputAudioNodes),\n      disconnect: disconnectMultipleOutputs2.bind(null, outputAudioNodes),\n      dispatchEvent(...args) {\n        return scriptProcessorNode.dispatchEvent(args[0]);\n      },\n      removeEventListener(...args) {\n        return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n      }\n    };\n    const patchedEventListeners = /* @__PURE__ */ new Map();\n    messageChannel.port1.addEventListener = /* @__PURE__ */ ((addEventListener) => {\n      return (...args) => {\n        if (args[0] === \"message\") {\n          const unpatchedEventListener = typeof args[1] === \"function\" ? args[1] : typeof args[1] === \"object\" && args[1] !== null && typeof args[1].handleEvent === \"function\" ? args[1].handleEvent : null;\n          if (unpatchedEventListener !== null) {\n            const patchedEventListener = patchedEventListeners.get(args[1]);\n            if (patchedEventListener !== void 0) {\n              args[1] = patchedEventListener;\n            } else {\n              args[1] = (event) => {\n                exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));\n              };\n              patchedEventListeners.set(unpatchedEventListener, args[1]);\n            }\n          }\n        }\n        return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.addEventListener);\n    messageChannel.port1.removeEventListener = /* @__PURE__ */ ((removeEventListener) => {\n      return (...args) => {\n        if (args[0] === \"message\") {\n          const patchedEventListener = patchedEventListeners.get(args[1]);\n          if (patchedEventListener !== void 0) {\n            patchedEventListeners.delete(args[1]);\n            args[1] = patchedEventListener;\n          }\n        }\n        return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n      };\n    })(messageChannel.port1.removeEventListener);\n    let onmessage = null;\n    Object.defineProperty(messageChannel.port1, \"onmessage\", {\n      get: () => onmessage,\n      set: (value) => {\n        if (typeof onmessage === \"function\") {\n          messageChannel.port1.removeEventListener(\"message\", onmessage);\n        }\n        onmessage = typeof value === \"function\" ? value : null;\n        if (typeof onmessage === \"function\") {\n          messageChannel.port1.addEventListener(\"message\", onmessage);\n          messageChannel.port1.start();\n        }\n      }\n    });\n    processorConstructor.prototype.port = messageChannel.port1;\n    let audioWorkletProcessor = null;\n    const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n    audioWorkletProcessorPromise.then((dWrkltPrcssr) => audioWorkletProcessor = dWrkltPrcssr);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters = processorConstructor.parameterDescriptors === void 0 ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    let isActive = true;\n    const disconnectOutputsGraph = () => {\n      if (options.numberOfOutputs > 0) {\n        scriptProcessorNode.disconnect(outputChannelSplitterNode);\n      }\n      for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n        const outputChannelMergerNode = outputChannelMergerNodes[i];\n        for (let j = 0; j < outputChannelCount[i]; j += 1) {\n          outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n        }\n        outputChannelSplitterNodeOutput += outputChannelCount[i];\n      }\n    };\n    const activeInputIndexes = /* @__PURE__ */ new Map();\n    scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n      if (audioWorkletProcessor !== null) {\n        const activeInputs = getActiveAudioWorkletNodeInputs2(nativeAudioWorkletNodeFaker);\n        for (let i = 0; i < bufferSize; i += 128) {\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.channelCount; k += 1) {\n              copyFromChannel(inputBuffer, inputs[j], k, k, i);\n            }\n          }\n          if (processorConstructor.parameterDescriptors !== void 0) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n              copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n          }\n          for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n              if (outputs[j][k].byteLength === 0) {\n                outputs[j][k] = new Float32Array(128);\n              }\n            }\n          }\n          try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n              const activeInput = activeInputs[index];\n              if (activeInput.size > 0) {\n                activeInputIndexes.set(index, bufferSize / 128);\n                return input;\n              }\n              const count = activeInputIndexes.get(index);\n              if (count === void 0) {\n                return [];\n              }\n              if (input.every((channelData) => channelData.every((sample) => sample === 0))) {\n                if (count === 1) {\n                  activeInputIndexes.delete(index);\n                } else {\n                  activeInputIndexes.set(index, count - 1);\n                }\n              }\n              return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n            isActive = activeSourceFlag;\n            for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n              for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n              }\n              outputChannelSplitterNodeOutput += outputChannelCount[j];\n            }\n          } catch (error) {\n            isActive = false;\n            nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent(\"processorerror\", {\n              colno: error.colno,\n              filename: error.filename,\n              lineno: error.lineno,\n              message: error.message\n            }));\n          }\n          if (!isActive) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n              gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n              for (let k = 0; k < options.channelCount; k += 1) {\n                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n              }\n            }\n            if (processorConstructor.parameterDescriptors !== void 0) {\n              const length = processorConstructor.parameterDescriptors.length;\n              for (let j = 0; j < length; j += 1) {\n                const constantSourceNode = constantSourceNodes[j];\n                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                constantSourceNode.stop();\n              }\n            }\n            inputChannelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.onaudioprocess = null;\n            if (isConnected) {\n              disconnectOutputsGraph();\n            } else {\n              disconnectFakeGraph();\n            }\n            break;\n          }\n        }\n      }\n    };\n    let isConnected = false;\n    const nativeGainNode = createNativeGainNode2(nativeContext, {\n      channelCount: 1,\n      channelCountMode: \"explicit\",\n      channelInterpretation: \"discrete\",\n      gain: 0\n    });\n    const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n    const disconnectFakeGraph = () => {\n      scriptProcessorNode.disconnect(nativeGainNode);\n      nativeGainNode.disconnect();\n    };\n    const whenConnected = () => {\n      if (isActive) {\n        disconnectFakeGraph();\n        if (options.numberOfOutputs > 0) {\n          scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n          const outputChannelMergerNode = outputChannelMergerNodes[i];\n          for (let j = 0; j < outputChannelCount[i]; j += 1) {\n            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n          }\n          outputChannelSplitterNodeOutput += outputChannelCount[i];\n        }\n      }\n      isConnected = true;\n    };\n    const whenDisconnected = () => {\n      if (isActive) {\n        connectFakeGraph();\n        disconnectOutputsGraph();\n      }\n      isConnected = false;\n    };\n    connectFakeGraph();\n    return monitorConnections2(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n  };\n};\nconst createNativeChannelMergerNodeFactory = (nativeAudioContextConstructor2, wrapChannelMergerNode2) => {\n  return (nativeContext, options) => {\n    const nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);\n    if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === \"webkitAudioContext\") {\n      wrapChannelMergerNode2(nativeContext, nativeChannelMergerNode);\n    }\n    assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n    return nativeChannelMergerNode;\n  };\n};\nconst wrapChannelSplitterNode = (channelSplitterNode) => {\n  const channelCount = channelSplitterNode.numberOfOutputs;\n  Object.defineProperty(channelSplitterNode, \"channelCount\", {\n    get: () => channelCount,\n    set: (value) => {\n      if (value !== channelCount) {\n        throw createInvalidStateError();\n      }\n    }\n  });\n  Object.defineProperty(channelSplitterNode, \"channelCountMode\", {\n    get: () => \"explicit\",\n    set: (value) => {\n      if (value !== \"explicit\") {\n        throw createInvalidStateError();\n      }\n    }\n  });\n  Object.defineProperty(channelSplitterNode, \"channelInterpretation\", {\n    get: () => \"discrete\",\n    set: (value) => {\n      if (value !== \"discrete\") {\n        throw createInvalidStateError();\n      }\n    }\n  });\n};\nconst createNativeChannelSplitterNode = (nativeContext, options) => {\n  const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);\n  assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n  wrapChannelSplitterNode(nativeChannelSplitterNode);\n  return nativeChannelSplitterNode;\n};\nconst createNativeConstantSourceNodeFactory = (addSilentConnection2, cacheTestResult2, createNativeConstantSourceNodeFaker2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2) => {\n  return (nativeContext, options) => {\n    if (nativeContext.createConstantSource === void 0) {\n      return createNativeConstantSourceNodeFaker2(nativeContext, options);\n    }\n    const nativeConstantSourceNode = nativeContext.createConstantSource();\n    assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n    assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, \"offset\");\n    if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {\n      wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n    }\n    if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {\n      wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n    }\n    addSilentConnection2(nativeContext, nativeConstantSourceNode);\n    return nativeConstantSourceNode;\n  };\n};\nconst interceptConnections = (original, interceptor) => {\n  original.connect = interceptor.connect.bind(interceptor);\n  original.disconnect = interceptor.disconnect.bind(interceptor);\n  return original;\n};\nconst createNativeConstantSourceNodeFakerFactory = (addSilentConnection2, createNativeAudioBufferSourceNode2, createNativeGainNode2, monitorConnections2) => {\n  return (nativeContext, { offset, ...audioNodeOptions }) => {\n    const audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n    const audioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, {\n      buffer: null,\n      channelCount: 2,\n      channelCountMode: \"max\",\n      channelInterpretation: \"speakers\",\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      playbackRate: 1\n    });\n    const gainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: offset });\n    const channelData = audioBuffer.getChannelData(0);\n    channelData[0] = 1;\n    channelData[1] = 1;\n    audioBufferSourceNode.buffer = audioBuffer;\n    audioBufferSourceNode.loop = true;\n    const nativeConstantSourceNodeFaker = {\n      get bufferSize() {\n        return void 0;\n      },\n      get channelCount() {\n        return gainNode.channelCount;\n      },\n      set channelCount(value) {\n        gainNode.channelCount = value;\n      },\n      get channelCountMode() {\n        return gainNode.channelCountMode;\n      },\n      set channelCountMode(value) {\n        gainNode.channelCountMode = value;\n      },\n      get channelInterpretation() {\n        return gainNode.channelInterpretation;\n      },\n      set channelInterpretation(value) {\n        gainNode.channelInterpretation = value;\n      },\n      get context() {\n        return gainNode.context;\n      },\n      get inputs() {\n        return [];\n      },\n      get numberOfInputs() {\n        return audioBufferSourceNode.numberOfInputs;\n      },\n      get numberOfOutputs() {\n        return gainNode.numberOfOutputs;\n      },\n      get offset() {\n        return gainNode.gain;\n      },\n      get onended() {\n        return audioBufferSourceNode.onended;\n      },\n      set onended(value) {\n        audioBufferSourceNode.onended = value;\n      },\n      addEventListener(...args) {\n        return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n      },\n      dispatchEvent(...args) {\n        return audioBufferSourceNode.dispatchEvent(args[0]);\n      },\n      removeEventListener(...args) {\n        return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n      },\n      start(when = 0) {\n        audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n      },\n      stop(when = 0) {\n        audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n      }\n    };\n    const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n    const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n    addSilentConnection2(nativeContext, audioBufferSourceNode);\n    return monitorConnections2(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n  };\n};\nconst createNativeGainNode = (nativeContext, options) => {\n  const nativeGainNode = nativeContext.createGain();\n  assignNativeAudioNodeOptions(nativeGainNode, options);\n  assignNativeAudioNodeAudioParamValue(nativeGainNode, options, \"gain\");\n  return nativeGainNode;\n};\nconst createNativeMediaStreamAudioSourceNode = (nativeAudioContext, { mediaStream }) => {\n  const audioStreamTracks = mediaStream.getAudioTracks();\n  audioStreamTracks.sort((a, b) => a.id < b.id ? -1 : a.id > b.id ? 1 : 0);\n  const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);\n  const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n  Object.defineProperty(nativeMediaStreamAudioSourceNode, \"mediaStream\", { value: mediaStream });\n  return nativeMediaStreamAudioSourceNode;\n};\nconst createNativeOfflineAudioContextConstructor = (window2) => {\n  if (window2 === null) {\n    return null;\n  }\n  if (window2.hasOwnProperty(\"OfflineAudioContext\")) {\n    return window2.OfflineAudioContext;\n  }\n  return window2.hasOwnProperty(\"webkitOfflineAudioContext\") ? window2.webkitOfflineAudioContext : null;\n};\nconst createNativeScriptProcessorNode = (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {\n  return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);\n};\nconst createNotSupportedError = () => new DOMException(\"\", \"NotSupportedError\");\nconst createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam2) => {\n  return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n    const audioParamRenderer = getAudioParamRenderer(audioParam);\n    audioParamRenderer.replay(nativeAudioParam);\n    return renderInputsOfAudioParam2(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n  };\n};\nconst createRenderInputsOfAudioNode = (getAudioNodeConnections2, getAudioNodeRenderer2, isPartOfACycle2) => {\n  return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n    const audioNodeConnections = getAudioNodeConnections2(audioNode);\n    await Promise.all(audioNodeConnections.activeInputs.map((connections2, input) => Array.from(connections2).map(async ([source, output]) => {\n      const audioNodeRenderer = getAudioNodeRenderer2(source);\n      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n      const destination = audioNode.context.destination;\n      if (!isPartOfACycle2(source) && (audioNode !== destination || !isPartOfACycle2(audioNode))) {\n        renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n      }\n    })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n  };\n};\nconst createRenderInputsOfAudioParam = (getAudioNodeRenderer2, getAudioParamConnections2, isPartOfACycle2) => {\n  return async (audioParam, nativeOfflineAudioContext, nativeAudioParam) => {\n    const audioParamConnections = getAudioParamConnections2(audioParam);\n    await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {\n      const audioNodeRenderer = getAudioNodeRenderer2(source);\n      const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n      if (!isPartOfACycle2(source)) {\n        renderedNativeAudioNode.connect(nativeAudioParam, output);\n      }\n    }));\n  };\n};\nconst createRenderNativeOfflineAudioContext = (cacheTestResult2, createNativeGainNode2, createNativeScriptProcessorNode2, testOfflineAudioContextCurrentTimeSupport) => {\n  return (nativeOfflineAudioContext) => {\n    if (cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n      return Promise.resolve(cacheTestResult2(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then((isOfflineAudioContextCurrentTimeSupported) => {\n        if (!isOfflineAudioContextCurrentTimeSupported) {\n          const scriptProcessorNode = createNativeScriptProcessorNode2(nativeOfflineAudioContext, 512, 0, 1);\n          nativeOfflineAudioContext.oncomplete = () => {\n            scriptProcessorNode.onaudioprocess = null;\n            scriptProcessorNode.disconnect();\n          };\n          scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime;\n          scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n        }\n        return nativeOfflineAudioContext.startRendering();\n      });\n    }\n    return new Promise((resolve) => {\n      const gainNode = createNativeGainNode2(nativeOfflineAudioContext, {\n        channelCount: 1,\n        channelCountMode: \"explicit\",\n        channelInterpretation: \"discrete\",\n        gain: 0\n      });\n      nativeOfflineAudioContext.oncomplete = (event) => {\n        gainNode.disconnect();\n        resolve(event.renderedBuffer);\n      };\n      gainNode.connect(nativeOfflineAudioContext.destination);\n      nativeOfflineAudioContext.startRendering();\n    });\n  };\n};\nconst createSetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore2) => {\n  return (nativeAudioWorkletNode, activeInputs) => {\n    activeAudioWorkletNodeInputsStore2.set(nativeAudioWorkletNode, activeInputs);\n  };\n};\nconst createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor2) => {\n  return () => {\n    if (nativeAudioBufferConstructor2 === null) {\n      return false;\n    }\n    try {\n      new nativeAudioBufferConstructor2({ length: 1, sampleRate: 44100 });\n    } catch {\n      return false;\n    }\n    return true;\n  };\n};\nconst createTestAudioWorkletProcessorPostMessageSupport = (nativeAudioWorkletNodeConstructor2, nativeOfflineAudioContextConstructor2) => {\n  return async () => {\n    if (nativeAudioWorkletNodeConstructor2 === null) {\n      return true;\n    }\n    if (nativeOfflineAudioContextConstructor2 === null) {\n      return false;\n    }\n    const blob2 = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor(\"a\",A)'], {\n      type: \"application/javascript; charset=utf-8\"\n    });\n    const offlineAudioContext = new nativeOfflineAudioContextConstructor2(1, 128, 44100);\n    const url2 = URL.createObjectURL(blob2);\n    let isEmittingMessageEvents = false;\n    let isEmittingProcessorErrorEvents = false;\n    try {\n      await offlineAudioContext.audioWorklet.addModule(url2);\n      const audioWorkletNode = new nativeAudioWorkletNodeConstructor2(offlineAudioContext, \"a\", { numberOfOutputs: 0 });\n      const oscillator = offlineAudioContext.createOscillator();\n      audioWorkletNode.port.onmessage = () => isEmittingMessageEvents = true;\n      audioWorkletNode.onprocessorerror = () => isEmittingProcessorErrorEvents = true;\n      oscillator.connect(audioWorkletNode);\n      oscillator.start(0);\n      await offlineAudioContext.startRendering();\n      await new Promise((resolve) => setTimeout(resolve));\n    } catch {\n    } finally {\n      URL.revokeObjectURL(url2);\n    }\n    return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;\n  };\n};\nconst createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode2, nativeOfflineAudioContextConstructor2) => {\n  return () => {\n    if (nativeOfflineAudioContextConstructor2 === null) {\n      return Promise.resolve(false);\n    }\n    const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);\n    const gainNode = createNativeGainNode2(nativeOfflineAudioContext, {\n      channelCount: 1,\n      channelCountMode: \"explicit\",\n      channelInterpretation: \"discrete\",\n      gain: 0\n    });\n    return new Promise((resolve) => {\n      nativeOfflineAudioContext.oncomplete = () => {\n        gainNode.disconnect();\n        resolve(nativeOfflineAudioContext.currentTime !== 0);\n      };\n      nativeOfflineAudioContext.startRendering();\n    });\n  };\n};\nconst createUnknownError = () => new DOMException(\"\", \"UnknownError\");\nconst createWindow$1 = () => typeof window === \"undefined\" ? null : window;\nconst createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong2, createIndexSizeError2) => {\n  return (audioBuffer) => {\n    audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n      const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);\n      const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);\n      if (channelNumber >= audioBuffer.numberOfChannels) {\n        throw createIndexSizeError2();\n      }\n      const audioBufferLength = audioBuffer.length;\n      const channelData = audioBuffer.getChannelData(channelNumber);\n      const destinationLength = destination.length;\n      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n        destination[i] = channelData[i + bufferOffset];\n      }\n    };\n    audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n      const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);\n      const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);\n      if (channelNumber >= audioBuffer.numberOfChannels) {\n        throw createIndexSizeError2();\n      }\n      const audioBufferLength = audioBuffer.length;\n      const channelData = audioBuffer.getChannelData(channelNumber);\n      const sourceLength = source.length;\n      for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n        channelData[i + bufferOffset] = source[i];\n      }\n    };\n  };\n};\nconst createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong2) => {\n  return (audioBuffer) => {\n    audioBuffer.copyFromChannel = /* @__PURE__ */ ((copyFromChannel2) => {\n      return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n        const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);\n        const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);\n        if (bufferOffset < audioBuffer.length) {\n          return copyFromChannel2.call(audioBuffer, destination, channelNumber, bufferOffset);\n        }\n      };\n    })(audioBuffer.copyFromChannel);\n    audioBuffer.copyToChannel = /* @__PURE__ */ ((copyToChannel2) => {\n      return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n        const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);\n        const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);\n        if (bufferOffset < audioBuffer.length) {\n          return copyToChannel2.call(audioBuffer, source, channelNumber, bufferOffset);\n        }\n      };\n    })(audioBuffer.copyToChannel);\n  };\n};\nconst createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = (overwriteAccessors2) => {\n  return (nativeAudioBufferSourceNode, nativeContext) => {\n    const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);\n    if (nativeAudioBufferSourceNode.buffer === null) {\n      nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n    }\n    overwriteAccessors2(nativeAudioBufferSourceNode, \"buffer\", (get) => () => {\n      const value = get.call(nativeAudioBufferSourceNode);\n      return value === nullifiedBuffer ? null : value;\n    }, (set) => (value) => {\n      return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n    });\n  };\n};\nconst createWrapChannelMergerNode = (createInvalidStateError2, monitorConnections2) => {\n  return (nativeContext, channelMergerNode) => {\n    channelMergerNode.channelCount = 1;\n    channelMergerNode.channelCountMode = \"explicit\";\n    Object.defineProperty(channelMergerNode, \"channelCount\", {\n      get: () => 1,\n      set: () => {\n        throw createInvalidStateError2();\n      }\n    });\n    Object.defineProperty(channelMergerNode, \"channelCountMode\", {\n      get: () => \"explicit\",\n      set: () => {\n        throw createInvalidStateError2();\n      }\n    });\n    const audioBufferSourceNode = nativeContext.createBufferSource();\n    const whenConnected = () => {\n      const length = channelMergerNode.numberOfInputs;\n      for (let i = 0; i < length; i += 1) {\n        audioBufferSourceNode.connect(channelMergerNode, 0, i);\n      }\n    };\n    const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n    monitorConnections2(channelMergerNode, whenConnected, whenDisconnected);\n  };\n};\nconst getFirstSample = (audioBuffer, buffer, channelNumber) => {\n  if (audioBuffer.copyFromChannel === void 0) {\n    return audioBuffer.getChannelData(channelNumber)[0];\n  }\n  audioBuffer.copyFromChannel(buffer, channelNumber);\n  return buffer[0];\n};\nconst overwriteAccessors = (object, property, createGetter, createSetter) => {\n  let prototype = object;\n  while (!prototype.hasOwnProperty(property)) {\n    prototype = Object.getPrototypeOf(prototype);\n  }\n  const { get, set } = Object.getOwnPropertyDescriptor(prototype, property);\n  Object.defineProperty(object, property, { get: createGetter(get), set: createSetter(set) });\n};\nconst sanitizeAudioWorkletNodeOptions = (options) => {\n  return {\n    ...options,\n    outputChannelCount: options.outputChannelCount !== void 0 ? options.outputChannelCount : options.numberOfInputs === 1 && options.numberOfOutputs === 1 ? (\n      /*\n       * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n       * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n       * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n       */\n      [options.channelCount]\n    ) : Array.from({ length: options.numberOfOutputs }, () => 1)\n  };\n};\nconst setValueAtTimeUntilPossible = (audioParam, value, startTime) => {\n  try {\n    audioParam.setValueAtTime(value, startTime);\n  } catch (err2) {\n    if (err2.code !== 9) {\n      throw err2;\n    }\n    setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);\n  }\n};\nconst testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext) => {\n  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n  nativeAudioBufferSourceNode.start();\n  try {\n    nativeAudioBufferSourceNode.start();\n  } catch {\n    return true;\n  }\n  return false;\n};\nconst testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext) => {\n  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n  const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n  nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n  try {\n    nativeAudioBufferSourceNode.start(0, 1);\n  } catch {\n    return false;\n  }\n  return true;\n};\nconst testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext) => {\n  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n  nativeAudioBufferSourceNode.start();\n  try {\n    nativeAudioBufferSourceNode.stop();\n  } catch {\n    return false;\n  }\n  return true;\n};\nconst testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext) => {\n  const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n  try {\n    nativeAudioBufferSourceNode.start(-1);\n  } catch (err2) {\n    return err2 instanceof RangeError;\n  }\n  return false;\n};\nconst testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext) => {\n  const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n  const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n  nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n  nativeAudioBufferSourceNode.start();\n  nativeAudioBufferSourceNode.stop();\n  try {\n    nativeAudioBufferSourceNode.stop();\n    return true;\n  } catch {\n    return false;\n  }\n};\nconst testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext) => {\n  const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n  try {\n    nativeAudioBufferSourceNode.stop(-1);\n  } catch (err2) {\n    return err2 instanceof RangeError;\n  }\n  return false;\n};\nconst testAudioWorkletNodeOptionsClonability = (audioWorkletNodeOptions) => {\n  const { port1, port2 } = new MessageChannel();\n  try {\n    port1.postMessage(audioWorkletNodeOptions);\n  } finally {\n    port1.close();\n    port2.close();\n  }\n};\nconst wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {\n  nativeAudioBufferSourceNode.start = /* @__PURE__ */ ((start) => {\n    return (when = 0, offset = 0, duration) => {\n      const buffer = nativeAudioBufferSourceNode.buffer;\n      const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n      if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n        start.call(nativeAudioBufferSourceNode, when, 0, 0);\n      } else {\n        start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n      }\n    };\n  })(nativeAudioBufferSourceNode.start);\n};\nconst wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (nativeAudioScheduledSourceNode, nativeContext) => {\n  const nativeGainNode = nativeContext.createGain();\n  nativeAudioScheduledSourceNode.connect(nativeGainNode);\n  const disconnectGainNode = /* @__PURE__ */ ((disconnect) => {\n    return () => {\n      disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n      nativeAudioScheduledSourceNode.removeEventListener(\"ended\", disconnectGainNode);\n    };\n  })(nativeAudioScheduledSourceNode.disconnect);\n  nativeAudioScheduledSourceNode.addEventListener(\"ended\", disconnectGainNode);\n  interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n  nativeAudioScheduledSourceNode.stop = /* @__PURE__ */ ((stop) => {\n    let isStopped = false;\n    return (when = 0) => {\n      if (isStopped) {\n        try {\n          stop.call(nativeAudioScheduledSourceNode, when);\n        } catch {\n          nativeGainNode.gain.setValueAtTime(0, when);\n        }\n      } else {\n        stop.call(nativeAudioScheduledSourceNode, when);\n        isStopped = true;\n      }\n    };\n  })(nativeAudioScheduledSourceNode.stop);\n};\nconst wrapEventListener$1 = (target, eventListener) => {\n  return (event) => {\n    const descriptor = { value: target };\n    Object.defineProperties(event, {\n      currentTarget: descriptor,\n      target: descriptor\n    });\n    if (typeof eventListener === \"function\") {\n      return eventListener.call(target, event);\n    }\n    return eventListener.handleEvent.call(target, event);\n  };\n};\nconst addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);\nconst addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);\nconst deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);\nconst audioNodeTailTimeStore = /* @__PURE__ */ new WeakMap();\nconst getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);\nconst cacheTestResult = createCacheTestResult(/* @__PURE__ */ new Map(), /* @__PURE__ */ new WeakMap());\nconst window$2 = createWindow$1();\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window$2);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst audioParamAudioNodeStore = /* @__PURE__ */ new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener$1);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window$2);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window$2);\nconst isNativeAudioParam = createIsNativeAudioParam(window$2);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window$2);\nconst audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode), cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor);\nconst audioBufferStore = /* @__PURE__ */ new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window$2);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);\nconst createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible);\nconst audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener$1);\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\nconst createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors);\nconst unrenderedAudioWorkletNodeStore = /* @__PURE__ */ new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener$1);\nconst isSecureContext = createIsSecureContext(window$2);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window$2);\nconst backupOfflineAudioContextStore = /* @__PURE__ */ new WeakMap();\nconst getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor);\nconst addAudioWorkletModule = isSecureContext ? createAddAudioWorkletModule(\n  cacheTestResult,\n  createNotSupportedError,\n  createEvaluateSource(window$2),\n  exposeCurrentFrameAndCurrentTime,\n  createFetchSource(createAbortError),\n  getNativeContext,\n  getOrCreateBackupOfflineAudioContext,\n  isNativeOfflineAudioContext,\n  nativeAudioWorkletNodeConstructor,\n  /* @__PURE__ */ new WeakMap(),\n  /* @__PURE__ */ new WeakMap(),\n  createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n  // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n  window$2\n) : void 0;\nconst mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst activeAudioWorkletNodeInputsStore = /* @__PURE__ */ new WeakMap();\nconst getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError, monitorConnections);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);\nconst getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);\nconst setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);\nconst audioWorkletNodeConstructor = isSecureContext ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener$1) : void 0;\nconst minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\nconst ERROR_MESSAGE = \"Missing AudioWorklet support. Maybe this is not running in a secure context.\";\nconst createPromisedAudioNodesEncoderInstanceIdAndPort = async (audioBuffer, audioContext, channelCount, mediaStream, mimeType) => {\n  const { encoderInstanceId, port } = await instantiate(mimeType, audioContext.sampleRate);\n  if (audioWorkletNodeConstructor === void 0) {\n    throw new Error(ERROR_MESSAGE);\n  }\n  const audioBufferSourceNode = audioBuffer === null ? null : new audioBufferSourceNodeConstructor(audioContext, { buffer: audioBuffer });\n  const mediaStreamAudioSourceNode = new mediaStreamAudioSourceNodeConstructor(audioContext, { mediaStream });\n  const recorderAudioWorkletNode = createRecorderAudioWorkletNode(audioWorkletNodeConstructor, audioContext, { channelCount });\n  return { audioBufferSourceNode, encoderInstanceId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode };\n};\nconst createWebAudioMediaRecorderFactory = (createBlobEvent2, createInvalidModificationError2, createInvalidStateError2, createNotSupportedError2) => {\n  return (eventTarget, mediaStream, mimeType) => {\n    var _a2;\n    const sampleRate = (_a2 = mediaStream.getAudioTracks()[0]) === null || _a2 === void 0 ? void 0 : _a2.getSettings().sampleRate;\n    const audioContext = new minimalAudioContextConstructor({ latencyHint: \"playback\", sampleRate });\n    const audioBuffer = MediaRecorder.isTypeSupported(\"audio/mp4\") ? new audioBufferConstructor({ length: 2688, sampleRate: audioContext.sampleRate }) : null;\n    const bufferedArrayBuffers = [];\n    const promisedAudioWorkletModule = addRecorderAudioWorkletModule((url2) => {\n      if (addAudioWorkletModule === void 0) {\n        throw new Error(ERROR_MESSAGE);\n      }\n      return addAudioWorkletModule(audioContext, url2);\n    });\n    let abortRecording = null;\n    let intervalId = null;\n    let promisedAudioNodesAndEncoderInstanceId = null;\n    let promisedPartialRecording = null;\n    let isAudioContextRunning = true;\n    const dispatchDataAvailableEvent = (arrayBuffers) => {\n      eventTarget.dispatchEvent(createBlobEvent2(\"dataavailable\", { data: new Blob(arrayBuffers, { type: mimeType }) }));\n    };\n    const requestNextPartialRecording = async (encoderInstanceId, timeslice) => {\n      const arrayBuffers = await encode(encoderInstanceId, timeslice);\n      if (promisedAudioNodesAndEncoderInstanceId === null) {\n        bufferedArrayBuffers.push(...arrayBuffers);\n      } else {\n        dispatchDataAvailableEvent(arrayBuffers);\n        promisedPartialRecording = requestNextPartialRecording(encoderInstanceId, timeslice);\n      }\n    };\n    const resume = () => {\n      isAudioContextRunning = true;\n      return audioContext.resume();\n    };\n    const stop = () => {\n      if (promisedAudioNodesAndEncoderInstanceId === null) {\n        return;\n      }\n      if (abortRecording !== null) {\n        mediaStream.removeEventListener(\"addtrack\", abortRecording);\n        mediaStream.removeEventListener(\"removetrack\", abortRecording);\n      }\n      if (intervalId !== null) {\n        clearTimeout(intervalId);\n      }\n      promisedAudioNodesAndEncoderInstanceId.then(async ({ encoderInstanceId, mediaStreamAudioSourceNode, recorderAudioWorkletNode }) => {\n        if (promisedPartialRecording !== null) {\n          promisedPartialRecording.catch(() => {\n          });\n          promisedPartialRecording = null;\n        }\n        await recorderAudioWorkletNode.stop();\n        mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n        const arrayBuffers = await encode(encoderInstanceId, null);\n        if (promisedAudioNodesAndEncoderInstanceId === null) {\n          await suspend();\n        }\n        dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n        bufferedArrayBuffers.length = 0;\n        eventTarget.dispatchEvent(new Event(\"stop\"));\n      });\n      promisedAudioNodesAndEncoderInstanceId = null;\n    };\n    const suspend = () => {\n      isAudioContextRunning = false;\n      return audioContext.suspend();\n    };\n    suspend();\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n      get state() {\n        return promisedAudioNodesAndEncoderInstanceId === null ? \"inactive\" : isAudioContextRunning ? \"recording\" : \"paused\";\n      },\n      pause() {\n        if (promisedAudioNodesAndEncoderInstanceId === null) {\n          throw createInvalidStateError2();\n        }\n        if (isAudioContextRunning) {\n          suspend();\n          eventTarget.dispatchEvent(new Event(\"pause\"));\n        }\n      },\n      resume() {\n        if (promisedAudioNodesAndEncoderInstanceId === null) {\n          throw createInvalidStateError2();\n        }\n        if (!isAudioContextRunning) {\n          resume();\n          eventTarget.dispatchEvent(new Event(\"resume\"));\n        }\n      },\n      start(timeslice) {\n        var _a3;\n        if (promisedAudioNodesAndEncoderInstanceId !== null) {\n          throw createInvalidStateError2();\n        }\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError2();\n        }\n        eventTarget.dispatchEvent(new Event(\"start\"));\n        const audioTracks = mediaStream.getAudioTracks();\n        const channelCount = audioTracks.length === 0 ? 2 : (_a3 = audioTracks[0].getSettings().channelCount) !== null && _a3 !== void 0 ? _a3 : 2;\n        promisedAudioNodesAndEncoderInstanceId = Promise.all([\n          resume(),\n          promisedAudioWorkletModule.then(() => createPromisedAudioNodesEncoderInstanceIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType))\n        ]).then(async ([, { audioBufferSourceNode, encoderInstanceId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode }]) => {\n          mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n          if (audioBufferSourceNode !== null) {\n            await new Promise((resolve) => {\n              audioBufferSourceNode.onended = resolve;\n              audioBufferSourceNode.connect(recorderAudioWorkletNode);\n              audioBufferSourceNode.start();\n            });\n            audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n          }\n          await recorderAudioWorkletNode.record(port);\n          if (timeslice !== void 0) {\n            promisedPartialRecording = requestNextPartialRecording(encoderInstanceId, timeslice);\n          }\n          return { encoderInstanceId, mediaStreamAudioSourceNode, recorderAudioWorkletNode };\n        });\n        const tracks = mediaStream.getTracks();\n        abortRecording = () => {\n          stop();\n          eventTarget.dispatchEvent(new ErrorEvent(\"error\", { error: createInvalidModificationError2() }));\n        };\n        mediaStream.addEventListener(\"addtrack\", abortRecording);\n        mediaStream.addEventListener(\"removetrack\", abortRecording);\n        intervalId = setInterval(() => {\n          const currentTracks = mediaStream.getTracks();\n          if ((currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) && abortRecording !== null) {\n            abortRecording();\n          }\n        }, 1e3);\n      },\n      stop\n    };\n  };\n};\nclass MultiBufferDataView {\n  constructor(buffers, byteOffset = 0, byteLength) {\n    if (byteOffset < 0 || byteLength !== void 0 && byteLength < 0) {\n      throw new RangeError();\n    }\n    const availableBytes = buffers.reduce((length, buffer) => length + buffer.byteLength, 0);\n    if (byteOffset > availableBytes || byteLength !== void 0 && byteOffset + byteLength > availableBytes) {\n      throw new RangeError();\n    }\n    const dataViews = [];\n    const effectiveByteLength = byteLength === void 0 ? availableBytes - byteOffset : byteLength;\n    const truncatedBuffers = [];\n    let consumedByteLength = 0;\n    let truncatedByteOffset = byteOffset;\n    for (const buffer of buffers) {\n      if (truncatedBuffers.length === 0) {\n        if (buffer.byteLength > truncatedByteOffset) {\n          consumedByteLength = buffer.byteLength - truncatedByteOffset;\n          const byteLengthOfDataView = consumedByteLength > effectiveByteLength ? effectiveByteLength : consumedByteLength;\n          dataViews.push(new DataView(buffer, truncatedByteOffset, byteLengthOfDataView));\n          truncatedBuffers.push(buffer);\n        } else {\n          truncatedByteOffset -= buffer.byteLength;\n        }\n      } else if (consumedByteLength < effectiveByteLength) {\n        consumedByteLength += buffer.byteLength;\n        const byteLengthOfDataView = consumedByteLength > effectiveByteLength ? buffer.byteLength - consumedByteLength + effectiveByteLength : buffer.byteLength;\n        dataViews.push(new DataView(buffer, 0, byteLengthOfDataView));\n        truncatedBuffers.push(buffer);\n      }\n    }\n    this._buffers = truncatedBuffers;\n    this._byteLength = effectiveByteLength;\n    this._byteOffset = truncatedByteOffset;\n    this._dataViews = dataViews;\n    this._internalBuffer = new DataView(new ArrayBuffer(8));\n  }\n  get buffers() {\n    return this._buffers;\n  }\n  get byteLength() {\n    return this._byteLength;\n  }\n  get byteOffset() {\n    return this._byteOffset;\n  }\n  getFloat32(byteOffset, littleEndian) {\n    this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n    this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n    this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));\n    this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));\n    return this._internalBuffer.getFloat32(0, littleEndian);\n  }\n  getFloat64(byteOffset, littleEndian) {\n    this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n    this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n    this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));\n    this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));\n    this._internalBuffer.setUint8(4, this.getUint8(byteOffset + 4));\n    this._internalBuffer.setUint8(5, this.getUint8(byteOffset + 5));\n    this._internalBuffer.setUint8(6, this.getUint8(byteOffset + 6));\n    this._internalBuffer.setUint8(7, this.getUint8(byteOffset + 7));\n    return this._internalBuffer.getFloat64(0, littleEndian);\n  }\n  getInt16(byteOffset, littleEndian) {\n    this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n    this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n    return this._internalBuffer.getInt16(0, littleEndian);\n  }\n  getInt32(byteOffset, littleEndian) {\n    this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n    this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n    this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));\n    this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));\n    return this._internalBuffer.getInt32(0, littleEndian);\n  }\n  getInt8(byteOffset) {\n    const [dataView, byteOffsetOfDataView] = this._findDataViewWithOffset(byteOffset);\n    return dataView.getInt8(byteOffset - byteOffsetOfDataView);\n  }\n  getUint16(byteOffset, littleEndian) {\n    this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n    this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n    return this._internalBuffer.getUint16(0, littleEndian);\n  }\n  getUint32(byteOffset, littleEndian) {\n    this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));\n    this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));\n    this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));\n    this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));\n    return this._internalBuffer.getUint32(0, littleEndian);\n  }\n  getUint8(byteOffset) {\n    const [dataView, byteOffsetOfDataView] = this._findDataViewWithOffset(byteOffset);\n    return dataView.getUint8(byteOffset - byteOffsetOfDataView);\n  }\n  setFloat32(byteOffset, value, littleEndian) {\n    this._internalBuffer.setFloat32(0, value, littleEndian);\n    this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n    this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n    this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));\n    this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));\n  }\n  setFloat64(byteOffset, value, littleEndian) {\n    this._internalBuffer.setFloat64(0, value, littleEndian);\n    this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n    this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n    this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));\n    this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));\n    this.setUint8(byteOffset + 4, this._internalBuffer.getUint8(4));\n    this.setUint8(byteOffset + 5, this._internalBuffer.getUint8(5));\n    this.setUint8(byteOffset + 6, this._internalBuffer.getUint8(6));\n    this.setUint8(byteOffset + 7, this._internalBuffer.getUint8(7));\n  }\n  setInt16(byteOffset, value, littleEndian) {\n    this._internalBuffer.setInt16(0, value, littleEndian);\n    this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n    this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n  }\n  setInt32(byteOffset, value, littleEndian) {\n    this._internalBuffer.setInt32(0, value, littleEndian);\n    this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n    this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n    this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));\n    this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));\n  }\n  setInt8(byteOffset, value) {\n    const [dataView, byteOffsetOfDataView] = this._findDataViewWithOffset(byteOffset);\n    dataView.setInt8(byteOffset - byteOffsetOfDataView, value);\n  }\n  setUint16(byteOffset, value, littleEndian) {\n    this._internalBuffer.setUint16(0, value, littleEndian);\n    this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n    this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n  }\n  setUint32(byteOffset, value, littleEndian) {\n    this._internalBuffer.setUint32(0, value, littleEndian);\n    this.setUint8(byteOffset, this._internalBuffer.getUint8(0));\n    this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));\n    this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));\n    this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));\n  }\n  setUint8(byteOffset, value) {\n    const [dataView, byteOffsetOfDataView] = this._findDataViewWithOffset(byteOffset);\n    dataView.setUint8(byteOffset - byteOffsetOfDataView, value);\n  }\n  _findDataViewWithOffset(byteOffset) {\n    let byteOffsetOfDataView = 0;\n    for (const dataView of this._dataViews) {\n      const byteOffsetOfNextDataView = byteOffsetOfDataView + dataView.byteLength;\n      if (byteOffset >= byteOffsetOfDataView && byteOffset < byteOffsetOfNextDataView) {\n        return [dataView, byteOffsetOfDataView];\n      }\n      byteOffsetOfDataView = byteOffsetOfNextDataView;\n    }\n    throw new RangeError();\n  }\n}\nconst createWebmPcmMediaRecorderFactory = (createBlobEvent2, decodeWebMChunk2, readVariableSizeInteger2) => {\n  return (eventTarget, nativeMediaRecorderConstructor2, mediaStream, mimeType) => {\n    const bufferedArrayBuffers = [];\n    const nativeMediaRecorder = new nativeMediaRecorderConstructor2(mediaStream, { mimeType: \"audio/webm; codecs=pcm\" });\n    let promisedPartialRecording = null;\n    let stopRecording = () => {\n    };\n    const dispatchDataAvailableEvent = (arrayBuffers) => {\n      eventTarget.dispatchEvent(createBlobEvent2(\"dataavailable\", { data: new Blob(arrayBuffers, { type: mimeType }) }));\n    };\n    const requestNextPartialRecording = async (encoderInstanceId, timeslice) => {\n      const arrayBuffers = await encode(encoderInstanceId, timeslice);\n      if (nativeMediaRecorder.state === \"inactive\") {\n        bufferedArrayBuffers.push(...arrayBuffers);\n      } else {\n        dispatchDataAvailableEvent(arrayBuffers);\n        promisedPartialRecording = requestNextPartialRecording(encoderInstanceId, timeslice);\n      }\n    };\n    const stop = () => {\n      if (nativeMediaRecorder.state === \"inactive\") {\n        return;\n      }\n      if (promisedPartialRecording !== null) {\n        promisedPartialRecording.catch(() => {\n        });\n        promisedPartialRecording = null;\n      }\n      stopRecording();\n      stopRecording = () => {\n      };\n      nativeMediaRecorder.stop();\n    };\n    nativeMediaRecorder.addEventListener(\"error\", (event) => {\n      stop();\n      eventTarget.dispatchEvent(new ErrorEvent(\"error\", {\n        error: event.error\n      }));\n    });\n    nativeMediaRecorder.addEventListener(\"pause\", () => eventTarget.dispatchEvent(new Event(\"pause\")));\n    nativeMediaRecorder.addEventListener(\"resume\", () => eventTarget.dispatchEvent(new Event(\"resume\")));\n    nativeMediaRecorder.addEventListener(\"start\", () => eventTarget.dispatchEvent(new Event(\"start\")));\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n      get state() {\n        return nativeMediaRecorder.state;\n      },\n      pause() {\n        return nativeMediaRecorder.pause();\n      },\n      resume() {\n        return nativeMediaRecorder.resume();\n      },\n      start(timeslice) {\n        const [audioTrack] = mediaStream.getAudioTracks();\n        if (audioTrack !== void 0 && nativeMediaRecorder.state === \"inactive\") {\n          const { channelCount, sampleRate } = audioTrack.getSettings();\n          if (channelCount === void 0) {\n            throw new Error(\"The channelCount is not defined.\");\n          }\n          if (sampleRate === void 0) {\n            throw new Error(\"The sampleRate is not defined.\");\n          }\n          let isRecording = false;\n          let isStopped = false;\n          let pendingInvocations = 0;\n          let promisedDataViewElementTypeEncoderInstanceIdAndPort = instantiate(mimeType, sampleRate);\n          stopRecording = () => {\n            isStopped = true;\n          };\n          const removeEventListener = on(nativeMediaRecorder, \"dataavailable\")(({ data }) => {\n            pendingInvocations += 1;\n            const promisedArrayBuffer = data.arrayBuffer();\n            promisedDataViewElementTypeEncoderInstanceIdAndPort = promisedDataViewElementTypeEncoderInstanceIdAndPort.then(async ({ dataView = null, elementType = null, encoderInstanceId, port }) => {\n              const arrayBuffer = await promisedArrayBuffer;\n              pendingInvocations -= 1;\n              const currentDataView = dataView === null ? new MultiBufferDataView([arrayBuffer]) : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n              if (!isRecording && nativeMediaRecorder.state === \"recording\" && !isStopped) {\n                const lengthAndValue = readVariableSizeInteger2(currentDataView, 0);\n                if (lengthAndValue === null) {\n                  return { dataView: currentDataView, elementType, encoderInstanceId, port };\n                }\n                const { value } = lengthAndValue;\n                if (value !== 172351395) {\n                  return { dataView, elementType, encoderInstanceId, port };\n                }\n                isRecording = true;\n              }\n              const { currentElementType, offset, contents } = decodeWebMChunk2(currentDataView, elementType, channelCount);\n              const remainingDataView = offset < currentDataView.byteLength ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset) : null;\n              contents.forEach((content) => port.postMessage(content, content.map(({ buffer }) => buffer)));\n              if (pendingInvocations === 0 && (nativeMediaRecorder.state === \"inactive\" || isStopped)) {\n                encode(encoderInstanceId, null).then((arrayBuffers) => {\n                  dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n                  bufferedArrayBuffers.length = 0;\n                  eventTarget.dispatchEvent(new Event(\"stop\"));\n                });\n                port.postMessage([]);\n                port.close();\n                removeEventListener();\n              }\n              return { dataView: remainingDataView, elementType: currentElementType, encoderInstanceId, port };\n            });\n          });\n          if (timeslice !== void 0) {\n            promisedDataViewElementTypeEncoderInstanceIdAndPort.then(({ encoderInstanceId }) => {\n              if (isStopped) {\n                return;\n              }\n              promisedPartialRecording = requestNextPartialRecording(encoderInstanceId, timeslice);\n            });\n          }\n        }\n        nativeMediaRecorder.start(100);\n      },\n      stop\n    };\n  };\n};\nconst createWindow = () => typeof window === \"undefined\" ? null : window;\nconst readVariableSizeIntegerLength = (dataView, offset) => {\n  if (offset >= dataView.byteLength) {\n    return null;\n  }\n  const byte = dataView.getUint8(offset);\n  if (byte > 127) {\n    return 1;\n  }\n  if (byte > 63) {\n    return 2;\n  }\n  if (byte > 31) {\n    return 3;\n  }\n  if (byte > 15) {\n    return 4;\n  }\n  if (byte > 7) {\n    return 5;\n  }\n  if (byte > 3) {\n    return 6;\n  }\n  if (byte > 1) {\n    return 7;\n  }\n  if (byte > 0) {\n    return 8;\n  }\n  const length = readVariableSizeIntegerLength(dataView, offset + 1);\n  return length === null ? null : length + 8;\n};\nconst wrapEventListener = (target, eventListener) => {\n  return (event) => {\n    const descriptor = { value: target };\n    Object.defineProperties(event, {\n      currentTarget: descriptor,\n      target: descriptor\n    });\n    if (typeof eventListener === \"function\") {\n      return eventListener.call(target, event);\n    }\n    return eventListener.handleEvent.call(target, event);\n  };\n};\nconst encoderRegexes = [];\nconst window$1 = createWindow();\nconst nativeBlobEventConstructor = createNativeBlobEventConstructor(window$1);\nconst createBlobEvent = createBlobEventFactory(nativeBlobEventConstructor);\nconst createWebAudioMediaRecorder = createWebAudioMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createInvalidStateError$1, createNotSupportedError$1);\nconst readVariableSizeInteger = createReadVariableSizeInteger(readVariableSizeIntegerLength);\nconst readElementContent = createReadElementContent(readVariableSizeInteger);\nconst readElementType = createReadElementType(readVariableSizeInteger);\nconst decodeWebMChunk = createDecodeWebMChunk(readElementContent, readElementType);\nconst createWebmPcmMediaRecorder = createWebmPcmMediaRecorderFactory(createBlobEvent, decodeWebMChunk, readVariableSizeInteger);\nconst createEventTarget = createEventTargetFactory(window$1);\nconst nativeMediaRecorderConstructor = createNativeMediaRecorderConstructor(window$1);\nconst mediaRecorderConstructor = createMediaRecorderConstructor(createNativeMediaRecorderFactory(createNotSupportedError$1), createNotSupportedError$1, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, createEventTargetConstructor$1(createEventTarget, wrapEventListener), nativeMediaRecorderConstructor);\nconst ports = /* @__PURE__ */ new WeakMap();\nconst register = async (port) => {\n  const encoderRegex = await register$1(port);\n  encoderRegexes.push(encoderRegex);\n  ports.set(port, encoderRegex);\n};\nconst wrap = createBroker({\n  characterize: ({ call }) => {\n    return () => call(\"characterize\");\n  },\n  encode: ({ call }) => {\n    return (recordingId, timeslice) => {\n      return call(\"encode\", { recordingId, timeslice });\n    };\n  },\n  record: ({ call }) => {\n    return async (recordingId, sampleRate, typedArrays) => {\n      await call(\"record\", { recordingId, sampleRate, typedArrays }, typedArrays.map(({ buffer }) => buffer));\n    };\n  }\n});\nconst load = (url2) => {\n  const worker2 = new Worker(url2);\n  return wrap(worker2);\n};\nconst worker = `(()=>{var e={455:function(e,t){!function(e){\"use strict\";var t=function(e){return function(t){var r=e(t);return t.add(r),r}},r=function(e){return function(t,r){return e.set(t,r),r}},n=void 0===Number.MAX_SAFE_INTEGER?9007199254740991:Number.MAX_SAFE_INTEGER,s=536870912,a=2*s,o=function(e,t){return function(r){var o=t.get(r),i=void 0===o?r.size:o<a?o+1:0;if(!r.has(i))return e(r,i);if(r.size<s){for(;r.has(i);)i=Math.floor(Math.random()*a);return e(r,i)}if(r.size>n)throw new Error(\"Congratulations, you created a collection of unique numbers which uses all available integers!\");for(;r.has(i);)i=Math.floor(Math.random()*n);return e(r,i)}},i=new WeakMap,c=r(i),l=o(c,i),u=t(l);e.addUniqueNumber=u,e.generateUniqueNumber=l}(t)}},t={};function r(n){var s=t[n];if(void 0!==s)return s.exports;var a=t[n]={exports:{}};return e[n].call(a.exports,a,a.exports,r),a.exports}(()=>{\"use strict\";const e=-32603,t=-32602,n=-32601,s=(e,t)=>Object.assign(new Error(e),{status:t}),a=t=>s('The handler of the method called \"'.concat(t,'\" returned an unexpected result.'),e),o=(t,r)=>async({data:{id:o,method:i,params:c}})=>{const l=r[i];try{if(void 0===l)throw(e=>s('The requested method called \"'.concat(e,'\" is not supported.'),n))(i);const r=void 0===c?l():l(c);if(void 0===r)throw(t=>s('The handler of the method called \"'.concat(t,'\" returned no required result.'),e))(i);const u=r instanceof Promise?await r:r;if(null===o){if(void 0!==u.result)throw a(i)}else{if(void 0===u.result)throw a(i);const{result:e,transferables:r=[]}=u;t.postMessage({id:o,result:e},r)}}catch(e){const{message:r,status:n=-32603}=e;t.postMessage({error:{code:n,message:r},id:o})}};var i=r(455);const c=new Map,l=(e,r,n)=>({...r,connect:({port:t})=>{t.start();const n=e(t,r),s=(0,i.generateUniqueNumber)(c);return c.set(s,(()=>{n(),t.close(),c.delete(s)})),{result:s}},disconnect:({portId:e})=>{const r=c.get(e);if(void 0===r)throw(e=>s('The specified parameter called \"portId\" with the given value \"'.concat(e,'\" does not identify a port connected to this worker.'),t))(e);return r(),{result:null}},isSupported:async()=>{if(await new Promise((e=>{const t=new ArrayBuffer(0),{port1:r,port2:n}=new MessageChannel;r.onmessage=({data:t})=>e(null!==t),n.postMessage(t,[t])}))){const e=n();return{result:e instanceof Promise?await e:e}}return{result:!1}}}),u=(e,t,r=()=>!0)=>{const n=l(u,t,r),s=o(e,n);return e.addEventListener(\"message\",s),()=>e.removeEventListener(\"message\",s)},d=e=>e.reduce(((e,t)=>e+t.length),0),h=(e,t)=>{const r=[];let n=0;e:for(;n<t;){const t=e.length;for(let s=0;s<t;s+=1){const t=e[s];void 0===r[s]&&(r[s]=[]);const a=t.shift();if(void 0===a)break e;r[s].push(a),0===s&&(n+=a.length)}}if(n>t){const s=n-t;r.forEach(((t,r)=>{const n=t.pop(),a=n.length-s;t.push(n.subarray(0,a)),e[r].unshift(n.subarray(a))}))}return r},f=new Map,m=(e=>(t,r,n)=>{const s=e.get(t);if(void 0===s){const s={channelDataArrays:n.map((e=>[e])),isComplete:!0,sampleRate:r};return e.set(t,s),s}return s.channelDataArrays.forEach(((e,t)=>e.push(n[t]))),s})(f),p=((e,t)=>(r,n,s,a)=>{const o=s>>3,i=\"subsequent\"===n?0:44,c=r.length,l=e(r[0]),u=new ArrayBuffer(l*c*o+i),d=new DataView(u);return\"subsequent\"!==n&&t(d,s,c,\"complete\"===n?l:Number.POSITIVE_INFINITY,a),r.forEach(((e,t)=>{let r=i+t*o;e.forEach((e=>{const t=e.length;for(let n=0;n<t;n+=1){const t=e[n];d.setInt16(r,t<0?32768*Math.max(-1,t):32767*Math.min(1,t),!0),r+=c*o}}))})),[u]})(d,((e,t,r,n,s)=>{const a=t>>3,o=Math.min(n*r*a,4294967251);e.setUint32(0,1380533830),e.setUint32(4,o+36,!0),e.setUint32(8,1463899717),e.setUint32(12,1718449184),e.setUint32(16,16,!0),e.setUint16(20,1,!0),e.setUint16(22,r,!0),e.setUint32(24,s,!0),e.setUint32(28,s*r*a,!0),e.setUint16(32,r*a,!0),e.setUint16(34,t,!0),e.setUint32(36,1684108385),e.setUint32(40,o,!0)})),v=new Map;u(self,{characterize:()=>({result:/^audio\\\\/wav$/}),encode:({recordingId:e,timeslice:t})=>{const r=v.get(e);void 0!==r&&(v.delete(e),r.reject(new Error(\"Another request was made to initiate an encoding.\")));const n=f.get(e);if(null!==t){if(void 0===n||d(n.channelDataArrays[0])*(1e3/n.sampleRate)<t)return new Promise(((r,n)=>{v.set(e,{reject:n,resolve:r,timeslice:t})}));const r=h(n.channelDataArrays,Math.ceil(t*(n.sampleRate/1e3))),s=p(r,n.isComplete?\"initial\":\"subsequent\",16,n.sampleRate);return n.isComplete=!1,{result:s,transferables:s}}if(void 0!==n){const t=p(n.channelDataArrays,n.isComplete?\"complete\":\"subsequent\",16,n.sampleRate);return f.delete(e),{result:t,transferables:t}}return{result:[],transferables:[]}},record:({recordingId:e,sampleRate:t,typedArrays:r})=>{const n=m(e,t,r),s=v.get(e);if(void 0!==s&&d(n.channelDataArrays[0])*(1e3/t)>=s.timeslice){const r=h(n.channelDataArrays,Math.ceil(s.timeslice*(t/1e3))),a=p(r,n.isComplete?\"initial\":\"subsequent\",16,t);n.isComplete=!1,v.delete(e),s.resolve({result:a,transferables:a})}return{result:null}}})})()})();`;\nconst blob = new Blob([worker], { type: \"application/javascript; charset=utf-8\" });\nconst url = URL.createObjectURL(blob);\nconst extendableMediaRecorderWavEncoder = load(url);\nconst connect = extendableMediaRecorderWavEncoder.connect;\nURL.revokeObjectURL(url);\nlet isEncoderRegistered = false;\nconst useAudioService = () => {\n  const handleError = (type, message, originalError) => {\n    console.error(`Audio Service Error (${type}):`, message, originalError);\n  };\n  const stopAllTracks = (currentStream) => {\n    if (currentStream) {\n      currentStream.getTracks().forEach((track) => {\n        track.stop();\n      });\n      currentStream = null;\n    }\n  };\n  const registerWavEncoder = async () => {\n    if (isEncoderRegistered) {\n      return;\n    }\n    try {\n      await register(await connect());\n      isEncoderRegistered = true;\n    } catch (err2) {\n      if (err2 instanceof Error && err2.message.includes(\"already an encoder stored\")) {\n        isEncoderRegistered = true;\n      } else {\n        handleError(\"encoder\", \"Failed to register WAV encoder\", err2);\n      }\n    }\n  };\n  const convertBlobToFileAndSubmit = async (blob2) => {\n    const name = `recording-${Date.now()}.wav`;\n    const file2 = new File([blob2], name, { type: blob2.type || \"audio/wav\" });\n    const body = new FormData();\n    body.append(\"image\", file2);\n    body.append(\"subfolder\", \"audio\");\n    body.append(\"type\", \"temp\");\n    const resp = await api.fetchApi(\"/upload/image\", {\n      method: \"POST\",\n      body\n    });\n    if (resp.status !== 200) {\n      const err2 = `Error uploading temp file: ${resp.status} - ${resp.statusText}`;\n      useToastStore().addAlert(err2);\n      throw new Error(err2);\n    }\n    const tempAudio = await resp.json();\n    return `audio/${tempAudio.name} [temp]`;\n  };\n  return {\n    // Methods\n    convertBlobToFileAndSubmit,\n    registerWavEncoder,\n    stopAllTracks\n  };\n};\nfunction splitFilePath(path) {\n  const folder_separator = path.lastIndexOf(\"/\");\n  if (folder_separator === -1) {\n    return [\"\", path];\n  }\n  return [\n    path.substring(0, folder_separator),\n    path.substring(folder_separator + 1)\n  ];\n}\nfunction getResourceURL(subfolder, filename, type = \"input\") {\n  const params = [\n    \"filename=\" + encodeURIComponent(filename),\n    \"type=\" + type,\n    \"subfolder=\" + subfolder,\n    app.getRandParam().substring(1)\n  ].join(\"&\");\n  return `/view?${params}`;\n}\nasync function uploadFile(audioWidget, audioUIWidget, file2, updateNode, pasted = false) {\n  try {\n    const body = new FormData();\n    body.append(\"image\", file2);\n    if (pasted) body.append(\"subfolder\", \"pasted\");\n    const resp = await api.fetchApi(\"/upload/image\", {\n      method: \"POST\",\n      body\n    });\n    if (resp.status === 200) {\n      const data = await resp.json();\n      let path = data.name;\n      if (data.subfolder) path = data.subfolder + \"/\" + path;\n      if (!audioWidget.options.values.includes(path)) {\n        audioWidget.options.values.push(path);\n      }\n      if (updateNode) {\n        audioUIWidget.element.src = api.apiURL(\n          getResourceURL(...splitFilePath(path))\n        );\n        audioWidget.value = path;\n      }\n    } else {\n      useToastStore().addAlert(resp.status + \" - \" + resp.statusText);\n    }\n  } catch (error) {\n    useToastStore().addAlert(error);\n  }\n}\napp.registerExtension({\n  name: \"Comfy.AudioWidget\",\n  async beforeRegisterNodeDef(nodeType, nodeData) {\n    if ([\n      \"LoadAudio\",\n      \"SaveAudio\",\n      \"PreviewAudio\",\n      \"SaveAudioMP3\",\n      \"SaveAudioOpus\"\n    ].includes(\n      // @ts-expect-error fixme ts strict error\n      nodeType.prototype.comfyClass\n    )) {\n      nodeData.input.required.audioUI = [\"AUDIO_UI\", {}];\n    }\n  },\n  getCustomWidgets() {\n    return {\n      AUDIO_UI(node, inputName) {\n        const audio = document.createElement(\"audio\");\n        audio.controls = true;\n        audio.classList.add(\"comfy-audio\");\n        audio.setAttribute(\"name\", \"media\");\n        const audioUIWidget = node.addDOMWidget(\n          inputName,\n          /* name=*/\n          \"audioUI\",\n          audio\n        );\n        audioUIWidget.serialize = false;\n        const { nodeData } = node.constructor;\n        if (nodeData == null) throw new TypeError(\"nodeData is null\");\n        const isOutputNode = nodeData.output_node;\n        if (isOutputNode) {\n          audioUIWidget.element.classList.add(\"empty-audio-widget\");\n          const onExecuted = node.onExecuted;\n          node.onExecuted = function(message) {\n            onExecuted == null ? void 0 : onExecuted.apply(this, arguments);\n            const audios = message.audio;\n            if (!audios) return;\n            const audio2 = audios[0];\n            audioUIWidget.element.src = api.apiURL(\n              getResourceURL(audio2.subfolder, audio2.filename, audio2.type)\n            );\n            audioUIWidget.element.classList.remove(\"empty-audio-widget\");\n          };\n        }\n        audioUIWidget.onRemove = useChainCallback(\n          audioUIWidget.onRemove,\n          () => {\n            if (!audioUIWidget.element) return;\n            audioUIWidget.element.pause();\n            audioUIWidget.element.src = \"\";\n            audioUIWidget.element.remove();\n          }\n        );\n        return { widget: audioUIWidget };\n      }\n    };\n  },\n  onNodeOutputsUpdated(nodeOutputs) {\n    for (const [nodeLocatorId, output] of Object.entries(nodeOutputs)) {\n      if (\"audio\" in output) {\n        const node = getNodeByLocatorId(app.graph, nodeLocatorId);\n        if (!node) continue;\n        const audioUIWidget = node.widgets.find(\n          (w) => w.name === \"audioUI\"\n        );\n        const audio = output.audio[0];\n        audioUIWidget.element.src = api.apiURL(\n          getResourceURL(audio.subfolder, audio.filename, audio.type)\n        );\n        audioUIWidget.element.classList.remove(\"empty-audio-widget\");\n      }\n    }\n  }\n});\napp.registerExtension({\n  name: \"Comfy.UploadAudio\",\n  async beforeRegisterNodeDef(_nodeType, nodeData) {\n    var _a2, _b2, _c, _d;\n    if (((_d = (_c = (_b2 = (_a2 = nodeData == null ? void 0 : nodeData.input) == null ? void 0 : _a2.required) == null ? void 0 : _b2.audio) == null ? void 0 : _c[1]) == null ? void 0 : _d.audio_upload) === true) {\n      nodeData.input.required.upload = [\"AUDIOUPLOAD\", {}];\n    }\n  },\n  getCustomWidgets() {\n    return {\n      AUDIOUPLOAD(node, inputName) {\n        const audioWidget = node.widgets.find(\n          (w) => w.name === \"audio\"\n        );\n        const audioUIWidget = node.widgets.find(\n          (w) => w.name === \"audioUI\"\n        );\n        const onAudioWidgetUpdate = () => {\n          audioUIWidget.element.src = api.apiURL(\n            getResourceURL(...splitFilePath(audioWidget.value))\n          );\n        };\n        if (audioWidget.value) {\n          onAudioWidgetUpdate();\n        }\n        audioWidget.callback = onAudioWidgetUpdate;\n        const onGraphConfigured = node.onGraphConfigured;\n        node.onGraphConfigured = function() {\n          onGraphConfigured == null ? void 0 : onGraphConfigured.apply(this, arguments);\n          if (audioWidget.value) {\n            onAudioWidgetUpdate();\n          }\n        };\n        const handleUpload = async (files) => {\n          if (files == null ? void 0 : files.length) {\n            uploadFile(audioWidget, audioUIWidget, files[0], true);\n          }\n          return files;\n        };\n        const isAudioFile = (file2) => file2.type.startsWith(\"audio/\");\n        const { openFileSelection } = useNodeFileInput(node, {\n          accept: \"audio/*\",\n          onSelect: handleUpload\n        });\n        const uploadWidget = node.addWidget(\n          \"button\",\n          inputName,\n          \"\",\n          openFileSelection,\n          { serialize: false }\n        );\n        uploadWidget.label = t(\"g.choose_file_to_upload\");\n        useNodeDragAndDrop(node, {\n          fileFilter: isAudioFile,\n          onDrop: handleUpload\n        });\n        useNodePaste(node, {\n          fileFilter: isAudioFile,\n          onPaste: handleUpload\n        });\n        node.previewMediaType = \"audio\";\n        return { widget: uploadWidget };\n      }\n    };\n  }\n});\napp.registerExtension({\n  name: \"Comfy.RecordAudio\",\n  getCustomWidgets() {\n    return {\n      AUDIO_RECORD(node, inputName) {\n        const audio = document.createElement(\"audio\");\n        audio.controls = true;\n        audio.classList.add(\"comfy-audio\");\n        audio.setAttribute(\"name\", \"media\");\n        const audioUIWidget = node.addDOMWidget(\n          inputName,\n          /* name=*/\n          \"audioUI\",\n          audio\n        );\n        let mediaRecorder = null;\n        let isRecording = false;\n        let audioChunks = [];\n        let currentStream = null;\n        let recordWidget = null;\n        let stopPromise = null;\n        let stopResolve = null;\n        audioUIWidget.serializeValue = async () => {\n          if (isRecording && mediaRecorder) {\n            stopPromise = new Promise((resolve) => {\n              stopResolve = resolve;\n            });\n            mediaRecorder.stop();\n            await stopPromise;\n          }\n          const audioSrc = audioUIWidget.element.src;\n          if (!audioSrc) {\n            useToastStore().addAlert(t(\"g.noAudioRecorded\"));\n            return \"\";\n          }\n          const blob2 = await fetch(audioSrc).then((r) => r.blob());\n          return await useAudioService().convertBlobToFileAndSubmit(blob2);\n        };\n        recordWidget = node.addWidget(\n          \"button\",\n          inputName,\n          \"\",\n          async () => {\n            if (!isRecording) {\n              try {\n                currentStream = await navigator.mediaDevices.getUserMedia({\n                  audio: true\n                });\n                mediaRecorder = new mediaRecorderConstructor(currentStream, {\n                  mimeType: \"audio/wav\"\n                });\n                audioChunks = [];\n                mediaRecorder.ondataavailable = (event) => {\n                  audioChunks.push(event.data);\n                };\n                mediaRecorder.onstop = async () => {\n                  const audioBlob = new Blob(audioChunks, { type: \"audio/wav\" });\n                  useAudioService().stopAllTracks(currentStream);\n                  if (audioUIWidget.element.src && audioUIWidget.element.src.startsWith(\"blob:\")) {\n                    URL.revokeObjectURL(audioUIWidget.element.src);\n                  }\n                  audioUIWidget.element.src = URL.createObjectURL(audioBlob);\n                  isRecording = false;\n                  if (recordWidget) {\n                    recordWidget.label = t(\"g.startRecording\");\n                  }\n                  if (stopResolve) {\n                    stopResolve();\n                    stopResolve = null;\n                    stopPromise = null;\n                  }\n                };\n                mediaRecorder.onerror = (event) => {\n                  console.error(\"MediaRecorder error:\", event);\n                  useAudioService().stopAllTracks(currentStream);\n                  isRecording = false;\n                  if (recordWidget) {\n                    recordWidget.label = t(\"g.startRecording\");\n                  }\n                  if (stopResolve) {\n                    stopResolve();\n                    stopResolve = null;\n                    stopPromise = null;\n                  }\n                };\n                mediaRecorder.start();\n                isRecording = true;\n                if (recordWidget) {\n                  recordWidget.label = t(\"g.stopRecording\");\n                }\n              } catch (err2) {\n                console.error(\"Error accessing microphone:\", err2);\n                useToastStore().addAlert(t(\"g.micPermissionDenied\"));\n                if (mediaRecorder) {\n                  try {\n                    mediaRecorder.stop();\n                  } catch {\n                  }\n                }\n                useAudioService().stopAllTracks(currentStream);\n                currentStream = null;\n                isRecording = false;\n                if (recordWidget) {\n                  recordWidget.label = t(\"g.startRecording\");\n                }\n              }\n            } else if (mediaRecorder && isRecording) {\n              mediaRecorder.stop();\n            }\n          },\n          { serialize: false }\n        );\n        recordWidget.label = t(\"g.startRecording\");\n        const originalOnRemoved = node.onRemoved;\n        node.onRemoved = function() {\n          var _a2;\n          if (isRecording && mediaRecorder) {\n            mediaRecorder.stop();\n          }\n          useAudioService().stopAllTracks(currentStream);\n          if ((_a2 = audioUIWidget.element.src) == null ? void 0 : _a2.startsWith(\"blob:\")) {\n            URL.revokeObjectURL(audioUIWidget.element.src);\n          }\n          originalOnRemoved == null ? void 0 : originalOnRemoved.call(this);\n        };\n        return { widget: recordWidget };\n      }\n    };\n  },\n  async nodeCreated(node) {\n    if (node.constructor.comfyClass !== \"RecordAudio\") return;\n    await useAudioService().registerWavEncoder();\n  }\n});\nconst isMediaUploadComboInput = (inputSpec) => {\n  const [inputName, inputOptions] = inputSpec;\n  if (!inputOptions) return false;\n  const isUploadInput = inputOptions[\"image_upload\"] === true || inputOptions[\"video_upload\"] === true || inputOptions[\"animated_image_upload\"] === true;\n  return isUploadInput && (isComboInputSpecV1(inputSpec) || inputName === \"COMBO\");\n};\nconst createUploadInput = (imageInputName, imageInputOptions) => [\n  \"IMAGEUPLOAD\",\n  {\n    ...imageInputOptions[1],\n    imageInputName\n  }\n];\napp.registerExtension({\n  name: \"Comfy.UploadImage\",\n  beforeRegisterNodeDef(_nodeType, nodeData) {\n    const { input } = nodeData ?? {};\n    const { required } = input ?? {};\n    if (!required) return;\n    const found = Object.entries(required).find(\n      ([_, input2]) => isMediaUploadComboInput(input2)\n    );\n    if (found) {\n      const [inputName, inputSpec] = found;\n      required.upload = createUploadInput(inputName, inputSpec);\n    }\n  }\n});\nconst WEBCAM_READY = Symbol();\napp.registerExtension({\n  name: \"Comfy.WebcamCapture\",\n  getCustomWidgets() {\n    return {\n      WEBCAM(node, inputName) {\n        let res;\n        node[WEBCAM_READY] = new Promise((resolve) => res = resolve);\n        const container = document.createElement(\"div\");\n        container.style.background = \"rgba(0,0,0,0.25)\";\n        container.style.textAlign = \"center\";\n        const video = document.createElement(\"video\");\n        video.style.height = video.style.width = \"100%\";\n        const loadVideo = async () => {\n          try {\n            const stream = await navigator.mediaDevices.getUserMedia({\n              video: true,\n              audio: false\n            });\n            container.replaceChildren(video);\n            setTimeout(() => res(video), 500);\n            video.addEventListener(\"loadedmetadata\", () => res(video), false);\n            video.srcObject = stream;\n            video.play();\n          } catch (error) {\n            const label = document.createElement(\"div\");\n            label.style.color = \"red\";\n            label.style.overflow = \"auto\";\n            label.style.maxHeight = \"100%\";\n            label.style.whiteSpace = \"pre-wrap\";\n            if (window.isSecureContext) {\n              label.textContent = \"Unable to load webcam, please ensure access is granted:\\n\" + // @ts-expect-error fixme ts strict error\n              error.message;\n            } else {\n              label.textContent = \"Unable to load webcam. A secure context is required, if you are not accessing ComfyUI on localhost (127.0.0.1) you will have to enable TLS (https)\\n\\n\" + // @ts-expect-error fixme ts strict error\n              error.message;\n            }\n            container.replaceChildren(label);\n          }\n        };\n        loadVideo();\n        return { widget: node.addDOMWidget(inputName, \"WEBCAM\", container) };\n      }\n    };\n  },\n  nodeCreated(node) {\n    if (node.type, node.constructor.comfyClass !== \"WebcamCapture\") return;\n    let video;\n    const camera = node.widgets.find((w2) => w2.name === \"image\");\n    const w = node.widgets.find((w2) => w2.name === \"width\");\n    const h = node.widgets.find((w2) => w2.name === \"height\");\n    const captureOnQueue = node.widgets.find(\n      (w2) => w2.name === \"capture_on_queue\"\n    );\n    const canvas = document.createElement(\"canvas\");\n    const capture = () => {\n      canvas.width = w.value;\n      canvas.height = h.value;\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(video, 0, 0, w.value, h.value);\n      const data = canvas.toDataURL(\"image/png\");\n      const img = new Image();\n      img.onload = () => {\n        node.imgs = [img];\n        app.graph.setDirtyCanvas(true);\n      };\n      img.src = data;\n    };\n    const btn = node.addWidget(\n      \"button\",\n      \"waiting for camera...\",\n      \"capture\",\n      capture\n    );\n    btn.disabled = true;\n    btn.serializeValue = () => void 0;\n    camera.serializeValue = async () => {\n      var _a2;\n      if (captureOnQueue.value) {\n        capture();\n      } else if (!((_a2 = node.imgs) == null ? void 0 : _a2.length)) {\n        const err2 = `No webcam image captured`;\n        useToastStore().addAlert(err2);\n        throw new Error(err2);\n      }\n      const blob2 = await new Promise((r) => canvas.toBlob(r));\n      const name = `${+/* @__PURE__ */ new Date()}.png`;\n      const file2 = new File([blob2], name);\n      const body = new FormData();\n      body.append(\"image\", file2);\n      body.append(\"subfolder\", \"webcam\");\n      body.append(\"type\", \"temp\");\n      const resp = await api.fetchApi(\"/upload/image\", {\n        method: \"POST\",\n        body\n      });\n      if (resp.status !== 200) {\n        const err2 = `Error uploading camera image: ${resp.status} - ${resp.statusText}`;\n        useToastStore().addAlert(err2);\n        throw new Error(err2);\n      }\n      return `webcam/${name} [temp]`;\n    };\n    node[WEBCAM_READY].then((v) => {\n      video = v;\n      if (!w.value) {\n        w.value = video.videoWidth || 640;\n        h.value = video.videoHeight || 480;\n      }\n      btn.disabled = false;\n      btn.label = t(\"g.capture\");\n    });\n  }\n});\n//# sourceMappingURL=index-ZuOXyzLm.js.map\n"],"names":[],"sourceRoot":"","ignoreList":[0]}